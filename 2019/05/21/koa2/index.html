<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>koa2笔记 | Mr.Yellow.Wills</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="koa2,鉴权,content-type,RESTfull,解决跨域,截取前端请求,服务端转发请求">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.3.9">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Mr.Yellow</h5>
          <a href="mailto:601661706@qq.com" title="601661706@qq.com" class="mail">
            
              <span>6</span>
            
              <span>0</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>6</span>
            
              <span>1</span>
            
              <span>7</span>
            
              <span>0</span>
            
              <span>6</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/YeWills/YeWills.github.io/tree/blog_code" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>koa2笔记</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">koa2笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-05-21T00:00:00.000Z" itemprop="datePublished" class="page-time">
  2019-05-21
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/后端/">后端</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-koa2"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">koa2笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-05-21 00:00:00" datetime="2019-05-21T00:00:00.000Z"  itemprop="datePublished">2019-05-21</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/后端/">后端</a></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h2 id="koa2常用知识"><a href="#koa2常用知识" class="headerlink" title="koa2常用知识"></a>koa2常用知识</h2><h3 id="context的别名"><a href="#context的别名" class="headerlink" title="context的别名"></a>context的别名</h3><p><a href="https://koajs.com/#introduction" target="_blank" rel="noopener">更多参看 官网 Request aliases Response aliases</a><br>摘录部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Request aliases 下面的简写，都指的是Request</span><br><span class="line">ctx.url  -- ctx.request.url 的别名</span><br><span class="line">ctx.method  -- ctx.request.method 的别名</span><br><span class="line">ctx.header</span><br><span class="line">ctx.path</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Response aliases 下面的简写，都指的是Request</span><br><span class="line">ctx.body  -- ctx.response.body 的别名</span><br><span class="line">ctx.status  -- ctx.response.status 的别名</span><br></pre></td></tr></table></figure>
<p>另外 ctx.req 是 ctx.request 的别名；<br>另外 ctx.res 是 ctx.response 的别名；</p>
<h3 id="POST请求参数的获取"><a href="#POST请求参数的获取" class="headerlink" title="POST请求参数的获取"></a>POST请求参数的获取</h3><p>koa 没有封装获取post请求参数的方法，要么通过ctx.req.on原生方式，要么通过koa-bodyparser</p>
<h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>使用ctx.req.on原生方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line">  let postdata=&apos;&apos;;</span><br><span class="line">  ctx.req.on(&apos;data&apos;, (data)=&gt;&#123;</span><br><span class="line">    postdata +=data;</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.req.on(&apos;end&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(postdata);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 另起一个git bash 窗口执行以下命令，注意，</span><br><span class="line">//一定用git bash， 因为cmd 没有curl命令</span><br><span class="line">curl -d &quot;param1=abc&amp;param2=qqw&quot; http://localhost:3000/</span><br><span class="line"></span><br><span class="line">// 在npm start 所在的cmd或git bash窗口，会出现 打印：</span><br><span class="line">//param1=abc&amp;param2=qqw</span><br></pre></td></tr></table></figure></p>
<h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>使用koa-bodyparser方式。koa-bodyparser的底层也是使用ctx.req.on实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  let postData = ctx.request.body;</span><br><span class="line">  console.log(postData);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br><span class="line"></span><br><span class="line">// 另起一个git bash 窗口执行以下命令，</span><br><span class="line">curl -d &quot;param1=abc&amp;param2=qqw&quot; http://localhost:3000/</span><br><span class="line"></span><br><span class="line">// 在npm start 所在的cmd或git bash窗口，会出现 打印：</span><br><span class="line">//&#123; param1: &apos;abc&apos;, param2: &apos;qqw&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="有关content-type"><a href="#有关content-type" class="headerlink" title="有关content-type"></a>有关content-type</h3><h4 id="先来看一个实例demo，感受下："><a href="#先来看一个实例demo，感受下：" class="headerlink" title="先来看一个实例demo，感受下："></a>先来看一个实例demo，感受下：</h4><p>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://127.0.0.1:3000/test&apos;, &#123;</span><br><span class="line">    method: &apos;GET&apos;, // or &apos;PUT&apos;</span><br><span class="line">    headers: new Headers(&#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;image/png&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; res.text())</span><br><span class="line">  .catch(error =&gt; console.error(&apos;Error:&apos;, error))</span><br><span class="line">  .then(response =&gt; console.log(&apos;Success:&apos;, response));</span><br></pre></td></tr></table></figure></p>
<p>后台代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p>
<p>页面响应：<br><figure class="image-box">
                <a rel=koa2笔记 href="/image/koa2/content-type.png" title="undefined" data-fancybox="images"><img src="/image/koa2/content-type.png" alt title class></a>
                <p></p>
            </figure><br><figure class="image-box">
                <a rel=koa2笔记 href="/image/koa2/content-res.png" title="undefined" data-fancybox="images"><img src="/image/koa2/content-res.png" alt title class></a>
                <p></p>
            </figure></p>
<p>后续操作：</p>
<ul>
<li>当切换设置不同的ctx.response.type=’text’;对应的Response Header 的 Content-type随之改变</li>
</ul>
<h4 id="另外一个实验："><a href="#另外一个实验：" class="headerlink" title="另外一个实验："></a>另外一个实验：</h4><p>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://127.0.0.1:3000/test&apos;, &#123;</span><br><span class="line">  method: &apos;GET&apos;,</span><br><span class="line">  headers: new Headers(&#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;image/png&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; res.json())</span><br><span class="line">.catch(error =&gt; console.error(&apos;Error:&apos;, error))</span><br><span class="line">.then(response =&gt; console.log(&apos;Success:&apos;, response));</span><br></pre></td></tr></table></figure></p>
<p>后台代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;html&apos;;</span><br><span class="line">  ctx.response.body=&#123;data:&apos;Hello World&apos;&#125;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p>
<p>发现的现象：</p>
<ul>
<li>设置不同的ctx.response.type=’html’时，Response Header 的 Content-type没有随之改变，还是显示为application/json</li>
<li>后台ctx.response.body={data:’Hello World’};改成  ctx.response.body=’<html>‘;<br>前台代码不变，发现res.json()解析报错，Unexpected token &lt; in JSON at position 0，<br>将res.json改成res.text就好了</html></li>
<li>后端实际的数据是json数据(ctx.response.body={data:’Hello World’})，但设置 ctx.response.type=’html’;然而并不影响前台通过res.json()正常解析到正确数据；</li>
<li>后端实际的数据是json数据(ctx.response.body={data:’Hello World’})，虽然前端设置了自定义Header content-type为image/png，但不影响前端正常解析，前端一样能正常获取数据。</li>
</ul>
<h4 id="得出结论："><a href="#得出结论：" class="headerlink" title="得出结论："></a>得出结论：</h4><p>结合上面页面响应的图片中：</p>
<ul>
<li>一个请求，有两个content-type,分别是Response Header 和 Request Header上的。</li>
<li>小区别是 Response Header 的是首字母大写的 Content-type ，Request Header 的是首字母小写的 content-type;</li>
<li>fetch 的 headers: new Headers({‘Content-Type’: ‘image/png’}) 设置的是 Request Header 的 content-type；</li>
<li>Response Header 的 Content-type 是 原则上是ctx.response.type控制设置的，但如上例，有时Response Header 的 Content-type 是 浏览器或koa自动识别ctx.response.body数据类型设置的。</li>
<li>fetch要想正确解析数据，需要根据后台实际数据，使用对应的解析方式，如 res.json() 、res.text()等等，如果解析方式不对，就报错。</li>
<li>另外注意的是，前端fetch的时候，如果自定义header，而且请求是跨域的，每发一次fetch，可能会产生两次请求，具体分析参见《koa2黑知识 – 跨域请求有时会发两次请求》：</li>
</ul>
<h4 id="常见的-content-type值–对应的ctx-response-type："><a href="#常见的-content-type值–对应的ctx-response-type：" class="headerlink" title="常见的 content-type值–对应的ctx.response.type："></a>常见的 content-type值–对应的ctx.response.type：</h4><p>application/json  – ctx.response.type=’json’<br>text/html  – ctx.response.type=’html’<br>image/png  – ctx.response.type=’image/png’<br>text/plain  – ctx.response.type=’text’  浏览器默认text/plain</p>
<h3 id="设置响应状态码"><a href="#设置响应状态码" class="headerlink" title="设置响应状态码"></a>设置响应状态码</h3><p>通过ctx.status设置，ctx.status是ctx.response.status的别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.status=562;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p>
<p>页面响应：<br><figure class="image-box">
                <a rel=koa2笔记 href="/image/koa2/status.png" title="undefined" data-fancybox="images"><img src="/image/koa2/status.png" alt title class></a>
                <p></p>
            </figure></p>
<h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>koa-bodyparser的底层也是使用ctx.req.on实现的，所以不能同时使用 koa-bodyparser与ctx.req.on，否则，可能报错，<br>详见《koa2黑知识 – koa-bodyparser导致ctx.req.on事件失效》</p>
<h3 id="如何在koa使用中间件"><a href="#如何在koa使用中间件" class="headerlink" title="如何在koa使用中间件"></a>如何在koa使用中间件</h3><h4 id="中间件是由app-use加载的"><a href="#中间件是由app-use加载的" class="headerlink" title="中间件是由app.use加载的"></a>中间件是由app.use加载的</h4><p>中间件一般都通过 app.use 函数来加载中间件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p>
<h4 id="中间件执行顺序"><a href="#中间件执行顺序" class="headerlink" title="中间件执行顺序"></a>中间件执行顺序</h4><p>中间件在 koa中执行顺序，遵循洋葱模型方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/image/koa2/middle.jpg)</span><br></pre></td></tr></table></figure></p>
<p>代码展示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;one start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;one end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;two start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;two end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;three start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;three end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// one start</span><br><span class="line">// two start</span><br><span class="line">// three start</span><br><span class="line">// three end</span><br><span class="line">// two end</span><br><span class="line">// one end</span><br></pre></td></tr></table></figure></p>
<h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><p>next()返回一个Promise对象，配合await使用，可以达到阻塞后面程序执行，等待 next() 返回类似reject()才最终执行nex()后面的程序。<br>每个中间件必须使用next()，否则异常。</p>
<h3 id="写一个中间件"><a href="#写一个中间件" class="headerlink" title="写一个中间件"></a>写一个中间件</h3><p>这里动手写一个logger中间件小demo，用来打印日志：<br>原代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(ctx.method,ctx.host + ctx.url)</span><br><span class="line">  await next();</span><br><span class="line">  ctx.body = &apos;hellow world&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>动手写一个logger中间件，用于打印日志，改造后如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line">const logger = async function(ctx, next)&#123;</span><br><span class="line">  console.log(ctx.method,ctx.host + ctx.url)</span><br><span class="line">  await next();</span><br><span class="line">&#125;</span><br><span class="line">app.use(logger)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.body = &apos;hellow world&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p>
<h3 id="两种鉴权方式"><a href="#两种鉴权方式" class="headerlink" title="两种鉴权方式"></a>两种鉴权方式</h3><p>一种是广泛使用的Cookie认证模式；<br>一种是基于Token的认证模式, koa中可以结合jsonwebtoken 与 koa-jwt实现Token鉴权.异步到这里了解更多《jsonwebtoken 与 koa-jwt》.<br><a href="https://github.com/YeWills/koa-demo/tree/router-Token" target="_blank" rel="noopener">这里是一个基于Token的鉴权demo</a></p>
<h3 id="写一个返回文件的接口"><a href="#写一个返回文件的接口" class="headerlink" title="写一个返回文件的接口"></a>写一个返回文件的接口</h3><h4 id="使用fs实现的方式"><a href="#使用fs实现的方式" class="headerlink" title="使用fs实现的方式"></a>使用fs实现的方式</h4><p>写一个接口，可以将本地的文件，返回给客户端,主要使用fs开完成，核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const extname = path.extname;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fpath = path.join(__dirname, &apos;./files/test.xlsx&apos;);</span><br><span class="line">const fstat = await stat(fpath);</span><br><span class="line">if (fstat.isFile()) &#123;</span><br><span class="line">  ctx.type = extname(fpath);</span><br><span class="line">  ctx.body = fs.createReadStream(fpath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function stat(file) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    fs.stat(file, function(err, stat) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve(stat);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/YeWills/koa-demo/tree/response-file" target="_blank" rel="noopener">完整demo</a>;<br>本demo 参考了 <a href="https://github.com/YeWills/examples" target="_blank" rel="noopener">koa 官网example</a>，koa 官网example挺好，展示了很多功能，如果有需求，可先到这里找示例实现。</p>
<h4 id="使用koa-static实现的方式"><a href="#使用koa-static实现的方式" class="headerlink" title="使用koa-static实现的方式"></a>使用koa-static实现的方式</h4><p>此方法参见《koa-static》，弊端是，无法自定义路由名称，只能以文件名称为接口url。</p>
<h3 id="让html在浏览器中访问的四种方法"><a href="#让html在浏览器中访问的四种方法" class="headerlink" title="让html在浏览器中访问的四种方法"></a>让html在浏览器中访问的四种方法</h3><p>本方法同样适用于 jpg、txt、docx等等文件。</p>
<h4 id="浏览器访问html的前身"><a href="#浏览器访问html的前身" class="headerlink" title="浏览器访问html的前身"></a>浏览器访问html的前身</h4><p>这是一种原始的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">    let html = `</span><br><span class="line">  &lt;h1&gt;登录&lt;\h1&gt;</span><br><span class="line">  &lt;form method = &quot;POST&quot; action= &quot;/&quot;&gt;</span><br><span class="line">  &lt;p&gt;用户名&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;p&gt;密码&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  `;</span><br><span class="line">  ctx.body=html;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="koa-view方法一"><a href="#koa-view方法一" class="headerlink" title="koa-view方法一"></a>koa-view方法一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/gethtml&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    await ctx.render(&apos;/static/test.html&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="koa-view方法二"><a href="#koa-view方法二" class="headerlink" title="koa-view方法二"></a>koa-view方法二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">    await ctx.render(&apos;/static/test.html&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">// 缺点在于无法访问到 http://localhost:3000/abc 此路由，都会被截获转发上面的/static/test.html</span><br><span class="line">router.get(&apos;/abc&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body=&apos;888999&apos;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="koa-static方法一"><a href="#koa-static方法一" class="headerlink" title="koa-static方法一"></a>koa-static方法一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const serve = require(&apos;koa-static&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">// http://localhost:3000/redis.html</span><br><span class="line">app.use(serve(handlePath(&apos;../pages/static/test_redirect&apos;)))</span><br><span class="line">// http://localhost:3000</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  ctx.redirect(&apos;/redis.html&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="最佳方法-koa-static方法二"><a href="#最佳方法-koa-static方法二" class="headerlink" title="最佳方法(koa-static方法二)"></a>最佳方法(koa-static方法二)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const serve = require(&apos;koa-static&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">// 在static内定义一个index.html，利用服务器默认找index.html特性</span><br><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在浏览器中输入<a href="http://localhost:3000，然后显示自己的index.html文件，一般使用的是koa-static或者是koa-views来实现。" target="_blank" rel="noopener">http://localhost:3000，然后显示自己的index.html文件，一般使用的是koa-static或者是koa-views来实现。</a><br>最好的方法是使用koa-static来做，好处多多,窍门在于给在static内定义一个index.html，利用服务器默认找index.html特性，这样在浏览器中只干干净净显示url <a href="http://localhost:3000，非常好，而且koa-static自己封装路由处理很好，不会影响你在koa中定义的其他路由。" target="_blank" rel="noopener">http://localhost:3000，非常好，而且koa-static自己封装路由处理很好，不会影响你在koa中定义的其他路由。</a><br>用koa-view也能达到目的，局限性大，会让你定义的其他路由失效,如果有疑问，可以用下面的demo测试研究一番。<br><a href="https://github.com/YeWills/koa-demo/tree/show-file-in-Browser" target="_blank" rel="noopener">以上四种情况，详细的demo</a></p>
<h3 id="前后端一体的小demo"><a href="#前后端一体的小demo" class="headerlink" title="前后端一体的小demo"></a>前后端一体的小demo</h3><p>通过对上面两节的总结，写了一个有图片、xls、正常json的三种接口，<br>以及前端对于这三种不同类型数据如何处理。<br>本demo也可用于理解blob。<br><a href="https://github.com/YeWills/koa-demo/tree/response-file" target="_blank" rel="noopener">《写一个返回文件的接口 –为同一个demo》</a></p>
<h3 id="文件上传-file和drap拖拽两种方式"><a href="#文件上传-file和drap拖拽两种方式" class="headerlink" title="文件上传-file和drap拖拽两种方式"></a>文件上传-file和drap拖拽两种方式</h3><p>服务端主要运用 koa-multer。<br><a href="https://github.com/YeWills/file-upload" target="_blank" rel="noopener">详细参考demo</a><br>也可参考：<br>《html笔记–文件上传-file和drap拖拽两种方式》</p>
<h3 id="截取前端请求方案"><a href="#截取前端请求方案" class="headerlink" title="截取前端请求方案"></a>截取前端请求方案</h3><p>koa启动服务，使用koa-view render 整个编译好的前端工程index.html, 此时index.html自然处于koa的同域名下，index.html发的每个请求都被koa 的app.use截取，在app.use内，再使用《服务端发起请求的方法》，组装数据，修改url，向指定服务器发起请求，而服务器之间请求没有跨域限制，成功的解决跨域。<br>这种方式最理想，因为不用修改后台，因为很多公司升级改造时，后台可以给你提供测试用户账号，因为老的项目客户正在使用，不能修改放开跨域限制的代码,遇到这种场景，就必须使用以上解决跨域的方式。<br><a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">服务端截取请求向另外服务器发请求的demo</a><br>参考《服务端发起请求的方法》了解更多<br>参考《跨域请求有时会发两次请求》了解更多</p>
<h3 id="服务端发起请求的方法"><a href="#服务端发起请求的方法" class="headerlink" title="服务端发起请求的方法"></a>服务端发起请求的方法</h3><p>服务端发起请求可以轻松实现，koa截取前端请求组装数据后 转发请求的功能。</p>
<h4 id="http方式"><a href="#http方式" class="headerlink" title="http方式"></a>http方式</h4><p>参考《http》</p>
<h4 id="request方式"><a href="#request方式" class="headerlink" title="request方式"></a>request方式</h4><p>参考《request-promise-native request》</p>
<h3 id="ctx-state"><a href="#ctx-state" class="headerlink" title="ctx.state"></a>ctx.state</h3><p>此属性，在做笔记为止，用的比较少，不用深究，用时再了解。<br>Koa 还约定了一个中间件的存储空间 ctx.state。通过 state 可以存储一些数据，比如用户数据，版本信息等。如果你使用 webpack 打包的话，可以使用中间件，将加载资源的方法作为 ctx.state 的属性传入到 view 层，方便获取资源路径。<a href="https://www.jianshu.com/p/d3afa36aa17a" target="_blank" rel="noopener">摘自此文</a></p>
<h2 id="koa2黑知识"><a href="#koa2黑知识" class="headerlink" title="koa2黑知识"></a>koa2黑知识</h2><h3 id="favicon-ico"><a href="#favicon-ico" class="headerlink" title="/favicon.ico"></a>/favicon.ico</h3><p>我们常加载dom时，会看到有一个/favicon.ico请求，这个是Dom渲染时，默认自带的静态资源。</p>
<h3 id="this-指向-ctx"><a href="#this-指向-ctx" class="headerlink" title="this 指向 ctx"></a>this 指向 ctx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line"> this; //此this其实就是ctx，就是Context</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;run in 3000&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="koa-bodyparser导致ctx-req-on事件失效"><a href="#koa-bodyparser导致ctx-req-on事件失效" class="headerlink" title="koa-bodyparser导致ctx.req.on事件失效"></a>koa-bodyparser导致ctx.req.on事件失效</h3><p>下面代码会报错，因为koa-bodyparser的底层就是基于ctx.req.on实现的，如果使用了koa-bodyparser，它可能会劫持ctx.req.on这个事件，导致ctx.req.on事件失效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line">  let postdata=&apos;&apos;;</span><br><span class="line">  ctx.req.on(&apos;data&apos;, (data)=&gt;&#123;</span><br><span class="line">    postdata +=data;</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.req.on(&apos;end&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(postdata);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;run in 3000&apos;)</span><br></pre></td></tr></table></figure></p>
<p>解决的方法也简单，koa-bodyparser本来是为了方便获取ctx.req.on,使用了koa-bodyparser就没必要使用ctx.req.on。<br>或者用kctx.req.on，就不要用koa-bodyparser；</p>
<h3 id="跨域的两种解决方式"><a href="#跨域的两种解决方式" class="headerlink" title="跨域的两种解决方式"></a>跨域的两种解决方式</h3><h4 id="koa2-cors解决跨域"><a href="#koa2-cors解决跨域" class="headerlink" title="koa2-cors解决跨域"></a>koa2-cors解决跨域</h4><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>var cors = require(‘koa2-cors’);<br>app.use(cors());</p>
<h5 id="将koa2-cors放在最上面"><a href="#将koa2-cors放在最上面" class="headerlink" title="将koa2-cors放在最上面"></a>将koa2-cors放在最上面</h5><p>将koa2-cors放在最上面，让koa2-cors先于其他中间件执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.use(cors()) // 解决跨域，跨域代码最好放在所有中间件前面</span><br><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const serve = require(&apos;koa-static&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  await ctx.render(&apos;index.html&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(bodyparser())// 解析post参数</span><br><span class="line">app.use(router.routes())// 调用路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br><span class="line">app.listen(3000, ()=&gt;&#123;</span><br><span class="line">  console.log(&apos;server is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>需要修改后台，需要后台放开跨域限制，如果后台已经投产，客户正在使用该后台，那么肯定不能放开跨域限制，这种跨域解决方法就满足不了需求。</p>
<h4 id="服务端向服务端发请求解决跨域"><a href="#服务端向服务端发请求解决跨域" class="headerlink" title="服务端向服务端发请求解决跨域"></a>服务端向服务端发请求解决跨域</h4><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p>参考《截取前端请求方案》<br>参考《跨域请求有时会发两次请求》<br>参考《跨域请求有时会发两次请求》<br>这里有一个服务端截取前端请求，转发给指定服务器的<a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">demo</a>，不过该demo只做了一个接口的转发,看本例了解下这种模式</p>
<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点是，不用修改后台，这种方法非常适合后台在使用，而要做产品升级的项目，缺点是，前端项目工程配置麻烦。</p>
<h3 id="home-id-name-路由对应的url"><a href="#home-id-name-路由对应的url" class="headerlink" title="/home/:id/:name 路由对应的url"></a>/home/:id/:name 路由对应的url</h3><p>router.get(‘/home’  —对应 <a href="http://localhost:3000/home?id=01&amp;name=admin" target="_blank" rel="noopener">http://localhost:3000/home?id=01&amp;name=admin</a><br>router.get(‘/home/:id/:name’  —对应 <a href="http://localhost:3000/home/01/admin" target="_blank" rel="noopener">http://localhost:3000/home/01/admin</a></p>
<h3 id="跨域请求有时会发两次请求"><a href="#跨域请求有时会发两次请求" class="headerlink" title="跨域请求有时会发两次请求"></a>跨域请求有时会发两次请求</h3><p>当前端fetch自定了header时，且接口跨域时，fetch一次，可能会发两次相同请求，两次请求一次是Request Method: OPTIONS的，<br>一次是Request Method: GET的，<br>原来fetch在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(preflight request), 用于试探服务端是否能接受真正的请求<a href="https://blog.csdn.net/cc1314_/article/details/78272329" target="_blank" rel="noopener">详细原因参见这里</a>；<br>解决之道就是把自定义headers字段删掉后；<br>或者不要使用require(‘koa2-cors’)的方式解决跨域，可以通过服务端请求服务器的方式解决跨域；<br>因为跨域是浏览器的限制机制，而服务器与服务器之间不存在跨域问题，具体思路：<br>在同域名下通过 koa 截取 项目的所有fetch请求，然后使用 request 模块，通过 request 给另外域名下的服务器发请求,<a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">服务端截取请求向另外服务器发请求的demo</a></p>
<h3 id="后台报错app有错误日志，也会报跨域错误"><a href="#后台报错app有错误日志，也会报跨域错误" class="headerlink" title="后台报错app有错误日志，也会报跨域错误"></a>后台报错app有错误日志，也会报跨域错误</h3><p>如果配置了koa2-cors解决跨域，但请求时有跨域报错，可能是app.use内部程序执行报错，会导致后台响应异常，然后前台可能显示为跨域限制错误</p>
<h3 id="奇怪的阻塞"><a href="#奇怪的阻塞" class="headerlink" title="奇怪的阻塞"></a>奇怪的阻塞</h3><h4 id="不带async"><a href="#不带async" class="headerlink" title="不带async"></a>不带async</h4><p>如下，执行顺序将为： 1 3 2 4。<br>首先打印1；<br>然后进入下个中间件，打印3；<br>因为加了await，所以下面的程序被阻塞了；<br>一旦阻塞，程序将先执行未被阻塞的 2，所以打印了2；<br>当get请求完毕，阻塞解除，执行4；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">     ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">     next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">await</span> axios.get(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">    next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>上面这种执行顺序没有按照洋葱模型顺序执行，不是我们想要的，如何解决呢？</p>
<h4 id="带async"><a href="#带async" class="headerlink" title="带async"></a>带async</h4><p>其他不变，就下面的变化,打印顺序就是洋葱模型执行的正常顺序：<br>1 3 4 2<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span>(ctx, next)=&gt;&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">     ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">     <span class="keyword">await</span> next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="保证洋葱模型-中间件必须带async、await"><a href="#保证洋葱模型-中间件必须带async、await" class="headerlink" title="保证洋葱模型-中间件必须带async、await"></a>保证洋葱模型-中间件必须带async、await</h3><p>具体参考《奇怪的阻塞》，为了保证中间件像洋葱模型的顺序一层一层执行程序，必须带上async、await。</p>
<h3 id="为什么要保证洋葱模型"><a href="#为什么要保证洋葱模型" class="headerlink" title="为什么要保证洋葱模型"></a>为什么要保证洋葱模型</h3><p>如果保证了洋葱模型，我们就可以确定，await next()之后，执行的代码肯定是后面中间件以及执行完成了的；<br>也就是说，console.log(2)肯定是下面的中间件程序执行完后才执行的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span>(ctx, next)=&gt;&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">await</span> next()</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">2</span>)<span class="comment">//保证这个打印是在下面所以中间件执行完成之后，才执行。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="koa2模块上"><a href="#koa2模块上" class="headerlink" title="koa2模块上"></a>koa2模块上</h2><h3 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h3><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">const router = require(&apos;koa-router&apos;)()</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line">const app = new Koa()</span><br><span class="line"> router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = `&lt;h1&gt;index page&lt;/h1&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/home&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &apos;&lt;h1&gt;HOME page&lt;/h1&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/404&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(cors()) // 解决跨域</span><br><span class="line">app.use(bodyparser())// 解析post参数</span><br><span class="line">app.use(router.routes())// 注册路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br><span class="line">app.listen(3000, ()=&gt;&#123;</span><br><span class="line">  console.log(&apos;server is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>关键 是在最后使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(router.routes())// 调用路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br></pre></td></tr></table></figure></p>
<p>当然，如果你不想处理异常状态码，完全可以不使用router.allowedMethods(),单独使用router.routes()即可。</p>
<h4 id="模拟路由中间件"><a href="#模拟路由中间件" class="headerlink" title="模拟路由中间件"></a>模拟路由中间件</h4><p>下面模拟路由写的中间件，可以加深对路由中间件的理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Router&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this._routers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  get(url, handler)&#123;</span><br><span class="line">    this._routers.push(&#123;</span><br><span class="line">      url:url,</span><br><span class="line">      method:&apos;GET&apos;,</span><br><span class="line">      handler</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  routes()&#123;</span><br><span class="line">    return async (ctx, next) =&gt; &#123;</span><br><span class="line">      const &#123;method, url&#125; = ctx;</span><br><span class="line">      const matchedRouter = this._routers.find(r =&gt; r.method === method &amp;&amp; r.url === url);</span><br><span class="line">      if( matchedRouter &amp;&amp;</span><br><span class="line">        matchedRouter.handler)&#123;</span><br><span class="line">          await matchedRouter.handler(context, next);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          await next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h3><h4 id="介绍-和-demo"><a href="#介绍-和-demo" class="headerlink" title="介绍 和 demo"></a>介绍 和 demo</h4><p>koa-static是静态资源请求中间件，这里写了一个<a href="https://github.com/YeWills/koa-demo/tree/static-views" target="_blank" rel="noopener">简单的demo</a>，可启动感受下，下面以该demo源码作为示例讲解koa-static；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure></p>
<p>通过图片可以看出项目静态文件目录结构<br><figure class="image-box">
                <a rel=koa2笔记 href="/image/koa2/static.jpg" title="undefined" data-fancybox="images"><img src="/image/koa2/static.jpg" alt title class></a>
                <p></p>
            </figure></p>
<p>配置上面这句代码后，你讲可以在浏览器上运行可现实文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:3000/css/style.css</span><br><span class="line">http://127.0.0.1:3000/img/films.jpg</span><br></pre></td></tr></table></figure></p>
<p>注意哦，不是 <a href="http://127.0.0.1:3000/pages/static/css/style.css" target="_blank" rel="noopener">http://127.0.0.1:3000/pages/static/css/style.css</a> !!这个地址是找不到的，很多刚用koa-static时都会犯这个错，认为就是handlePath(‘../pages/static’) 定义的url，然后就拼接成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个地址是访问不到的</span><br><span class="line">http://127.0.0.1:3000/pages/static/css/style.css</span><br></pre></td></tr></table></figure></p>
<h4 id="理解koa-static"><a href="#理解koa-static" class="headerlink" title="理解koa-static"></a>理解koa-static</h4><p>koa-static是静态资源请求中间件，不过这样说，我们并不能直观理解koa-static是什么，原理是什么。<br>我们大可将koa-static看成是一个 为提供目录下每个文件 配置路由的中间件，<br>只要你提供一个文件的具体位置给koa-static，koa-static会结合路由的功能，为每个该文件位置下的文件配置一个 url 路由；<br>这个url路由其实就是一个普通的接口url，我们将这个普通的url输入浏览器，回车就可以看到改接口url的返回内容；</p>
<h4 id="koa-static是个批量配置接口url的中间件"><a href="#koa-static是个批量配置接口url的中间件" class="headerlink" title="koa-static是个批量配置接口url的中间件"></a>koa-static是个批量配置接口url的中间件</h4><p>所以，koa-static其实是一个很棒批量配置接口url的中间件，可以为你提供的文件目录下的所有文件批量配置好url接口，<br>你就可以轻松通过此url接口访问此文件。</p>
<h3 id="koa-views"><a href="#koa-views" class="headerlink" title="koa-views"></a>koa-views</h3><h4 id="介绍-和-demo-1"><a href="#介绍-和-demo-1" class="headerlink" title="介绍 和 demo"></a>介绍 和 demo</h4><p>如果我们只需要ctx.body只需要返回一段简单的代码如下，那么就用不到koa-views。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.response.body = &apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;</span><br></pre></td></tr></table></figure></p>
<p>如果我们要ctx.response.body直接返回一个如下复杂的html，这个时候，再去拼接字符串太麻烦，<br>koa-views就是让body返回html变得简单，你直接单独定义好一个html，然后直接引用此html即可，非常方便。<br>koa-views可以用于<strong>普通的html文件</strong>，也可以用于模板引擎，用于模板引擎的时候，可通过ctx.state传值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let html = `</span><br><span class="line">  &lt;h1&gt;登录&lt;\h1&gt;</span><br><span class="line">  &lt;form method = &quot;POST&quot; action= &quot;/&quot;&gt;</span><br><span class="line">  &lt;p&gt;用户名&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;p&gt;密码&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  `</span><br><span class="line">  ctx.body=html;</span><br></pre></td></tr></table></figure></p>
<p>这里写了一个<a href="https://github.com/YeWills/koa-demo/tree/static-views" target="_blank" rel="noopener">简单的demo</a>，可启动感受下加深理解。<br>此demo和《koa-static》demo是同一个</p>
<h4 id="koa-views的使用"><a href="#koa-views的使用" class="headerlink" title="koa-views的使用"></a>koa-views的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  await ctx.render(&apos;index.html&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="render是koa-views集成到ctx的"><a href="#render是koa-views集成到ctx的" class="headerlink" title="render是koa-views集成到ctx的"></a>render是koa-views集成到ctx的</h4><p>如上的代码，ctx本身没有render方法，只是使用koa-views中间件后，ctx才有这个方法的</p>
<h4 id="index-html中静态文件的路径"><a href="#index-html中静态文件的路径" class="headerlink" title="index.html中静态文件的路径"></a>index.html中静态文件的路径</h4><p>请结合上面demo源码看(此demo和《koa-static》demo是同一个)<br>项目路径和请看参看 《koa-static》的图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure>
<p>我们在《koa-static》中知道css和jpg的访问接口url是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:3000/css/style.css</span><br><span class="line">http://127.0.0.1:3000/img/films.jpg</span><br></pre></td></tr></table></figure></p>
<p>此时，index.html的css和img的路径应该配置为如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">  &lt;title&gt;东成西就&lt;/title&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;films&quot;&gt;东成西就就是棒！&lt;/div&gt;</span><br><span class="line">  &lt;img src=&quot;/img/films.jpg&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h3><p>此中间件的作用 是 把POST请求的参数解析到ctx.request.body中，koa-bodyparser底层就是基于ctx.req.on实现的。<br>其他信息见《koa-bodyparser导致ctx.req.on事件失效》  《POST请求参数的获取》</p>
<h3 id="jsonwebtoken-与-koa-jwt"><a href="#jsonwebtoken-与-koa-jwt" class="headerlink" title="jsonwebtoken 与 koa-jwt"></a>jsonwebtoken 与 koa-jwt</h3><p>jsonwebtoken 简称 JWT，用来实现Token的生成、校验和解码。<br>使用koa-jwt中间件可以将 jsonwebtoken与koa有机结合起来。<br>jsonwebtoken 与 koa-jwt 的关系，就跟 redux 与react-redux的关系。<br><a href="https://github.com/YeWills/koa-demo/tree/router-Token" target="_blank" rel="noopener">这里是一个基于Token的鉴权demo</a>。</p>
<p>使用方法：<br>一般方案为：登录是，koa通过jsonwebtoken给用户一个Token编码，之后客户端发送请求时，在Header上都带上此Token码，<br>后端接受请求时，验证此Token码进行鉴权。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const &#123; sign &#125; = require(&apos;jsonwebtoken&apos;);</span><br><span class="line">const secret = &apos;demo&apos;;</span><br><span class="line">const jwt = require(&apos;koa-jwt&apos;)(&#123; secret &#125;);</span><br><span class="line"></span><br><span class="line">//生成Token，secret作为密钥开发者自定义设置，expiresIn为失效时间，不要设置太久</span><br><span class="line">//登陆成功后，后台通过jsonwebtoken为该用户生成Token编码，</span><br><span class="line">//客户端拿到Token编码后，下次发请求时，在Header中带上Token码</span><br><span class="line">router.post(&apos;/api/login&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; username &#125; = ctx.request.body;</span><br><span class="line">    const token = sign(&#123; username &#125;, secret, &#123; expiresIn: &apos;1h&apos; &#125;);</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      message: &apos;Get Token Success&apos;,</span><br><span class="line">      code: 1,</span><br><span class="line">      token</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)</span><br><span class="line">  //登录之后的接口请求，都要验证Token，所以都要在Header中将上一步登录是获得的Token传给后台</span><br><span class="line">    .get(&apos;/api/userInfo&apos;, jwt, async ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      username: ctx.state.user.username</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>http说的是 require(‘http’)模块。<br>koa利用http直接从服务端向其他服务器发起请求，<br>如下，koa服务端，接收到请求时，在路由函数体内，将请求参数重新组装，通过http，转发给对应服务器。<br>这种方法好处之一是避免跨域问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Http = require(&apos;http&apos;);</span><br><span class="line">router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    let &#123; kw &#125; = ctx.query;</span><br><span class="line">    let resData = await new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          //http://m.maoyan.com/ajax/search?kw=捉妖记&amp;cityId=10</span><br><span class="line">            Http.request(&#123;</span><br><span class="line">                hostname: &apos;m.maoyan.com&apos;,</span><br><span class="line">                path: &apos;/ajax/search?&apos; + Querystring.stringify(&#123;</span><br><span class="line">                    kw,</span><br><span class="line">                    cityId: 10</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;, (res) =&gt; &#123;</span><br><span class="line">                res.setEncoding(&apos;utf8&apos;);</span><br><span class="line">                let data = [];</span><br><span class="line">                res.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">                    data.push(chunk)</span><br><span class="line">                &#125;).on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">                    resolve(data.join(&apos;&apos;));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;).end();</span><br><span class="line">        &#125;);</span><br><span class="line">    ctx.body = Render(JSON.parse(resData), kw);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">完整http request的demo</a></p>
<h3 id="request-promise-native-request"><a href="#request-promise-native-request" class="headerlink" title="request-promise-native request"></a>request-promise-native request</h3><p>以下是自己对request-promise-native request的直观理解，没有深入研究，对不对待考：<br>request-promise-native 可能依赖 request，安装好request-promise-native会自动安装request，<br>所以request-promise-native 和request是一回事，request-promise-native是request的增强版，<br>他们都只做一件事，在服务器发起接口请求，与同为服务器发请求的http效果一样；<br>与浏览器端发请求的fetch axios功能一样，作用的环境不一样而已。</p>
<p>暂时不用过多了解，用时深究，这里有一个用到request-promise-native request的demo，<br><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">完整http request的demo</a>。</p>
<h3 id="koa-multer"><a href="#koa-multer" class="headerlink" title="koa-multer"></a>koa-multer</h3><p>express或koa，收到前台的上传请求后，因为上传文件的请求时一个多类型文件数据(multipart/form-data)请求，<br>必须通过require(‘multer’)才能正常处理这样的请求。<br>multer就是为了 处理多文件接口而生。<br>multer同koa-multer，去koa-multer的GitHub上，已经说明其文档直接参考express的multer。<br>更多参考《文件上传-file和drap拖拽两种方式》<br>koa-multer 用来做文件上传功能，需要配合 fs模块一起，比较简单，<a href="https://github.com/YeWills/koa-demo/tree/upload-file" target="_blank" rel="noopener">这是文件上传koa-multer 和fs demo</a>。</p>
<h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p>demo和介绍，参考《koa-multer》《写一个返回文件的接口》，这两部分都有demo，使用fs做了一个文件上传和读取本地文件并返回给前台的功能</p>
<h2 id="koa2模块下"><a href="#koa2模块下" class="headerlink" title="koa2模块下"></a>koa2模块下</h2><h3 id="koa2-cors"><a href="#koa2-cors" class="headerlink" title="koa2-cors"></a>koa2-cors</h3><p>参考《koa2-cors解决跨域》</p>
<h3 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h3><p>querystring模块有以下作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Querystring = require(&apos;querystring&apos;)</span><br><span class="line">Querystring.escape(&apos;id=1&apos;) //返回 id%3D1</span><br><span class="line">Querystring.unescape(&apos;id%3D1&apos;) //返回 id=1</span><br><span class="line">querystring.parse(&apos;foo=bar&amp;abc=xyz&amp;abc=123&apos;) //返回 &#123;foo: &apos;bar&apos;,abc: [&apos;xyz&apos;, &apos;123&apos;]&#125;</span><br><span class="line">querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;) // 返回 &apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://nodejs.cn/api/querystring.html" target="_blank" rel="noopener">更多点击官网</a></p>
<p><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">这里有一个querystring的demo</a></p>
<h3 id="koa-json、log4js、ip"><a href="#koa-json、log4js、ip" class="headerlink" title="koa-json、log4js、ip"></a>koa-json、log4js、ip</h3><p><a href="https://github.com/YeWills/koa-demo/tree/pro-static" target="_blank" rel="noopener">这里只放一个demo</a>，不深入了解，用到的时候再深究，此demo包含koa-static、log4js与ip、koa-json、koa-nunjucks</p>
<h3 id="koa-nunjucks"><a href="#koa-nunjucks" class="headerlink" title="koa-nunjucks"></a>koa-nunjucks</h3><p>koa-nunjucks是基于nunjucks的html 模板中间件。<br>没有什么太复杂的需求，只是用koa玩玩，如果不用html模板，用koa-views就可以了，如果要用html模板，可以用koa-nunjucks，当然也可以用ejs模板，等等，有很多这方面的模板。<br>这里只放一个demo，不过多解释，用到的时候再了解。<br><a href="https://github.com/YeWills/koa-demo/tree/web-pro" target="_blank" rel="noopener">koa-nunjucks的使用demo</a></p>
<h3 id="ejs-pug"><a href="#ejs-pug" class="headerlink" title="ejs pug"></a>ejs pug</h3><p>暂时不用过多了解，用时深究，<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">参见demo</a>。</p>
<h3 id="puppeteer-parcel-bundler-glob"><a href="#puppeteer-parcel-bundler-glob" class="headerlink" title="puppeteer parcel-bundler  glob"></a>puppeteer parcel-bundler  glob</h3><p>暂时不用过多了解，用时深究，<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">参见demo</a>。</p>
<h2 id="RESTfull-和-http"><a href="#RESTfull-和-http" class="headerlink" title="RESTfull 和  http"></a>RESTfull 和  http</h2><h3 id="RESTful-规范"><a href="#RESTful-规范" class="headerlink" title="RESTful 规范"></a>RESTful 规范</h3><p>非RESTful规范定义的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.get(/app/adduser)</span><br><span class="line">router.get(/app/edituser)</span><br><span class="line">router.get(/app/deleteuser)</span><br></pre></td></tr></table></figure></p>
<p>基于RESTful规范设计的API，全局只提供唯一的URI /app/user<br>设计如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.post(/app/user) //新增用户id</span><br><span class="line">router.edit(/app/user:id) 编辑名字为id的用户</span><br><span class="line">router.delete(/app/user:id) 删除名字为id的用户</span><br></pre></td></tr></table></figure></p>
<h3 id="URL-的7个部分组成："><a href="#URL-的7个部分组成：" class="headerlink" title="URL 的7个部分组成："></a>URL 的7个部分组成：</h3><p>scheme:[//[user[:password]@]host[:post][/path][?query][#fragemnt]<br>scheme:使用协议 如FTP、HTTP等<br>user[:password] : 表示访问资源的用户和密码，常见于FTP协议<br>host 主机<br>port 端口<br>path 访问资源路径<br>query 请求数据，以？开头<br>fragment 定位锚点，以#开头，可用于快速定位网页对应段落</p>
<h3 id="常用http状态码"><a href="#常用http状态码" class="headerlink" title="常用http状态码"></a>常用http状态码</h3><p>1<strong> 消息   100 继续，继续响应剩余部分，如已完成，可忽略<br>2</strong> 成功<br>3<strong> 重定向  301 永久移动； 302 临时移动； 304 未修改，请求资源对比上次没有修改<br>4</strong> 请求错误 401 未授权 ； 403 禁止； 404 未找到；<br>5<strong> 和 6</strong> 服务器错误  500 服务器内部错误； 503 服务不可用；</p>
<h2 id="相关demo"><a href="#相关demo" class="headerlink" title="相关demo"></a>相关demo</h2><h3 id="koa-demo"><a href="#koa-demo" class="headerlink" title="koa-demo"></a>koa-demo</h3><p>主要的示例demo:<a href="https://github.com/YeWills/koa-demo" target="_blank" rel="noopener">koa-demo</a>;</p>
<h3 id="koa2-films"><a href="#koa2-films" class="headerlink" title="koa2_films"></a>koa2_films</h3><p>很好的综合运行demo(含爬虫，mongodb，koa,前后端一体化编译开发):<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">koa2_films/koa_web</a>,<br>此仓库其他分支还有单纯的 开发后台的分支;<br>也有单纯的爬虫demo：<a href="https://github.com/YeWills/koa2_films/tree/puppeteer" target="_blank" rel="noopener">爬虫小demo</a>；<br>还有一个分支为：<a href="https://github.com/YeWills/koa2_films/tree/event_IO_loop" target="_blank" rel="noopener">nodejs 异步io的理解 阻塞非阻塞，事件循环与驱动，单线程，子进程，进程通讯)events 框架demo</a>；<br><a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">服务端截取请求向另外服务器发请求的demo</a>;</p>
<h3 id="films-new"><a href="#films-new" class="headerlink" title="films_new"></a>films_new</h3><p><a href="https://github.com/YeWills/react-redux-demo/tree/films_new" target="_blank" rel="noopener">films_new</a>是react-redux-demo仓库下的分支。<br>这是前端代码，用来像后台发起请求。</p>
<h3 id="koa-miniprogram"><a href="#koa-miniprogram" class="headerlink" title="koa-miniprogram"></a>koa-miniprogram</h3><p>此项目为微信开发，《koa与node.js开发实战》 书第九章以后的代码，在此仓库，我整理成单独几份，暂时没有微信学习，将源码整理备份，以备以后用。<br>其中<a href="https://github.com/YeWills/koa-miniprogram/tree/particle-css" target="_blank" rel="noopener">particle-css分支</a>挺好的一个css页面，同时还有超炫背景粒子-particlesJS插件的使用 效果：</p>
<h2 id="参考和学习资料"><a href="#参考和学习资料" class="headerlink" title="参考和学习资料"></a>参考和学习资料</h2><p><a href>koa与node.js开发实战</a><br><a href>Koa2框架从0开始构建预告片网站</a><br><a href="https://koajs.com/#context" target="_blank" rel="noopener">koa 官网</a><br><a href="https://github.com/koajs/koa#readme" target="_blank" rel="noopener">koa github </a><br><a href="https://github.com/YeWills/examples" target="_blank" rel="noopener">koa example，挺好的官方示例，比较全，做需求时可先在这找示例</a><br><a href="https://www.jianshu.com/p/d3afa36aa17a" target="_blank" rel="noopener">koa2入门笔记</a></p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2023-01-14T11:35:06.174Z" itemprop="dateUpdated">2023-01-14 11:35:06</time>
</span><br>


        
        博客内容均为原创，转载注明出处，原文地址：<a href="/2019/05/21/koa2/" target="_blank" rel="external">https://yewills.github.io/2019/05/21/koa2/</a>
        
    </div>
    <footer>
        <a href="https://yewills.github.io">
            <img src="/img/avatar.jpg" alt="Mr.Yellow">
            Mr.Yellow
        </a>
    </footer>
</blockquote>

        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RESTfull/">RESTfull</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/content-type/">content-type</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/koa2/">koa2</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/截取前端请求/">截取前端请求</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务端转发请求/">服务端转发请求</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/解决跨域/">解决跨域</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/鉴权/">鉴权</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://yewills.github.io/2019/05/21/koa2/&title=《koa2笔记》 — Mr.Yellow.Wills&pic=https://yewills.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yewills.github.io/2019/05/21/koa2/&title=《koa2笔记》 — Mr.Yellow.Wills&source=hellow kity" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/05/21/js/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">js笔记(一)</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/05/21/wills_react_pro/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">wills-react-pro项目笔记</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#koa2常用知识"><span class="post-toc-number">1.</span> <span class="post-toc-text">koa2常用知识</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#context的别名"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">context的别名</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#POST请求参数的获取"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">POST请求参数的获取</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#方式一："><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">方式一：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#方式二："><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">方式二：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#有关content-type"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">有关content-type</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#先来看一个实例demo，感受下："><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">先来看一个实例demo，感受下：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#另外一个实验："><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">另外一个实验：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#得出结论："><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">得出结论：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#常见的-content-type值–对应的ctx-response-type："><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">常见的 content-type值–对应的ctx.response.type：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#设置响应状态码"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">设置响应状态码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意点："><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">注意点：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何在koa使用中间件"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">如何在koa使用中间件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#中间件是由app-use加载的"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">中间件是由app.use加载的</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#中间件执行顺序"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">中间件执行顺序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#next"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">next()</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#写一个中间件"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">写一个中间件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#两种鉴权方式"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">两种鉴权方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#写一个返回文件的接口"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">写一个返回文件的接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用fs实现的方式"><span class="post-toc-number">1.8.1.</span> <span class="post-toc-text">使用fs实现的方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用koa-static实现的方式"><span class="post-toc-number">1.8.2.</span> <span class="post-toc-text">使用koa-static实现的方式</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#让html在浏览器中访问的四种方法"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">让html在浏览器中访问的四种方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#浏览器访问html的前身"><span class="post-toc-number">1.9.1.</span> <span class="post-toc-text">浏览器访问html的前身</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#koa-view方法一"><span class="post-toc-number">1.9.2.</span> <span class="post-toc-text">koa-view方法一</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#koa-view方法二"><span class="post-toc-number">1.9.3.</span> <span class="post-toc-text">koa-view方法二</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#koa-static方法一"><span class="post-toc-number">1.9.4.</span> <span class="post-toc-text">koa-static方法一</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最佳方法-koa-static方法二"><span class="post-toc-number">1.9.5.</span> <span class="post-toc-text">最佳方法(koa-static方法二)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#小结"><span class="post-toc-number">1.9.6.</span> <span class="post-toc-text">小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#前后端一体的小demo"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">前后端一体的小demo</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件上传-file和drap拖拽两种方式"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">文件上传-file和drap拖拽两种方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#截取前端请求方案"><span class="post-toc-number">1.12.</span> <span class="post-toc-text">截取前端请求方案</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#服务端发起请求的方法"><span class="post-toc-number">1.13.</span> <span class="post-toc-text">服务端发起请求的方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#http方式"><span class="post-toc-number">1.13.1.</span> <span class="post-toc-text">http方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#request方式"><span class="post-toc-number">1.13.2.</span> <span class="post-toc-text">request方式</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ctx-state"><span class="post-toc-number">1.14.</span> <span class="post-toc-text">ctx.state</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#koa2黑知识"><span class="post-toc-number">2.</span> <span class="post-toc-text">koa2黑知识</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#favicon-ico"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">/favicon.ico</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#this-指向-ctx"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">this 指向 ctx</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa-bodyparser导致ctx-req-on事件失效"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">koa-bodyparser导致ctx.req.on事件失效</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#跨域的两种解决方式"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">跨域的两种解决方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#koa2-cors解决跨域"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">koa2-cors解决跨域</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#服务端向服务端发请求解决跨域"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">服务端向服务端发请求解决跨域</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#home-id-name-路由对应的url"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">/home/:id/:name 路由对应的url</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#跨域请求有时会发两次请求"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">跨域请求有时会发两次请求</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#后台报错app有错误日志，也会报跨域错误"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">后台报错app有错误日志，也会报跨域错误</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#奇怪的阻塞"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">奇怪的阻塞</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不带async"><span class="post-toc-number">2.8.1.</span> <span class="post-toc-text">不带async</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#带async"><span class="post-toc-number">2.8.2.</span> <span class="post-toc-text">带async</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#保证洋葱模型-中间件必须带async、await"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">保证洋葱模型-中间件必须带async、await</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为什么要保证洋葱模型"><span class="post-toc-number">2.10.</span> <span class="post-toc-text">为什么要保证洋葱模型</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#koa2模块上"><span class="post-toc-number">3.</span> <span class="post-toc-text">koa2模块上</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa-router"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">koa-router</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Usage"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">Usage</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#模拟路由中间件"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">模拟路由中间件</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa-static"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">koa-static</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#介绍-和-demo"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">介绍 和 demo</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#理解koa-static"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">理解koa-static</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#koa-static是个批量配置接口url的中间件"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">koa-static是个批量配置接口url的中间件</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa-views"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">koa-views</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#介绍-和-demo-1"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">介绍 和 demo</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#koa-views的使用"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">koa-views的使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#render是koa-views集成到ctx的"><span class="post-toc-number">3.3.3.</span> <span class="post-toc-text">render是koa-views集成到ctx的</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#index-html中静态文件的路径"><span class="post-toc-number">3.3.4.</span> <span class="post-toc-text">index.html中静态文件的路径</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa-bodyparser"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">koa-bodyparser</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jsonwebtoken-与-koa-jwt"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">jsonwebtoken 与 koa-jwt</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#http"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">http</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#request-promise-native-request"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">request-promise-native request</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa-multer"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">koa-multer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#fs"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">fs</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#koa2模块下"><span class="post-toc-number">4.</span> <span class="post-toc-text">koa2模块下</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa2-cors"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">koa2-cors</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#querystring"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">querystring</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa-json、log4js、ip"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">koa-json、log4js、ip</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa-nunjucks"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">koa-nunjucks</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ejs-pug"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">ejs pug</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#puppeteer-parcel-bundler-glob"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">puppeteer parcel-bundler  glob</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RESTfull-和-http"><span class="post-toc-number">5.</span> <span class="post-toc-text">RESTfull 和  http</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#RESTful-规范"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">RESTful 规范</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#URL-的7个部分组成："><span class="post-toc-number">5.2.</span> <span class="post-toc-text">URL 的7个部分组成：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常用http状态码"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">常用http状态码</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#相关demo"><span class="post-toc-number">6.</span> <span class="post-toc-text">相关demo</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa-demo"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">koa-demo</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa2-films"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">koa2_films</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#films-new"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">films_new</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#koa-miniprogram"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">koa-miniprogram</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考和学习资料"><span class="post-toc-number">7.</span> <span class="post-toc-text">参考和学习资料</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

        <footer class="footer">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://www.lujingtao.com" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                Mr.Yellow &copy; 2017 - 2023
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://yewills.github.io/2019/05/21/koa2/&title=《koa2笔记》 — Mr.Yellow.Wills&pic=https://yewills.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yewills.github.io/2019/05/21/koa2/&title=《koa2笔记》 — Mr.Yellow.Wills&source=hellow kity" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAAB00lEQVR42u3aMW7DMBAEwPz/0w6QykUo71Ik7QSjSjBkatQceHv8+oqvx8/1fP/8y+iZ/H7xhYuLe5v7uLxGxBH6mpKsP3oGFxf3PDcpXtf0pDy1/8LFxf187u5ChouL+z+4bWnDxcX9W9yk+Rktkbcx+Wcs6NVwcXFvcOcC07X32/NdXFzcRVOJtiSNCtxc8frlXbi4uEe4eXNyvbnJByT571GvhouLu5k7t0QbiLQfX2x0cHFxl3KT0Uj++rYszo1kcHFx93ETXLLtyF+ZB6PDXg0XF/cId27k2bY0bSkcBiK4uLhHuHeGH6tGs9GmBxcX9wi3LVtFrDnV/BSnRXBxcY9w2+Xub2uS1V7sy3BxcTdz60PVZalqo9V6X4aLi7uIm49P2kFsvn7xPC4u7hFuEVaWB6qS+COPSHBxcU9yk6ZlrmzVYUdSNHFxcY9w2xaobZDyaLU9BIaLi7uPO1d68o+ZK5Qvjmzi4uJu5uZXG50kTc6dz8DFxd3NnYtE51qaNmTBxcV9LzffrCS1cK7hiVbAxcX9SG6+dBuPRlsrXFzcD+MmYWje/OTr4OLivoubNz9z49I7YWuR8uLi4i7i3glM80MYeYS6Md/FxcV9/d9vga0bMRfOZM8AAAAASUVORK5CYII=" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="/js/plugins/jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.3.9"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.3.9"></script>
<script type="text/javascript" src="/js/plugins/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/plugins/MathJax.js"></script>
<script type="text/javascript" src="/js/plugins/TeX-AMS-MML_HTMLorMML.js"></script>
<script type="text/javascript" src="/js/plugins/MathMenu.js"></script>
<script type="text/javascript" src="/js/plugins/MathZoom.js"></script>

<script type="text/javascript" src="/js/plugins/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.3.9"></script>
<script type="text/javascript" src="/js/blog.js?v=1.3.9"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.3.9"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src=""></script>







    
</body>
</html>
