<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>常用算法 | Mr.Yellow.Wills</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="算法,排序,递归,二叉树,数组">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.3.9">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Mr.Yellow</h5>
          <a href="mailto:601661706@qq.com" title="601661706@qq.com" class="mail">
            
              <span>6</span>
            
              <span>0</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>6</span>
            
              <span>1</span>
            
              <span>7</span>
            
              <span>0</span>
            
              <span>6</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/YeWills/YeWills.github.io/tree/blog_code" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>常用算法</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">常用算法</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-04-09T00:00:00.000Z" itemprop="datePublished" class="page-time">
  2019-04-09
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/js/">js</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-calc"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">常用算法</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-04-09 00:00:00" datetime="2019-04-09T00:00:00.000Z"  itemprop="datePublished">2019-04-09</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/js/">js</a></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h2 id="阅读说明"><a href="#阅读说明" class="headerlink" title="阅读说明"></a>阅读说明</h2><p>为了让每个算法模块能够有更多的的目录层级，本文直接将各模块单列出一个章节讲，这样的弊端是，知识点看起来比较乱，<br>一眼看不出他们对应的是什么算法内容。<br>所以本章节用于将各章节对应的算法知识点，进行目录分类。具体模块内容请跳转到相关章节看。</p>
<p>算法模块：</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="电话号码"><a href="#电话号码" class="headerlink" title="电话号码"></a>电话号码</h4><h4 id="卡牌分组"><a href="#卡牌分组" class="headerlink" title="卡牌分组"></a>卡牌分组</h4><h4 id="种花问题"><a href="#种花问题" class="headerlink" title="种花问题"></a>种花问题</h4><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h4 id="最大间距-冒泡排序实现"><a href="#最大间距-冒泡排序实现" class="headerlink" title="最大间距 (冒泡排序实现)"></a>最大间距 (冒泡排序实现)</h4><h4 id="数组中的第K个最大元素-冒泡排序实现"><a href="#数组中的第K个最大元素-冒泡排序实现" class="headerlink" title="数组中的第K个最大元素 (冒泡排序实现)"></a>数组中的第K个最大元素 (冒泡排序实现)</h4><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="复原ip地址"><a href="#复原ip地址" class="headerlink" title="复原ip地址"></a>复原ip地址</h4><h4 id="递归阶乘"><a href="#递归阶乘" class="headerlink" title="递归阶乘"></a>递归阶乘</h4><h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h4><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><p><strong>基础算法篇</strong></p>
<h2 id="电话号码-1"><a href="#电话号码-1" class="headerlink" title="电话号码"></a>电话号码</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">力扣原题 – 电话号码的字母组合</a><br>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function calc(str) &#123;</span><br><span class="line">     let map = [&apos;&apos;, 1, &apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;, &apos;jkl&apos;, &apos;mno&apos;, &apos;pqrs&apos;, &apos;tuv&apos;, &apos;wxyz&apos;]</span><br><span class="line">     let num = str.split(&apos;&apos;)</span><br><span class="line">     let code = []</span><br><span class="line">     num.forEach(item =&gt; &#123;</span><br><span class="line">       if (map[item]) &#123;</span><br><span class="line">         code.push(map[item])</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     let comb = (arr) =&gt; &#123;</span><br><span class="line">       // 临时变量用来保存前两个组合的结果</span><br><span class="line">       let tmp = []</span><br><span class="line">       // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素</span><br><span class="line">       for (let i = 0; i &lt; arr[0].length; i++) &#123;</span><br><span class="line">         for (let j = 0; j &lt; arr[1].length; j++) &#123;</span><br><span class="line">           tmp.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       arr.splice(0, 2, tmp)</span><br><span class="line">       if (arr.length &gt; 1) &#123;</span><br><span class="line">         comb(arr)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         return tmp</span><br><span class="line">       &#125;</span><br><span class="line">       return arr[0]</span><br><span class="line">     &#125;</span><br><span class="line">     return comb(code)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //calc(&apos;32&apos;)</span><br></pre></td></tr></table></figure></p>
<p>现在对上面方法进行思路和要点解析</p>
<h3 id="每次只让第一个和第二个元素两两组合"><a href="#每次只让第一个和第二个元素两两组合" class="headerlink" title="每次只让第一个和第二个元素两两组合"></a>每次只让第一个和第二个元素两两组合</h3><p>不管输入多少位数，都让前两位数字进行组合，组合的结果 再跟 第三位数字进行组合，逻辑一样，依次类推。 逻辑一样的部分，则突出了使用递归的需求。<br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/phone.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/phone.jpg" alt title class></a>
                <p></p>
            </figure></p>
<h3 id="递归是重头戏"><a href="#递归是重头戏" class="headerlink" title="递归是重头戏"></a>递归是重头戏</h3><p>参考上面《两两组合》</p>
<h3 id="return-arr-0-很需要"><a href="#return-arr-0-很需要" class="headerlink" title="return arr[0] 很需要"></a>return arr[0] 很需要</h3><p>咋一看，觉得这一句不需要，以为有 if else，就不会走到 return arr[0]。这也是我误解的，其实下面的comb(arr)递归，执行完后，就会执行后面的return arr[0]。<br>以上也是我对于递归的误区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (arr.length &gt; 1) &#123;</span><br><span class="line">       comb(arr)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       return tmp</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">return arr[0]</span><br></pre></td></tr></table></figure></p>
<h3 id="递归完了还会往下执行"><a href="#递归完了还会往下执行" class="headerlink" title="递归完了还会往下执行"></a>递归完了还会往下执行</h3><p>参考上面 《return arr[0] 很需要》</p>
<h3 id="解决方法优化"><a href="#解决方法优化" class="headerlink" title="解决方法优化"></a>解决方法优化</h3><p>上面解决代码中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (arr.length &gt; 1) &#123;</span><br><span class="line">         comb(arr)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         //带有一定歧义</span><br><span class="line">         return tmp</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>可写成如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function calc(str) &#123;</span><br><span class="line">   let map = [&apos;&apos;, 1, &apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;, &apos;jkl&apos;, &apos;mno&apos;, &apos;pqrs&apos;, &apos;tuv&apos;, &apos;wxyz&apos;]</span><br><span class="line">   let num = str.split(&apos;&apos;)</span><br><span class="line">   let code = []</span><br><span class="line">   num.forEach(item =&gt; &#123;</span><br><span class="line">     if (map[item]) &#123;</span><br><span class="line">       code.push(map[item])</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   let comb = (arr) =&gt; &#123;</span><br><span class="line">     // 临时变量用来保存前两个组合的结果</span><br><span class="line">     let tmp = []</span><br><span class="line">     // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素</span><br><span class="line">     for (let i = 0; i &lt; arr[0].length; i++) &#123;</span><br><span class="line">       for (let j = 0; j &lt; arr[1].length; j++) &#123;</span><br><span class="line">         tmp.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     arr.splice(0, 2, tmp)</span><br><span class="line">     if (arr.length &gt; 1) &#123;</span><br><span class="line">       return comb(arr)</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">       return arr[0]</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return comb(code)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="再一次优化"><a href="#再一次优化" class="headerlink" title="再一次优化"></a>再一次优化</h3><p>上面的代码看起来有点晕，下面将两两组合的逻辑提出来，让代码更清晰，本次优化的逻辑与上面是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function combile(a1,b1)&#123;</span><br><span class="line">    let arr=[];</span><br><span class="line">    a1.forEach(ai=&gt;&#123;</span><br><span class="line">        b1.forEach(bi=&gt;&#123;</span><br><span class="line">            arr.push(`$&#123;ai&#125;$&#123;bi&#125;`);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">function calc1(str)&#123;</span><br><span class="line">   let map = [&apos;&apos;, 1, &apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;, &apos;jkl&apos;, &apos;mno&apos;, &apos;pqrs&apos;, &apos;tuv&apos;, &apos;wxyz&apos;];</span><br><span class="line">   const allStr = str.split(&apos;&apos;).map(num=&gt;map[Number(num)]);</span><br><span class="line">   const cur = (strarr)=&gt;&#123;</span><br><span class="line">     //第一次strarr[0]是一个字符串， 以后strarr[0]经过splice后，都是数组</span><br><span class="line">    const one = typeof strarr[0] === &apos;string&apos; ? strarr[0].split(&apos;&apos;) : strarr[0];</span><br><span class="line">    const two = strarr[1].split(&apos;&apos;);</span><br><span class="line">    const newItem0 = combile(one, two);</span><br><span class="line">    strarr.splice(0,2,newItem0);</span><br><span class="line">       if(strarr.length&lt;2)&#123;</span><br><span class="line">           return strarr[0];</span><br><span class="line">       &#125;</span><br><span class="line">     return cur(strarr)</span><br><span class="line">   &#125;</span><br><span class="line">  return cur(allStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="考察算法要点"><a href="#考察算法要点" class="headerlink" title="考察算法要点"></a>考察算法要点</h3><p>给定一个数组，如何让内部元素两两组和，返回一个全组合结果；<br>其核心思想是，不管数组有多少元素，每次只让第一个元素和第二个元素两两组和；<br>递归以上行为，经过递归后，最终数组只有一个元素。这个元素就是组合结果。<br>所以核心是第一个和第二个两两组和；<br>技术实施是递归；<br>利用的原则是数组两两组和到最后必然只有一个元素；</p>
<h2 id="卡牌分组-1"><a href="#卡牌分组-1" class="headerlink" title="卡牌分组"></a>卡牌分组</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>给定一副牌，每张牌上都写着一个整数。<br>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：<br>每组都有 X 张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;= 2 时返回 true。<br><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards" target="_blank" rel="noopener">力扣原题 – 卡牌分组</a></p>
<p>用白话解释原题：给定一副牌，这副牌可以是1张或1万张，将这副牌分成一组或多组，每组牌的数字都相同，每组牌的个数不少于2.</p>
<h3 id="解法一：-数组前后两两比较"><a href="#解法一：-数组前后两两比较" class="headerlink" title="解法一： 数组前后两两比较"></a>解法一： 数组前后两两比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr) &#123;</span><br><span class="line">      // 将卡牌按值排序保证相同的卡牌是挨着的</span><br><span class="line">      let str = arr.sort((a, b) =&gt; a - b).join(&apos;&apos;)</span><br><span class="line">      // 分组(单张或者多张)  \1 在正则中表示连续一样的匹配</span><br><span class="line">      let group = str.match(/(\d)\1+|\d/g)</span><br><span class="line">      // 求两个数的最大公约数</span><br><span class="line">      let gcd = (a, b) =&gt; &#123;    </span><br><span class="line">        if(b === 0)  return a;   </span><br><span class="line">        return gcd(b, a % b)</span><br><span class="line">       &#125;</span><br><span class="line">      // 思想：只要所有的分组具有最大公约数(大于1)就满足条件</span><br><span class="line">      // 对所有的分组进行最大公约数验证，相邻两个分组的最大公约数，再与后面的公约数进行验证，以此类推，有一个最大公约数为1就退出</span><br><span class="line">      while (group.length &gt; 1) &#123;</span><br><span class="line">        let a = group.shift().length</span><br><span class="line">        let b = group.shift().length</span><br><span class="line">        let v = gcd(a, b)</span><br><span class="line">        if (v === 1) &#123;</span><br><span class="line">          return false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 将前两个分组的最大公约数推进数组与下一个分组再次验证是否有最大公约数</span><br><span class="line">          group.unshift(&apos;0&apos;.repeat(v))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 考虑边界[&apos;11&apos;]即只有一个分组的时候</span><br><span class="line">      return group.length ? group[0].length &gt; 1 : false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>下面是最大公约数的求法，可以不必理解，知道这样用就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let gcd = (a, b) =&gt; &#123;    </span><br><span class="line">    if(b === 0)  return a;   </span><br><span class="line">    return gcd(b, a % b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="最大公约数除了1值外，其他值都合法"><a href="#最大公约数除了1值外，其他值都合法" class="headerlink" title="最大公约数除了1值外，其他值都合法"></a>最大公约数除了1值外，其他值都合法</h4><h3 id="数组前后两两比较"><a href="#数组前后两两比较" class="headerlink" title="数组前后两两比较"></a>数组前后两两比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (group.length &gt; 1) &#123;</span><br><span class="line">        let a = group.shift().length</span><br><span class="line">        let b = group.shift().length</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出元素出现次数的方法-推荐-–match正则"><a href="#找出元素出现次数的方法-推荐-–match正则" class="headerlink" title="找出元素出现次数的方法(推荐)–match正则"></a>找出元素出现次数的方法(推荐)–match正则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 分组(单张或者多张)  \1 在正则中表示连续一样的匹配</span><br><span class="line"> let group = str.match(/(\d)\1+|\d/g)</span><br></pre></td></tr></table></figure>
<h3 id="找出元素出现次数的方法–object-key方式"><a href="#找出元素出现次数的方法–object-key方式" class="headerlink" title="找出元素出现次数的方法–object key方式"></a>找出元素出现次数的方法–object key方式</h3><p>参考下面的《最小相同数与所有相同数比较的 实现方式》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const hash = deck.reduce((pre, num) =&gt; &#123;    //统计出每种数字的数目</span><br><span class="line">  if(!pre[num]) &#123;</span><br><span class="line">    pre[num] = 1</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    pre[num]++</span><br><span class="line">  &#125;</span><br><span class="line">  return pre</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="while-实现-递归效果"><a href="#while-实现-递归效果" class="headerlink" title="while 实现 递归效果"></a>while 实现 递归效果</h3><p>见上面的代码。</p>
<h3 id="解法一优化：用递归代替while写法"><a href="#解法一优化：用递归代替while写法" class="headerlink" title="解法一优化：用递归代替while写法"></a>解法一优化：用递归代替while写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr) &#123;</span><br><span class="line">     let str = arr.sort((a, b) =&gt; a - b).join(&apos;&apos;)</span><br><span class="line">     let group = str.match(/(\d)\1+|\d/g)</span><br><span class="line">     let gcd = (a, b) =&gt; &#123;    </span><br><span class="line">       if(b === 0)  return a;   </span><br><span class="line">       return gcd(b, a % b)</span><br><span class="line">      &#125;</span><br><span class="line">      const cur = (arr)=&gt;&#123;</span><br><span class="line">        if(arr.length&lt;2)&#123;</span><br><span class="line">          return arr[0].length &gt; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        const one = arr.shift().length;</span><br><span class="line">        const two = arr.shift().length;</span><br><span class="line">        let v = gcd(one, two);</span><br><span class="line">        if (v === 1) &#123;</span><br><span class="line">         return false</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         arr.unshift(&apos;0&apos;.repeat(v));</span><br><span class="line">        return cur(arr);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     return cur(group);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法二：最小相同数与所有相同数比较"><a href="#解法二：最小相同数与所有相同数比较" class="headerlink" title="解法二：最小相同数与所有相同数比较"></a>解法二：最小相同数与所有相同数比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var hasGroupsSizeX = function(deck) &#123;</span><br><span class="line">  let getResult = (a, b) =&gt; &#123;    //定义一个寻找公约数的方法</span><br><span class="line">    if(b === 0)  return a;   </span><br><span class="line">    return getResult(b, a % b)</span><br><span class="line">  &#125;</span><br><span class="line">  const hash = deck.reduce((pre, num) =&gt; &#123;    //统计出每种数字的数目</span><br><span class="line">    if(!pre[num]) &#123;</span><br><span class="line">      pre[num] = 1</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      pre[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    return pre</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">  const numCount = Object.values(hash)     //将hash中的每项数值存入数组，便于后续遍历</span><br><span class="line">  const min = numCount.sort((a, b) =&gt; a-b)[0];         //利用数组排序快速获取最小值</span><br><span class="line">  if (min &lt; 2) return false; //根据题意，如果最分组最小数量小于2，直接返回false</span><br><span class="line">  return !numCount.some((item,index) =&gt; &#123;</span><br><span class="line">    if(index &gt; 0) return getResult(item, min) === 1</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两种方案的利弊"><a href="#两种方案的利弊" class="headerlink" title="两种方案的利弊"></a>两种方案的利弊</h3><p>尽管两种方法都能实现，但是解法一比解法二节省了一次遍历，当数据量大时，这种性能上的差别就会比较大，所以推荐第一种方案。</p>
<h2 id="种花问题-1"><a href="#种花问题-1" class="headerlink" title="种花问题"></a>种花问题</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。<br>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花，算出n的最大值。<br><a href="https://leetcode-cn.com/problems/can-place-flowers" target="_blank" rel="noopener">力扣原题 – 种花问题</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr)&#123;</span><br><span class="line">    // 计数器</span><br><span class="line">    let max = 0</span><br><span class="line">    for (let i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">      //只有arr[i] === 0时，说明可以种花，因此只需考虑arr[i] === 0的逻辑，其他情况不用考虑</span><br><span class="line">      if (arr[i] === 0) &#123;</span><br><span class="line">        //当 arr[i] === 0 时都符合条件，唯有边界值 i===0 与 i === arr.length-2 时需要特殊考虑</span><br><span class="line">        if (i === 0 &amp;&amp; arr[1] === 0) &#123;</span><br><span class="line">          max++</span><br><span class="line">          //跳转，这里i++，加上for循环自动也++，所以i实际加了2</span><br><span class="line">          i++</span><br><span class="line">        &#125; else if (i === arr.length-2 &amp;&amp; arr[arr.length-1] === 0) &#123;</span><br><span class="line">          max++</span><br><span class="line">        &#125;else if (arr[i - 1] === 0 &amp;&amp; arr[i + 1] === 0) &#123;</span><br><span class="line">          max++</span><br><span class="line">           //跳转，这里i++，加上for循环自动也++，所以i实际加了2</span><br><span class="line">          i++</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  calc([1, 0, 0, 0, 1, 0, 0])// 2</span><br><span class="line">  calc([1, 0, 0, 0, 1])//1</span><br><span class="line">  calc([0,0,1, 0, 0, 0, 1])//2</span><br></pre></td></tr></table></figure>
<h3 id="要点分析"><a href="#要点分析" class="headerlink" title="要点分析"></a>要点分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,0,0,0,0,0,0,0,1]</span><br></pre></td></tr></table></figure>
<p>其实就是在数组中找000的模型，有000就可以变成010，达到要求。<br>另外一个要考虑的是边界问题，比如，[0,0,1]，这不符合 000，但依然可以在最左侧加1；<br>这种问题其实就是在数组中找 000 这种模型，就涉及到用数学建模的思想来解决。</p>
<h3 id="核心一：-000的数学建模"><a href="#核心一：-000的数学建模" class="headerlink" title="核心一： 000的数学建模"></a>核心一： 000的数学建模</h3><p>以后遇到类似的找这种000的形式的东西，就考虑用数学建模。</p>
<h3 id="核心二：-遍历"><a href="#核心二：-遍历" class="headerlink" title="核心二： 遍历"></a>核心二： 遍历</h3><p>种花问题，主要运用遍历来解决，使用了很多遍历技巧，比如跳级忽略遍历，以及i+1等的处理，<br>i+1的遍历技巧本质上就是多个遍历元素的技巧；<br>因为一般遍历元素只有一个arr[i]（姑且称这种遍历为单元遍历）,多个遍历元素是指遍历体中同时存在 arr[i] arr[i+n] （多元遍历）。</p>
<h3 id="单元遍历-与-多元遍历"><a href="#单元遍历-与-多元遍历" class="headerlink" title="单元遍历 与 多元遍历"></a>单元遍历 与 多元遍历</h3><p>参考《核心二： 遍历》</p>
<h3 id="遍历体用-i-跳级忽略遍历"><a href="#遍历体用-i-跳级忽略遍历" class="headerlink" title="遍历体用 i++ 跳级忽略遍历"></a>遍历体用 i++ 跳级忽略遍历</h3><p>例如下面的，index位置 1 2 3 符合 000；<br>2 3 4 也符合 000；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,0,0,0,0,1]</span><br></pre></td></tr></table></figure></p>
<p>但实际上当遍历了index 123后，下一次只要求遍历index 345；<br>如何做到呢，可通过在for循环内，i++ :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0, len = arr.length - 1; i &lt; len; i++) &#123;</span><br><span class="line">   //跳转，这里i++，加上for循环自动也++，所以i实际加了2</span><br><span class="line">   i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h3><p>参考《要点分析》</p>
<h3 id="arr-i-1-与arr-i-1-的遍历技巧"><a href="#arr-i-1-与arr-i-1-的遍历技巧" class="headerlink" title="arr[i+1]与arr[i-1]的遍历技巧"></a>arr[i+1]与arr[i-1]的遍历技巧</h3><h4 id="arr-i-1-与-arr-i-1-与-i-lt-arr-length-1-的妙用"><a href="#arr-i-1-与-arr-i-1-与-i-lt-arr-length-1-的妙用" class="headerlink" title="arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用"></a>arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用</h4><p>因为for循环体内用了arr[i+1]，那么在for的title上能遍历的最大值是 arr.length - 2，也就是i &lt; arr.length - 1；<br>这个是一个很实用的用法，我们在写for循环时，如果for循环体内有这样的情况，就应该考虑好for的title上最大的i &lt; arr.length值也应响应配合增加或减少。并且这个最大的arr.length值到底多少<strong>与函数体内最大的arr[i+1]有关，而与arr[i-1]无关。</strong>，当然，如果用到arr[i-1]时，<strong>就要考虑边界值的问题</strong>，也就是当i为0时的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">       ...</span><br><span class="line">         &#125; else if (arr[i - 1] === 0 &amp;&amp; arr[i + 1] === 0) &#123;</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="arr-i-1-时考虑边界值，arr-i-1-时考虑i值最大值"><a href="#arr-i-1-时考虑边界值，arr-i-1-时考虑i值最大值" class="headerlink" title="arr[i-1]时考虑边界值，arr[i-1]时考虑i值最大值"></a>arr[i-1]时考虑边界值，arr[i-1]时考虑i值最大值</h4><p>参考《arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用》</p>
<h3 id="遍历的经典练习题"><a href="#遍历的经典练习题" class="headerlink" title="遍历的经典练习题"></a>遍历的经典练习题</h3><p>种花问题基于遍历实现，用到了比较多的遍历技巧，可称为经典遍历的运用练习题。</p>
<h2 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>冒泡排序大白话解释就是，将数组内的最大值，从左到右或右带左地排序，这个过程好像数组内的最大值好像冒泡一样，从水底上浮的过程。<br>冒泡排序是每次比较左右两个值，每次进行比较交换位置。<br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/water.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/water.jpg" alt title class></a>
                <p></p>
            </figure><br>如下图，要实现如下的一个渐进的排序过程：<br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/bubble.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/bubble.jpg" alt title class></a>
                <p></p>
            </figure><br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/bubble1.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/bubble1.jpg" alt title class></a>
                <p></p>
            </figure><br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/bubble2.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/bubble2.jpg" alt title class></a>
                <p></p>
            </figure></p>
<h3 id="将最值移到边缘的技巧"><a href="#将最值移到边缘的技巧" class="headerlink" title="将最值移到边缘的技巧"></a>将最值移到边缘的技巧</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">let</span> c = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">            arr[j + <span class="number">1</span>] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序是最值移动的多次重复"><a href="#排序是最值移动的多次重复" class="headerlink" title="排序是最值移动的多次重复"></a>排序是最值移动的多次重复</h3><p>既然有一种算法可以将最值移动至边缘，那么这种算法就构成了排序的可能，我们可以将最值移动称之为排序的最小组成。<br>就好比，复杂的现象 无非都是 将简单的现象重复多遍的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">let</span> c = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">            arr[j + <span class="number">1</span>] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calc([<span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">999</span>,<span class="number">6</span>]) <span class="comment">//[0, 1, 2, 3, 4, 5, 6, 9, 999]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过最值移动，将最值移至边缘，那么下次遍历的时候，只需排除这个最值，将剩余的元素重复最值的移动。<br>现在最值移动的算法我们已经知道了，要做的是，每次最值移动时不包含边缘的最值。</p>
<h3 id="处理i-1-遍历的技巧"><a href="#处理i-1-遍历的技巧" class="headerlink" title="处理i+1 遍历的技巧"></a>处理i+1 遍历的技巧</h3><p>参考 《将最值移到边缘的技巧》</p>
<h2 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="概述-以及-选择、冒泡区别"><a href="#概述-以及-选择、冒泡区别" class="headerlink" title="概述 以及 选择、冒泡区别"></a>概述 以及 选择、冒泡区别</h3><figure class="image-box">
                <a rel=常用算法 href="/image/calc/select-dubble.jpeg" title="undefined" data-fancybox="images"><img src="/image/calc/select-dubble.jpeg" alt title class></a>
                <p></p>
            </figure>
<p>如下图，要实现如下的一个渐进的排序过程：<br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/select.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/select.jpg" alt title class></a>
                <p></p>
            </figure><br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/select1.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/select1.jpg" alt title class></a>
                <p></p>
            </figure></p>
<h3 id="选定第1个位置放置最小值"><a href="#选定第1个位置放置最小值" class="headerlink" title="选定第1个位置放置最小值"></a>选定第1个位置放置最小值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var i = 0 //第1个位置</span><br><span class="line"> for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">          if (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">            let c = arr[i]</span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            arr[j] = c</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="选定第2个位置放置剩余数组的最小值"><a href="#选定第2个位置放置剩余数组的最小值" class="headerlink" title="选定第2个位置放置剩余数组的最小值"></a>选定第2个位置放置剩余数组的最小值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var i = 1 //第2个位置</span><br><span class="line"> for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">          if (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">            let c = arr[i]</span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            arr[j] = c</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>将上面选定位置最值算法重复多遍，就达到排序的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr) &#123;</span><br><span class="line">      // 选择排序</span><br><span class="line">      for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">          if (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">            let c = arr[i]</span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            arr[j] = c</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a>最大间距</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><a href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" rel="noopener">力扣原题 – 最大间距</a><br>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>如果数组元素个数小于 2，则返回 0。</p>
<h3 id="推荐方法"><a href="#推荐方法" class="headerlink" title="推荐方法"></a>推荐方法</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>这种题一般通过排序完成，并且在排序的过程中，获取最大值，以下通过 冒泡排序的方式来做，主要利用冒泡的时候，其他已经逐步排序好最大值了，利用这逐步排序好的最大值，逐步求出间距：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getDistance(a, b, max) &#123;</span><br><span class="line">     const num = a - b;</span><br><span class="line">     if (max &lt; num) &#123;</span><br><span class="line">       max = Math.abs(num);</span><br><span class="line">     &#125;</span><br><span class="line">     return max;</span><br><span class="line">   &#125;</span><br><span class="line">   function calc(arr) &#123;</span><br><span class="line">     let max=0;</span><br><span class="line">     for (let i = arr.length - 1, tmp; i &gt; 0; i--) &#123;</span><br><span class="line">       for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">         if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">           let c = arr[j];</span><br><span class="line">           arr[j] = arr[j + 1];</span><br><span class="line">           arr[j + 1] = c;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (i &lt; (arr.length - 1)) &#123;</span><br><span class="line">         max = getDistance(arr[i + 1], arr[i], max);</span><br><span class="line">         if (i === 1) &#123;</span><br><span class="line">           max = getDistance(arr[1], arr[0], max);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h4><p>当i === (arr.length - 2)与i=1时需要处理不同逻辑。</p>
<h3 id="借助冒泡或选择排序实现"><a href="#借助冒泡或选择排序实现" class="headerlink" title="借助冒泡或选择排序实现"></a>借助冒泡或选择排序实现</h3><p>如上代码，因为冒泡或选择排序是，最左或最右端值已经排序好，排序好的就可以计算差值。所以可利用这一特性，找出最大间距。</p>
<h3 id="不推荐方法"><a href="#不推荐方法" class="headerlink" title="不推荐方法"></a>不推荐方法</h3><p>不推荐理由，利用sort进行了一次遍历，然后又用遍历求最大间距，用了两次遍历，相比上面的推荐方法的一次遍历，这种方法性能不好。<br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/max.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/max.jpg" alt title class></a>
                <p></p>
            </figure></p>
<h3 id="遍历是核心"><a href="#遍历是核心" class="headerlink" title="遍历是核心"></a>遍历是核心</h3><p>最大间距的解决主要借助遍历实现。</p>
<h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">力扣原题 – 数组中的第K个最大元素</a><br>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:</p>
<p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:</p>
<p>先说不推荐方法</p>
<h3 id="不推荐方法-1"><a href="#不推荐方法-1" class="headerlink" title="不推荐方法"></a>不推荐方法</h3><p>这种方法非常容易理解，但是却有浪费之嫌，因为根本不需要对整个数组先排序再查找，因为一旦找到第k个值，就可以停止程序了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default (arr, k) =&gt; &#123;</span><br><span class="line">  return arr.sort((a, b) =&gt; b - a)[k - 1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="推荐方法-1"><a href="#推荐方法-1" class="headerlink" title="推荐方法"></a>推荐方法</h3><p>利用冒泡排序来做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default (arr, k) =&gt; &#123;</span><br><span class="line">  let len = arr.length - 1</span><br><span class="line">  for (let i = len, tmp; i &gt; len - k; i--) &#123;</span><br><span class="line">    for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">        tmp = arr[j]</span><br><span class="line">        arr[j] = arr[j + 1]</span><br><span class="line">        arr[j + 1] = tmp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // arr[len+1-k]</span><br><span class="line">  return arr[len - (k - 1)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="借助冒泡或选择排序实现-1"><a href="#借助冒泡或选择排序实现-1" class="headerlink" title="借助冒泡或选择排序实现"></a>借助冒泡或选择排序实现</h3><p>如上代码，因为冒泡或选择排序是，最左或最右端值已经排序好，排序到第k个时，马上停止遍历，有助于性能。</p>
<h2 id="快速排序-最好的排序方式"><a href="#快速排序-最好的排序方式" class="headerlink" title="快速排序(最好的排序方式)"></a>快速排序(最好的排序方式)</h2><h3 id="要点分析-1"><a href="#要点分析-1" class="headerlink" title="要点分析"></a>要点分析</h3><p>快速排序，以数组中间一个元素为基准，小于的放在左边，大于的放在右边，然后递归，排序完成。<br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/quick0.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/quick0.jpg" alt title class></a>
                <p></p>
            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(ary)&#123;</span><br><span class="line">       if(ary.length&lt;=1)&#123;</span><br><span class="line">           return ary;</span><br><span class="line">       &#125;</span><br><span class="line">       var pointIndex = Math.floor(ary.length/2);</span><br><span class="line">       //从ary中删除pointIndex，并且通过[0]取出pointValue值</span><br><span class="line">       var pointValue = ary.splice(pointIndex, 1)[0];</span><br><span class="line">       var left = [];</span><br><span class="line">       var right = [];</span><br><span class="line">       for (var i=0; i&lt;ary.length; i++)&#123;</span><br><span class="line">           var cur = ary[i];</span><br><span class="line">           cur &lt; pointValue ? left.push(cur) : right.push(cur);</span><br><span class="line">       &#125;</span><br><span class="line">       return quickSort(left).concat([pointValue],quickSort(right));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="中间元素，左右两边分组"><a href="#中间元素，左右两边分组" class="headerlink" title="中间元素，左右两边分组"></a>中间元素，左右两边分组</h3><p>快速排序是选一个数组中间元素值为准，左右分两组，这种操作类似易经大衍筮法占卜的手法。<br>不过快速排序不是一定要数组中间值，任意一个元素为准都可以，只是推荐使用中间元素。</p>
<h3 id="推荐使用中间元素-但也可使用其他元素"><a href="#推荐使用中间元素-但也可使用其他元素" class="headerlink" title="推荐使用中间元素,但也可使用其他元素"></a>推荐使用中间元素,但也可使用其他元素</h3><p>这里有一个以其他元素为准的快速排序写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    if (arr.length &lt;= 1) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    let leftArr = [];</span><br><span class="line">    let rightArr = [];</span><br><span class="line">    let q = arr[0];</span><br><span class="line">    for (let i = 1, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">        if (arr[i] &gt; q) &#123;</span><br><span class="line">            rightArr.push(arr[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            leftArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    return [].concat(quickSort(leftArr), [q], quickSort(rightArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="递归的经典运用"><a href="#递归的经典运用" class="headerlink" title="递归的经典运用"></a>递归的经典运用</h3><p>递归是快速排序的核心，如果无法理解，暂且就记住这种场景解法，用多了，自然就有了这种逻辑思维了。</p>
<h3 id="递归最后呈现的由最后的边界值决定"><a href="#递归最后呈现的由最后的边界值决定" class="headerlink" title="递归最后呈现的由最后的边界值决定"></a>递归最后呈现的由最后的边界值决定</h3><p>比如上面的代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">ary</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(ary.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> ary;<span class="comment">//这是边界值</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> pointIndex = <span class="built_in">Math</span>.floor(ary.length/<span class="number">2</span>);</span><br><span class="line">       <span class="comment">//从ary中删除pointIndex，并且通过[0]取出pointValue值</span></span><br><span class="line">       <span class="keyword">var</span> pointValue = ary.splice(pointIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">var</span> left = [];</span><br><span class="line">       <span class="keyword">var</span> right = [];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ary.length; i++)&#123;</span><br><span class="line">           <span class="keyword">var</span> cur = ary[i];</span><br><span class="line">           cur &lt; pointValue ? left.push(cur) : right.push(cur);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> quickSort(left).concat([pointValue],quickSort(right));<span class="comment">//return 表达式</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>无论quickSort(left)递归了多少次，quickSort(left)的值，肯定是 ary ，<br>同理，quickSort(right))的值，肯定是 ary。</p>
<h3 id="递归结果是边界值与return表达式作用的结果"><a href="#递归结果是边界值与return表达式作用的结果" class="headerlink" title="递归结果是边界值与return表达式作用的结果"></a>递归结果是边界值与return表达式作用的结果</h3><p>因此，无论怎么样，quickSort(ary)执行的结果，必将形式如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quickSort(left).concat([pointValue],quickSort(right))</span><br></pre></td></tr></table></figure></p>
<p>经过上面的分析，quickSort(left)等效 ary，<br>上面等效<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>].concat([<span class="number">1</span>],[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>这说明了，递归最后呈现的由最后的边界值决定，且返回的结果 就是边界值与return表达式作用的结果。</p>
<h2 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="通常方案"><a href="#通常方案" class="headerlink" title="通常方案"></a>通常方案</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>将原来数组打散重新将所有元素一个个放置，新建一个数组，用于接收放置的元素。<br>元素在新数组中，按照大小顺序插入放置。</p>
<figure class="image-box">
                <a rel=常用算法 href="/image/calc/insort1.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/insort1.jpg" alt title class></a>
                <p></p>
            </figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">ary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newAry=[];</span><br><span class="line">    newAry.push(ary[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;ary.length; i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> cur =ary[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = newAry.length - <span class="number">1</span>; j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">//其实这里就考虑两种情况，将最大值放入右侧，或者找不到最大值，就说明这个是最小值，放入左侧，</span></span><br><span class="line">            <span class="keyword">if</span>(cur&gt;newAry[j])&#123;</span><br><span class="line">                newAry.splice(j+<span class="number">1</span>,<span class="number">0</span>,cur);<span class="comment">//最大值放到右侧</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//j===0，数组表示遍历完了，说明此时数组的全部元素都大于cur</span></span><br><span class="line">                <span class="keyword">if</span>(j===<span class="number">0</span>)&#123;</span><br><span class="line">                  newAry.unshift(cur);<span class="comment">//最小值放入左侧</span></span><br><span class="line">                  <span class="keyword">break</span>;<span class="comment">//这个break可以不用，写出来，只是方便理解，告诉你，如果改变了newAry，那么将结束遍历</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newAry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提高"><a href="#提高" class="headerlink" title="提高"></a>提高</h3><h4 id="可不用了解"><a href="#可不用了解" class="headerlink" title="可不用了解"></a>可不用了解</h4><p>下面的提高做法，是网上比较流行的插入排序算法，有精力可以了解下</p>
<h4 id="不新建数组直接排序的实现"><a href="#不新建数组直接排序的实现" class="headerlink" title="不新建数组直接排序的实现"></a>不新建数组直接排序的实现</h4><p>这种方法与方案一不同的是，方案二没有单独创建新数组来存放排序元素，而是直接基于原数组进行改造，相对来说理解起来要难一点。<br>其实找到窍门后，理解起来就好了，理解插入排序，只需要理解<strong>内层遍历如何排序</strong>，就理解了整个插入排序的思想，后面有讲到。</p>
<figure class="image-box">
                <a rel=常用算法 href="/image/calc/insort2.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/insort2.jpg" alt title class></a>
                <p></p>
            </figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> function insertSort(ary)&#123;</span><br><span class="line">    var key,j;</span><br><span class="line">    for(var i=1;i&lt;ary.length;i++)&#123;</span><br><span class="line">            key=ary[i];</span><br><span class="line">            for(var j=i-1;j&gt;-1;j--)&#123;</span><br><span class="line">                if(ary[j]&gt;key)&#123;</span><br><span class="line">                  如果ary[j]大于key，那么将ary[j]往右挪一步</span><br><span class="line">                    ary[j+1]=ary[j];</span><br><span class="line">                    if(j===0)&#123;</span><br><span class="line">                        //能走到j===0说明ary[j]都大于key，原来的j 数组已经整体往右挪一步，此时ary[0]值就是key；</span><br><span class="line">                        ary[0]=key;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    如果ary[j]小于key，那么将key置于其右侧</span><br><span class="line">                    ary[j+1]=key;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="外层遍历提供元素，内层遍历进行排序"><a href="#外层遍历提供元素，内层遍历进行排序" class="headerlink" title="外层遍历提供元素，内层遍历进行排序"></a>外层遍历提供元素，内层遍历进行排序</h4><h4 id="内层排序技巧"><a href="#内层排序技巧" class="headerlink" title="内层排序技巧"></a>内层排序技巧</h4><p>外层遍历每次给内层遍历输入一个元素；<br>内层遍历 接收这个元素后，如何排序；<br>接收一个元素势必增加长度；<br>所以通过j+1，通过比较，数组整体平移整个数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">key=ary[i];</span><br><span class="line">            for(var j=i-1;j&gt;-1;j--)&#123;</span><br><span class="line">                if(ary[j]&gt;key)&#123;</span><br><span class="line">                  如果ary[j]大于key，那么将ary[j]往右挪一步</span><br><span class="line">                    ary[j+1]=ary[j];</span><br><span class="line">                    if(j===0)&#123;</span><br><span class="line">                        //能走到j===0说明ary[j]都大于key，原来的j 数组已经整体往右挪一步，此时ary[0]值就是key；</span><br><span class="line">                        ary[0]=key;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    如果ary[j]小于key，那么将key置于其右侧</span><br><span class="line">                    ary[j+1]=key;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="遍历的经典应用"><a href="#遍历的经典应用" class="headerlink" title="遍历的经典应用"></a>遍历的经典应用</h4><p>此方案是经典的</p>
<h4 id="用while来改写方案二"><a href="#用while来改写方案二" class="headerlink" title="用while来改写方案二"></a>用while来改写方案二</h4><p>此写法其思想跟方案二是一样的。<br>while的好处是代码十分简洁，但是此代码极具误导性，单凭此，就可以认定这种写法是不推荐的。<br>这里有一个理解误区，a[0] 可以进入 while体内，等出来的时候j就变成了 -1 ，ary[-1+1]就是a[0]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function insertSort1(ary)&#123;</span><br><span class="line">    var key,j;</span><br><span class="line">    for(var i=1;i&lt;ary.length;i++)&#123;</span><br><span class="line">            key=ary[i];</span><br><span class="line">            j=i-1;</span><br><span class="line">            while(j&gt;-1&amp;&amp;ary[j]&gt;key)&#123;</span><br><span class="line">                ary[j+1]=ary[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            ary[j+1]=key;</span><br><span class="line">        &#125;</span><br><span class="line">        return ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="复原ip地址-1"><a href="#复原ip地址-1" class="headerlink" title="复原ip地址"></a>复原ip地址</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br>示例:<br>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]<br><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">力扣原题 –  复原IP地址</a></p>
<p>用白话解释原题：给出一串字符，写出它能组成的所有的ip.</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>代码如下，个人觉得代码不容易理解，请先看下面当代码分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function calc(str) &#123;</span><br><span class="line">      // 保存所有符合条件的IP地址</span><br><span class="line">      let r = []</span><br><span class="line">      // 分四步递归处理ip分段</span><br><span class="line">      let search = (cur, sub) =&gt; &#123;</span><br><span class="line">        // 非法输入过滤 ip地址最多不超过12个字符长</span><br><span class="line">        if (sub.length &gt; 12) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        // 边界条件</span><br><span class="line">        if (cur.length === 4 &amp;&amp; cur.join(&apos;&apos;) === str) &#123;</span><br><span class="line">          r.push(cur.join(&apos;.&apos;))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 正常的处理过程 </span><br><span class="line">          // Math.min(3, sub.length) i必须小于等于3</span><br><span class="line">          for (let i = 0, tmp; i &lt; Math.min(3, sub.length); i++) &#123;</span><br><span class="line">            tmp = sub.substr(0, i + 1)</span><br><span class="line">            if (tmp - 256 &lt; 0) &#123;</span><br><span class="line">              const newCur = cur.concat([tmp]);</span><br><span class="line">              const newSub = sub.substr(i + 1);</span><br><span class="line">              //当 newCur的数组元素超过4时，就不是ip地址了；</span><br><span class="line">              //当newCur有三个元素，准备补充第四个元素时，如果第四个元素当字符长度大于3位，就没有必要再继续下去</span><br><span class="line">              if(newCur.length &gt; 4 || (newCur.length === 3 &amp;&amp; newSub.length&gt;3))&#123;</span><br><span class="line">                continue</span><br><span class="line">              &#125;</span><br><span class="line">              search(newCur, newSub)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      search([], str)</span><br><span class="line">      return r</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>如下图，25525511135 这样一个字符串，要组成一个ip时；<br>ip由四个不大于256的数字排列组成；<br>第一个数字可以是 2 25 255；<br>当第一个数字为2时 剩下的代码为 5525511135；<br>此时它的第二个数字可以是 5 55 552(大于256，不符合规则)；<br>当第二个数字为5时，剩下的代码为 525511135；<br>此时它第三个数字可以是 5 52 525；<br>当第三个数字为5时， 剩下代码为25511136 不符合规则；<br>依次类推–递归。<br>如果你还是对分析或则上面代码不太理解，请拿出你对纸和笔，将上面代码在纸上遍历几次，就明白了。<br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/cur.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/cur.jpg" alt title class></a>
                <p></p>
            </figure></p>
<h3 id="递归设计中-必不可少的-边界条件"><a href="#递归设计中-必不可少的-边界条件" class="headerlink" title="递归设计中 必不可少的 边界条件"></a>递归设计中 必不可少的 边界条件</h3><p>要写一个递归，必须要写终止递归条件，也就是边界条件。上面代码的边界条件就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (cur.length === 4 &amp;&amp; cur.join(&apos;&apos;) === str) &#123;</span><br><span class="line">         r.push(cur.join(&apos;.&apos;))</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对称二叉树-1"><a href="#对称二叉树-1" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p> <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">力扣原题–对称二叉树</a></p>
<h3 id="创建对称二叉树"><a href="#创建对称二叉树" class="headerlink" title="创建对称二叉树"></a>创建对称二叉树</h3><h4 id="二叉树模型图"><a href="#二叉树模型图" class="headerlink" title="二叉树模型图"></a>二叉树模型图</h4> <figure class="image-box">
                <a rel=常用算法 href="/image/calc/tree.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/tree.jpg" alt title class></a>
                <p></p>
            </figure>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p> 以下是创建二叉树代码，后面会针对代码疑问进行解答</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"> // 二叉树的节点</span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(val) &#123;</span><br><span class="line">    this.val = val</span><br><span class="line">    this.left = this.right = undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tree &#123;</span><br><span class="line">  constructor(data) &#123;</span><br><span class="line">    // 临时存储所有节点，方便寻找父子节点</span><br><span class="line">    let nodeList = []</span><br><span class="line">    // 顶节点</span><br><span class="line">    let root</span><br><span class="line">    for (let i = 0, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">      let node = new Node(data[i])</span><br><span class="line">      nodeList.push(node)</span><br><span class="line">      if (i &gt; 0) &#123;</span><br><span class="line">        // 计算当前节点属于那一层</span><br><span class="line">        let n = Math.floor(Math.sqrt(i + 1))</span><br><span class="line">        // 记录当前层的起始nodelist的index</span><br><span class="line">        let q = Math.pow(2, n) - 1</span><br><span class="line">        // 记录上一层的起始nodelist的index</span><br><span class="line">        let p = Math.pow(2, n - 1) - 1</span><br><span class="line">        // 找到当前节点的父节nodelist的index</span><br><span class="line">        let parent = nodeList[p + Math.floor((i - q) / 2)]</span><br><span class="line">        // 将当前节点和上一层的父节点做关联</span><br><span class="line">        if (parent.left) &#123;</span><br><span class="line">          parent.right = node</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          parent.left = node</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //只有第一个元素是起始节点，</span><br><span class="line">    root = nodeList.shift()</span><br><span class="line">    //其他元素完成使命，可以去掉</span><br><span class="line">    nodeList.length = 0</span><br><span class="line">    return root</span><br><span class="line">  &#125;</span><br><span class="line">  //验证二叉树是否是对称</span><br><span class="line">  static isSymmetry(root) &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">    let walk = (left, right) =&gt; &#123;</span><br><span class="line">      if (!left &amp;&amp; !right) &#123;</span><br><span class="line">        return true</span><br><span class="line">      &#125;</span><br><span class="line">      if ((left &amp;&amp; !right) || (!left &amp;&amp; right) || (left.val !== right.val)) &#123;</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">      return walk(left.left, right.right) &amp;&amp; walk(left.right, right.left)</span><br><span class="line">    &#125;</span><br><span class="line">    return walk(root.left, root.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Tree([1, 2, 2, 3, 4, 4, 3])</span><br><span class="line">//返回：</span><br><span class="line">const tree = &#123;</span><br><span class="line">  &quot;val&quot;: 1,</span><br><span class="line">  &quot;right&quot;: &#123;</span><br><span class="line">    &quot;val&quot;: 2,</span><br><span class="line">    &quot;right&quot;: &#123;</span><br><span class="line">      &quot;val&quot;: 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;left&quot;: &#123;</span><br><span class="line">      &quot;val&quot;: 4</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;left&quot;: &#123;</span><br><span class="line">    &quot;val&quot;: 2,</span><br><span class="line">    &quot;right&quot;: &#123;</span><br><span class="line">      &quot;val&quot;: 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;left&quot;: &#123;</span><br><span class="line">      &quot;val&quot;: 3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="当前节点属于那一层"><a href="#当前节点属于那一层" class="headerlink" title="当前节点属于那一层"></a>当前节点属于那一层</h4><p> 如果理解不了，请记住，这是业内得出的公式，无需太较真理解，记住这个定理公式就行。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算当前节点属于那一层</span><br><span class="line"> let n = Math.floor(Math.sqrt(i + 1))</span><br></pre></td></tr></table></figure></p>
<h4 id="记录当前层的起始nodelist的index"><a href="#记录当前层的起始nodelist的index" class="headerlink" title="记录当前层的起始nodelist的index"></a>记录当前层的起始nodelist的index</h4><p> 由上面的二叉树模型图看出，每一层的元素的起始点起始就是前面所有层元素个数之和，<br> 而这个和的值正好是2的n次幂，所以每一层对应到nodelist数组的index就是如下公式：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 记录当前层的起始 nodelist的index</span><br><span class="line">  let q = Math.pow(2, n) - 1</span><br><span class="line">  // 记录上一层的起始 nodelist的index</span><br><span class="line">  let p = Math.pow(2, n - 1) - 1</span><br></pre></td></tr></table></figure></p>
<h4 id="每一层有多少个元素"><a href="#每一层有多少个元素" class="headerlink" title="每一层有多少个元素"></a>每一层有多少个元素</h4><p> 参考上面《记录当前层的起始nodelist的index》</p>
<h4 id="找到当前节点的父节nodelist的index"><a href="#找到当前节点的父节nodelist的index" class="headerlink" title="找到当前节点的父节nodelist的index"></a>找到当前节点的父节nodelist的index</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 找到当前节点的父节点</span><br><span class="line">        let parent = nodeList[p + Math.floor((i - q) / 2)]</span><br></pre></td></tr></table></figure>
<p>有几个知识点要了解：<br>当前层的起始点 Math.pow(2, n) - 1 ，例如第二层，起始点是3；<br>那么这个3就是上面代码中的nodelist的index，<br>第一层，起始点是0；那么这个0就是nodelist的index；<br>所以上面代码中 进行for遍历时，i就是nodelist的下标，q或p也是nodelist的下标。<br>由于每两个子节点对应一个父节点，所以需要除以2</p>
<h4 id="数组每个元素都生成一个node节点"><a href="#数组每个元素都生成一个node节点" class="headerlink" title="数组每个元素都生成一个node节点"></a>数组每个元素都生成一个node节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> for (let i = 0, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">      let node = new Node(data[i])</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="利用node节点Object浅拷贝特性"><a href="#利用node节点Object浅拷贝特性" class="headerlink" title="利用node节点Object浅拷贝特性"></a>利用node节点Object浅拷贝特性</h4><p>利用这一浅拷贝特点，让第一个数组元素成为所有数组其他元素形成的节点的共同父节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let parent = nodeList[p + Math.floor((i - q) / 2)]</span><br><span class="line">       // 将当前节点和上一层的父节点做关联</span><br><span class="line">       if (parent.left) &#123;</span><br><span class="line">         parent.right = node</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         parent.left = node</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="验证二叉树是否是对称"><a href="#验证二叉树是否是对称" class="headerlink" title="验证二叉树是否是对称"></a>验证二叉树是否是对称</h3><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>代码见上面《创建二叉树》</p>
<h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><p>主要运用了递归原理验证二叉树是否对称。</p>
<h2 id="验证二叉搜索树-1"><a href="#验证二叉搜索树-1" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">力扣原题–验证二叉搜索树</a></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3> <figure class="image-box">
                <a rel=常用算法 href="/image/calc/tree1.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/tree1.jpg" alt title class></a>
                <p></p>
            </figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">  constructor (val) &#123;</span><br><span class="line">    this.val = val</span><br><span class="line">    this.left = this.right = undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tree &#123;</span><br><span class="line">  constructor (data) &#123;</span><br><span class="line">    let root = new Node(data.shift())</span><br><span class="line">    // 遍历所有的数据，逐渐插入到当前这棵搜索树中去</span><br><span class="line">    data.forEach(item =&gt; &#123;</span><br><span class="line">      this.insert(root, item)</span><br><span class="line">    &#125;)</span><br><span class="line">    return root</span><br><span class="line">  &#125;</span><br><span class="line">  insert (node, data) &#123;</span><br><span class="line">    if (node.val &gt; data) &#123;</span><br><span class="line">      if (node.left === undefined) &#123;</span><br><span class="line">        node.left = new Node(data)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.insert(node.left, data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (node.right === undefined) &#123;</span><br><span class="line">        node.right = new Node(data)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.insert(node.right, data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  static walk (root) &#123;</span><br><span class="line">    if (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125; else if ((root.left &amp;&amp; root.val &lt; root.left.val) || (root.right &amp;&amp; root.val &gt; root.right.val)) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return Tree.walk(root.left) &amp;&amp; Tree.walk(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> new Tree([2, 1, 3,6,8,9])</span><br></pre></td></tr></table></figure>
<h3 id="小左大右"><a href="#小左大右" class="headerlink" title="小左大右"></a>小左大右</h3><p>本搜索二叉树按照左大右小排列。</p>
<h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>上面代码中，无论生成二叉树与验证二叉树都使用了二叉树，注意递归中 边界值处理技巧。</p>
<h2 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h2><h3 id="递归的结构"><a href="#递归的结构" class="headerlink" title="递归的结构"></a>递归的结构</h3><p>每个递归由一个递归体以及一个边界值组成。且必须有一个边界值。</p>
<h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3> <figure class="image-box">
                <a rel=常用算法 href="/image/calc/recursion.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/recursion.jpg" alt title class></a>
                <p></p>
            </figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foctorial(n)&#123;</span><br><span class="line">  if(n === 1 || n === 0)&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return n * foctorial(n-1)</span><br><span class="line">&#125;</span><br><span class="line">foctorial(5)//120</span><br></pre></td></tr></table></figure>
<h4 id="边界值-又称基线条件"><a href="#边界值-又称基线条件" class="headerlink" title="边界值(又称基线条件)"></a>边界值(又称基线条件)</h4><p>边界值与基线条件是一个道理，即一个停止点。<br>如下，递归中，很多最终都是通过边界值来计算，且终止递归。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//我们只需写出边界（1）的实现就行。</span><br><span class="line">foctorial(5) = 5*4*3*2*(1)；</span><br></pre></td></tr></table></figure></p>
<p>边界值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(n === 1 || n === 0)&#123;</span><br><span class="line">   return 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="斐波那契数-1"><a href="#斐波那契数-1" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>斐波那契数列 是一个由 0, 1, 1, 2, 3, 5, 8, 13, 21 等组成等序列。数2由1加1得到，数3由2加1得到…。<br>斐波那契数列有个定义：</p>
<ul>
<li>位置0的数是0；</li>
<li>1和2的数是1；</li>
<li>n(n&gt;2)的数是n-1、 n-2 之和。<h4 id="实现一（常规实现）"><a href="#实现一（常规实现）" class="headerlink" title="实现一（常规实现）"></a>实现一（常规实现）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function fn(n)&#123;</span><br><span class="line">     if(n&lt;1) return 0;</span><br><span class="line">     if(n&lt;=2) return 1;</span><br><span class="line">     let prepreStartval = 0;</span><br><span class="line">     let preStartval = 1;</span><br><span class="line">     //前一个的前一个位置的值</span><br><span class="line">     let prepre=prepreStartval;</span><br><span class="line">     //前一个位置的值</span><br><span class="line">     let pre=preStartval;</span><br><span class="line">     //本位置的值</span><br><span class="line">     let item= &apos;&apos;;</span><br><span class="line">     for(let i=2;i&lt;=n;i++)&#123;</span><br><span class="line">         //本位置的值 = 前一个位置值 + 前一个的前一个位置值</span><br><span class="line">         item=pre+prepre;</span><br><span class="line">         //新的前一个的前一个的值 变成上个位置的前一个位置的值</span><br><span class="line">         prepre=pre;</span><br><span class="line">         //新的前一个的值 变成上一个位置的值</span><br><span class="line">         pre=item;</span><br><span class="line">     &#125;</span><br><span class="line">     return item;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="实现二-（递归实现）"><a href="#实现二-（递归实现）" class="headerlink" title="实现二 （递归实现）"></a>实现二 （递归实现）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn(n)&#123;</span><br><span class="line">    if(n&lt;1) return 0;</span><br><span class="line">    if(n&lt;=2) return 1;</span><br><span class="line">    return fn(n-1) + fn(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> function calculate(n, fn)&#123;</span><br><span class="line">    var arr=[];</span><br><span class="line">    for(var j=0; j&lt;n; j++)&#123; </span><br><span class="line">        arr[j]=fn(j) </span><br><span class="line">    &#125; </span><br><span class="line">    return arr; </span><br><span class="line">&#125;</span><br><span class="line">calculate(8, fn)  // [0, 1, 1, 2, 3, 5, 8, 13]</span><br></pre></td></tr></table></figure></p>
<h4 id="实现三-（记忆化优化）"><a href="#实现三-（记忆化优化）" class="headerlink" title="实现三 （记忆化优化）"></a>实现三 （记忆化优化）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function calcFactory()&#123;</span><br><span class="line">    const memo = [0, 1];</span><br><span class="line">    const fn=(n)=&gt;&#123;</span><br><span class="line">        //memo[n]===0  0是非，但本例中是一个值；</span><br><span class="line">        if(memo[n] || memo[n]===0) return memo[n];</span><br><span class="line">        return memo[n] = fn(n-1) + fn(n-2);</span><br><span class="line">    &#125;</span><br><span class="line">    return fn;</span><br><span class="line">&#125;</span><br><span class="line">var calc = calcFactory()；</span><br><span class="line">calc(8) //13;</span><br></pre></td></tr></table></figure>
<h3 id="边界值-与-最小化分析"><a href="#边界值-与-最小化分析" class="headerlink" title="边界值 与 最小化分析"></a>边界值 与 最小化分析</h3><p>很多递归问题或其他算法问题，他们几乎都是由最小值或边界值重复或计算而来，在解决问题时，可以将问题使用边界值最小化分析</p>
<h3 id="递归记忆化技巧"><a href="#递归记忆化技巧" class="headerlink" title="递归记忆化技巧"></a>递归记忆化技巧</h3><p>参考《斐波那契数  –  实现三 （记忆优化）》</p>
<h3 id="递归与while"><a href="#递归与while" class="headerlink" title="递归与while"></a>递归与while</h3><p>有时候递归能实现的，通过while也能实现，while具有一些递归的质能。<br>参考《卡牌分组 — while 实现 递归效果》</p>
<h3 id="递归经典应用示例"><a href="#递归经典应用示例" class="headerlink" title="递归经典应用示例"></a>递归经典应用示例</h3><h4 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h4><p>参考《快速排序》</p>
<h4 id="电话号码-2"><a href="#电话号码-2" class="headerlink" title="电话号码"></a>电话号码</h4><p>参考《电话号码》</p>
<h4 id="卡牌分组-2"><a href="#卡牌分组-2" class="headerlink" title="卡牌分组"></a>卡牌分组</h4><p>参考《卡牌分组》</p>
<h4 id="复原ip地址-2"><a href="#复原ip地址-2" class="headerlink" title="复原ip地址"></a>复原ip地址</h4><p>参考《复原ip地址》</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="遍历类型"><a href="#遍历类型" class="headerlink" title="遍历类型"></a>遍历类型</h3><h4 id="多元遍历"><a href="#多元遍历" class="headerlink" title="多元遍历"></a>多元遍历</h4><p>上面的 种花问题，冒泡排序， 选择排序，都是多元遍历的运用；</p>
<h4 id="多层遍历"><a href="#多层遍历" class="headerlink" title="多层遍历"></a>多层遍历</h4><p>冒泡排序，选择排序 是多层遍历的运用；</p>
<h4 id="跳级-忽略-遍历"><a href="#跳级-忽略-遍历" class="headerlink" title="跳级(忽略)遍历"></a>跳级(忽略)遍历</h4><p>参考 《种花问题 — 遍历体用 i++ 跳级忽略遍历》</p>
<h4 id="多层遍历-内层遍历j-1"><a href="#多层遍历-内层遍历j-1" class="headerlink" title="多层遍历 内层遍历j+1"></a>多层遍历 内层遍历j+1</h4><p>内外两层遍历，内层遍历通过j+1,腾出多一个位置来接收一个元素，进行排序的技巧，参考<br>《插入排序 — 方案二 (推荐)》</p>
<h3 id="经典应用示例"><a href="#经典应用示例" class="headerlink" title="经典应用示例"></a>经典应用示例</h3><h4 id="插入排序-（非常经典）"><a href="#插入排序-（非常经典）" class="headerlink" title="插入排序 （非常经典）"></a>插入排序 （非常经典）</h4><p>是非常经典的排序方式，尤其是方案二。<br>插入排序与冒泡排序形成了两种思路的遍历思想；<br>插入由内部遍历排序，冒泡由外部遍历排序。</p>
<h4 id="种花问题-2"><a href="#种花问题-2" class="headerlink" title="种花问题"></a>种花问题</h4><p>这里是遍历的经典运用，参考《种花问题》</p>
<h4 id="冒泡排序-2"><a href="#冒泡排序-2" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>参考《冒泡排序》</p>
<h4 id="选择排序-2"><a href="#选择排序-2" class="headerlink" title="选择排序"></a>选择排序</h4><p>参考《选择排序》</p>
<h4 id="最大间距-1"><a href="#最大间距-1" class="headerlink" title="最大间距"></a>最大间距</h4><p>参考 《最大间距》</p>
<h4 id="数组中的第K个最大元素-1"><a href="#数组中的第K个最大元素-1" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h4><p>参考 《数组中的第K个最大元素》</p>
<h2 id="常用算法场景"><a href="#常用算法场景" class="headerlink" title="常用算法场景"></a>常用算法场景</h2><h3 id="数组前后两两比较-1"><a href="#数组前后两两比较-1" class="headerlink" title="数组前后两两比较"></a>数组前后两两比较</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p>参考：《电话号码》中的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const cur = (strarr)=&gt;&#123;</span><br><span class="line">    //第一次strarr[0]是一个字符串， 以后strarr[0]经过splice后，都是数组</span><br><span class="line">   const one = typeof strarr[0] === &apos;string&apos; ? strarr[0].split(&apos;&apos;) : strarr[0];</span><br><span class="line">   const two = strarr[1].split(&apos;&apos;);</span><br><span class="line">   const newItem0 = combile(one, two);</span><br><span class="line">   strarr.splice(0,2,newItem0);</span><br><span class="line">      if(strarr.length&lt;2)&#123;</span><br><span class="line">          return strarr[0];</span><br><span class="line">      &#125;</span><br><span class="line">    return cur(strarr)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>更多参考 《卡牌分组》</p>
<h4 id="每次只比较数组的第一和第二项"><a href="#每次只比较数组的第一和第二项" class="headerlink" title="每次只比较数组的第一和第二项"></a>每次只比较数组的第一和第二项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = typeof strarr[0] === &apos;string&apos; ? strarr[0].split(&apos;&apos;) : strarr[0];</span><br><span class="line">const two = strarr[1].split(&apos;&apos;);</span><br><span class="line">const newItem0 = combile(one, two);</span><br></pre></td></tr></table></figure>
<h4 id="删除第一和第二项，将比较结果重新置为第一项"><a href="#删除第一和第二项，将比较结果重新置为第一项" class="headerlink" title="删除第一和第二项，将比较结果重新置为第一项"></a>删除第一和第二项，将比较结果重新置为第一项</h4><p>如上代码，每次比较完第一和第二项后，删除他们，并将比较结果置为第一项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strarr.splice(0,2,newItem0);</span><br></pre></td></tr></table></figure></p>
<h4 id="递归是核心"><a href="#递归是核心" class="headerlink" title="递归是核心"></a>递归是核心</h4><p>见代码</p>
<h4 id="边界值：strarr-length-lt-2"><a href="#边界值：strarr-length-lt-2" class="headerlink" title="边界值：strarr.length&lt;2"></a>边界值：strarr.length&lt;2</h4><p>两两比较到最后，数组只剩下一个元素，此时递归停止，所以边界值：strarr.length&lt;2。</p>
<h3 id="找出元素出现次数"><a href="#找出元素出现次数" class="headerlink" title="找出元素出现次数"></a>找出元素出现次数</h3><h4 id="找出元素出现次数的方法-推荐-–match正则-1"><a href="#找出元素出现次数的方法-推荐-–match正则-1" class="headerlink" title="找出元素出现次数的方法(推荐)–match正则"></a>找出元素出现次数的方法(推荐)–match正则</h4><p>详细参考 《卡牌分组》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 分组(单张或者多张)  \1 在正则中表示连续一样的匹配</span><br><span class="line"> let group = str.match(/(\d)\1+|\d/g)</span><br></pre></td></tr></table></figure></p>
<h4 id="找出元素出现次数的方法–object-key方式-1"><a href="#找出元素出现次数的方法–object-key方式-1" class="headerlink" title="找出元素出现次数的方法–object key方式"></a>找出元素出现次数的方法–object key方式</h4><p>详细参考 《卡牌分组》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const hash = deck.reduce((pre, num) =&gt; &#123;    //统计出每种数字的数目</span><br><span class="line">  if(!pre[num]) &#123;</span><br><span class="line">    pre[num] = 1</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    pre[num]++</span><br><span class="line">  &#125;</span><br><span class="line">  return pre</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="时间／空间复杂度"><a href="#时间／空间复杂度" class="headerlink" title="时间／空间复杂度"></a>时间／空间复杂度</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>简言之，<br>时间复杂度是对运行次数的描述，因为运行次数的多少决定了花多少时间。<br>空间复杂度是对运行内存的描述，在排序时定义了多少变量，就会消耗多少内存。<br>一般关注好时间复杂度即可。<br><figure class="image-box">
                <a rel=常用算法 href="/image/calc/time.jpg" title="undefined" data-fancybox="images"><img src="/image/calc/time.jpg" alt title class></a>
                <p></p>
            </figure></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//时间复杂度为 O(9)</span><br><span class="line">for (let j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">     console.log(j)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//时间复杂度为 O(9*9)</span><br><span class="line">  for (let i = 9; i &gt; 0; i--) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">             console.log(j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/chapter/315.html#Anchor" target="_blank" rel="noopener">JavaScript版 数据结构与算法</a><br><a href="https://v.youku.com/v_show/id_XMjQ4MjMxMDIwNA==.html?spm=a2h0j.11185381.listitem_page1.5!18~A" target="_blank" rel="noopener">珠峰教育 –js排序</a><br><a href="http://www.ituring.com.cn/book/2653" target="_blank" rel="noopener">学习JavaScript数据结构与算法（第3版）</a></p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2022-10-21T08:41:22.913Z" itemprop="dateUpdated">2022-10-21 08:41:22</time>
</span><br>


        
        博客内容均为原创，转载注明出处，原文地址：<a href="/2019/04/09/calc/" target="_blank" rel="external">https://yewills.github.io/2019/04/09/calc/</a>
        
    </div>
    <footer>
        <a href="https://yewills.github.io">
            <img src="/img/avatar.jpg" alt="Mr.Yellow">
            Mr.Yellow
        </a>
    </footer>
</blockquote>

        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二叉树/">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序/">排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数组/">数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/递归/">递归</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://yewills.github.io/2019/04/09/calc/&title=《常用算法》 — Mr.Yellow.Wills&pic=https://yewills.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yewills.github.io/2019/04/09/calc/&title=《常用算法》 — Mr.Yellow.Wills&source=hellow kity" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/05/21/wills_react_pro/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">wills-react-pro项目笔记</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/01/01/webpack/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">webpack笔记</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#阅读说明"><span class="post-toc-number">1.</span> <span class="post-toc-text">阅读说明</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#电话号码"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">电话号码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#卡牌分组"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">卡牌分组</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#种花问题"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">种花问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#排序"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#冒泡排序"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">冒泡排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#选择排序"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">选择排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#快速排序"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">快速排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#插入排序"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">插入排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最大间距-冒泡排序实现"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">最大间距 (冒泡排序实现)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#数组中的第K个最大元素-冒泡排序实现"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">数组中的第K个最大元素 (冒泡排序实现)</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">递归</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#复原ip地址"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">复原ip地址</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#递归阶乘"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">递归阶乘</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#斐波那契数"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">斐波那契数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据结构"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#二叉树"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">二叉树</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#对称二叉树"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">对称二叉树</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#验证二叉搜索树"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">验证二叉搜索树</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#电话号码-1"><span class="post-toc-number">2.</span> <span class="post-toc-text">电话号码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#每次只让第一个和第二个元素两两组合"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">每次只让第一个和第二个元素两两组合</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归是重头戏"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">递归是重头戏</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#return-arr-0-很需要"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">return arr[0] 很需要</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归完了还会往下执行"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">递归完了还会往下执行</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解决方法优化"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">解决方法优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#再一次优化"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">再一次优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#考察算法要点"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">考察算法要点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#卡牌分组-1"><span class="post-toc-number">3.</span> <span class="post-toc-text">卡牌分组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-1"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解法一：-数组前后两两比较"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">解法一： 数组前后两两比较</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最大公约数"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">最大公约数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#代码实现"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">代码实现</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最大公约数除了1值外，其他值都合法"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">最大公约数除了1值外，其他值都合法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组前后两两比较"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">数组前后两两比较</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#找出元素出现次数的方法-推荐-–match正则"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">找出元素出现次数的方法(推荐)–match正则</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#找出元素出现次数的方法–object-key方式"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">找出元素出现次数的方法–object key方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#while-实现-递归效果"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">while 实现 递归效果</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解法一优化：用递归代替while写法"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">解法一优化：用递归代替while写法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解法二：最小相同数与所有相同数比较"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">解法二：最小相同数与所有相同数比较</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#两种方案的利弊"><span class="post-toc-number">3.10.</span> <span class="post-toc-text">两种方案的利弊</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#种花问题-1"><span class="post-toc-number">4.</span> <span class="post-toc-text">种花问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-2"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#要点分析"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">要点分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#核心一：-000的数学建模"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">核心一： 000的数学建模</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#核心二：-遍历"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">核心二： 遍历</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单元遍历-与-多元遍历"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">单元遍历 与 多元遍历</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#遍历体用-i-跳级忽略遍历"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">遍历体用 i++ 跳级忽略遍历</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#边界问题"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">边界问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#arr-i-1-与arr-i-1-的遍历技巧"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">arr[i+1]与arr[i-1]的遍历技巧</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#arr-i-1-与-arr-i-1-与-i-lt-arr-length-1-的妙用"><span class="post-toc-number">4.8.1.</span> <span class="post-toc-text">arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#arr-i-1-时考虑边界值，arr-i-1-时考虑i值最大值"><span class="post-toc-number">4.8.2.</span> <span class="post-toc-text">arr[i-1]时考虑边界值，arr[i-1]时考虑i值最大值</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#遍历的经典练习题"><span class="post-toc-number">4.9.</span> <span class="post-toc-text">遍历的经典练习题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#冒泡排序-1"><span class="post-toc-number">5.</span> <span class="post-toc-text">冒泡排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-3"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将最值移到边缘的技巧"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">将最值移到边缘的技巧</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#排序是最值移动的多次重复"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">排序是最值移动的多次重复</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原理"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#处理i-1-遍历的技巧"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">处理i+1 遍历的技巧</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#选择排序-1"><span class="post-toc-number">6.</span> <span class="post-toc-text">选择排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-以及-选择、冒泡区别"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">概述 以及 选择、冒泡区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选定第1个位置放置最小值"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">选定第1个位置放置最小值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选定第2个位置放置剩余数组的最小值"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">选定第2个位置放置剩余数组的最小值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实现"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#最大间距"><span class="post-toc-number">7.</span> <span class="post-toc-text">最大间距</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-4"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#推荐方法"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">推荐方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#介绍"><span class="post-toc-number">7.2.1.</span> <span class="post-toc-text">介绍</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#边界处理"><span class="post-toc-number">7.2.2.</span> <span class="post-toc-text">边界处理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#借助冒泡或选择排序实现"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">借助冒泡或选择排序实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#不推荐方法"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">不推荐方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#遍历是核心"><span class="post-toc-number">7.5.</span> <span class="post-toc-text">遍历是核心</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数组中的第K个最大元素"><span class="post-toc-number">8.</span> <span class="post-toc-text">数组中的第K个最大元素</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#不推荐方法-1"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">不推荐方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#推荐方法-1"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">推荐方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#借助冒泡或选择排序实现-1"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">借助冒泡或选择排序实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#快速排序-最好的排序方式"><span class="post-toc-number">9.</span> <span class="post-toc-text">快速排序(最好的排序方式)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#要点分析-1"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">要点分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#中间元素，左右两边分组"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">中间元素，左右两边分组</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#推荐使用中间元素-但也可使用其他元素"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">推荐使用中间元素,但也可使用其他元素</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归的经典运用"><span class="post-toc-number">9.4.</span> <span class="post-toc-text">递归的经典运用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归最后呈现的由最后的边界值决定"><span class="post-toc-number">9.5.</span> <span class="post-toc-text">递归最后呈现的由最后的边界值决定</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归结果是边界值与return表达式作用的结果"><span class="post-toc-number">9.6.</span> <span class="post-toc-text">递归结果是边界值与return表达式作用的结果</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#插入排序-1"><span class="post-toc-number">10.</span> <span class="post-toc-text">插入排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通常方案"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">通常方案</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#概述-5"><span class="post-toc-number">10.1.1.</span> <span class="post-toc-text">概述</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#提高"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">提高</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#可不用了解"><span class="post-toc-number">10.2.1.</span> <span class="post-toc-text">可不用了解</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不新建数组直接排序的实现"><span class="post-toc-number">10.2.2.</span> <span class="post-toc-text">不新建数组直接排序的实现</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#外层遍历提供元素，内层遍历进行排序"><span class="post-toc-number">10.2.3.</span> <span class="post-toc-text">外层遍历提供元素，内层遍历进行排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内层排序技巧"><span class="post-toc-number">10.2.4.</span> <span class="post-toc-text">内层排序技巧</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#遍历的经典应用"><span class="post-toc-number">10.2.5.</span> <span class="post-toc-text">遍历的经典应用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#用while来改写方案二"><span class="post-toc-number">10.2.6.</span> <span class="post-toc-text">用while来改写方案二</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#复原ip地址-1"><span class="post-toc-number">11.</span> <span class="post-toc-text">复原ip地址</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-6"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解决方法"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">解决方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码分析"><span class="post-toc-number">11.3.</span> <span class="post-toc-text">代码分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归设计中-必不可少的-边界条件"><span class="post-toc-number">11.4.</span> <span class="post-toc-text">递归设计中 必不可少的 边界条件</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#对称二叉树-1"><span class="post-toc-number">12.</span> <span class="post-toc-text">对称二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建对称二叉树"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">创建对称二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#二叉树模型图"><span class="post-toc-number">12.1.1.</span> <span class="post-toc-text">二叉树模型图</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#代码"><span class="post-toc-number">12.1.2.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#当前节点属于那一层"><span class="post-toc-number">12.1.3.</span> <span class="post-toc-text">当前节点属于那一层</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#记录当前层的起始nodelist的index"><span class="post-toc-number">12.1.4.</span> <span class="post-toc-text">记录当前层的起始nodelist的index</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#每一层有多少个元素"><span class="post-toc-number">12.1.5.</span> <span class="post-toc-text">每一层有多少个元素</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#找到当前节点的父节nodelist的index"><span class="post-toc-number">12.1.6.</span> <span class="post-toc-text">找到当前节点的父节nodelist的index</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#数组每个元素都生成一个node节点"><span class="post-toc-number">12.1.7.</span> <span class="post-toc-text">数组每个元素都生成一个node节点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#利用node节点Object浅拷贝特性"><span class="post-toc-number">12.1.8.</span> <span class="post-toc-text">利用node节点Object浅拷贝特性</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#验证二叉树是否是对称"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">验证二叉树是否是对称</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实现-1"><span class="post-toc-number">12.2.1.</span> <span class="post-toc-text">实现</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#递归-1"><span class="post-toc-number">12.2.2.</span> <span class="post-toc-text">递归</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#验证二叉搜索树-1"><span class="post-toc-number">13.</span> <span class="post-toc-text">验证二叉搜索树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#代码-1"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#小左大右"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">小左大右</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归-2"><span class="post-toc-number">13.3.</span> <span class="post-toc-text">递归</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#递归-3"><span class="post-toc-number">14.</span> <span class="post-toc-text">递归</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归的结构"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">递归的结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#阶乘"><span class="post-toc-number">14.2.</span> <span class="post-toc-text">阶乘</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#边界值-又称基线条件"><span class="post-toc-number">14.2.1.</span> <span class="post-toc-text">边界值(又称基线条件)</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#斐波那契数-1"><span class="post-toc-number">14.3.</span> <span class="post-toc-text">斐波那契数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#概念"><span class="post-toc-number">14.3.1.</span> <span class="post-toc-text">概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实现一（常规实现）"><span class="post-toc-number">14.3.2.</span> <span class="post-toc-text">实现一（常规实现）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实现二-（递归实现）"><span class="post-toc-number">14.3.3.</span> <span class="post-toc-text">实现二 （递归实现）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实现三-（记忆化优化）"><span class="post-toc-number">14.3.4.</span> <span class="post-toc-text">实现三 （记忆化优化）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#边界值-与-最小化分析"><span class="post-toc-number">14.4.</span> <span class="post-toc-text">边界值 与 最小化分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归记忆化技巧"><span class="post-toc-number">14.5.</span> <span class="post-toc-text">递归记忆化技巧</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归与while"><span class="post-toc-number">14.6.</span> <span class="post-toc-text">递归与while</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归经典应用示例"><span class="post-toc-number">14.7.</span> <span class="post-toc-text">递归经典应用示例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#快速排序-1"><span class="post-toc-number">14.7.1.</span> <span class="post-toc-text">快速排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#电话号码-2"><span class="post-toc-number">14.7.2.</span> <span class="post-toc-text">电话号码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#卡牌分组-2"><span class="post-toc-number">14.7.3.</span> <span class="post-toc-text">卡牌分组</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#复原ip地址-2"><span class="post-toc-number">14.7.4.</span> <span class="post-toc-text">复原ip地址</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#遍历"><span class="post-toc-number">15.</span> <span class="post-toc-text">遍历</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#遍历类型"><span class="post-toc-number">15.1.</span> <span class="post-toc-text">遍历类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多元遍历"><span class="post-toc-number">15.1.1.</span> <span class="post-toc-text">多元遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多层遍历"><span class="post-toc-number">15.1.2.</span> <span class="post-toc-text">多层遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#跳级-忽略-遍历"><span class="post-toc-number">15.1.3.</span> <span class="post-toc-text">跳级(忽略)遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多层遍历-内层遍历j-1"><span class="post-toc-number">15.1.4.</span> <span class="post-toc-text">多层遍历 内层遍历j+1</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#经典应用示例"><span class="post-toc-number">15.2.</span> <span class="post-toc-text">经典应用示例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#插入排序-（非常经典）"><span class="post-toc-number">15.2.1.</span> <span class="post-toc-text">插入排序 （非常经典）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#种花问题-2"><span class="post-toc-number">15.2.2.</span> <span class="post-toc-text">种花问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#冒泡排序-2"><span class="post-toc-number">15.2.3.</span> <span class="post-toc-text">冒泡排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#选择排序-2"><span class="post-toc-number">15.2.4.</span> <span class="post-toc-text">选择排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最大间距-1"><span class="post-toc-number">15.2.5.</span> <span class="post-toc-text">最大间距</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#数组中的第K个最大元素-1"><span class="post-toc-number">15.2.6.</span> <span class="post-toc-text">数组中的第K个最大元素</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常用算法场景"><span class="post-toc-number">16.</span> <span class="post-toc-text">常用算法场景</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组前后两两比较-1"><span class="post-toc-number">16.1.</span> <span class="post-toc-text">数组前后两两比较</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#概述-7"><span class="post-toc-number">16.1.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#每次只比较数组的第一和第二项"><span class="post-toc-number">16.1.2.</span> <span class="post-toc-text">每次只比较数组的第一和第二项</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#删除第一和第二项，将比较结果重新置为第一项"><span class="post-toc-number">16.1.3.</span> <span class="post-toc-text">删除第一和第二项，将比较结果重新置为第一项</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#递归是核心"><span class="post-toc-number">16.1.4.</span> <span class="post-toc-text">递归是核心</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#边界值：strarr-length-lt-2"><span class="post-toc-number">16.1.5.</span> <span class="post-toc-text">边界值：strarr.length&lt;2</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#找出元素出现次数"><span class="post-toc-number">16.2.</span> <span class="post-toc-text">找出元素出现次数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#找出元素出现次数的方法-推荐-–match正则-1"><span class="post-toc-number">16.2.1.</span> <span class="post-toc-text">找出元素出现次数的方法(推荐)–match正则</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#找出元素出现次数的方法–object-key方式-1"><span class="post-toc-number">16.2.2.</span> <span class="post-toc-text">找出元素出现次数的方法–object key方式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#时间／空间复杂度"><span class="post-toc-number">17.</span> <span class="post-toc-text">时间／空间复杂度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-8"><span class="post-toc-number">17.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#时间复杂度"><span class="post-toc-number">17.2.</span> <span class="post-toc-text">时间复杂度</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考"><span class="post-toc-number">18.</span> <span class="post-toc-text">参考</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

        <footer class="footer">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://www.lujingtao.com" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                Mr.Yellow &copy; 2017 - 2022
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://yewills.github.io/2019/04/09/calc/&title=《常用算法》 — Mr.Yellow.Wills&pic=https://yewills.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://yewills.github.io/2019/04/09/calc/&title=《常用算法》 — Mr.Yellow.Wills&source=hellow kity" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABw0lEQVR42u3aS3LDIBAFQN3/0s7Wixi9YQArqWblUsmi2UzNh+uK1+ttvT+5Gqv/BVxc3H3c13CNueMtx/8aP//4fVxc3IPccaDJt0mCVP4+Li7uX+GO3xn/xsXF/d/cm0QkgOLi4j6fmxQ/1UJlrpRaVqvh4uI2uNXm5o7fW/q7uLi4U9zX1OqMRvLg9cu+uLi4R7h5kyLZppo2TSZPuLi4R7h5QpMcby4Uzg1xcXFxz3CrDY4k8PUrs4//xcXF3cbN05dqcrPqKgYuLu5JbuFMcZCaC1jRIXFxcY9w82FJjqiWMZONWlxc3M3c6jWp/IrGXNq0LObh4uK2uUkYyo/UuVNxkzbh4uIe5+aNjDzAzVUuuLi43+JWN662TqoJzU3JhIuLe4SbJyXVlmj1GMmgFxcX9ww3b1jkZVJe5Ez2dHFxcTdzq+VHv6maN0qivAwXF3cDtxNWVjVHCgERFxf3CHfHwKM6fO0nT7i4uDu4SfDqF0ULLl7g4uIe55ZrpqWN1EKqhIuL+zBudYx6LVq4uLhP5uaBLB+jJm9uT3FwcXHjUWu1pMmvbSUtlQVtEVxc3Aa304uILlQVAx8uLu5XuT8Iay7laStgtQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="/js/plugins/jquery-2.1.1.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.3.9"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.3.9"></script>
<script type="text/javascript" src="/js/plugins/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/plugins/MathJax.js"></script>
<script type="text/javascript" src="/js/plugins/TeX-AMS-MML_HTMLorMML.js"></script>
<script type="text/javascript" src="/js/plugins/MathMenu.js"></script>
<script type="text/javascript" src="/js/plugins/MathZoom.js"></script>

<script type="text/javascript" src="/js/plugins/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.3.9"></script>
<script type="text/javascript" src="/js/blog.js?v=1.3.9"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.3.9"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src=""></script>







    
</body>
</html>
