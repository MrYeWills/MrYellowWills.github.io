<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>hexo笔记</title>
      <link href="/2021/01/03/hexo/"/>
      <url>/2021/01/03/hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-常用知识"><a href="#hexo-常用知识" class="headerlink" title="hexo 常用知识"></a>hexo 常用知识</h2><h3 id="public目录"><a href="#public目录" class="headerlink" title="public目录"></a>public目录</h3><p>根目录执行hexo g 命令，会在根目录下生成一个public/ 文件夹，<br>hexo g是一个编译源码的命令，编译后的源码，可以直接供GitHub网址生成博客。<br>因此public/ 文件夹是用来将源码上传到github上，供github生成博客的。</p><h3 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h3><h4 id="启动本地服务，看博客效果"><a href="#启动本地服务，看博客效果" class="headerlink" title="启动本地服务，看博客效果"></a>启动本地服务，看博客效果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h4 id="发布到GitHub"><a href="#发布到GitHub" class="headerlink" title="发布到GitHub"></a>发布到GitHub</h4><p>将git仓库放在public中，每次需要发布时，根目录下执行hexo g，然后在public目录下 git push;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></p><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><p>hexo d 并不会删除publc目录的.git文件夹，只会增量叠加。 –目前没有用过；<br>注意，不要执行hexo clean，它会删除public目录</p><h3 id="写的文章放在哪里与-posts目录"><a href="#写的文章放在哪里与-posts目录" class="headerlink" title="写的文章放在哪里与_posts目录"></a>写的文章放在哪里与_posts目录</h3><p>YeWills.github.io/source/_posts/<br>所有的文章都放置于_posts目录下。</p><h3 id="创建tag与categories相关事情"><a href="#创建tag与categories相关事情" class="headerlink" title="创建tag与categories相关事情"></a>创建tag与categories相关事情</h3><p>二者配置一样，以categories为例：<br>hexo new page categories<br>生成目录和文件：<br>YeWills.github.io/source/categories/index.md<br>修改index.md元数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>同时修改<br>YeWills.github.io/scaffolds/draft.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>YeWills.github.io/scaffolds/page.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>YeWills.github.io/scaffolds/post.md<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>如此便可以配置出categories的all或全部 的选项卡内容，如果没有以上步骤，也可以生成categories，但无法生产categories的all或全部 的选项卡内容；<br>且点击本主题左侧菜单栏categories会报404错误。</p><p>这一步的配置内容，可看commit 哈希值 cbb06710ce7a40ade93</p><h3 id="categories、tags两种配置方式"><a href="#categories、tags两种配置方式" class="headerlink" title="categories、tags两种配置方式"></a>categories、tags两种配置方式</h3><p>categories:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 推荐使用方法 method one,双横杠方式，可以配置多级，</span><br><span class="line">categories: </span><br><span class="line">- react</span><br><span class="line">- react读书笔记</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method two,只能配置一个值</span><br><span class="line">categories: &quot;react&quot;</span><br></pre></td></tr></table></figure><p>tags:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method one</span><br><span class="line">tags:[react, react读书笔记]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// method two,只能配置一个值</span><br><span class="line">tags: react</span><br></pre></td></tr></table></figure><h3 id="博客菜单栏左侧内容修改"><a href="#博客菜单栏左侧内容修改" class="headerlink" title="博客菜单栏左侧内容修改"></a>博客菜单栏左侧内容修改</h3><p>比如修改qq号码，名字，git地址，都可在这里修改YeWills.github.io/themes/mellow/_config.yml</p><h3 id="博客菜单栏左侧菜单增减"><a href="#博客菜单栏左侧菜单增减" class="headerlink" title="博客菜单栏左侧菜单增减"></a>博客菜单栏左侧菜单增减</h3><p>比如修改qq号码，名字，git地址，都可在这里修改YeWills.github.io/themes/mellow/_config.yml<br>修改改文件的menu部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home:</span><br><span class="line">    text: HOME</span><br><span class="line">    url: /</span><br><span class="line">    icon: home</span><br><span class="line">  th-list:</span><br><span class="line">    text: CATEGORIES</span><br><span class="line">    url: /categories</span><br><span class="line">    icon: th-list</span><br><span class="line">  tags:</span><br><span class="line">    text: TAGS</span><br><span class="line">    url: /tags</span><br><span class="line">    icon: tags</span><br><span class="line">  archives:</span><br><span class="line">    text: ARCHIVES</span><br><span class="line">    url: /archives</span><br><span class="line">    icon: archives</span><br></pre></td></tr></table></figure></p><p>如上，menu.th-list配置的是categories目录</p><h2 id="hexo-黑知识"><a href="#hexo-黑知识" class="headerlink" title="hexo 黑知识"></a>hexo 黑知识</h2><h3 id="loading三级标题的编译异常"><a href="#loading三级标题的编译异常" class="headerlink" title="loading三级标题的编译异常"></a>loading三级标题的编译异常</h3><p>给三级标题名只有单独的 一个 loading 字时，hexo编译出来的目录可能会异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个会异常</span><br><span class="line">### loading</span><br></pre></td></tr></table></figure></p><p>解决之道是在标题不定义为单独的loading，加点字就行如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个正常</span><br><span class="line">### 有关loading</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac和linux笔记</title>
      <link href="/2021/01/03/mac_linux/"/>
      <url>/2021/01/03/mac_linux/</url>
      
        <content type="html"><![CDATA[<h3 id="显示用户目录"><a href="#显示用户目录" class="headerlink" title="显示用户目录"></a>显示用户目录</h3><p>MAC电脑默认隐藏了你的用户目录，所以才找不到。<br>在finder的偏好设置中选择“边栏”选中个人收藏下“房子的图标”，这样就用户目录，然后在边栏就可以看到用户目录，然后就可以找到目录了</p><h3 id="切换大写"><a href="#切换大写" class="headerlink" title="切换大写"></a>切换大写</h3><p>长按 caps lock 直至灯亮就是大写，短按变小写。</p><h3 id="有关echo"><a href="#有关echo" class="headerlink" title="有关echo"></a>有关echo</h3><p>echo类似console.log，日志打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $ PATH</span><br></pre></td></tr></table></figure></p><h3 id="linux下关键字"><a href="#linux下关键字" class="headerlink" title="linux下关键字"></a>linux下关键字</h3><h4 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h4><p>我是谁</p><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>系统日期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jsdeiMac:~ xhkj$ date</span><br><span class="line">2019年 5月19日 星期日 23时50分00秒 CST</span><br><span class="line">jsdeiMac:~ xhkj$ whoami</span><br><span class="line">xhkj</span><br></pre></td></tr></table></figure></p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>sudo是linux下的一个使用最高权限执行命令的关键字，<br>此命令需要输入用户密码</p><h3 id="mac常用"><a href="#mac常用" class="headerlink" title="mac常用"></a>mac常用</h3><h4 id="打开usr目录"><a href="#打开usr目录" class="headerlink" title="打开usr目录"></a>打开usr目录</h4><p>打开finder，快捷键 command+shift+G，输入 <code>/usr</code>回车即可。</p><h4 id="ps-aux-grep-mysql"><a href="#ps-aux-grep-mysql" class="headerlink" title="ps aux | grep mysql"></a>ps aux | grep mysql</h4><p>查看</p><h4 id="mysql安装"><a href="#mysql安装" class="headerlink" title="mysql安装"></a>mysql安装</h4><p>参考 <a href="https://jingyan.baidu.com/article/fa4125ac0e3c2928ac709204.html" target="_blank" rel="noopener">文档</a></p><h4 id="微信能网络，浏览器网络很慢"><a href="#微信能网络，浏览器网络很慢" class="headerlink" title="微信能网络，浏览器网络很慢"></a>微信能网络，浏览器网络很慢</h4><p>是dns出现了问题，解决方法很简单，在dns服务器中增加 114.114.114.114即可。<br>114.114.114.114 是与谷歌dns 8.8.8.8 一样的利于dns解析的配置，<br>配置后，可让你浏览器上网dns解析快速。<br>解决qq能上网，但浏览器无法上网的困扰。</p>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nginx代理</title>
      <link href="/2021/01/03/nginx/"/>
      <url>/2021/01/03/nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><a href="https://segmentfault.com/a/1190000016020328?utm_source=sf-related" target="_blank" rel="noopener">MAC下安装nginx</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure></p><h3 id="重新启动nginx-配置更新后"><a href="#重新启动nginx-配置更新后" class="headerlink" title="重新启动nginx (配置更新后)"></a>重新启动nginx (配置更新后)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="安装配置目录"><a href="#安装配置目录" class="headerlink" title="安装配置目录"></a>安装配置目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/etc/nginx/</span><br></pre></td></tr></table></figure><h3 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h3><h4 id="权限不够-使用sudo"><a href="#权限不够-使用sudo" class="headerlink" title="权限不够-使用sudo"></a>权限不够-使用sudo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nginx</span><br><span class="line">nginx: [alert] could not open error log file: open() &quot;/usr/local/var/log/nginx/error.log&quot; failed (13: Permission denied)</span><br><span class="line">2020/10/22 11:32:33 [emerg] 29584#0: open() &quot;/usr/local/var/log/nginx/access.log&quot; failed (13: Permission denied)</span><br></pre></td></tr></table></figure><h3 id="杀掉nginx进程"><a href="#杀掉nginx进程" class="headerlink" title="杀掉nginx进程"></a>杀掉nginx进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep nginx</span><br><span class="line">    0 29678     1   0 11:37上午 ??         0:00.00 nginx: master process nginx</span><br><span class="line">   -2 29679 29678   0 11:37上午 ??         0:00.01 nginx: worker process</span><br><span class="line">  501 32921 32907   0  2:42下午 ttys000    0:00.00 grep nginx</span><br><span class="line">$ sudo Kill -TERM 29678</span><br><span class="line">Password:</span><br><span class="line">$ ps -ef|grep nginx</span><br><span class="line">  501 32936 32907   0  2:42下午 ttys000    0:00.01 grep nginx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>npm包开发</title>
      <link href="/2021/01/03/npm/"/>
      <url>/2021/01/03/npm/</url>
      
        <content type="html"><![CDATA[<h2 id="npm包集中管理项目"><a href="#npm包集中管理项目" class="headerlink" title="npm包集中管理项目"></a>npm包集中管理项目</h2><h3 id="概述与地址"><a href="#概述与地址" class="headerlink" title="概述与地址"></a>概述与地址</h3><p><a href="https://github.com/YeWills/npmtest" target="_blank" rel="noopener">项目地址</a><br>如果发布的npm包比较多，能集中管理这些包，是一种很好的提效方式。<br>为此，本项目使用 lerna 来集中管理发布，让lerna集中做包 version 等的管理，并集中发布到npm。<br>使用umi团队的 father (father-build) 来将packages包内的 src 编译到 lib（father默认将src编译到lib），<br>以便发布时使用编译后的es5代码。</p><h3 id="lerna-npm发布利器"><a href="#lerna-npm发布利器" class="headerlink" title="lerna npm发布利器"></a>lerna npm发布利器</h3><h4 id="集中发布管理"><a href="#集中发布管理" class="headerlink" title="集中发布管理"></a>集中发布管理</h4><p>如上分析，lerna可以用于集中对包做version等管理。并集中发布。<br>lerna功能比较多，它会比对各个包，如果包没有变化，不改变包版本，如果有变化，会智能叠加小版本号。</p><h4 id="集中安装包依赖"><a href="#集中安装包依赖" class="headerlink" title="集中安装包依赖"></a>集中安装包依赖</h4><p><code>lerna bootstrap</code>可以用于集中安装packages下的包的依赖。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>可网上查阅lerna。</p><h3 id="father编译es5-father-build"><a href="#father编译es5-father-build" class="headerlink" title="father编译es5 (father-build)"></a>father编译es5 (father-build)</h3><p>参考《概述与地址》讲解</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "private": false,//工程是私有或公有，若发布，默认设置false</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "bootstrap": "lerna bootstrap",//给package下的包，安装依赖</span><br><span class="line">    "build": "father-build",// yarn build -w  src 编译到 lib，father默认将src编译到lib</span><br><span class="line">    "changelog": "lerna-changelog",</span><br><span class="line">    "clean": "lerna clean -y",</span><br><span class="line">    "lint": "eslint --ext .js packages",</span><br><span class="line">    "precommit": "lint-staged",</span><br><span class="line">    "prettier": "prettier --write '**/*.&#123;js,jsx,tsx,ts,less,md,json&#125;'",</span><br><span class="line">    "dpublish": "lerna publish"//集中管理发布包，包含name version ，发布前，将根目录下git push</span><br><span class="line">  &#125;,</span><br><span class="line">  "lint-staged": &#123;</span><br><span class="line">    "**/*.&#123;js,jsx,tsx,ts,less,json&#125;": [</span><br><span class="line">      "prettier --write",</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  "devDependencies": &#123;</span><br><span class="line">    "father-build": "^1.13.1",</span><br><span class="line">    "husky": "1.2.0",</span><br><span class="line">    "lerna": "3.6.0",</span><br><span class="line">  &#125;,</span><br><span class="line">  "dependencies": &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lerna-json"><a href="#lerna-json" class="headerlink" title="lerna.json"></a>lerna.json</h3><p><code>lerna bootstrap</code>可以用于集中安装packages下的包的依赖。使用npm或yarn安装时，<br>请定义好<code>&quot;npmClient&quot;: &quot;npm&quot;</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"packages"</span>: [<span class="string">"packages/*"</span>],</span><br><span class="line">  <span class="attr">"command"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: &#123;</span><br><span class="line">      <span class="attr">"exact"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "npmClient": "npm",//使用yarn 或 npm 命令安装</span><br><span class="line">  "version": "independent"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="husky-提交前验证"><a href="#husky-提交前验证" class="headerlink" title="husky 提交前验证"></a>husky 提交前验证</h3><p>见项目源码。</p><h3 id="包发布前，必须提交项目代码"><a href="#包发布前，必须提交项目代码" class="headerlink" title="包发布前，必须提交项目代码"></a>包发布前，必须提交项目代码</h3><p>执行 <code>yarn dpublish</code>前，必须根目录下，提交项目所有代码，否则出错。</p><h3 id="发布时注意-npm-源的控制；"><a href="#发布时注意-npm-源的控制；" class="headerlink" title="发布时注意 npm 源的控制；"></a>发布时注意 npm 源的控制；</h3><p>发布时，将包发布到npm指定到源，就可以在对应的源上进行npm install。</p><h3 id="实时编译-w"><a href="#实时编译-w" class="headerlink" title="实时编译 -w"></a>实时编译 -w</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &quot;father-build&quot;,// yarn build -w  src 编译到 lib，father默认将src编译到lib</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn build -w //开启代码实时监听编译，当packages内的包的src文件有变化时，实时编译到对应的lib文件内。</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;版本修改&quot;</span><br><span class="line">git push</span><br><span class="line">yarn dpublish //代码编译，并提交后，将包发布到npm服务器上</span><br></pre></td></tr></table></figure><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><h3 id="npm-link"><a href="#npm-link" class="headerlink" title="npm link"></a>npm link</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>npm包未发布到线上时，需要本地调试，为解决npm包开发项目，与实际使用的业务项目不在同一个目录下的问题。<br>在npm包所在的目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//比如 packages/yewBtn根目录下</span><br><span class="line">npm link</span><br></pre></td></tr></table></figure></p><p>npm在电脑本地内，将形成一个本地映射，在实际开发目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link packageName</span><br></pre></td></tr></table></figure></p><p>本地项目下将可以使用此包，且包的开发文件内，如果有改动，实际业务项目内将会获取到。</p><h4 id="只需要执行一次npm-link"><a href="#只需要执行一次npm-link" class="headerlink" title="只需要执行一次npm link"></a>只需要执行一次npm link</h4><p>在包目录下，只需要执行一次npm link，在业务代码中就可以拿到最新源码</p><h4 id="通过node-module包看是否最新"><a href="#通过node-module包看是否最新" class="headerlink" title="通过node module包看是否最新"></a>通过node module包看是否最新</h4><p>想知道node module包引用的是否为npm link最新代码，直接取node module包看就行。</p><h4 id="以目录地址为标识"><a href="#以目录地址为标识" class="headerlink" title="以目录地址为标识"></a>以目录地址为标识</h4><p>在源码上执行 npm link 后，npm 将会建立以这个源码目录为标志的软链接，只要目录地址不变，<br>只需要最初执行一次npm link，以后业务代码中都可以用到最新。</p><h4 id="与lerna一起使用的技巧"><a href="#与lerna一起使用的技巧" class="headerlink" title="与lerna一起使用的技巧"></a>与lerna一起使用的技巧</h4><p>一般业务代码中只能使用编译后es5版本的代码，开启 lerna –watch 后，只要源码有改变，就实时编译，业务代码中npm link到的代码就最新。</p><h2 id="npm包开发"><a href="#npm包开发" class="headerlink" title="npm包开发"></a>npm包开发</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>npm的开发主要是日常包开发，调试，发布，三个内容。<br>更多，可参考<a href="https://www.jianshu.com/p/f33a919443ed" target="_blank" rel="noopener">如何在npm上发布自己的包</a></p><h3 id="package-json-1"><a href="#package-json-1" class="headerlink" title="package.json"></a>package.json</h3><p>相关信息查阅网上，这里挑几个重点。</p><h4 id="files"><a href="#files" class="headerlink" title="files"></a>files</h4><p>选择要发布到npm服务器上的files<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"files": [</span><br><span class="line">   "cli.js",</span><br><span class="line">   "index.js",</span><br><span class="line">   <span class="string">"lib"</span></span><br><span class="line"> ],</span><br></pre></td></tr></table></figure></p><h4 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h4><p>如果设置此属性，意味着安装此包后，可执行如下<code>create-umi</code>命令，就会执行右侧cli.js。<br>bin的实现，大多使用<code>Yeoman</code>完成。<br>可参考 create-umi 包中bin开发处理。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"bin": &#123;</span><br><span class="line">   "create-umi": "cli.js"</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="dependencies与devDependencies区别技巧"><a href="#dependencies与devDependencies区别技巧" class="headerlink" title="dependencies与devDependencies区别技巧"></a>dependencies与devDependencies区别技巧</h4><p>devDependencies通常用于开发时，如eslint，或者启动命令的包 如 cross-env 等等。<br>还有一个最直观的：<br>凡事在项目业务或组件代码中，明确做来import依赖的，说明是生产必须包 dependencies ，<br>其他没有被import的，基本上是 devDependencies</p><h3 id="以create-umi为示例"><a href="#以create-umi为示例" class="headerlink" title="以create-umi为示例"></a>以create-umi为示例</h3><p>create-umi是npm包开发的一个典范，可以参照其源码进行开发。</p><h3 id="Yeoman写bin"><a href="#Yeoman写bin" class="headerlink" title="Yeoman写bin"></a>Yeoman写bin</h3><p>umi的bin，市面上很多bin的编写都使用了<code>Yeoman</code>。<br>参考《package.json  -  bin》</p><h2 id="创建一个npm工程"><a href="#创建一个npm工程" class="headerlink" title="创建一个npm工程"></a>创建一个npm工程</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="image-box">                <img src="/image/npm/menu.png" alt="" title="" class="">                <p></p>            </figure><p>### </p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>npm script</title>
      <link href="/2021/01/03/npmscript/"/>
      <url>/2021/01/03/npmscript/</url>
      
        <content type="html"><![CDATA[<h2 id="黑知识"><a href="#黑知识" class="headerlink" title="黑知识"></a>黑知识</h2><h3 id="关于pre的写法"><a href="#关于pre的写法" class="headerlink" title="关于pre的写法"></a>关于pre的写法</h3><p>如果npm script 写法中带有预先 pre，如下面的commit，那么在执行npm run commit 之前就会执行precommit命令？？<br>存疑，待研究。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "precommit": "lint-staged",</span><br><span class="line">    "lint": "npm run lint:js &amp;&amp; npm run lint:style &amp;&amp; npm run lint:prettier",</span><br><span class="line">    "lint-staged": "lint-staged",</span><br><span class="line">    "lint-staged:js": "eslint --ext .js,.jsx,.ts,.tsx",</span><br><span class="line">    "lint:fix": "eslint --fix --cache --ext .js,.jsx,.ts,.tsx --format=pretty \"./packages/**/src/**\" &amp;&amp; npm run lint:style",</span><br><span class="line">    "lint:js": "eslint --cache --ext .js,.jsx,.ts,.tsx --format=pretty \"./packages/**/src/**\"",</span><br><span class="line">    "lint:prettier": "check-prettier lint",</span><br><span class="line">    "lint:style": "stylelint --fix \"**/*.less\" --syntax less",</span><br><span class="line">    "prettier": "prettier -c --write \"**/*\""</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm-script </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>部署、运维及边缘</title>
      <link href="/2021/01/03/other/"/>
      <url>/2021/01/03/other/</url>
      
        <content type="html"><![CDATA[<p>这篇笔记暂时随便写下，后期会修改或删除。</p><h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><h3 id="通过iterm登陆腾讯云"><a href="#通过iterm登陆腾讯云" class="headerlink" title="通过iterm登陆腾讯云"></a>通过iterm登陆腾讯云</h3><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><a href="https://www.jianshu.com/p/2dae7b13ce2f" target="_blank" rel="noopener">linux安装docker</a></p><h4 id="加速器配上很重要"><a href="#加速器配上很重要" class="headerlink" title="加速器配上很重要"></a>加速器配上很重要</h4><p>下面是腾讯云的加速器地址，加速器对腾讯云中加载资源很重要，否则龟速。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><h4 id="注意启动docker"><a href="#注意启动docker" class="headerlink" title="注意启动docker"></a>注意启动docker</h4><h3 id="安装portainer"><a href="#安装portainer" class="headerlink" title="安装portainer"></a>安装portainer</h3><p>portainer是docker可视化的一个工具。安装好后，浏览器启动：<br><code>http://81.70.51.148:9000/#/containers</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create portainer_data</span><br><span class="line">docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br></pre></td></tr></table></figure></p><h3 id="安装-jenkins"><a href="#安装-jenkins" class="headerlink" title="安装 jenkins"></a>安装 jenkins</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins/jenkins</span><br><span class="line">docker run -d -v jenkins_home:/var/jenkins_home -p 8080:8080 -p 50000:50000 jenkins/jenkins</span><br></pre></td></tr></table></figure><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx-hz -p 8090:80 -d nginx</span><br></pre></td></tr></table></figure><h3 id="写入脚本"><a href="#写入脚本" class="headerlink" title="写入脚本"></a>写入脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo [INFO] 开始构建</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">echo [INFO] 编译并部署结束!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 边缘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> jenkens </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EnForm动态表单的使用</title>
      <link href="/2021/01/03/react_form_usage/"/>
      <url>/2021/01/03/react_form_usage/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这些年做react，深受form使用麻烦的苦，最后发现动态配置化表单是form使用的正确姿势，高效，易读，易维护。<br>结合自己的工作经验，花了一个多星期手写了一版 form的二次封装。<br>二次封装最难的是方案设计和实现，样式是最简单的了，每个公司样式需求各不同，本次封装就不涉及样式了，只专注功能实现。<br>核心源码行数不多，如果有兴趣，直接去github上，下载源码看看，下面有连接。</p><h2 id="默认用法"><a href="#默认用法" class="headerlink" title="默认用法"></a>默认用法</h2><p>这种用法使用enform提供的默认样式。<br>默认从上到下排列。默认表单超过8个field会进行分栏；你也可以自定设置每列显示的field数目。<br>在config.js中设置好：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;EnForm</span><br><span class="line">    title=<span class="string">"动态表单"</span></span><br><span class="line">    config=&#123;formConfig&#125;</span><br><span class="line">    onSubmit=&#123;onSubmit&#125;</span><br><span class="line">  /&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//config.js</span></span><br><span class="line"><span class="keyword">import</span> CustomInput <span class="keyword">from</span> <span class="string">'./component/CustomInput'</span>;</span><br><span class="line"><span class="keyword">const</span> formConfig = &#123;</span><br><span class="line">  fields: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'editname'</span>,</span><br><span class="line">      defaultValue: <span class="string">'test'</span>,</span><br><span class="line">      title: <span class="string">'edit user name'</span>,</span><br><span class="line">      <span class="comment">//支持自定义field</span></span><br><span class="line">      Render: CustomInput,</span><br><span class="line">      <span class="comment">//支持自定义验证规则</span></span><br><span class="line">      validate: [</span><br><span class="line">        [<span class="function">(<span class="params">value, formValue</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">String</span>(value).length &gt; <span class="built_in">String</span>(formValue.region).length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'hellow region'</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">          <span class="comment">//支持自定义验证规则映射功能</span></span><br><span class="line">        &#125;, [<span class="string">'region'</span>]]</span><br><span class="line">      ],</span><br><span class="line">      <span class="comment">//支持自定义验证规则error信息</span></span><br><span class="line">      required: <span class="string">'this is required'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'region'</span>,</span><br><span class="line">      title: <span class="string">'region'</span>,</span><br><span class="line">      type: <span class="string">'input'</span>,</span><br><span class="line">      defaultValue: <span class="string">''</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> formConfig;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/YeWills/react-redux-hooks-demo/tree/form-demo" target="_blank" rel="noopener">点击查看详细demo</a></p><h2 id="自由排列"><a href="#自由排列" class="headerlink" title="自由排列"></a>自由排列</h2><p>如果你既想配置化生成表单，又想自由排列field的位置，又想在form表单中插入任意内容，也是非常方便的，<br>这也是Enform的亮点了,<br><code>EnForm.EnField</code>中定义的name 要与 config.js中的name一致从而保持一种映射关系。<br>同时定义<code>layoutMode=&quot;custom&quot;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;EnForm</span><br><span class="line">    title=<span class="string">"登录"</span></span><br><span class="line">    config=&#123;formConfig&#125;</span><br><span class="line">    onSubmit=&#123;onSubmit&#125;</span><br><span class="line">    layoutMode=<span class="string">"custom"</span></span><br><span class="line">  &gt;</span><br><span class="line">    &lt;div &gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          随意排列,任意写入内容</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;EnForm.EnField className="form-cell" name="editname" /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;hellow world&lt;/</span>p&gt;</span><br><span class="line">    &lt;EnForm.EnField className=<span class="string">"form-cell"</span> name=<span class="string">"useName"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"region"</span>&gt;</span><br><span class="line">      &lt;div&gt;任意位置&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;EnForm.EnField className="form-cell" name="region" /</span>&gt;</span><br><span class="line">      &lt;div&gt;自由放置&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;EnForm.EnField className="form-cell" name="passWord" /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;EnForm.EnField className="form-cell" name="select" /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/EnForm&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//config.js</span></span><br><span class="line"><span class="comment">//与上面《默认用法》的config.js一样</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/YeWills/react-redux-hooks-demo/tree/context-form" target="_blank" rel="noopener">点击查看详细demo</a></p><h2 id="联动"><a href="#联动" class="headerlink" title="联动"></a>联动</h2><p>如果组件间需要联系，设置起来也是非常方便的, 在config.js中，将联动组件定义为自定义组件，每个自定义组件都将获得修改form三要素 form value， form validate error msgs， form field display 的能力：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formConfig = &#123;</span><br><span class="line">  fields: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'editname'</span>,</span><br><span class="line">      defaultValue: <span class="string">'test'</span>,</span><br><span class="line">      title: <span class="string">'edit user name'</span>,</span><br><span class="line">      <span class="comment">//支持自定义field</span></span><br><span class="line">      Render: CustomInput,</span><br><span class="line">      <span class="comment">//支持自定义验证规则</span></span><br><span class="line">      validate: [</span><br><span class="line">        [<span class="function">(<span class="params">value, formValue</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">String</span>(value).length &gt; <span class="built_in">String</span>(formValue.region).length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'hellow region'</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">          <span class="comment">//支持自定义验证规则映射功能</span></span><br><span class="line">        &#125;, [<span class="string">'region'</span>]]</span><br><span class="line">      ],</span><br><span class="line">      <span class="comment">//支持自定义验证规则error信息</span></span><br><span class="line">      required: <span class="string">'this is required'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CustomInput</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (props) =&gt; &#123;</span><br><span class="line">  <span class="comment">//onChange 设置新的form值</span></span><br><span class="line">  <span class="comment">//setDisplay 设置form内任何内容 显示／隐藏／readonly 等显示的相关信息</span></span><br><span class="line">  <span class="comment">//setErrMsgs 设置新的form error值</span></span><br><span class="line">  <span class="keyword">const</span> &#123; value, <span class="attr">onChange</span>: propsOnChange, setDisplay, setErrMsgs &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> getNewFormValue = <span class="function">(<span class="params">value, field, &#123;formValue&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; ...formValue, [field.name]: value, <span class="attr">passWord</span>:<span class="string">`<span class="subst">$&#123;value&#125;</span> - custom set`</span> &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123; </span><br><span class="line">     <span class="comment">// 联动修改其他field值</span></span><br><span class="line">    propsOnChange(e.target.value, getNewFormValue);</span><br><span class="line">  &#125;; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useState(<span class="string">'hide'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      setText(text === <span class="string">'hide'</span>? <span class="string">'show'</span>: <span class="string">'hide'</span>);</span><br><span class="line">      setDisplay(<span class="function">(<span class="params">formDisplay</span>)=&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> deleteStatus = _.get(formDisplay, <span class="string">'passWord.delete'</span>);</span><br><span class="line">          <span class="keyword">return</span> &#123;...formDisplay, <span class="attr">passWord</span>:&#123;...formDisplay.passWord, <span class="attr">delete</span>: !deleteStatus&#125;&#125;;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      value=&#123;value&#125;</span><br><span class="line">      onChange=&#123;onChange&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;span onClick=&#123;onClick&#125;&gt;&#123;text&#125; password&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><p><a href="https://yewills.github.io/2020/05/25/react_form_design/">设计方案博客 - EnForm动态表单封装 </a></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/YeWills/react-redux-hooks-demo/tree/context-form" target="_blank" rel="noopener">源码/demo github </a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> form </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React Router</title>
      <link href="/2021/01/03/react_router/"/>
      <url>/2021/01/03/react_router/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Router常见知识"><a href="#React-Router常见知识" class="headerlink" title="React Router常见知识"></a>React Router常见知识</h2><h3 id="HashRouter-还是-BrowserRouter-以及-Router-Route-讲解"><a href="#HashRouter-还是-BrowserRouter-以及-Router-Route-讲解" class="headerlink" title="HashRouter 还是 BrowserRouter 以及 Router  Route 讲解"></a>HashRouter 还是 BrowserRouter 以及 Router  Route 讲解</h3><p>简言之如果项目服务端做了服务端渲染，可以选择BrowserRouter，否则请选择HashRouter，因此一般项目都是HashRouter，因为大多项目么有做服务端渲染。<br>详细见下面（还讲了：利用服务器解析机制，服务器不会解析路由#以后的部分）：<br>摘自《React 实战：设计模式和最佳实践》第15章；<br>react-router 的工作方式，是在组件树顶层放一个 Router 组件，然后在组件树中散落着很多 Route 组件（注意比 Router 少一个“r”），顶层的 Router 组件负责分析监听 URL 的变化，在它保护伞之下的 Route 组件可以直接读取这些信息。</p><p>很明显，Router 和 Route 的配合，就是之前我们介绍过的“提供者模式”，Router 是“提供者”，Route是“消费者”。</p><p>更进一步，Router 其实也是一层抽象，让下面的 Route 无需各种不同 URL 设计的细节，不要以为 URL 就一种设计方法，至少可以分为两种。</p><p>第一种很自然，比如 / 对应 Home 页，/about 对应 About 页，但是这样的设计需要服务器端渲染，因为用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about 的访问返回 HTML。</p><p>第二种看起来不自然，但是实现更简单。<strong>只有一个路径 /，通过 URL 后面的 # 部分来决定路由，/#/ 对应 Home 页，/#/about 对应 About 页。因为 URL 中#之后的部分是不会发送给服务器的，所以，无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML 就可以，然后由浏览器端解析 # 后的部分，完成浏览器端渲染。</strong></p><p>在 react-router，有 BrowserRouter 支持第一种 URL，有 HashRouter 支持第二种 URL。</p><p>因为 create-react-app 产生的应用默认不支持服务器端渲染，为了简单起见，我们在下面的例子中使用 HashRouter，在实际产品中，其实最好还是用 BrowserRouter，这样用户体验更好。</p><p>修改index.js文件，增加下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;HashRouter&#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HashRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/HashRouter&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>把 Router 用在 React 组件树的最顶层，这是最佳实践。因为将来我们如果想把 HashRouter 换成 BrowserRouter，组件 App 以下几乎不用任何改变。</p><h3 id="带-与不带-的路由的区别"><a href="#带-与不带-的路由的区别" class="headerlink" title="带#与不带#的路由的区别"></a>带#与不带#的路由的区别</h3><p>利用服务器解析机制，服务器不会解析路由#以后的部分，详细见本章第《HashRouter 还是 BrowserRouter 以及 Router  Route 讲解》</p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>摘自《React 实战：设计模式和最佳实践》第15章；<br>我们来看 Content 这个组件，这里会用到 react-router 最常用的两个组件 Route 和 Switch。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Content = () =&gt; (</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route exact path=&apos;/&apos; component=&#123;Home&#125;/&gt;</span><br><span class="line">      &lt;Route path=&apos;/about&apos; component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>Route 组件的 path 属性用于匹配路径，因为我们需要匹配 / 到 Home，匹配 /about 到 About，所以肯定需要两个 Route，但是，我们不能这么写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&apos;/&apos; component=&#123;Home&#125;/&gt;</span><br><span class="line">&lt;Route path=&apos;/about&apos; component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>如果按照上面这么写，当访问 /about 页面时，不光匹配 /about，也配中 /，界面上会把 Home 和 About 都渲染出来的。</p><p>解决方法，可以在想要精确匹配的 Route 上加一个属性 exact，或者使用 Switch 组件。</p><p>可以把 Switch 组件看做是 JavaScript 的 switch 语句，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">switch (条件) &#123;</span><br><span class="line">  case 1: 渲染1; break;</span><br><span class="line">  case 2: 渲染2; break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上往下找第一个匹配的 Route，匹配中了之后，立刻就 break，不继续这个 Switch 下其他的 Route 匹配了。</p><p>可以看到，react-router 巧妙地用 React 组件实现了路由的所有逻辑，印证了那句话：React 世界里一切都是组件。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>摘自《React 实战：设计模式和最佳实践》第15章；<br>在了解了 react-router的基本路由功能之后，再来理解“动态路由”就容易了。</p><p>假设，我们增加一个新的页面叫 Product，对应路径为 /product，但是只有用户登录了之后才显示。如果用静态路由，我们在渲染之前就确定这条路由规则，这样即使用户没有登录，也可以访问 product，我们还不得不在 Product 组件中做用户是否登录的检查。</p><p>如果用动态路由，则只需要在代码中的一处涉及这个逻辑：</p><pre><code>&lt;Switch&gt;  &lt;Route exact path=&apos;/&apos; component={Home}/&gt;  {    isUserLogin() &amp;&amp;    &lt;Route exact path=&apos;/product&apos; component={Product}/&gt;,  }    &lt;Route path=&apos;/about&apos; component={About}/&gt;&lt;/Switch&gt;</code></pre><p>可以用任何条件决定 Route 组件实例是否渲染，比如，可以根据页面宽度、设备类型决定路由规则，动态路由有了最大的自由度。</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
          <category> React Router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端以外笔记</title>
      <link href="/2021/01/03/tool/"/>
      <url>/2021/01/03/tool/</url>
      
        <content type="html"><![CDATA[<p>本篇笔记用来记录前端知识以外的笔记，或者一时无法分类的笔记</p><h2 id="github直接浏览demo效果"><a href="#github直接浏览demo效果" class="headerlink" title="github直接浏览demo效果"></a>github直接浏览demo效果</h2><p>在网上介绍了很多关于github直接浏览demo的效果，不过有很多方法确实不太好，混淆视听，比如preview的那种方式，就不值得推荐。<br>推荐的做法是使用GitHub pages方法。</p><h3 id="GitHub-pages方式-推荐"><a href="#GitHub-pages方式-推荐" class="headerlink" title="GitHub pages方式(推荐)"></a>GitHub pages方式(推荐)</h3><p>网上查找下，很多教程。</p><h3 id="master-分支"><a href="#master-分支" class="headerlink" title="master 分支"></a>master 分支</h3><p>这种方式，它只针对仓库的master分支，因此请将要显示的html放置在master分支上。</p><h3 id="根路径-文件地址可以显示任何html"><a href="#根路径-文件地址可以显示任何html" class="headerlink" title="根路径+文件地址可以显示任何html"></a>根路径+文件地址可以显示任何html</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//根路径：</span><br><span class="line">https://yewills.github.io/d3-note-demo/</span><br><span class="line"></span><br><span class="line">文件路径：</span><br><span class="line">/pages/sar-chart/</span><br><span class="line"></span><br><span class="line">实际地址为：</span><br><span class="line">https://yewills.github.io/d3-note-demo/pages/sar-chart/</span><br></pre></td></tr></table></figure><h3 id="src引用文件的netWork调试"><a href="#src引用文件的netWork调试" class="headerlink" title="src引用文件的netWork调试"></a>src引用文件的netWork调试</h3><p>文件使用github.io时，一般不会有src引用问题，原来的项目引用地址，就是什么地址，如果产生问题，可以打开调试，重新写上可访问地址。</p>]]></content>
      
      
      <categories>
          
          <category> 前端以外 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端以外 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git笔记</title>
      <link href="/2021/01/03/git/"/>
      <url>/2021/01/03/git/</url>
      
        <content type="html"><![CDATA[<p>一直在用git，也想总结一点git笔记，因此就有了本篇。</p><h3 id="git图形化工具误你一生"><a href="#git图形化工具误你一生" class="headerlink" title="git图形化工具误你一生"></a>git图形化工具误你一生</h3><p>使用git图形化工具是使用git的错误开始，使用图形化越深，错的越深。<br>珍爱git，及早丢弃图形化。</p><h3 id="git-init-与-git-remote"><a href="#git-init-与-git-remote" class="headerlink" title="git init 与 git remote"></a>git init 与 git remote</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>本地一个文件夹，里面有很多文件，你想从现在开始，对此文件进行版本管理，执行git init即可；<br>git init后，就可以尽情地对此项目各种版本管理操作；<br>有一天你想对这个git init项目上传到github上，<br>在命令窗口执行 git remote，cmd窗口会提示你如何上传到GitHub服务器上。</p><h4 id="git-remote-相关问题"><a href="#git-remote-相关问题" class="headerlink" title="git remote 相关问题"></a>git remote 相关问题</h4><p>本地仓库git init后，在关联远程地址时，要求做如下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Either specify the URL from the command-line or configure a remote repository using</span><br><span class="line">//这里的name 通常为 remote name，默认的远程名字为origin，</span><br><span class="line">//所以此处name请记住一定要写origin，不然会导致下面讲到的无法使用git push 就可以轻松push。</span><br><span class="line">//当然如果有需求，也可以定义其他远程名。</span><br><span class="line">    git remote add &lt;name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line">and then push using the remote name</span><br><span class="line">//这里的name是远程上的branch名，仓库第一个分支名通常命名为 master</span><br><span class="line">    git push &lt;name&gt;</span><br></pre></td></tr></table></figure></p><h4 id="git-push时，要求-git-remote-add-的问题"><a href="#git-push时，要求-git-remote-add-的问题" class="headerlink" title="git push时，要求 git remote add  的问题"></a>git push时，要求 git remote add <name> <url>的问题</url></name></h4><p>此问题与上面说的 《git remote 相关问题》一脉相承，<br>这里我们要了解一个知识点， <strong>使用git push 推送到服务器时，默认是推送到名字为 origin的远程上</strong>，所以本地分支与远程分支建立联系时，使用的是origin，那么该分支每次push时，使用git push就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add orgin https://.....</span><br></pre></td></tr></table></figure></p><p>从该分支checkout出来的branch，push到远程时，也能正常使用 git push即可推送。</p><h3 id="看cmd窗口提示很关键"><a href="#看cmd窗口提示很关键" class="headerlink" title="看cmd窗口提示很关键"></a>看cmd窗口提示很关键</h3><p>上面说到了执行git remote cmd窗口会有提示，按照提示，就可以完成想做的事情。<br>git 提供了强大的提示功能，要重视cmd窗口提示信息，很关键。<br>git bash 粘贴复制很好用</p><h3 id="使用git-bash，放弃cmd"><a href="#使用git-bash，放弃cmd" class="headerlink" title="使用git bash，放弃cmd"></a>使用git bash，放弃cmd</h3><p>git bash才是最适合用来管理git的命令窗口，比如 git bash 能时刻显示当前你所处的分支名，能完整保留git的操作，因为cmd超过一定操作会删除以前的操作日志。</p><h3 id="git-fetch-git-pull-切远程分支"><a href="#git-fetch-git-pull-切远程分支" class="headerlink" title="git fetch\git pull\切远程分支"></a>git fetch\git pull\切远程分支</h3><p>git fetch 将远程分支更新到本地，但不与本地分支合并，下载到本地的分支的名字前面都有origin/,例如origin/master.<br>git pull 是git fetch与git merge origin/branch 的两步。</p><h4 id="拉取新项目时，如何切换到项目的其他分支"><a href="#拉取新项目时，如何切换到项目的其他分支" class="headerlink" title="拉取新项目时，如何切换到项目的其他分支"></a>拉取新项目时，如何切换到项目的其他分支</h4><p>执行 git fetch后，git checkout即可</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>git checkout . 清除所有<br>git checkout string  ，此string可以是分支名，也可是commitHash</p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><h4 id="PR冲突时，处理冲突"><a href="#PR冲突时，处理冲突" class="headerlink" title="PR冲突时，处理冲突"></a>PR冲突时，处理冲突</h4><p>多人开发，在提PR给develop分支时，当github页面提示有冲突时,处理如下：<br>切到自己的分支(PR到develop的分支)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git rebase develop</span><br><span class="line">//这时会显示冲突内容，解决冲突，执行</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br><span class="line">git push origin -f</span><br></pre></td></tr></table></figure></p><p>然后重新PR,这时就不报错了<br>有人将上一操作过程称为变基。<br>git rebase 功能类似 git merge，区别在于，git merge时，你的commit 是按先后顺序排列的，merge完成后可能一眼看不到自己的提交。<br>git rebase则不同，git rebase后，你与develop不同的提交(也就是你修改的)commit将显示在第一条，(注意的是，git rebase冲突修改将不会生成commit，从上面只有git add,没有git commit得到佐证，因为只有git commit 才会生成一条commit):<br><figure class="image-box">                <img src="/image/git/git3.png" alt="" title="" class="">                <p></p>            </figure></p><p>以上过程是把git rebase 当git merge来用，git rebase的这种当merge的用法，用的不多，用得最多的就是上面展示的，用来处理PR后的冲突。</p><h4 id="将最新修改合并过来，且保证提交的连续性"><a href="#将最新修改合并过来，且保证提交的连续性" class="headerlink" title="将最新修改合并过来，且保证提交的连续性"></a>将最新修改合并过来，且保证提交的连续性</h4><p>比如，你在做用户管理功能，同事在做登录功能；<br>你的用户管理的页面效果写好了，要做接口联调，需要用到同事做的登录功能的用户参数；<br>注意，<br>你可以直接merge 同事的代码过来，但弊端是，你自己做的用户管理提交可能无法显示在git log的最前面；<br>在此推荐用rebase 同事的代码，好处是，既将同事的修改merge过来，又可以将自己的修改显示最上方，保证当前业务功能的commit的连续性和直观性。</p><h4 id="rebase-与-merge"><a href="#rebase-与-merge" class="headerlink" title="rebase 与 merge"></a>rebase 与 merge</h4><p>如上所说，rebase有这么多好处，merge能做到的，rebase都能做到，为什么不都用rebase呢？<br>因为merge是无害的，不改变commithash值；<br>而rebase有改变commithash值的风险，这就意味着你做分支的合并时就会出现冲突，如果你有一群小伙伴一起开发，那么这个冲突起来，会让你hold不住，然而这并不妨碍你对rebase的热爱。</p><p>因此鉴于merge的无害性，一般情况下分支合并就使用merge；<br>在特定场景下才使用rebase；</p><h4 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h4><p>这是日常开发必备用法，不会此法，不能说会使用git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//正常使用</span><br><span class="line">git rebase -i HEAD~6</span><br><span class="line">按字母i键，进入insert模式(编辑模式)</span><br><span class="line">留一个最上面的pick，</span><br><span class="line">后面的pick全部换成s；</span><br><span class="line">修改好后，按esc键(退出编辑模式)</span><br><span class="line">:wq //保存编辑修改，vim命令</span><br><span class="line">:q! //不保存编辑修改，vim命令</span><br></pre></td></tr></table></figure><p>如果遇到冲突，除了以上命令，按提示操作，还会执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//注意的是，执行完git add . 后，不必执行git commit</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure></p><p>放弃rebase<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure></p><p>注意的是以下两种方法都支持，两种方法各有优点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~6</span><br><span class="line">git rebase -i c9r26r869b8  //c9r26r869b8 此hash值不被合并，此hash以前的所有commit将被合并</span><br></pre></td></tr></table></figure></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><h4 id="将分支回滚到指定历史版本"><a href="#将分支回滚到指定历史版本" class="headerlink" title="将分支回滚到指定历史版本"></a>将分支回滚到指定历史版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// --hard 是强制的意思</span><br><span class="line">git reset --hard commitHash</span><br></pre></td></tr></table></figure><h4 id="放弃所有修改，回到干净的当前仓库版本"><a href="#放弃所有修改，回到干净的当前仓库版本" class="headerlink" title="放弃所有修改，回到干净的当前仓库版本"></a>放弃所有修改，回到干净的当前仓库版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure><h4 id="git-reset-HEAD"><a href="#git-reset-HEAD" class="headerlink" title="git reset HEAD~"></a>git reset HEAD~</h4><p>这个方法非常好用，本意是重新修改上一次提交。<br>执行这个命令后，将上一次提交的所有文件将至于 not staged 状态,<br>然后，你可很直观看到这次提交修改的所有文件，<br>并且vscode对于not staged状态的文件，会将他们集中显示到源代码管理窗口，<br>这对于git rebase 很多commit后，然后再次整理或格式化所有的修改内容 是很棒的功能。</p><h4 id="回到指定提交后，并重新修改这一次提交内容"><a href="#回到指定提交后，并重新修改这一次提交内容" class="headerlink" title="回到指定提交后，并重新修改这一次提交内容"></a>回到指定提交后，并重新修改这一次提交内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitHash</span><br><span class="line">//~ 指的是上一次的意思</span><br><span class="line">git reset HEAD~</span><br></pre></td></tr></table></figure><h4 id="再次对前几次commit修改的内容修改"><a href="#再次对前几次commit修改的内容修改" class="headerlink" title="再次对前几次commit修改的内容修改"></a>再次对前几次commit修改的内容修改</h4><p>我们做一个面包屑菜单功能，可能做了很多次提交，现在想对这么多次的提交所修改的所有内容，重新审阅一遍，以便修改内容或者格式化，解决方案如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~6</span><br><span class="line">git reset HEAD~</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;面包屑功能&quot;</span><br></pre></td></tr></table></figure></p><p>参考《git reset HEAD~》</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>git reset后，要push时，都需加上-f，强制push</p><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><p>如果你使用git reset,那么git log无法查到当前提交之后的提交日志，此时使用 git reflog</p><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>不懂git cherry-pick，说明你还不懂git这位美女的基本套路，必备git操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick commitHash</span><br></pre></td></tr></table></figure></p><p>git cherry-pick 与 git reset 配合使用可以尽情任意穿插回滚修改版本提交，只有此时，你才懂git的美，从此爱不释手，相逢恨晚。</p><h4 id="commitHash值会变"><a href="#commitHash值会变" class="headerlink" title="commitHash值会变"></a>commitHash值会变</h4><p>当一个commit从一个branch cherry-pick到另外一个branch的时候，在新的branch上，对应的commit的hash值与原始的hash值不一样，有了变化。不过其他信息，包含时间信息，都么有变。</p><h4 id="commit会置顶"><a href="#commit会置顶" class="headerlink" title="commit会置顶"></a>commit会置顶</h4><p>cherry-pick的commit在新的branch上会置顶。</p><h4 id="行为类似rebase"><a href="#行为类似rebase" class="headerlink" title="行为类似rebase"></a>行为类似rebase</h4><p>结合以上，说明cherry-pick的行为类似rebase的过程（置顶与hash码变化）</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -D branch //删除本地分支</span><br><span class="line">git branch -a // 查看远程有多少分支</span><br></pre></td></tr></table></figure><h3 id="git-push-删除远程分支"><a href="#git-push-删除远程分支" class="headerlink" title="git push 删除远程分支"></a>git push 删除远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin -d branch</span><br></pre></td></tr></table></figure><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>命令简单，Google下命令即可，git tag很重要也很好用，<br>tag的好处有，它既像一个branch，保存了当次tag的所有提交，又提供了一个zip包，<br>很多开源框架的 历史版本API 都是通过tag完成，非常之好用</p><h3 id="gitk"><a href="#gitk" class="headerlink" title="gitk"></a>gitk</h3><p>非常好用的查看工具，git自带，此工具太好用，是查历史，凭关键字查提交的一把好手，太重要，用得太频繁，你必需会，<br>启动方法：<br>git bash中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure></p><p>比较好的gitk命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询abc.js文件的历史修改记录，比任何插件显示的全</span><br><span class="line">gitk -- **/ abc.js</span><br></pre></td></tr></table></figure></p><h3 id="工作目录、index、HEAD、object、快照"><a href="#工作目录、index、HEAD、object、快照" class="headerlink" title="工作目录、index、HEAD、object、快照"></a>工作目录、index、HEAD、object、快照</h3><p>工作目录、index（暂存区）、HEAD（当前所处commit）、object（文件树）。<br>快照：可以理解为版本每次提交后，git会给提交拍照，用来记录版本信息。<br>尤其 工作目录、index、HEAD 这三个概念是git的三驾马车，就好比 action、reducer、selector 是react-redux的三驾马车一样。<br>要多刷视频和书籍《精通git》了解这仨，了解git一切只是什么指针或快照，虽然我现在也忘得差不多，但一定要了解。<br><figure class="image-box">                <img src="/image/git/git1.png" alt="" title="" class="">                <p></p>            </figure><br>工作目录，index（暂存区）、HEAD（master分支）、objexts（树）。<br>index与HEAD都是通过指针指向文件树objects；</p><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line">git stash apply</span><br><span class="line">git checkout -b branch</span><br><span class="line">git log -n</span><br><span class="line">git commit -amend</span><br><span class="line">git help stash //使用help方式一</span><br><span class="line">git stash --help //使用help方式二</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure><h3 id="git-技巧"><a href="#git-技巧" class="headerlink" title="git 技巧"></a>git 技巧</h3><h4 id="空格使用"><a href="#空格使用" class="headerlink" title="空格使用"></a>空格使用</h4><p>清除多个或merge多个 可使用空格，一次搞定，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout file1.js file2.js</span><br><span class="line">git merge branch1 branch2</span><br></pre></td></tr></table></figure></p><h4 id="–abort"><a href="#–abort" class="headerlink" title="–abort"></a>–abort</h4><p>–abort一般是放弃的意思，如<br>放弃merge<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure></p><h4 id="–contnue"><a href="#–contnue" class="headerlink" title="–contnue"></a>–contnue</h4><p>–abort一般是放弃的意思，如<br>放弃merge<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --contnue</span><br></pre></td></tr></table></figure></p><h4 id="字母q"><a href="#字母q" class="headerlink" title="字母q"></a>字母q</h4><p>在git log命令出来一堆历史时，按回车或其他键，只会显示更多历史，按字母q可退出。</p><h4 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h4><p>-i表示交互的意思。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~6</span><br></pre></td></tr></table></figure></p><h4 id="双点号，三点号的特殊意义"><a href="#双点号，三点号的特殊意义" class="headerlink" title="双点号，三点号的特殊意义"></a>双点号，三点号的特殊意义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p master..origin/master 查看二者区别</span><br></pre></td></tr></table></figure><h4 id="gitk查看历史最可靠"><a href="#gitk查看历史最可靠" class="headerlink" title="gitk查看历史最可靠"></a>gitk查看历史最可靠</h4><p>vscode的一些插件(如 Git History)，可以很好地查看历史，不过也会有一些历史被漏掉，如对于一些git rebase -i的历史或者处理冲突的历史 有可能被漏掉不被显示，此时请使用gitk查历史，gitk最可靠，会显示所以提交，巨细无遗。</p><h4 id="多程序同时操作一个文件引起的报错"><a href="#多程序同时操作一个文件引起的报错" class="headerlink" title="多程序同时操作一个文件引起的报错"></a>多程序同时操作一个文件引起的报错</h4><p>执行复杂操作时，报 permission错误，可能是由于其他程序和git同时操作一个文件引起的，<br>此时，可以停止npm start或关闭编辑器，只让git一个程序操作项目，解决此问题。</p><h4 id="merge-commitHash"><a href="#merge-commitHash" class="headerlink" title="merge commitHash"></a>merge commitHash</h4><p>git merge branch，也可以git merge commitHash；<br>同理估计也可以git rebase commitHash</p><h4 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h4><p>需要懂那么点vim 操作知识，如:wq :q! 参考 《git rebase》</p><h4 id="手动处理冲突"><a href="#手动处理冲突" class="headerlink" title="手动处理冲突"></a>手动处理冲突</h4><p>手动处理冲突其实很简单，而且又做到不依赖插件。</p><h4 id="ssh可能并没有你想象重要"><a href="#ssh可能并没有你想象重要" class="headerlink" title="ssh可能并没有你想象重要"></a>ssh可能并没有你想象重要</h4><p>由于公司原因一直也没设置ssh，各种push什么的，也很少需要输入用户密码，不影响工作，也许ssh没有你现象的高大上。</p><h3 id="推荐使用vscode"><a href="#推荐使用vscode" class="headerlink" title="推荐使用vscode"></a>推荐使用vscode</h3><p>vscode内置了对git的支持，对git支持太友好，vscode自带的显示git版本变化的功能很好用，<br>配合vscode的一些git插件，能够很好的显示每行代码的历史记录，是甩锅，找坑的必备良器。</p><h3 id="不会用GitHub就是耍流氓"><a href="#不会用GitHub就是耍流氓" class="headerlink" title="不会用GitHub就是耍流氓"></a>不会用GitHub就是耍流氓</h3><p>用git，不会使用GitHub的基本操作，就是耍流氓，既然你跟git感情这么好，干嘛不更好一点，娶了她呢，这不是耍流氓吗。<br>主要要熟练 github的git workflow (也就是PR代码审核) 和 fork功能，以及看tag。<br>理解 git workflow的最核心的两大目的:PR代码审核 以及 维护一套测试、稳定和发布分支。<br><figure class="image-box">                <img src="/image/git/git2.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="git入门阶段不需知道的"><a href="#git入门阶段不需知道的" class="headerlink" title="git入门阶段不需知道的"></a>git入门阶段不需知道的</h3><h4 id="git-rebase-i-HEAD后记得合并到test-branch"><a href="#git-rebase-i-HEAD后记得合并到test-branch" class="headerlink" title="git rebase -i HEAD后记得合并到test branch"></a>git rebase -i HEAD后记得合并到test branch</h4><p>分支PR到develop后，如果在PR前做了合并历史(git rebase -i HEAD)，如果test branch基于develop创建，记得将自己被PR的分支 merge一次到test branch，由于test branch 滞后于develop branch，防止 从develop新建的branch merge到test branch时冲突，</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="unable-to-access-Could-not-resolve-host-github-com"><a href="#unable-to-access-Could-not-resolve-host-github-com" class="headerlink" title="unable to access ..Could not resolve host: github.com"></a>unable to access ..Could not resolve host: github.com</h4><p>之前git push还是好好的，用着用着就 git push 异常，并报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &apos;https://github.com/YeWills/YeWills.github.io.git/&apos;: Could not resolve host: github.com</span><br></pre></td></tr></table></figure><p>不过令人费解的是，<strong>试github其他仓库，不用科学上网，可以push成功的。</strong></p><p>终极解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># step1. ping github.com </span><br><span class="line">获取到github.com的ip为192.30.252.128 </span><br><span class="line"># step2. 在/etc/hosts中添加一行如下: </span><br><span class="line">sudo  vim /etc/hosts</span><br><span class="line">192.30.252.128 github.com</span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/piaotiejun/article/details/48734175" target="_blank" rel="noopener">参考</a><br>一般情况，上面即可解决，如果解决不了，考虑下面方法：</p><p>造成以上原因，有可能为以下几点：<br>网络被墙了？<br>使用了强制push –force （普通push是可以的）</p><p>亲测以下几种方式偶尔可以解决：</p><ul><li>科学上网，然后push，此方法有时有效，有时也无效；</li><li>重设账号密码：<br>（1）先重新设置本机git配置：git config –global credential.helper store （这一步可以不用）<br>（2）输入github账号和密码 （这一步可以不用）<br>（3）最后push代码：git push -u origin master （这一步必须，如果是强制push，加上 -f）</li></ul><p><a href="https://blog.csdn.net/mhs624014469/article/details/77124540?utm_source=blogxgwz3" target="_blank" rel="noopener">这里还有另外几种解决方式</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>决定房价的因素</title>
      <link href="/2021/01/03/house/"/>
      <url>/2021/01/03/house/</url>
      
        <content type="html"><![CDATA[<p>由于近年来经常被各种房价新闻混淆视听，这里写一点关于房价的见解和梳理，让自己不被新闻混淆，以笔记的形势写的，内容格式语言粗糙了点。</p><h2 id="房价只于供给与需求有关。"><a href="#房价只于供给与需求有关。" class="headerlink" title="房价只于供给与需求有关。"></a>房价只于供给与需求有关。</h2><p>供需合理时，房价才合理，供需不合理时的房价永远是病态的。<br>市场上房子供应充足，房子的需求也大，那么此时的房价就是合理的价格，正常的供需产生合理的价格。<br>如果房子供应短缺，房子需求却大，那么此时的房价就是偏高；<br>如果供求太短缺，房子需求还是大，那么就产生了病态的价格。<br>比如现在市场急缺10万套房子，而只建了5000套，此时房价不病态才怪。</p><h2 id="房价与土地无关"><a href="#房价与土地无关" class="headerlink" title="房价与土地无关"></a>房价与土地无关</h2><p>房价与土地无关，为什么这样说，比如北京，其实有很多地方可以建房子，<br>北京面积16.5k平方千米，人口2154万；<br>香港1.1k平方千米，人口748万；<br>按照香港的密度建房子：<br>北京面积=16<em>香港面积；<br>北京理论可容下的人口=16</em>748万=1.1968亿；<br>1.1968亿人是什么概念，全国人口最多省是广东省，人口也才 1.1346亿；<br>就算广东省所有的人跑到北京，北京不仅能容得下，还能再容600万人口；<br>而更震惊的是香港只开发了25%的土地，<a href="http://www.ceweekly.cn/2014/0723/87935.shtml" target="_blank" rel="noopener">还有75%的土地被港府禁止开发</a>。<br>所以北京现在的面积可建的房屋，可容下的人，远不止1.19亿；<br>为什么有这么多土地，却没有这么多房子呢？<br>就是没有建的原因，不要问我为什么不建，我就不建怎么了，你咬我啊。<br>土地不等于房子，你要在土地上建房子了，那才等于房子。<br>所以房价与土地无关，只于房子的供给，房子的实际存量有关。</p><h2 id="房价与人口无关"><a href="#房价与人口无关" class="headerlink" title="房价与人口无关"></a>房价与人口无关</h2><p>这个有深层次原因，具体为：</p><h3 id="未来几十年，大城市人口将越来越多，不被全国人口影响，："><a href="#未来几十年，大城市人口将越来越多，不被全国人口影响，：" class="headerlink" title="未来几十年，大城市人口将越来越多，不被全国人口影响，："></a>未来几十年，大城市人口将越来越多，不被全国人口影响，：</h3><p>现在全国人口出生率是减少了，但具体到一个城市，比如深圳，<br>深圳2019年人口净流入约为50万，<a href="https://city.shenchuang.com/city/20180524/1087719_2.shtml" target="_blank" rel="noopener">而深圳2019年建的房子，也就5万套</a>，<br>这样供求失衡，如何不导致房价畸形上升。<br>所以全国人口无法代表了某一个城市的人口，进而无关房价。</p><h3 id="改革开发三十几年积累了很多购房需求没有得到释放"><a href="#改革开发三十几年积累了很多购房需求没有得到释放" class="headerlink" title="改革开发三十几年积累了很多购房需求没有得到释放"></a>改革开发三十几年积累了很多购房需求没有得到释放</h3><p>就算一个城市人口不增长，但是2019年为止，改革开放41年，在2008年以前，进城务工的人，应该没有将城市当作家，只是工作完就回老家，<br>没有买房，然而随着时代发展，城市的优越性越来越突出，农村的缺点越来越明显，农村作为上古时代主要的人口聚集地，悄然陨落，随着时代的发展，淘汰农村作为主要人口聚集地将是无法阻挡的趋势，甚至极端地说，未来的发展中，农村这种聚集方式将被淘汰，取而代之的是城市。<br>随着农民进城务工，发现城市的优越性后，越来越难以回到农村，于是产生了购房需求。而这种现象其实也就是2008年前后才明显产生，到现在不过十年。<br>而这一份购房需求的潜能是从改革开发到2008年就开始积累的，直到2008年大家才开始想着去买房，才去释放需求，就好比改革开放40年来，有越来越多的人到城市，这个人口的累计花了40年，他们一直没有买房，直到2008年，突然想着去买房，到现在也才释放10年时间，所以到现在，2019年，其实是累计了很多年的购房需求的，就算城市的人口不增加，购房的需求还是有的。</p><h3 id="城市中对房子已经存在的需求缺口与房子的构建速度太悬殊"><a href="#城市中对房子已经存在的需求缺口与房子的构建速度太悬殊" class="headerlink" title="城市中对房子已经存在的需求缺口与房子的构建速度太悬殊"></a>城市中对房子已经存在的需求缺口与房子的构建速度太悬殊</h3><p>比如北京，我们假设还需要1000万套房子，但是每年只给你建5万套，那么这个缺口需要等400年才能满足。等400年后，建的房子才够人们需求。<br>而现实当中现在城市中房子已经存在的缺口与房子的构建速度，太悬殊了，对于大城市或热门城市，更加悬殊，就算人口负增长，以目前房屋建造速度，都需要几十年乃至几百年才能达到供需平衡。<br>所以说，房价与人口无关，</p><h3 id="城镇化率不高将削弱人口负增长的影响"><a href="#城镇化率不高将削弱人口负增长的影响" class="headerlink" title="城镇化率不高将削弱人口负增长的影响"></a>城镇化率不高将削弱人口负增长的影响</h3><p>中国现在的城镇化率还有待提高，就算人口负增长，也无法阻挡城市人口越来越多，冲淡全国人口减少对城市房价的影响。</p><h2 id="房价与国家干预无关"><a href="#房价与国家干预无关" class="headerlink" title="房价与国家干预无关"></a>房价与国家干预无关</h2><p>房价与国家干预无关，比如2008年国家限价后，2009年出现房价报复上涨，2015年限购后，2016年房价出现报复上涨。<br>国家干净并没有改变供求关系，而是让买的人不能买，卖的人无法卖，什么限购限价，都只是干扰了买卖；<br>这过程当中，国家并没有扩建房屋，提高供应，而需求的人随着事件推移越来越多，但越来越不能买；<br>这样的后果是，房屋就100栋，限购五年，第一年需求的人是1万人，第二年是2万人，，，第五年需求的人是5万人；<br>到第五年的时候，由于限购，房子一栋也没卖出去，也没有一个人能买到房，房子供应还是100栋；<br>好了，到第五年不限购的时候，房子供应是100套，需求是5万套，这些人都应该会像饿狼扑食一般吧，这就是导致了房价报复增长了。<br>所以国家干预只是暂停了交易，并没有改变供求关系，并不能本质上改变房价。</p><h2 id="限购与房价报复性上涨"><a href="#限购与房价报复性上涨" class="headerlink" title="限购与房价报复性上涨"></a>限购与房价报复性上涨</h2><p>每当限购之时导致购房需求累计，供应不变，解购之后，越来越畸形的供需关系将导致报复性上涨，更多参考《房价与国家干预无关》</p><h2 id="如何判断房价是否高了"><a href="#如何判断房价是否高了" class="headerlink" title="如何判断房价是否高了"></a>如何判断房价是否高了</h2><p>房子供需平衡，就说明房价合理，目前包括香港、北上广。。。供需都不平衡，房价依然过高。</p><h2 id="目前的房价是否高，以及将来房价走势"><a href="#目前的房价是否高，以及将来房价走势" class="headerlink" title="目前的房价是否高，以及将来房价走势"></a>目前的房价是否高，以及将来房价走势</h2><p>以当前的供求关系，说明了房价过高；<br>然而在未来，以目前房屋供应速度，加上需求增长，供求关系在未来将变得越来越畸形，<br>必然导致房价将继续上涨，在未来，买房将越来越困难，至少比现在更困难。</p><h2 id="工资上涨能否跑过房价上涨"><a href="#工资上涨能否跑过房价上涨" class="headerlink" title="工资上涨能否跑过房价上涨"></a>工资上涨能否跑过房价上涨</h2><p>房价只于供求有关，供求关系不变，工资越涨，房价将更加增长，以目前的形势，在未来，工资永远跑不过房价。</p><h2 id="香港八万五建屋计划"><a href="#香港八万五建屋计划" class="headerlink" title="香港八万五建屋计划"></a>香港八万五建屋计划</h2><p>97年，为了缓解房屋短缺，香港推行八万5计划，建造8万5千套房子，结果遭反对，特别是地产商返回，导致计划搁置。<br>虽然计划搁置了，但是却提供了解决住房问题的思路。</p><h2 id="解决住房问题"><a href="#解决住房问题" class="headerlink" title="解决住房问题"></a>解决住房问题</h2><p>由上面香港八万五建屋计划，可以映射出，要解决住房问题，最好直接的做法是增加供应；<br>然而增加供应，将导致房价下降，进而导致土地贬值；<br>国家目前有太多要办的事情，国际大环境不好，贸易战，边界冲突，领土纠纷，国际扩张等等，这些都需要很多钱；<br>因此大幅增加供应，是不会做的，但为了解决民生，未来大幅增加出租房才是比较好的解决方法，<br>增加出租房，出租房是无法买卖的，不会影响房屋的供求关系，就不会影响房价，完美地规避了与既得利益房产集团利益。<br>另一方面，出租房又能实实在解决住房问题，改善民生，一箭双雕。</p><h2 id="有一万种手段保证土地不贬值"><a href="#有一万种手段保证土地不贬值" class="headerlink" title="有一万种手段保证土地不贬值"></a>有一万种手段保证土地不贬值</h2><p>目前的供求关系太失衡，上层根本不用担心人口减少、经济环境不好导致房价下降；<br>比如现在房屋缺口1000万，每年只给你建5万栋，房价只会等到400年后降低，土地价格当然也要等400年后才降低；</p><h2 id="法宝就是限制供应"><a href="#法宝就是限制供应" class="headerlink" title="法宝就是限制供应"></a>法宝就是限制供应</h2><p>只要不给你供应房屋，或很少地供应房屋，什么人口减少，经济下降，这些都是屁话，都不会影响房价下跌。</p><h2 id="租房"><a href="#租房" class="headerlink" title="租房"></a>租房</h2><p><strong>有钱买房，没钱租房，这才是正道</strong><br>考虑到当前形势，考虑到国际大环境，国家要做的事情太多，这些都要求房价稳定，所以如果你有钱，可以考虑买套房；<br>如果没钱，租房是很划算的选择，而且国家当前租房相比其他国家，性价比还是比较高的。<br>参考。《香港八万五建屋计划 与 解决房屋问题》《解决住房问题》</p><h2 id="几种影响房价的现象"><a href="#几种影响房价的现象" class="headerlink" title="几种影响房价的现象"></a>几种影响房价的现象</h2><h3 id="人口净流入增多"><a href="#人口净流入增多" class="headerlink" title="人口净流入增多"></a>人口净流入增多</h3><p>如果一个城市人口净流入增多，房价基本会上涨。</p><h3 id="土地流拍"><a href="#土地流拍" class="headerlink" title="土地流拍"></a>土地流拍</h3><p>土地流拍，说明房地产商不愿盖房子，房子供应将变少，未来可能房价看涨；</p><h3 id="棚改与拆迁"><a href="#棚改与拆迁" class="headerlink" title="棚改与拆迁"></a>棚改与拆迁</h3><p>如果拆迁后，拆一个房子盖10个房子供应市场，房价将下降，如果拆一个房子，供应也就增加一个房子，这个房子将被拆迁户买下，将导致房价暴涨。</p><h2 id="城市不缺土地建房子"><a href="#城市不缺土地建房子" class="headerlink" title="城市不缺土地建房子"></a>城市不缺土地建房子</h2><p>目前各大城市本质上不缺建房子的土地，土地都是充裕的，缺批准土地建房子。</p><h2 id="彩礼与结婚难问题"><a href="#彩礼与结婚难问题" class="headerlink" title="彩礼与结婚难问题"></a>彩礼与结婚难问题</h2><p>房子与结婚，结婚与女人，这都是绕不开的话题。<br>当前最紧张的供求关系有两个，一个是房屋供求，一个是男女供求失衡；<br>房屋供求的失衡导致畸形房价，尚且可通过租房来弥补；<br>但男女供求关系失衡，尤其是女人的供求关系失衡(如果有冒犯了女生，请多见谅)，问题就不好处理了；<br>男女性别失衡，致女人更加金贵，女人身价高了，将被整个社会宠坏，<br>也导致了家庭问题，道德伦理问题。<br>在可遇见的将来，其实当前已经显现，男女性别的失衡，道德伦理日益严重。</p>]]></content>
      
      
      <categories>
          
          <category> 技术之外 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>js设计模式上(面向对象、闭包、命名空间)</title>
      <link href="/2021/01/03/js_design_start/"/>
      <url>/2021/01/03/js_design_start/</url>
      
        <content type="html"><![CDATA[<p>js设计模式分两篇来写，此为上篇。下篇为《js设计模式下》。<br>js设计模式之前需要了解js的面向对象编程、闭包、命名空间编程模式的概念。</p><h1 id="js的面向对象编程"><a href="#js的面向对象编程" class="headerlink" title="js的面向对象编程"></a>js的面向对象编程</h1><p>注意，这里说的是js的面向对象编程，非java面向对象编程。js的面向对象编程与java是有区别的。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>js面向对象编程的核心概念是 类 和 实例(对象)。<br>类 在es6上就是 class类，在es5中就是构造函数中定义一系列的propoty原型<br>实例 就是 new class类，或者 new 构造函数。实例就是对象。<br>而定义类，最后实例化这个类，都是为了得到这个实例对象。重点最终是对象。这就是面向对象的编程。</p><p>简单说，js面向对象编程，就是熟悉使用 class类 来进行js编程。<br>由于react框架的流行，组件都是通过class类编程，因此熟练使用 js的面向对象编程变得更加重要。</p><p>注意的是，js的面向对象编程与java是有区别的。</p><h2 id="new-的理解"><a href="#new-的理解" class="headerlink" title="new 的理解"></a>new 的理解</h2><h3 id="关于new"><a href="#关于new" class="headerlink" title="关于new"></a>关于new</h3><p><a href="https://blog.csdn.net/zhouziyu2011/article/details/60143385" target="_blank" rel="noopener">关于new 的理解</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var baseObj = new Base();</span><br><span class="line">//new操作符具体干了什么呢?其实很简单，就干了三件事情：</span><br><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">var result = Base.call(obj);</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line"></span><br><span class="line">if (typeof(result) === &quot;object&quot;)&#123;</span><br><span class="line">  baseObj = result;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  baseObj = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是两个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Test = function()&#123;</span><br><span class="line">            this.html = 1111;</span><br><span class="line">            // return &#123;a:123&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          var obj = new Test()</span><br><span class="line">          console.log(obj) //&#123;html: 1111&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Test = function()&#123;</span><br><span class="line">            this.html = 1111;</span><br><span class="line">            return &#123;a:123&#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          var obj = new Test()</span><br><span class="line">          console.log(obj) //&#123;a: 123&#125;</span><br></pre></td></tr></table></figure><h3 id="new-Fn-与-new-Fn的区别"><a href="#new-Fn-与-new-Fn的区别" class="headerlink" title="new Fn() 与 new Fn的区别"></a>new Fn() 与 new Fn的区别</h3><p>function Fn(){<br>    this.name=’weide’;<br>}<br>console.log(new Fn) //Fn {name: “weide”}<br>console.log(new Fn()) //Fn {name: “weide”}<br>看起来二者没有区别，在构造函数Fn不用传参的时候，他们确实没有区别，只有当构造函数需要传参的时候，<br>才必须使用小括号：new Fn()</p><p>下面将讲 面向对象编程三大特征 多态，继承，封装</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>js的多态与java的面向对象多态不同。</p><p>js的多态定义：对同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。<br>以上通俗点的定义就是：对同一个函数作用于不同对象时（也就是同一个函数，接受不同的对象作为参数时），函数执行的结果不同。</p><p>列举多态的几个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//最简单的：</span><br><span class="line">var  a  =  5;</span><br><span class="line">console.log(a);</span><br><span class="line">a=&quot;str&quot;;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//最经典的：</span><br><span class="line">var makeSound = function(animal) &#123; // 把不变的部分隔离出来</span><br><span class="line">    animal.sound();</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">var Duck = function() &#123;&#125;;</span><br><span class="line">Duck.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&quot;嘎嘎嘎&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">var Chicken = function() &#123;&#125;;</span><br><span class="line">Chicken.prototype.sound = function() &#123;</span><br><span class="line">    console.log(&quot;咯咯咯&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">makeSound( new Duck() ); // 嘎嘎嘎</span><br><span class="line">makeSound( new Chicken() ); // 咯咯咯</span><br></pre></td></tr></table></figure><p>多态的思想实际上是把“做什么”和“谁去做”分离开来，达到 开放-封闭的设计原则。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型浅拷贝的痛点"><a href="#原型浅拷贝的痛点" class="headerlink" title="原型浅拷贝的痛点"></a>原型浅拷贝的痛点</h3><p>所有new实例将指向构造函数原型上的引用类型，造成浅拷贝问题，一个实例修改了此引用类型，其他所有实例受此影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function newF(o, constructor)&#123;</span><br><span class="line">    o.__proto__ = constructor.prototype;</span><br><span class="line">    constructor.call(o); </span><br><span class="line">&#125;</span><br><span class="line">var aa = &#123;&#125;;</span><br><span class="line">var bb = &#123;&#125;;</span><br><span class="line">newF(aa, Super);</span><br><span class="line">newF(bb, Super);</span><br><span class="line">console.log(aa.apples === bb.apples)//true</span><br><span class="line">console.log(aa.colors === bb.colors)//false</span><br></pre></td></tr></table></figure></p><p>以上过程代码等效于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var aa = new Super();</span><br><span class="line">var bb = new Super();</span><br><span class="line">console.log(aa.apples === bb.apples)//true</span><br><span class="line">console.log(aa.colors === bb.colors)//false</span><br></pre></td></tr></table></figure></p><p>以上说明了，构造函数 new出来的所有实例，他们会针对同一个构造函数prototype对象被赋值，如果prototype对象里面有引用类型，那么将相互影响，结合上面代码，这情况等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Super.prototype = &#123;apples:&#123;&#125;&#125;;</span><br><span class="line">aa.__proto__ = Super.prototype </span><br><span class="line">//等同于</span><br><span class="line">aa.apples = Super.prototype.apples</span><br></pre></td></tr></table></figure></p><h3 id="es5继承"><a href="#es5继承" class="headerlink" title="es5继承"></a>es5继承</h3><h4 id="套路"><a href="#套路" class="headerlink" title="套路"></a>套路</h4><p>es5继承方法有类继承和原型继承，我们不用去管他们叫什么名字和概念是什么，他们的套路无非三种：<br>1、代理函数(proxy)的构造函数内让父构造函数call一次，就会重写覆盖父构造函数内属性，以此来避免浅拷贝问题。<br>2、将父函数的new 实例对象 赋值给代理函数的prototype。<br>3、将父函数的prototype 赋值给代理函数的prototype。</p><h4 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h4><p>通过以上套路，大致有以下两种方式实现继承：<br>方式一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//方式一，将父函数的new 实例对象 赋值给代理函数的prototype，弊端 会执行两次父函数</span><br><span class="line"> function Super()&#123;</span><br><span class="line">    this.colors = [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function proxy()&#123;</span><br><span class="line">    //执行一次父函数Super</span><br><span class="line">     Super.call(this);</span><br><span class="line">&#125;</span><br><span class="line">//方式一 proxy.prototype直接赋值 new 构造函数</span><br><span class="line">proxy.prototype = new Super();//执行第二次父函数Super</span><br><span class="line">var aa = new proxy();//次步代码 会 重写覆盖父构造函数内属性</span><br><span class="line">var bb = new proxy();</span><br><span class="line">console.log(aa.colors === bb.colors)//true</span><br></pre></td></tr></table></figure></p><p>方式二、此方式与方式一一样，其他代码与方式一都一样，只有一句不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方式二，相比方式二的好处在于 父函数 只执行一遍</span><br><span class="line"> ...</span><br><span class="line">proxy.prototype = Super.prototype</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h4><p>以上方式都无法解决 prototype 对象的 浅拷贝问题。原因见 《所有new实例将浅拷贝原型上的引用类型 》</p><h4 id="es5最佳继承方式一：与深拷贝函数结合"><a href="#es5最佳继承方式一：与深拷贝函数结合" class="headerlink" title="es5最佳继承方式一：与深拷贝函数结合"></a>es5最佳继承方式一：与深拷贝函数结合</h4><p>传统的继承方式都无法解决prototype的浅拷贝问题，只能引入深拷贝函数，如下代码的deepcopy深拷贝方法，网上有很多，可以去找。<br>所以es5方法写继承最佳方式：父函数.call + proxy.prototype = deepcopy(Super.prototype).<br>简言之 call + 原型赋原型 + 深拷贝<br>作用：<br>call 拷贝 构造函数内属性<br>原型赋原型 拷贝原型方法，避免执行一次父函数<br>深拷贝 避免原型浅拷贝问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Super(name)&#123;</span><br><span class="line">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.apples = &#123;&#125;;</span><br><span class="line">function Sub(name)&#123;</span><br><span class="line">    Super.call(this);</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = deepcopy(Super.prototype);</span><br></pre></td></tr></table></figure><h4 id="es5最佳继承方式二：引用对象不写入父原型上"><a href="#es5最佳继承方式二：引用对象不写入父原型上" class="headerlink" title="es5最佳继承方式二：引用对象不写入父原型上"></a>es5最佳继承方式二：引用对象不写入父原型上</h4><p>es5继承的痛点是无法原型浅拷贝问题，如果能引用对象不写入父原型上，则可放心继承。</p><h3 id="最终极方式：es6-class"><a href="#最终极方式：es6-class" class="headerlink" title="最终极方式：es6 class"></a>最终极方式：es6 class</h3><p>class是es6 的api，是一个语法糖，使用class进行继承，能够轻松进行继承，且无浅拷贝问题。<br>因此推荐使用es6的class类继承方式，代码优雅而简洁，不推荐使用es5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Super &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.colors = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Sub extends Super&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new Sub();</span><br><span class="line">var instance2 = new Sub();</span><br><span class="line">console.log(instance1.colors === instance2.colors);//false</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装这个最好理解，直白的说就是：<br>封装说的就类。类由一系列的方法和属性组成，将一系列的方法和属性封装起来，封装成一个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123;</span><br><span class="line">        alert(`$&#123;this.name&#125; eat something`)</span><br><span class="line">    &#125;</span><br><span class="line">    speak() &#123;</span><br><span class="line">        alert(`My name is $&#123;this.name&#125;, age $&#123;this.age&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><a href="https://blog.csdn.net/ybdt1201/article/details/53366613" target="_blank" rel="noopener">关于闭包详细知识，可参考我在几年前写的一篇博客，这里只摘取一些必要知识</a>，以下内容基本摘至这篇博客，如有疑问，点击进入了解。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>官方对闭包的定义：所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p><p>还有一种对闭包更直接明了的说法：<a href="https://www.cnblogs.com/tinkbell/p/3173293.html" target="_blank" rel="noopener">闭包就是有权访问另一个函数作用域中变量的函数。</a><br>分析这句话:<br>　　1.闭包是定义在函数中的函数.<br>　　2.闭包能访问函数内的私有变量.<br>　　3.即使包含函数执行完了, 被闭包引用的变量也得不到释放.</p><p>满足以上定义的，都可称之为闭包。</p><h2 id="三种定义方式"><a href="#三种定义方式" class="headerlink" title="三种定义方式"></a>三种定义方式</h2><p>闭包有三种定义方式，一种就是经典的return方式，一种就是new的方式，一种就是对象方式。<br>我目前看到的闭包就这三种，基本这三种满足了工作中绝大部分需求了。<br>网上有很多人列举了很多闭包方式，其实本质上都是对这三种方式的发展延伸而已。</p><h3 id="return方式"><a href="#return方式" class="headerlink" title="return方式"></a>return方式</h3><p>这种方式最经典，也最为常用，推荐这种写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    var num = 1;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        num++;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new-方式"><a href="#new-方式" class="headerlink" title="new 方式"></a>new 方式</h3><p>这种方式之所以被认定为闭包，是因为以下两点理由，下面代码中：<br>1、a是母函数<br>2、inc是a执行后返回，相当于return的函数，此函数绑定了a的私有变量n， 这是决定inc是否为闭包的重要依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">  var n = 0;</span><br><span class="line">  this.inc = function () &#123;</span><br><span class="line">    n++;</span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var cc = new a();</span><br><span class="line">cc.inc()//1</span><br><span class="line">cc.inc()//2</span><br></pre></td></tr></table></figure></p><h3 id="对象方式"><a href="#对象方式" class="headerlink" title="对象方式"></a>对象方式</h3><p>下面两个闭包例子，套路都一样，外层定义个对象，然后在母函数内部给这个对象定义一个函数，此函数绑定了私有变量，即为闭包函数。<br>我们姑且称这种定义闭包的方式为对象方式吧。<br>以下方式之所以被认定为闭包，是因为以下两点理由，下面代码中：<br>1、有母函数（下面两个例子母函数是匿名函数，当然也可以定义为非匿名函数）<br>2、母函数执行后，给函数绑定了母函数的私有变量n， 这是决定内部函数是否为闭包的重要依据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">(function() &#123;</span><br><span class="line">    var n = 1;</span><br><span class="line">    obj.count = function () &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    console.log(n);</span><br><span class="line">                 &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br><span class="line">obj.count();//2</span><br><span class="line">obj.count();//3</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var divDom = $(&apos;#name&apos;);</span><br><span class="line">(function() &#123;</span><br><span class="line">    var n = 1;</span><br><span class="line">    divDom.onclick = function () &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                    console.log(n);</span><br><span class="line">                 &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br><span class="line">divDom.onclick();//2</span><br><span class="line">divDom.onclick();//3</span><br></pre></td></tr></table></figure><h2 id="不是闭包的设计"><a href="#不是闭包的设计" class="headerlink" title="不是闭包的设计"></a>不是闭包的设计</h2><p>列举一下非闭包的设计方式，以此加深对闭包的理解<br>很多人认为自运行匿名函数、命名空间设计模式和原型定义方式都是闭包，我觉得是不对的。</p><h3 id="自运行匿名函数："><a href="#自运行匿名函数：" class="headerlink" title="自运行匿名函数："></a>自运行匿名函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包</span><br><span class="line">(function fn()&#123;</span><br><span class="line">          var n = 8;</span><br><span class="line">           console.log(n) ;</span><br><span class="line">      &#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这一种是闭包的设计，但并不是因为它是自运行匿名函数的原因，而是因为匿名函数内部return了一个函数的原因，</span><br><span class="line">//这其实就是上面讲的两种闭包设计模式的第一种 return方式</span><br><span class="line">(function fn()&#123;</span><br><span class="line">      var n = 8;</span><br><span class="line">      return function()&#123;</span><br><span class="line">          console.log(n) ;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure><h3 id="js的命名空间写法"><a href="#js的命名空间写法" class="headerlink" title="js的命名空间写法"></a>js的命名空间写法</h3><p>js的命名空间写法不能称之为闭包，它最多是使用了js关于引用对象一处改变，都受改变的特性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这是命名空间的写法，但不是闭包</span><br><span class="line">var obj = &#123;</span><br><span class="line">  n:8,</span><br><span class="line">  count:function()&#123;</span><br><span class="line">    this.n++;</span><br><span class="line">    console.log(this.n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.count()//9</span><br><span class="line">obj.count()//10</span><br></pre></td></tr></table></figure></p><h3 id="原型定义方式"><a href="#原型定义方式" class="headerlink" title="原型定义方式"></a>原型定义方式</h3><p>还有一些把函数定义在原型上，这本质上也是运用了引用对象的特性，不是闭包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包，是运用了引用对象的特性，才有对象元素值叠加的效果</span><br><span class="line">function a()&#123;</span><br><span class="line">  this.n = 8;</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.count=function()&#123;</span><br><span class="line">  this.n++;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line">var obj = new a();</span><br><span class="line">obj.count()//9</span><br><span class="line">obj.count()//10</span><br></pre></td></tr></table></figure></p><p> 如果稍微换一下，就行不通了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//这不是闭包</span><br><span class="line">function a()&#123;</span><br><span class="line">  this.n = 8;</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.count=function()&#123;</span><br><span class="line">  this.n++;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line">var newCount = (new a()).count;</span><br><span class="line">newCount()//NaN</span><br><span class="line">newCount()//NaN</span><br></pre></td></tr></table></figure></p><h2 id="闭包的用处"><a href="#闭包的用处" class="headerlink" title="闭包的用处"></a>闭包的用处</h2><h3 id="定义私有变量"><a href="#定义私有变量" class="headerlink" title="定义私有变量"></a>定义私有变量</h3><p>若不想某些变量被其他函数访问，就可以写一个闭包设计，将变量定义为私有变量，只有闭包函数可以访问，达到其他函数无法访问的目的。</p><h3 id="保存变量值"><a href="#保存变量值" class="headerlink" title="保存变量值"></a>保存变量值</h3><p>这是闭包最经典和关键意义所在，也是闭包函数存在的意义。闭包函数绑定了母函数的变量，每次执行完，此变量不销毁，达到保存变量值的目的。</p><h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><h3 id="保存变量值。"><a href="#保存变量值。" class="headerlink" title="保存变量值。"></a>保存变量值。</h3><h3 id="进行前后两次执行时的比较。"><a href="#进行前后两次执行时的比较。" class="headerlink" title="进行前后两次执行时的比较。"></a>进行前后两次执行时的比较。</h3><h4 id="react-redux的props状态比较"><a href="#react-redux的props状态比较" class="headerlink" title="react-redux的props状态比较"></a>react-redux的props状态比较</h4><p>比如react-redux就是通过闭包的这个特性，保存prop上一次状态，然后跟当前props比较。</p><h4 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h4><p>这是性能优化经常使用的手段，可以网上查阅，都是用闭包来进行。</p><h4 id="for循环的使用"><a href="#for循环的使用" class="headerlink" title="for循环的使用"></a>for循环的使用</h4><p>错误写法，这种for达不到预期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//错误写法</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(let i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//2</span><br></pre></td></tr></table></figure></p><p>为什么是2？<br>如下当for循环中定义的变量i，不光是for循环体内的变量，还是foo函数体内的块级变量，当for循环执行完后，会将函数体内的变量i赋值为2，此时调用函数，肯定打印为2.<br>for循环体内：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)<span class="comment">//2</span></span><br><span class="line">test();<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><p>正确写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//正确写法</span><br><span class="line">//为什么能记住当时值，是因为是自运行的函数，每次都会执行一次</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = (function fn(j)&#123;</span><br><span class="line">            return function test()&#123;</span><br><span class="line">                return j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//0</span><br></pre></td></tr></table></figure></p><p>换一种写法，可能更容易理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//正确写法</span><br><span class="line">function foo()&#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for(var i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">        arr[i] = (function fn(j)&#123;</span><br><span class="line">            var _j = j;//定义一个变量，更容易理解</span><br><span class="line">            return function test()&#123;</span><br><span class="line">                return _j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">var bar = foo();</span><br><span class="line">console.log(bar[0]());//0</span><br></pre></td></tr></table></figure></p><h2 id="对闭包的误解"><a href="#对闭包的误解" class="headerlink" title="对闭包的误解"></a>对闭包的误解</h2><p>很多人认为闭包会增加内存，导致内存泄漏，这是错误的，是对闭包的误解。<br>如果你不把变量定义为闭包访问的私有变量，你也一定会把这些变量定义在全局作用域上，全局作用上下文也是不销毁的，一样也是增加了内存。<br>所以闭包并没有增加内存，更没有内存泄漏。<br>如果增加了内存和内存泄漏，其实都是编码水平有待提高导致。</p><h1 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h1><p>js使用命名空间模式设计，主要是为了避免命名冲突。<br>命名空间设计模式有很多，工作中最常用的是 对象字面量表示法 的设计模式。其他命名空间模式，我觉得应该用的不多，知道一下即可，这里不展开，可以网上查，<a href="https://www.cnblogs.com/syfwhu/p/4885628.html" target="_blank" rel="noopener">也可参考此篇文章</a>。</p><h2 id="对象字面量表示法"><a href="#对象字面量表示法" class="headerlink" title="对象字面量表示法"></a>对象字面量表示法</h2><p>对象字面量表示法是命名空间设计模式的一种，用得最广，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//对象字面量表示法 的命名空间设计模式</span><br><span class="line">var myApplication = &#123;</span><br><span class="line">    // 可以很容易的为对象字面量定义功能</span><br><span class="line">    getInfo:function() &#123;</span><br><span class="line">        // ***</span><br><span class="line">    &#125;,</span><br><span class="line">    // 可以进一步支撑对象命名空间</span><br><span class="line">    models:&#123;&#125;,</span><br><span class="line">    views:&#123;</span><br><span class="line">        pages:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    collections:&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="命名空间与设计模式区别"><a href="#命名空间与设计模式区别" class="headerlink" title="命名空间与设计模式区别"></a>命名空间与设计模式区别</h2><p>很多人命名空间的设计模式，是js 单例的设计模式，其实二者完全是两样东西。<br>命名空间偏向于是一种编程规范的设计；<br>js的一些设计模式，例如单例、观察者模式，更多的偏向功能实现方案的js设计模式。如设计绑定和监听时，选择观察者设计模式。<br>所以说，命名空间是一种编程规范，设计模式(如单例，以下设计模式都为这种含义)是一种功能实现的设计方案。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js设计模式 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> 命名空间 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mongoose 与 mongodb笔记</title>
      <link href="/2021/01/03/mongoose_mongodb/"/>
      <url>/2021/01/03/mongoose_mongodb/</url>
      
        <content type="html"><![CDATA[<p>关于 mongoose 与 mongodb笔记 暂时以问答方式叙述。</p><h2 id="mongoose-与-mongodb-基本知识"><a href="#mongoose-与-mongodb-基本知识" class="headerlink" title="mongoose 与 mongodb 基本知识"></a>mongoose 与 mongodb 基本知识</h2><h3 id="什么是mongodb服务端和客户端"><a href="#什么是mongodb服务端和客户端" class="headerlink" title="什么是mongodb服务端和客户端"></a>什么是mongodb服务端和客户端</h3><p>启动mongodb服务端，cmd命令为 mongod；这表明在电脑上启动了mongodb服务，启动了mongodb服务端；<br>启动mongodb客户端，cmd命令为 mongo；此命令执行后，cmd处于输入状态，可以对数据库进行增删改查；<br>以上两面命令 都基于mongodb安装目录(C:\Program Files\MongoDB\Server\4.0\bin)下的mongod.exe和mongo.exe；</p><h3 id="在哪些目录下执行mongo等命令才能连接数据库"><a href="#在哪些目录下执行mongo等命令才能连接数据库" class="headerlink" title="在哪些目录下执行mongo等命令才能连接数据库?"></a>在哪些目录下执行mongo等命令才能连接数据库?</h3><p>启动mongodb有两层意思，一个是启动mongodb服务器，一个是启动mongodb的客户端mongo。<br>上面两个动作没有目录限制，这个命令是全局的，在任意目录上都启动cmd都可以操作MongoDB数据库。<br>整个电脑，任何项目创建的数据库，都可以通过任意目录下，启动<br>cmd都可以查到，并且对数据库进行增删改查操作。</p><h3 id="启动mongodb-以及数据库、表格的查看"><a href="#启动mongodb-以及数据库、表格的查看" class="headerlink" title="启动mongodb 以及数据库、表格的查看"></a>启动mongodb 以及数据库、表格的查看</h3><p>主要为两个命令：<br>mongod //启动mongod 服务器，这是一切操作数据库的基础准备工作<br>mongo //启动mongodb客户端，用来连接mongodb并进行相关数据的查询<br>具体步骤如下：</p><h4 id="在任意目录下启动cmd-执行-mongod"><a href="#在任意目录下启动cmd-执行-mongod" class="headerlink" title="在任意目录下启动cmd 执行 mongod;"></a>在任意目录下启动cmd 执行 mongod;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ mongod</span><br><span class="line">2019-03-24T11:25:33.479+0800 I CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols &apos;none&apos;</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] MongoDB starting : pid=8380 port=27017 dbpath=C:\data\db\ 64-bit host=UO4SB7YL9WOZ3OK</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] targetMinOS: Windows 7/Windows Server 2008 R2</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] db version v4.0.6</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] git version: caa42a1f75a56c7643d0b68d3880444375ec42e3</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] allocator: tcmalloc</span><br><span class="line">2019-03-24T11:25:33.483+0800 I CONTROL  [initandlisten] modules: none</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten] build environment:</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten]     distmod: 2008plus-ssl</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten]     distarch: x86_64</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten]     target_arch: x86_64</span><br><span class="line">2019-03-24T11:25:33.484+0800 I CONTROL  [initandlisten] options: &#123;&#125;</span><br><span class="line">2019-03-24T11:25:33.486+0800 I STORAGE  [initandlisten] exception in initAndListen: NonExistentPath: Data directory C:\data\db\ not found., terminating</span><br><span class="line">2019-03-24T11:25:33.486+0800 I NETWORK  [initandlisten] shutdown: going to close listening sockets...</span><br><span class="line">2019-03-24T11:25:33.486+0800 I CONTROL  [initandlisten] now exiting</span><br><span class="line">2019-03-24T11:25:33.486+0800 I CONTROL  [initandlisten] shutting down with code:100</span><br></pre></td></tr></table></figure><h4 id="接着执行-mongo；"><a href="#接着执行-mongo；" class="headerlink" title="接着执行 mongo；"></a>接着执行 mongo；</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v4.0.6</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;4f84c125-8db8-4d3a-ad61-5c85b2817fb7&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.0.6</span><br></pre></td></tr></table></figure><p>此时命令窗口处于等待输入命令的状态，就像输入node后，等待执行的情况。</p><h4 id="数据库、表格的查看；"><a href="#数据库、表格的查看；" class="headerlink" title="数据库、表格的查看；"></a>数据库、表格的查看；</h4><p>此时在此cmd窗口，接着输入以下命令，对数据库进行增删改查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v4.0.6</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;4f84c125-8db8-4d3a-ad61-5c85b2817fb7&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.0.6</span><br><span class="line">show dbs  //显示MongoDB目前有多少数据库</span><br><span class="line">admin           0.000GB</span><br><span class="line">config          0.000GB</span><br><span class="line">douban-test     0.000GB</span><br><span class="line">douban-trailer  0.000GB</span><br><span class="line">local           0.000GB</span><br><span class="line">test            0.000GB</span><br><span class="line">yyy             0.000GB</span><br><span class="line">use yyy //使用yyy数据库，use 数据库name，有此name就是用此数据库，没有就是创建数据库</span><br><span class="line">switched to db yyy</span><br><span class="line">show tables //显示数据库有多少表格</span><br><span class="line">fruits</span><br><span class="line">db.fruits.find() //显示 fruits 表格的数据内容</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5c964dbe52f3fd21d06da3a0&quot;), &quot;category&quot; : &quot;apple&quot;, &quot;name&quot; : &quot;apple&quot;, &quot;__v&quot; : 0 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5c964dca541443051483e3c8&quot;), &quot;category&quot; : &quot;apple&quot;, &quot;name&quot; : &quot;apple&quot;, &quot;__v&quot; : 0 &#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/shirly77/p/6536327.html" target="_blank" rel="noopener">更多信息点击</a></p><h3 id="用mongodb原生命令还是mongoose操作数据库？"><a href="#用mongodb原生命令还是mongoose操作数据库？" class="headerlink" title="用mongodb原生命令还是mongoose操作数据库？"></a>用mongodb原生命令还是mongoose操作数据库？</h3><p>在这里只讨论node端。<br>值得注意的是，我们大多不通过mongodb原生命令操作数据库，而是通过mongoose；<br>一个是mongoose 更能优雅地进行MongoDB对象建模，<br>而且Mongoose写了很多mongodb的验证机制、类型转换与业务逻辑模板，然后提供几个简单的api给我们，简化了工作，等等。<br>因此在实际项目开发中，包括连接数据库以及之后的所有操作都是通过mongoose来操作。<br>因此建议不用太去花太多时间去看mongodb的api教程，稍微了解下即可，然后多看看mongoose的相关操作。</p><h3 id="花更多时间学mongodb还是mongoose教程？"><a href="#花更多时间学mongodb还是mongoose教程？" class="headerlink" title="花更多时间学mongodb还是mongoose教程？"></a>花更多时间学mongodb还是mongoose教程？</h3><p>请参看《用mongodb原生命令还是mongoose操作数据库？》。</p><h3 id="要不要手动建文件夹目录data-db？"><a href="#要不要手动建文件夹目录data-db？" class="headerlink" title="要不要手动建文件夹目录data\db？"></a>要不要手动建文件夹目录data\db？</h3><p>我在刚接触 mongodb时，以为启动mongodb要建文件夹目录，用来存放数据库数据，其实不必了。<br>只要在cmd上启动好mongodb服务器就好，其他的就交给项目使用mongoose来操作mongodb就好。<br>不要创建什么数据库文件夹目录。</p><h3 id="经典demo-创建数据库、表格和数据"><a href="#经典demo-创建数据库、表格和数据" class="headerlink" title="经典demo-创建数据库、表格和数据"></a>经典demo-创建数据库、表格和数据</h3><h4 id="demo-代码"><a href="#demo-代码" class="headerlink" title="demo 代码"></a>demo 代码</h4><p>启动mongodb后，在任意目录下，使用node 执行如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">//mongoose.connect 连接mongodb服务器中的数据库，newdbName是数据库名，有则连，无此name数据，就创建</span><br><span class="line">mongoose.connect(&apos;mongodb://localhost:27017/newdbName&apos;,&#123;</span><br><span class="line">    useNewUrlParser:true</span><br><span class="line">&#125;);</span><br><span class="line">//Schema 定义表格Field的类型和规则，这个过程称为 建数据模型</span><br><span class="line">var schema = new mongoose.Schema(&#123; name: &apos;string&apos;, size: &apos;string&apos; &#125;);</span><br><span class="line">//Model 将Schema定义的模型继承过来，生成表格tables,这里生成的名字为 Tank，在数据库中表格名是复数，见《的解释》</span><br><span class="line">var Model = mongoose.model(&apos;Tank&apos;, schema);</span><br><span class="line">//new Model()此方法用来表格数据的增删改查,</span><br><span class="line">var small = new Model(&#123; size: &apos;small&apos; &#125;);</span><br><span class="line">small.save(function (err) &#123;</span><br><span class="line">  if (err) return handleError(err);</span><br><span class="line">  console.log(&apos;创建成功&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="mongodb客户端mongo检测是否生成成功"><a href="#mongodb客户端mongo检测是否生成成功" class="headerlink" title="mongodb客户端mongo检测是否生成成功"></a>mongodb客户端mongo检测是否生成成功</h4><p>将以上代码复制到js中，然后 node 该js试试，如果出现创建成功；<br>然后任意目录下 启动cmd，打开mongodb客户端，查看newdbName数据库是否生成，以下是正常生成的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Administrator@UO4SB7YL9WOZ3OK MINGW64 ~/Desktop</span><br><span class="line">$ mongo</span><br><span class="line">MongoDB shell version v4.0.6</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb</span><br><span class="line">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;a6d3c14e-703d-44d8-851f-60dbb5ad2b9e&quot;) &#125;</span><br><span class="line">MongoDB server version: 4.0.6</span><br><span class="line">show dbs</span><br><span class="line">admin           0.000GB</span><br><span class="line">config          0.000GB</span><br><span class="line">douban-test     0.000GB</span><br><span class="line">douban-trailer  0.000GB</span><br><span class="line">local           0.000GB</span><br><span class="line">newdbName       0.000GB</span><br><span class="line">onedb           0.000GB</span><br><span class="line">test            0.000GB</span><br><span class="line">twodb           0.000GB</span><br><span class="line">yyy             0.000GB</span><br><span class="line">use newdbName</span><br><span class="line">switched to db newdbName</span><br><span class="line">show tables</span><br><span class="line">tanks</span><br><span class="line">db.tanks.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5c974d5df84c0d2b9450f43c&quot;), &quot;size&quot; : &quot;small&quot;, &quot;__v&quot; : 0 &#125;</span><br></pre></td></tr></table></figure><h3 id="mongodb、mongoose概念"><a href="#mongodb、mongoose概念" class="headerlink" title="mongodb、mongoose概念"></a>mongodb、mongoose概念</h3><p>本节内容参考如下，如有疑问点击如下连接详细了解。<br><a href="https://www.cnblogs.com/chris-oil/p/9142795.html" target="_blank" rel="noopener">参考1</a><br><a href="http://www.runoob.com/mongodb/mongodb-databases-documents-collections.html" target="_blank" rel="noopener">参考2</a></p><h4 id="mongodb-与-传统数据库-概念对比"><a href="#mongodb-与-传统数据库-概念对比" class="headerlink" title="mongodb 与 传统数据库 概念对比"></a>mongodb 与 传统数据库 概念对比</h4><figure class="image-box">                <img src="/image/mongodb/db.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="mongodb-、mongoose-与-传统数据库-概念对比"><a href="#mongodb-、mongoose-与-传统数据库-概念对比" class="headerlink" title="mongodb 、mongoose 与 传统数据库 概念对比"></a>mongodb 、mongoose 与 传统数据库 概念对比</h4><p>结合 《经典创建数据库、添加表格和数据 demo》一起看<br><figure class="image-box">                <img src="/image/mongodb/mongoose.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="mongoose核心概念-与-数据库知识-对应关系"><a href="#mongoose核心概念-与-数据库知识-对应关系" class="headerlink" title="mongoose核心概念 与 数据库知识 对应关系"></a>mongoose核心概念 与 数据库知识 对应关系</h4><p>结合 《经典创建数据库、添加表格和数据 demo》一起看<br><figure class="image-box">                <img src="/image/mongodb/index.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>mongodb中说的集合，其实就是tables，通过model生成；</li><li>mongodb中说的文档，其实就是tables的行数据，通过model实例生成；</li><li>mongoose的重点在Schema和model，其实与数据直接打交道最多的是model；</li><li>至于生成或连接数据库，就是mongoose.connect方法。</li></ul><h3 id="mongoose-model第一个参数的复数才是tables名字！！"><a href="#mongoose-model第一个参数的复数才是tables名字！！" class="headerlink" title="mongoose.model第一个参数的复数才是tables名字！！"></a>mongoose.model第一个参数的复数才是tables名字！！</h3><p>mongoose.model(abc,oneSchema)定义的第一个参数abc,abc并非tables表格名字,它的复数才是，数据库中的表格名字是abces。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let Model = mongoose.model(&quot;fruit&quot;,Schema);</span><br><span class="line">let apple = new Model(&#123;</span><br><span class="line">        category:&apos;apple&apos;,</span><br><span class="line">        name:&apos;apple&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">apple.save()</span><br><span class="line"></span><br><span class="line">cmd中执行命令：</span><br><span class="line">show tables，</span><br><span class="line">名字是fruits,非 fruit。</span><br></pre></td></tr></table></figure></p><h3 id="创建或连接数据库"><a href="#创建或连接数据库" class="headerlink" title="创建或连接数据库"></a>创建或连接数据库</h3><p>创建和连接数据库一般通过mongoose，用的命令都是mongoose.connect。</p><p>在任意目录cmd，然后执行如下命令，看到mongodb服务器中有数据库twodb；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line">show dbs</span><br><span class="line">admin           0.000GB</span><br><span class="line">config          0.000GB</span><br><span class="line">local           0.000GB</span><br><span class="line">newdbName       0.000GB</span><br><span class="line">onedb           0.000GB</span><br><span class="line">test            0.000GB</span><br><span class="line">twodb           0.000GB</span><br></pre></td></tr></table></figure></p><p>例如我现在要连接 数据库twodb，步骤如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(&apos;mongodb://localhost:27017/twodb&apos;,&#123;</span><br><span class="line">    useNewUrlParser:true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上，mongodb://localhost:27017/ 这是默认写法，twodb是数据库写法，<br>当twodb这个数据库在mongodb存在时，就连接此数据库，当不存在时，就是创建名为twodb的数据库。</p><h3 id="mongodb-localhost-27017-dbName"><a href="#mongodb-localhost-27017-dbName" class="headerlink" title="mongodb://localhost:27017/dbName"></a>mongodb://localhost:27017/dbName</h3><p>我们如果要连接dbName数据库，为什么mongoose.connect的时候，却要写成mongodb://localhost:27017/twodb;<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(&apos;mongodb://localhost:27017/twodb&apos;)</span><br></pre></td></tr></table></figure></p><p>那么为什么要这样呢。<br><strong>原来这是mongodb的标准 URI 连接语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</span><br></pre></td></tr></table></figure><ul><li>mongodb:// 这是固定的格式，必须要指定。</li><li>username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库</li><li>host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。</li><li>portX 可选的指定端口，如果不填，默认为27017</li><li>/database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。</li><li>?options 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&amp;或;（分号）隔开<br>这里就不展开了，<a href="http://www.runoob.com/mongodb/mongodb-connections.html" target="_blank" rel="noopener">更详细的请点击这里了解</a>。</li></ul><p>一般使用mongoose.connect(‘mongodb://localhost:27017/twodb’)连接即可。</p><h3 id="mongodb目录"><a href="#mongodb目录" class="headerlink" title="mongodb目录"></a>mongodb目录</h3><p>C:\Program Files\MongoDB\Server\4.0\bin</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/chris-oil/p/9142795.html" target="_blank" rel="noopener">深入浅出mongoose—–包括mongoose基本所有操作,非常实用!!!!!</a><br><a href="https://www.cnblogs.com/shirly77/p/6536327.html" target="_blank" rel="noopener">mongodb 怎样检测 安装成功 以及mongodb的一些增删改查命令</a><br><a href="http://www.runoob.com/mongodb/mongodb-query.html" target="_blank" rel="noopener">MongoDB 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongoose </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react中的表单处理</title>
      <link href="/2021/01/03/react_form/"/>
      <url>/2021/01/03/react_form/</url>
      
        <content type="html"><![CDATA[<h2 id="不封装form可以吗"><a href="#不封装form可以吗" class="headerlink" title="不封装form可以吗"></a>不封装form可以吗</h2><p>很多人第一印象觉得有UI框架如ant-design，或者bootstrap，就不需要二次封装form了，其实不然。<br>如果不封装form，你只有一个UI库给你，你引入input select 等组件后，<br>需要自己做以下事情：</p><ul><li>每个filed写value onChange</li><li>要写validate</li><li>要写样式</li><li>要写 submit 逻辑，如果是pop，还要写hide close；</li></ul><p>上面这些，就算你咬着牙写完了一个表单，下一个表单你一切还得重新来，因此为项目二次封装抽象这些公共逻辑势在必行。<br>说得直白点，你还要抽象form的一些公共逻辑，封装得越好，项目开发起来就越爽，越快。<br>要想抽象form的公共逻辑，那么你必须要深刻认识form。</p><h2 id="认识form很重要"><a href="#认识form很重要" class="headerlink" title="认识form很重要"></a>认识form很重要</h2><h3 id="每个filed都有value-onchange"><a href="#每个filed都有value-onchange" class="headerlink" title="每个filed都有value onchange"></a>每个filed都有value onchange</h3><p>在form中，input，select，checkbox，等等，都包含了 value onchange 熟悉；<br>因此，可以为每个filed抽象出value、onchange逻辑；</p><h3 id="validate"><a href="#validate" class="headerlink" title="validate"></a>validate</h3><p>一般表单验证都是即时验证，也就是输入框实时输入时就要验证；<br>有些还要加一个提交时再验证，做一个双保险。</p><h3 id="validate的error信息显示"><a href="#validate的error信息显示" class="headerlink" title="validate的error信息显示"></a>validate的error信息显示</h3><p>这个跟validate基本属于同一个问题。</p><h3 id="实时form值"><a href="#实时form值" class="headerlink" title="实时form值"></a>实时form值</h3><p>要有一个公共的form值，实时反应各个field的值。</p><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>大多form都有一个reset功能</p><h2 id="设计模式很重要"><a href="#设计模式很重要" class="headerlink" title="设计模式很重要"></a>设计模式很重要</h2><p>每次field改变后，如何让form响应变动渲染最新的值呢。<br>一般有两种模式：将form定义为完全受控组件；让form存储自己的状态；</p><h3 id="将form定义为完全受控组件"><a href="#将form定义为完全受控组件" class="headerlink" title="将form定义为完全受控组件"></a>将form定义为完全受控组件</h3><p>这种设计模式是最直观的，给form定义一个value和onchange，form内任何一个filed改变时都触发这个onchange，这个onchange改变整个form值。<br>这种模式有个特点，它的value值是整个form值，因此是一个对象。</p><h3 id="让form存储自己的状态-推荐"><a href="#让form存储自己的状态-推荐" class="headerlink" title="让form存储自己的状态(推荐)"></a>让form存储自己的状态(推荐)</h3><h4 id="如何在父层获取form的state"><a href="#如何在父层获取form的state" class="headerlink" title="如何在父层获取form的state"></a>如何在父层获取form的state</h4><p>这种设计模式要求form维护自己的状态，首先我们想到的是，设置一个state，这个state包含了各个filed的值。但这样但花就有个问题在于在form的父层无法实时获取form值。</p><h4 id="改变state的同时，修改存储store"><a href="#改变state的同时，修改存储store" class="headerlink" title="改变state的同时，修改存储store"></a>改变state的同时，修改存储store</h4><p>解决之道在于定义一个公共的store，每次filed改变state值的时候，同时改变store。<br>form渲染使用state，外层提交使用store，而这个store由父层构造而来，那么内部渲染和外部数据使用都兼顾了。</p><h2 id="方案的实施"><a href="#方案的实施" class="headerlink" title="方案的实施"></a>方案的实施</h2><h3 id="选定方案–让form存储自己的状态"><a href="#选定方案–让form存储自己的状态" class="headerlink" title="选定方案–让form存储自己的状态"></a>选定方案–让form存储自己的状态</h3><p>我们一般选用上面的《让form存储自己的状态(推荐)》这种模式。<strong>下面的讲解都以此模式展开</strong>，<br><strong>本实施方案，参考博客<a href="https://zhuanlan.zhihu.com/p/57820186" target="_blank" rel="noopener"> React 实现高度简洁的 Form 组件 </a></strong>，以下如有疑问，可查阅此博客</p><h3 id="设计filed"><a href="#设计filed" class="headerlink" title="设计filed"></a>设计filed</h3><p>filed都由一个value 和 onchange，还有一个errortip，而value和errortip都是由onchange触发生成。<br>此时我们给filed传递一个预设的store，在store中有一个filed onchange 方法，我们叫做store.set，此方法每次都改变value和errortip值，同时将这些值存储到store中。</p><h3 id="即时验证"><a href="#即时验证" class="headerlink" title="即时验证"></a>即时验证</h3><p>见《设计filed》</p><h3 id="生成error-tip"><a href="#生成error-tip" class="headerlink" title="生成error tip"></a>生成error tip</h3><p>见《设计filed》</p><h3 id="预设store"><a href="#预设store" class="headerlink" title="预设store"></a>预设store</h3><p>上面说到了预设的store，在这个store中我们的主要任务是，实时改变store的value和error值，并暴露出相关API给上面的《设计filed》使用。由此可见，我们将validate 实时存储的逻辑抽象到了store中。</p><h3 id="如何传递store"><a href="#如何传递store" class="headerlink" title="如何传递store"></a>如何传递store</h3><p>上面看到了filed用到了store，如何将store传给filed呢，我们的做法是，在父层new 一个store，让这个store作为props传递给form，form拿到这个store设置为contex，form下面的所有组件都可以使用此context</p><h3 id="天花板式的第三方包与功能"><a href="#天花板式的第三方包与功能" class="headerlink" title="天花板式的第三方包与功能"></a>天花板式的第三方包与功能</h3><p>我们先分析下(让form存储自己的状态)的模式：</p><ul><li>为了让父层拿到实时的form值，我们必须在父层给构造一个store对象，用于存储form值；–天花板</li><li>store与from进行互动，以便存储值(把store对象传递给form，form在与store沟通时，将值顺利存储到store)；–第三方包与程序<br>上面的第一步，我们要在父层定义store，父层就是天花板，这个store就类似一个d3.js第三方包，form值的获取就好比用d3框架画出的各式各样的绘图，form必须遵守d3的API才能正确画图，这画出来的图就是做出来的功能。<br>(让form存储自己的状态)的模式他的设计思想 跟 天花板式的第三方包与功能及其相似。<br>你开发一个form框架，然后在filed中使用这个框架。<h3 id="为什么不把-store与filed直接结合一起"><a href="#为什么不把-store与filed直接结合一起" class="headerlink" title="为什么不把 store与filed直接结合一起"></a>为什么不把 store与filed直接结合一起</h3>为什么不把 store与filed直接结合一起，或者store集成到filed上，不用在父层传递store。<br>原因就是刚才说到的：为了让父层拿到实时的form值，我们必须在父层给构造一个store对象，用于存储form值。<h3 id="各个元素如何排版布局"><a href="#各个元素如何排版布局" class="headerlink" title="各个元素如何排版布局"></a>各个元素如何排版布局</h3>每个filed的html如下，因为html是固定的，因此可以统一制定好样式：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"form"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">label</span> <span class="attr">className</span>=<span class="string">"form__label"</span>&gt;</span>&#123;label&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"form__content"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"form__control"</span>&gt;</span>&#123;child&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"form__message"</span>&gt;</span>&#123;error&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="注入验证规则"><a href="#注入验证规则" class="headerlink" title="注入验证规则"></a>注入验证规则</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> FormStore(&#123;<span class="comment">/* 初始值 */</span>, &#123;</span><br><span class="line">  username: <span class="function">(<span class="params">val</span>) =&gt;</span> !!val.trim() || <span class="string">'用户名不能为空'</span>,</span><br><span class="line">  password: <span class="function">(<span class="params">val</span>) =&gt;</span> !!(val.length &gt; <span class="number">6</span> &amp;&amp; val.length &lt; <span class="number">18</span>) || <span class="string">'密码长度必须大于6个字符，小于18个字符'</span>,</span><br><span class="line">  passwordAgain: <span class="function">(<span class="params">val, vals</span>) =&gt;</span> val === vals.password || <span class="string">'两次输入密码不一致'</span></span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="未说细节"><a href="#未说细节" class="headerlink" title="未说细节"></a>未说细节</h3><p>将filed的onchange逻辑使用一个替身listen代替，采用（取消）订阅方式，执行此onchange等一系列动作。详见博客<a href="https://zhuanlan.zhihu.com/p/57820186" target="_blank" rel="noopener">React 实现高度简洁的 Form 组件 </a>。</p><h3 id="小结与代码"><a href="#小结与代码" class="headerlink" title="小结与代码"></a>小结与代码</h3><p>封装这个表单：</p><ul><li>要封装一个store，这一部分是纯js逻辑处理；</li><li>要封装一个公共的filed，以便抽取filed公共的逻辑到filed，这一部分采用组合模式设计；</li><li>要封装一个form，这个form要配合filed和父层的引用；<br>具体代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//store</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormStore</span> </span>&#123;</span><br><span class="line">  <span class="comment">// constructor ...</span></span><br><span class="line">  <span class="comment">// subscribe ...</span></span><br><span class="line">  <span class="comment">// notify ...</span></span><br><span class="line">  <span class="comment">// 获取表单值</span></span><br><span class="line">  get(name) &#123;</span><br><span class="line">    <span class="comment">// 如果传入name，返回对应的表单值，否则返回整个表单的值</span></span><br><span class="line">    <span class="keyword">return</span> name === <span class="literal">undefined</span> ? <span class="keyword">this</span>.values : <span class="keyword">this</span>.values[name];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置表单值</span></span><br><span class="line">  set(name, value) &#123;</span><br><span class="line">    <span class="comment">//如果指定了name</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="comment">// 设置name对应的值</span></span><br><span class="line">      <span class="keyword">this</span>.values[name] = value;</span><br><span class="line">      <span class="comment">// 执行表单校验，见下</span></span><br><span class="line">      <span class="keyword">this</span>.validate(name);</span><br><span class="line">      <span class="comment">// 通知表单变动</span></span><br><span class="line">      <span class="keyword">this</span>.notify(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量设置表单值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (name) &#123;</span><br><span class="line">      <span class="keyword">const</span> values = name;</span><br><span class="line">      <span class="built_in">Object</span>.keys(values).forEach(<span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">this</span>.set(key, values[key]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重置表单值</span></span><br><span class="line">  reset() &#123;</span><br><span class="line">    <span class="comment">// 清空错误信息</span></span><br><span class="line">    <span class="keyword">this</span>.errors = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 重置默认值</span></span><br><span class="line">    <span class="keyword">this</span>.values = deepCopy(<span class="keyword">this</span>.defaultValues);</span><br><span class="line">    <span class="comment">// 执行通知</span></span><br><span class="line">    <span class="keyword">this</span>.notify(<span class="string">"*"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filed</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValueFromEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> e &amp;&amp; e.target</span><br><span class="line">    ? e.target.type === <span class="string">"checkbox"</span></span><br><span class="line">      ? e.target.checked</span><br><span class="line">      : e.target.value</span><br><span class="line">    : e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Field</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; label, name, children &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到Form传下来的FormStore实例</span></span><br><span class="line">  <span class="keyword">const</span> store = React.useContext(FormStoreContext);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件内部状态，用于触发组件的重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(</span><br><span class="line">    name &amp;&amp; store ? store.get(name) : <span class="literal">undefined</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = React.useState(</span><br><span class="line">    name &amp;&amp; store ? store.error(name) : <span class="literal">undefined</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表单组件onChange事件，用于从事件中取得表单值</span></span><br><span class="line">  <span class="keyword">const</span> onChange = React.useCallback(</span><br><span class="line">    (...args) =&gt; name &amp;&amp; store &amp;&amp; store.set(name, valueGetter(...args)),</span><br><span class="line">    [name, store]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅表单数据变动</span></span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!name || !store) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> store.subscribe(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当前name的数据发生了变动，获取数据并重新渲染</span></span><br><span class="line">      <span class="keyword">if</span> (n === name || n === <span class="string">"*"</span>) &#123;</span><br><span class="line">        setValue(store.get(name));</span><br><span class="line">        setError(store.error(name));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [name, store]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> child = children;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果children是一个合法的组件，传入value和onChange</span></span><br><span class="line">  <span class="keyword">if</span> (name &amp;&amp; store &amp;&amp; React.isValidElement(child)) &#123;</span><br><span class="line">    <span class="keyword">const</span> childProps = &#123; value, onChange &#125;;</span><br><span class="line">    child = React.cloneElement(child, childProps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表单结构，具体的样式就不贴出来了</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"form"</span>&gt;</span><br><span class="line">      &lt;label className=<span class="string">"form__label"</span>&gt;&#123;label&#125;&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="form__content"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="form__control"&gt;&#123;child&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;div className=<span class="string">"form__message"</span>&gt;&#123;error&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//form</span></span><br><span class="line"><span class="keyword">const</span> FormStoreContext = React.createContext(<span class="literal">undefined</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; store, children, onSubmit &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FormStoreContext.Provider value=&#123;store&#125;&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;onSubmit&#125;&gt;&#123;children&#125;&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>FormStoreContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.store = <span class="keyword">new</span> FormStore();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">this</span>.store.get();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Form store=&#123;<span class="keyword">this</span>.store&#125; onSubmit=&#123;<span class="keyword">this</span>.onSubmit&#125;&gt;</span><br><span class="line">        &lt;Field name=<span class="string">"username"</span>&gt;</span><br><span class="line">          &lt;input /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Field&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Field name="password"&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input type="password" /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Field&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button&gt;Submit&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/Form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="优化与不足"><a href="#优化与不足" class="headerlink" title="优化与不足"></a>优化与不足</h3><p>本方案实施主要是针对 <a href="https://zhuanlan.zhihu.com/p/57820186" target="_blank" rel="noopener">React 实现高度简洁的 Form 组件 </a> 博客的解读。<br>我觉得这里有几块可以优化的，</p><h4 id="动态生成表单"><a href="#动态生成表单" class="headerlink" title="动态生成表单"></a>动态生成表单</h4><p>上面博客中，使用如下：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Field name=<span class="string">"password"</span> label=<span class="string">"密码"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"password"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/Field&gt;</span></span><br></pre></td></tr></table></figure></p><p>在filed中转化为：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div className=<span class="string">"form"</span>&gt;</span><br><span class="line">    &lt;label className=<span class="string">"form__label"</span>&gt;&#123;label&#125;&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div className="form__content"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="form__control"&gt;&#123;child&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"form__message"</span>&gt;&#123;error&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></p><p>因此filed只需要知道 name type label这三个信息，因此完全可以以json的方式传递给form，动态生成表单。</p><h4 id="联动、自定义-设计不足"><a href="#联动、自定义-设计不足" class="headerlink" title="联动、自定义 设计不足"></a>联动、自定义 设计不足</h4><p>通篇博客读下来，没看到对联动做的逻辑封装。</p><h2 id="动态表单"><a href="#动态表单" class="headerlink" title="动态表单"></a>动态表单</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>无论是传统的html方式使用form，还是配置化的生成表单方式，都是基于以上设计模式上的扩展。动态表单的优点在于，快捷生成表单，就好像使用json通过模版引擎批量生成表单一样，非常爽。<br>但是动态表单在设计上都有一个痛点在于 如何联动与自定义需求。</p><p>参考 另外两篇博客 《EnForm动态表单的使用》 《EnForm动态表单封装》</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> form </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EnForm动态表单封装</title>
      <link href="/2021/01/03/react_form_design/"/>
      <url>/2021/01/03/react_form_design/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次封装，利用的是工作之余，时间难免宝贵，主要注重功能实现，细节或代码风格没有太注重，请忽略之。</p><h2 id="状态提升的运用"><a href="#状态提升的运用" class="headerlink" title="状态提升的运用"></a>状态提升的运用</h2><p>市面上的form封装，基本套路都是，field设置为完全受控组件，将field状态提升至form。<br>这是form封装方案设计的关键第一步，如果将field设置为非受控组件，后期很多功能实现起来将比较麻烦。</p><p>很多人认为，这个状态提升，就应该是提升到form的state中，其实不然，这里又很多套路，自然也就有几种方案：</p><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>状态提升，状态全部存储于form的this内。而非form内的state。<br>每次field onchange时候，使用form的this，进行 this.forceupdate 或者 this.setState({});<br>方案代表 是阿里的的 <a href="https://github.com/alibaba-fusion/field" target="_blank" rel="noopener">fusion field</a>，源码不多，有兴趣可以去看看。<br>我倒是觉得 他们取field这个名字是有歧义的，看fiel的源码，你会发现，这个field更像一个form层面 的 store+field。</p><p>这种方案有些人或许会感觉比较怪，其实不然，react-redux 其实是这种方案的最佳实践着，有兴趣可以看看react-redux 源码中connect实现。<br>在connect中其实也是将状态存储于this中，而非state中，然后通过setState一个空值，触发render。</p><p>另外 对于 form封装时，设计一个form store 是一种普遍的设计方式。</p><h4 id="经典逻辑抽象分离的实践"><a href="#经典逻辑抽象分离的实践" class="headerlink" title="经典逻辑抽象分离的实践"></a>经典逻辑抽象分离的实践</h4><p><a href="https://github.com/alibaba-fusion/field" target="_blank" rel="noopener">fusion field</a>是经典的逻辑抽象分离实践，以后遇到逻辑抽离的时候，可以参考此源码的实现。<br>源码主要是订阅模式的一种经典实践。</p><h3 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h3><p>状态提升，将状态存储于this中，另外为了让form内的field能够取到状态，在form内设置了context，并将this内的state放置于context中，让所有的子元素包括field都能通过context获取状态。<br>核心源码不多，有兴趣可以看看。里面对<br><a href="https://github.com/alibaba-fusion/next/tree/master/src/form" target="_blank" rel="noopener">alibaba-fusion/next/form</a><br>里面用到了对于ReactFragment的判断这点还是挺好，可能是历史原因， fusion／form 必须要配合 上面的 fusion field使用，为了实现自由排列，源码当中大量使用了React.cloneElement来做props注入，在form内使用一次，在field内又使用一次，而且是遍历性质，React.cloneElement固然是一个非常棒的API，前后两次大量使用，感觉每次 field的onchange消耗还是挺多。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getNewChildren = <span class="function">(<span class="params">children, props</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> React.Children.map(children, child =&gt; &#123;</span><br><span class="line">      <span class="comment">//对于ReactFragment的判断</span></span><br><span class="line">        <span class="keyword">if</span> (obj.isReactFragment(child)) &#123;</span><br><span class="line">            <span class="keyword">return</span> getNewChildren(child.props.children, props);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            child &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> child.type === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">            child.type._typeMark === <span class="string">'form_item'</span></span><br><span class="line">        ) &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> React.cloneElement(child, pickerDefined(childrenProps));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="方案三：-EnForm使用方案"><a href="#方案三：-EnForm使用方案" class="headerlink" title="方案三：(EnForm使用方案)"></a>方案三：(EnForm使用方案)</h3><p>状态提升，将状态存储于state内，为了兼容自由排列，当form使用自由排列模式时，对form做context，将form的state放置于context中传递给field。<br>这是我本次form封装的方案，因为一开始就是这样设计的，所有就按这样的方式封装了，<br>后面了解到了上面的方案一、方案二，所以，如果重新来过，我可能会尝试将状态放置于this中，设计一次。</p><p>另外上面两种方案的代表框架 fusion field 与 alibaba-fusion/next/form 之所以没能够实现配置化生成表单，主要是他们无法从业务层面对form内的各种type field 比如input select 进行二次封装。<br>而我这次封装form的同时，也封装了EnInput， EnSelect，所以支持了配置化生成表单。</p><h3 id="方案四："><a href="#方案四：" class="headerlink" title="方案四："></a>方案四：</h3><p>状态提升，将状态存储与父层的context内，这种方式与 状态存储于this中的设计套路一样，也是通过this.forceupdate的方式进行渲染。<br>context值类似原来的props一样用来渲染组件。</p><h3 id="状态提升存于this-配合forceUpdate"><a href="#状态提升存于this-配合forceUpdate" class="headerlink" title="状态提升存于this 配合forceUpdate"></a>状态提升存于this 配合forceUpdate</h3><p>这种方式是 方案一和方案二使用的，也是react-redux，这些有名开源框架使用的，所以以后在开发的时候，设计复杂组件时，这种方式不失为一种选择。应该熟练运用好这种方式。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>由上可知，状态提升，一般提升去的地方有三个， 父层的 state， 父层的 this， 父层 的context；<br>提升到 父层的this 或 context上时，基本上通过 this。forceupdate 或者setstate一个空值进行整个父层的更新，子层的所有状态皆从 this或context上获取。<br>其实，redux 是这种设计模式的最佳实践， redux就是将state置于context中，更新采用react-redux 的 setState一个空值。<br>所以将数据存储与this或context上，渲染组件的方式，本质上与组件通过props来渲染，没有大不同。</p><p>下面是form介绍一些form功能的细节分析与实现：</p><h2 id="form的三个state"><a href="#form的三个state" class="headerlink" title="form的三个state"></a>form的三个state</h2><p>没有封装form前，可能以为form有很多七七八八的状态，其实，form就三个状态需要维护，就可以基本覆盖form绝大部分功能点，<br>这就是上面所说的状态提升后的三个状态：</p><ul><li>errMsgs – 用来控制错误信息</li><li>formValue  – 用来控制form value值</li><li>formDisplay  – 用来控制field的显示、隐藏、删除、readonly、disabled，之所以把这个显示信息的状态<br>由field提升到form上，因为提升到form后，所有的filed都能共享这一信息，并且修改；</li></ul><h2 id="认识表单中的元素"><a href="#认识表单中的元素" class="headerlink" title="认识表单中的元素"></a>认识表单中的元素</h2><h3 id="操作form数据的"><a href="#操作form数据的" class="headerlink" title="操作form数据的"></a>操作form数据的</h3><p>这类field会改变form value值，包含常规与自定义 field。</p><h4 id="常规field"><a href="#常规field" class="headerlink" title="常规field"></a>常规field</h4><h4 id="自定义field"><a href="#自定义field" class="headerlink" title="自定义field"></a>自定义field</h4><h3 id="依赖form数据做操作的"><a href="#依赖form数据做操作的" class="headerlink" title="依赖form数据做操作的"></a>依赖form数据做操作的</h3><p>比如需要根据最新form value ，进行发送请求的field。<br>这部分元素 不会改变form值，但需要知道form的值做操作。<br>这类可以定义为自定义field。使用config的Render实现。</p><h3 id="与form无数据交互"><a href="#与form无数据交互" class="headerlink" title="与form无数据交互"></a>与form无数据交互</h3><p>比如form的title，或者一些提示语句，分割线，icon 等等。<br>这类元素，根据情况，可以定义为自定义field，也可以使用自由排列模式下form实现。</p><h2 id="单独提取Field"><a href="#单独提取Field" class="headerlink" title="单独提取Field"></a>单独提取Field</h2><p>无论是常规field还是自定义field，可能做的事情，都与与上面的form的三个状态有关：</p><h3 id="常规field做的事情"><a href="#常规field做的事情" class="headerlink" title="常规field做的事情"></a>常规field做的事情</h3><ul><li>设置form的新的value值；</li><li>设置form的新的验证error信息；</li></ul><h3 id="自定义field做的事情"><a href="#自定义field做的事情" class="headerlink" title="自定义field做的事情"></a>自定义field做的事情</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>设置form的新的value值；</li><li>设置form的新的验证error信息；</li><li>隐藏(删除)／显示field， readonly／disable field；</li></ul><h4 id="关于验证的思考"><a href="#关于验证的思考" class="headerlink" title="关于验证的思考"></a>关于验证的思考</h4><p>由于验证是以value的参考标准的，不会考虑该组件是否为自定义或标准组件，所以自定义组件的验证，基本上不用重新设计，套用整体的验证即可；</p><h3 id="每个field的name唯一性"><a href="#每个field的name唯一性" class="headerlink" title="每个field的name唯一性"></a>每个field的name唯一性</h3><h2 id="validate"><a href="#validate" class="headerlink" title="validate"></a>validate</h2><h3 id="filed-的rule可能有多个"><a href="#filed-的rule可能有多个" class="headerlink" title="filed 的rule可能有多个"></a>filed 的rule可能有多个</h3><p>因为有多个，所以每个field的validate应该是遍历的方式去验证每个rule。</p><h3 id="validate-增加相关联映射-filed-检测"><a href="#validate-增加相关联映射-filed-检测" class="headerlink" title="validate 增加相关联映射 filed 检测"></a>validate 增加相关联映射 filed 检测</h3><p>目前觉得最优解方案是定义自定义validate的时候，写明依赖的组件；<br>两个相互依赖检测的组件，都按常规定义好验证方法和依赖组件，虽然验证方法可能是互斥；<br>但考虑到依赖的关系可能并非两个field的关系，可能是三个field，这个时候，验证方法可能不会是互斥关系；<br>此时就需要最后按常规每个field下都定义好验证方法。<br>而且这种自定义方式不会出现很多，所以没必要做一层互斥优化。<br>相关方法为源码中的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidateHelper</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(formConfig)&#123;</span><br><span class="line">            <span class="keyword">this</span>.relateFieldMaps = <span class="keyword">this</span>.getRelateFieldMap(formConfig);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ValidateHelper.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    getRelateFieldMap = <span class="function">(<span class="params">formConfig</span>)=&gt;</span>&#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自定义规则写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;   <span class="attr">name</span>: <span class="string">'region'</span>,</span><br><span class="line">    title: <span class="string">'region'</span>,</span><br><span class="line">    type: <span class="string">'select'</span>,</span><br><span class="line">    defaultValue:<span class="string">''</span>,</span><br><span class="line">    validate:[</span><br><span class="line">        [</span><br><span class="line">            (value,formValue)=&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">String</span>(value).length&lt; <span class="built_in">String</span>(formValue[<span class="string">'useName'</span>]).length)&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">'no small useName'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">            &#125;, </span><br><span class="line">            <span class="comment">//希望同时验证 useName 的验证规则</span></span><br><span class="line">            [<span class="string">'useName'</span>]</span><br><span class="line">         ]</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure></p><h3 id="validate-form-与-field的不同"><a href="#validate-form-与-field的不同" class="headerlink" title="validate form 与 field的不同"></a>validate form 与 field的不同</h3><p>validate form的时候，是对所有field的全量验证，不需要考虑每个field验证的依赖映射关系；<br>单个field onchange 验证的时候，考虑性能，不对整个form进行检测，而只检测当前field的规则 和 与field验证有关联映射关系的field的验证。</p><h3 id="验证触发策略"><a href="#验证触发策略" class="headerlink" title="验证触发策略"></a>验证触发策略</h3><h4 id="即时验证-EnForm使用的策略"><a href="#即时验证-EnForm使用的策略" class="headerlink" title="即时验证 (EnForm使用的策略)"></a>即时验证 (EnForm使用的策略)</h4><p>当form没有submit时候，不验证，submit后，开始验证，然后以后每次field onchange都验证。</p><h4 id="失焦验证"><a href="#失焦验证" class="headerlink" title="失焦验证"></a>失焦验证</h4><p>如题。</p><h4 id="开启验证的开关"><a href="#开启验证的开关" class="headerlink" title="开启验证的开关"></a>开启验证的开关</h4><p>这个根据项目需求来定，有些项目是上面说的即时验证，没有submit前，不进行验证。<br>有些项目不易submit为准，当表单打开时不验证，当光标focus 一个field，然后触发onblur的时候，就进行验证，无论submit与否。<br>简单的说，有些以submit开启验证，有些直接以onlbur开启验证。</p><p>可以根据项目需求，定制验证触发机制。</p><h2 id="field-type组件二次封装"><a href="#field-type组件二次封装" class="headerlink" title="field type组件二次封装"></a>field type组件二次封装</h2><p>如上面《状态提升的运用  –  方案三》分析的，这是实现config 配置化的临门一脚 不可或缺一步。</p><h2 id="默认排版样式"><a href="#默认排版样式" class="headerlink" title="默认排版样式"></a>默认排版样式</h2><p>默认排版的设计，结合了一些工作经验，当超过8个field时，会加一列实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getColumnLength = <span class="function">(<span class="params">length, rows</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> columnLength = length/rows;</span><br><span class="line">  <span class="keyword">const</span> num = length%rows;</span><br><span class="line">  <span class="keyword">if</span>(num === <span class="number">0</span>) <span class="keyword">return</span> columnLength;</span><br><span class="line">  <span class="keyword">if</span>(length &gt; rows*columnLength) <span class="keyword">return</span> columnLength+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> columnLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eslint-disable-next-line import/prefer-default-export</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getLayout = <span class="function">(<span class="params">fields, rowsLength</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> columnLength = getColumnLength(fields.length, rowsLength);</span><br><span class="line">  <span class="keyword">const</span> layouts = [];</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(index &lt; columnLength)&#123;</span><br><span class="line">    <span class="keyword">const</span> lastIndex = rowsLength*(index+<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(index === columnLength <span class="number">-1</span> ) lastIndex = fields.length<span class="number">-1</span>;</span><br><span class="line">    layouts.push(</span><br><span class="line">      &lt;section className=<span class="string">"column"</span> key=&#123;index&#125;&gt;</span><br><span class="line">        &#123;fields.slice(rowsLength*index, lastIndex)&#125;</span><br><span class="line">      &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">    index++;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return layouts;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="源码与demo"><a href="#源码与demo" class="headerlink" title="源码与demo"></a>源码与demo</h2><p><a href="https://github.com/YeWills/react-redux-hooks-demo/tree/context-form/src/components/EnForm" target="_blank" rel="noopener">github EnForm源码</a></p><p><a href="https://github.com/YeWills/react-redux-hooks-demo/tree/context-form" target="_blank" rel="noopener">github demo</a></p><h2 id="react中的表单处理"><a href="#react中的表单处理" class="headerlink" title="react中的表单处理"></a>react中的表单处理</h2><p>这里是之前整理的一篇 关于 表单处理的博客，同样对封装表单具有参考价值。<br><a href="https://yewills.github.io/2020/04/24/react_form/">react中的表单处理</a></p><h2 id="放弃的方案"><a href="#放弃的方案" class="headerlink" title="放弃的方案"></a>放弃的方案</h2><p>为了实现又能配置化，又能自由排列，想了很多方案，刚开始用的 React.cloneElement 方案，也可以达到这一目的，不过局限性比较多，这个方案的亮点在于，<br>不仅通过 React.cloneElement 改变了当前元素的props，而且找到了一种通过React.cloneElement改变当前元素的子元素的props的方法，以下是这一方案的一些分析，权当灵感式的头脑风暴：</p><h3 id="有限度的自由排列布局"><a href="#有限度的自由排列布局" class="headerlink" title="有限度的自由排列布局"></a>有限度的自由排列布局</h3><h4 id="field最多只能在在第二层"><a href="#field最多只能在在第二层" class="headerlink" title="field最多只能在在第二层"></a>field最多只能在在第二层</h4><p>如果要使用form自带（含自定义）的field，就必须使用将field放在最多第二层级上，<br>否则form内将不识别；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div &gt;</span><br><span class="line">    &lt;EnForm.Field className=<span class="string">"form-cell"</span> enfield name=<span class="string">"editname"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;天若有情天亦老&lt;/</span>p&gt;</span><br><span class="line">  &lt;EnForm.Field className=<span class="string">"form-cell"</span> enfield name=<span class="string">"useName"</span> /&gt;</span><br><span class="line">  &lt;div className=<span class="string">"region"</span>&gt;</span><br><span class="line">    &lt;div&gt;test&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;EnForm.Field className="form-cell" enfield name="region" /</span>&gt;</span><br><span class="line">    &lt;div&gt;test&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;EnForm.Field className="form-cell" enfield name="passWord" /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;EnForm.Field className="form-cell" enfield name="select" /</span>&gt;</span><br></pre></td></tr></table></figure></p><p>逻辑实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">content = children.map(<span class="function">(<span class="params">cell, index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cell.props.enfield)&#123;</span><br><span class="line">      <span class="keyword">return</span> React.cloneElement(cell,  getProps(cell.props))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> cellChilds = toArray(cell.props.children);</span><br><span class="line">    <span class="keyword">if</span>(!cellChilds.find(<span class="function"><span class="params">t</span>=&gt;</span> _.get(t,<span class="string">'props.enfield'</span>))) <span class="keyword">return</span> cell;</span><br><span class="line">    <span class="keyword">const</span> newChildren = cellChilds.map(<span class="function">(<span class="params">t</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(_.get(t,<span class="string">'props.enfield'</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> React.cloneElement(t,  getProps(t.props))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> React.cloneElement(cell, &#123;...cell.props, <span class="attr">children</span>:newChildren, <span class="attr">key</span>:index&#125;);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h4 id="为什么不要超过两层"><a href="#为什么不要超过两层" class="headerlink" title="为什么不要超过两层"></a>为什么不要超过两层</h4><p>这个思路就跟react hooks，必须定义在顶层一样，<br>太多递归遍历是消耗性能的，而且定义在两层，基本上达到了百分之九十以上的自由排列field的需求。<br>剩下百分之十不到的，就不用管了。</p><h4 id="可以超过两层定义field吗"><a href="#可以超过两层定义field吗" class="headerlink" title="可以超过两层定义field吗"></a>可以超过两层定义field吗</h4><p>原则上是可以的，但是会导致深度copy的问题，可能就会消耗性能，这样就没有必要了，<br>此时不如手写一版form。</p><h3 id="无限度的自由排列布局"><a href="#无限度的自由排列布局" class="headerlink" title="无限度的自由排列布局"></a>无限度的自由排列布局</h3><p>将任意想排列的样子定义在自定义field内，再配合有限度自由排列的方案，<br>可轻易达到大部分的自由排列需求。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://github.com/YeWills/react-redux-hooks-demo/tree/blog-form" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> form </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>next form 封装</title>
      <link href="/2021/01/03/react_form_next/"/>
      <url>/2021/01/03/react_form_next/</url>
      
        <content type="html"><![CDATA[<h2 id="form拥有的能力"><a href="#form拥有的能力" class="headerlink" title="form拥有的能力"></a>form拥有的能力</h2><h3 id="redux状态"><a href="#redux状态" class="headerlink" title="redux状态"></a>redux状态</h3><h4 id="内部实现-formStore-formDispatch"><a href="#内部实现-formStore-formDispatch" class="headerlink" title="内部实现 (formStore formDispatch)"></a>内部实现 (formStore formDispatch)</h4><p>formStore是给form封装的，主要用于form内的自定义组件。<br>form Store 用于较为复杂的form，根据需求是否选用，与form做了分离封装：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"> contextHoc(FormContext, initFormStoreState)(AddText)</span><br><span class="line"></span><br><span class="line"><span class="comment">//contextHoc</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Wrap <span class="keyword">from</span> <span class="string">"./Wrap"</span>;</span><br><span class="line"><span class="keyword">const</span> contextHoc = <span class="function">(<span class="params">FormContext, initialState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">Comp</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;Wrap FormContext=&#123;FormContext&#125; initialState=&#123;initialState&#125; &#123;...props&#125;&gt;</span><br><span class="line">          &lt;Comp /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Wrap&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default contextHoc;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Wrap</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(state, action);</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"setErrors"</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; erros &#125; = state;</span><br><span class="line">      <span class="keyword">const</span> &#123; preload &#125; = action;</span><br><span class="line">      <span class="keyword">const</span> updates = preload.reduce(<span class="function">(<span class="params">acc, &#123; name, value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        acc[name] = value;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">      &#125;, &#123;&#125;);</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">errors</span>: &#123; ...erros, ...updates &#125; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"resetErrors"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">errors</span>: &#123;&#125; &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"setValues"</span>: &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; values &#125; = state;</span><br><span class="line">      <span class="keyword">const</span> &#123; preload &#125; = action;</span><br><span class="line">      <span class="keyword">const</span> updates = preload.reduce(<span class="function">(<span class="params">acc, &#123; name, value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        acc[name] = value;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">      &#125;, &#123;&#125;);</span><br><span class="line">      <span class="comment">//_isValueChange 用于标识form的store values是否重新被赋值，可用场景有表单编辑的保存按钮，若无变化则禁用</span></span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">values</span>: &#123; ...values, <span class="attr">_isValueChange</span>: <span class="literal">true</span>, ...updates&#125; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"resetValues"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">values</span>: &#123;&#125; &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"reset"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">errors</span>: &#123;&#125;, <span class="attr">values</span>: &#123;&#125; &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">values</span>: &#123; ...initialState &#125;, <span class="attr">errors</span>: &#123;&#125; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Wrap = <span class="function">(<span class="params">&#123; children, FormContext, initialState = &#123;&#125;, ...rest &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [formStore, fDispatch] = useReducer(reducer, initialState, init);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FormContext.Provider value=&#123;fDispatch&#125;&gt;</span><br><span class="line">      &#123;React.cloneElement(children, &#123;</span><br><span class="line">        ...children.props,</span><br><span class="line">        ...rest,</span><br><span class="line">        formStore,</span><br><span class="line">        action: fDispatch</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;<span class="regexp">/FormContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Wrap;</span></span><br></pre></td></tr></table></figure><h4 id="发起action的两种方式"><a href="#发起action的两种方式" class="headerlink" title="发起action的两种方式"></a>发起action的两种方式</h4><p>在form内，将以上能力注入到每个自定义组件内，如果你不嫌麻烦，你同样可通过context直接获取atcion。<br>因为form store 就是利用context+reducer实现的一个小型redux。</p><h4 id="父组件将获取form-store能力"><a href="#父组件将获取form-store能力" class="headerlink" title="父组件将获取form store能力"></a>父组件将获取form store能力</h4><p>将包含Enform的组件，使用contextHoc(FormContext, initFormStoreState)(AddCoupon)后，AddCoupon将拥有form store的所有能力。</p><h4 id="父组件或子组件"><a href="#父组件或子组件" class="headerlink" title="父组件或子组件"></a>父组件或子组件</h4><p>form组件内发起action赋值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">formDispatch(&#123;</span><br><span class="line">             type: <span class="string">"setValues"</span>,</span><br><span class="line">             preload: [<span class="comment">//使用数组</span></span><br><span class="line">               &#123;</span><br><span class="line">                 name: <span class="string">"orgList"</span>,</span><br><span class="line">                 value: storeIdsVal</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123;</span><br><span class="line">                 name: <span class="string">"_isValueChange"</span>,</span><br><span class="line">                 value: <span class="literal">false</span></span><br><span class="line">               &#125;</span><br><span class="line">             ]</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure></p><h4 id="其他细节处理"><a href="#其他细节处理" class="headerlink" title="其他细节处理"></a>其他细节处理</h4><ul><li>setValues 使用数组写法，满足一次性需要赋值多个状态的需求</li><li>reset 重置值的能力</li><li>_isValueChange 判断store是否重新赋值能力</li><li>setErrors 作为验证备用的状态，暂时还没遇到需求，大多验证需求可通过 next form 自带的valitor消化</li><li>以装饰器写法，分离独立能力，可自行选择是否使用form store</li></ul><h3 id="state状态"><a href="#state状态" class="headerlink" title="state状态"></a>state状态</h3><h4 id="内部实现-formValues与Field"><a href="#内部实现-formValues与Field" class="headerlink" title="内部实现 (formValues与Field)"></a>内部实现 (formValues与Field)</h4><p>formValues是form自带的value，结合Field使用，非常方便：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Enform内</span></span><br><span class="line"><span class="keyword">this</span>.field = <span class="keyword">new</span> Field(<span class="keyword">this</span>, &#123; <span class="attr">values</span>: defaultValue &#125;);</span><br></pre></td></tr></table></figure></p><h4 id="特殊情况下外部使用"><a href="#特殊情况下外部使用" class="headerlink" title="特殊情况下外部使用"></a>特殊情况下外部使用</h4><p>一般不建议使用class的ref，特殊情况下，比如引用Enform的外层父组件无法重新设置form值，办法是ref。</p><h3 id="event事件"><a href="#event事件" class="headerlink" title="event事件"></a>event事件</h3><h4 id="内部实现-formAcion-与父组件通信桥梁"><a href="#内部实现-formAcion-与父组件通信桥梁" class="headerlink" title="内部实现(formAcion,与父组件通信桥梁)"></a>内部实现(formAcion,与父组件通信桥梁)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//form 的父组件内</span></span><br><span class="line">  <span class="keyword">const</span> formAction = <span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">"openAddDialog"</span>) &#123;</span><br><span class="line">      setShop(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &lt;EnForm</span><br><span class="line">    formAction=&#123;formAction&#125;</span><br><span class="line">  /&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// form 内的子组件内：</span></span><br><span class="line">  formAction(<span class="string">"openAddDialog"</span>);</span><br></pre></td></tr></table></figure><h3 id="公共数据"><a href="#公共数据" class="headerlink" title="公共数据"></a>公共数据</h3><p>将一些公共的数据以下斜杠的方式注入form values 或 store中，比如<code>{__common__：row}</code>以便让整个form公用。</p><h3 id="判断form-value-是否改变"><a href="#判断form-value-是否改变" class="headerlink" title="判断form value 是否改变"></a>判断form value 是否改变</h3><p>_isValueChange 用于标识form的store values是否重新被赋值，可用场景有表单编辑的保存按钮，若无变化则禁用。<br>form store 的 value 赋值都在 setValues中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"setValues"</span>: &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; values &#125; = state;</span><br><span class="line">  <span class="keyword">const</span> &#123; preload &#125; = action;</span><br><span class="line">  <span class="keyword">const</span> updates = preload.reduce(<span class="function">(<span class="params">acc, &#123; name, value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    acc[name] = value;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">  <span class="comment">//_isValueChange 用于标识form的store values是否重新被赋值，可用场景有表单编辑的保存按钮，若无变化则禁用</span></span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, <span class="attr">values</span>: &#123; ...values, <span class="attr">_isValueChange</span>: <span class="literal">true</span>, ...updates&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="以此类推"><a href="#以此类推" class="headerlink" title="以此类推"></a>以此类推</h4><p>写一些大组件或复杂组件的时候，比如Table，可以考虑优先使用class实现，因为class可以对外暴露ref。</p><h2 id="form源码实现"><a href="#form源码实现" class="headerlink" title="form源码实现"></a>form源码实现</h2><h3 id="两种表单"><a href="#两种表单" class="headerlink" title="两种表单"></a>两种表单</h3><p>主要实现 一般表单 与 label列表查询表单。</p><h4 id="label列表查询表单"><a href="#label列表查询表单" class="headerlink" title="label列表查询表单"></a>label列表查询表单</h4><p>单行无label列表查询表单 比如 添加材料 列表查询。<br>与普通表单不一样的是，单行无label列表查询表单 label为空，样式也有一些差异处理，查询按钮可能内嵌于表单内。<br>因为适用场景不多，对 单行无label列表查询表单 封装不多，只设计了单行的场景，根据需求可以扩展。</p><h3 id="render-props模式"><a href="#render-props模式" class="headerlink" title="render props模式"></a>render props模式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>config是Enform的props，render是config内每个field的配置，<br>render是一种render props模式，<br>写Enform的时候，有些地方采用了render props模式，<br>主要是next FormItem 能将其一级child组件集成到form体系内，被form统一封装，拥有value能力。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FormItem</span></span><br><span class="line">&lt;FormItem</span><br><span class="line">  required=&#123;required&#125;</span><br><span class="line">  labelAlign=<span class="string">"left"</span></span><br><span class="line">  labelCol=&#123;&#123; <span class="attr">span</span>: <span class="keyword">this</span>.getLableColSpan(labelCol) &#125;&#125;</span><br><span class="line">  wrapperCol=&#123;&#123; <span class="attr">span</span>: <span class="keyword">this</span>.getWrapperColSpan(wrapperCol, type) &#125;&#125;</span><br><span class="line">  label=&#123;<span class="keyword">this</span>.getLabel(fieldInfo)&#125;</span><br><span class="line">  className=&#123;<span class="string">`<span class="subst">$&#123;styles.item&#125;</span> <span class="subst">$&#123;className&#125;</span>`</span>&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;<span class="keyword">this</span>.generateField(fieldInfo)&#125;</span><br><span class="line">&lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/generateField</span></span><br><span class="line"><span class="regexp">generateField = fieldInfo =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  if (render) &#123;</span></span><br><span class="line"><span class="regexp">     /</span><span class="regexp">/render props模式</span></span><br><span class="line"><span class="regexp">    return render(fieldInfo, this.field);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  if (CustomField) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/组件模式</span></span><br><span class="line"><span class="regexp">    return &lt;CustomField field=&#123;this.field&#125; /</span>&gt;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//config</span></span><br><span class="line">    &#123;</span><br><span class="line">      label: <span class="string">"test门槛"</span>,</span><br><span class="line">      name: <span class="string">"condType"</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      render: Test</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="keyword">const</span> Test = <span class="function">(<span class="params">&#123; name, extraProps &#125;, formField</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Radio.Group itemDirection=<span class="string">"ver"</span> name=&#123;name&#125; &#123;...extraProps&#125;&gt;</span><br><span class="line">      &lt;Radio value=&#123;none&#125;&gt;test门槛&lt;<span class="regexp">/Radio&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Radio value=&#123;limit&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;FormItem label=""&gt;</span></span><br><span class="line"><span class="regexp">          &lt;EnNumPicker</span></span><br><span class="line"><span class="regexp">            name=&#123;conditionValueKey&#125;</span></span><br><span class="line"><span class="regexp">            min=&#123;1&#125;</span></span><br><span class="line"><span class="regexp">            max=&#123;9999&#125;</span></span><br><span class="line"><span class="regexp">            hasTrigger=&#123;false&#125;</span></span><br><span class="line"><span class="regexp">            editable=&#123;!isDisabled&#125;</span></span><br><span class="line"><span class="regexp">            disabled=&#123;isDisabled&#125;</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;&amp;nbsp;&amp;nbsp;数量&lt;/</span>span&gt;</span><br><span class="line">      &lt;<span class="regexp">/Radio&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Radio.Group&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="next-form使用的技巧"><a href="#next-form使用的技巧" class="headerlink" title="next form使用的技巧"></a>next form使用的技巧</h3><h4 id="form能集成任意组件"><a href="#form能集成任意组件" class="headerlink" title="form能集成任意组件"></a>form能集成任意组件</h4><p>自定义组件，只要定义好name，就拥有form内其他如input组件的能力<br>其实自定义组件有歧义，<br>在next form 看来，自定义组件与其他如Input组件是一样的并没有不同，只是定义好name，然后组件内对value，onchange进行劫持即可。</p><h4 id="validator的触发时机"><a href="#validator的触发时机" class="headerlink" title="validator的触发时机"></a>validator的触发时机</h4><p>validator默认的触发时机是onchange与submit。<br>当你在自定义组件，自定义了validator，想在自定义组件内触发validator，<br>在自定义组件内，执行onChange。<br>因为validator默认的触发时机是onchange与submit。</p><h3 id="组件模式"><a href="#组件模式" class="headerlink" title="组件模式"></a>组件模式</h3><p>由上面next form使用的技巧可知，任何组件都可以集成到form体系内，拥有统一的form value等</p><h3 id="render-props-组件-模式"><a href="#render-props-组件-模式" class="headerlink" title="render props/组件 模式"></a>render props/组件 模式</h3><h4 id="render-props使用场景"><a href="#render-props使用场景" class="headerlink" title="render props使用场景"></a>render props使用场景</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VaTerm = <span class="function">(<span class="params">&#123; name, extraProps &#125;, formField</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> radioValue = <span class="built_in">String</span>(formField.getValue(name));</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Radio.Group</span><br><span class="line">      itemDirection=<span class="string">"ver"</span></span><br><span class="line">      name=&#123;name&#125;</span><br><span class="line">      className=&#123;styles.validTime&#125;</span><br><span class="line">      &#123;...extraProps&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;Radio value=&#123;absoluteTime&#125;&gt;</span><br><span class="line">        &lt;FormItem label=<span class="string">""</span>&gt;</span><br><span class="line">          &lt;DatePicker.RangePicker</span><br><span class="line">            disabled=&#123;extraProps?.disabled || isEqual(radioValue, relaTime)&#125;</span><br><span class="line">            name=&#123;dateName&#125;</span><br><span class="line">            onClick=&#123;e =&gt; &#123;</span><br><span class="line">              <span class="comment">//datapicker与radio点击事件冲突，导致时间面板闪现。</span></span><br><span class="line">              e.preventDefault();</span><br><span class="line">              e.stopPropagation();</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            disabledDate=&#123;disabledDate&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Radio&gt;</span><br><span class="line">      &lt;Radio value=&#123;relaTime&#125;&gt;</span><br><span class="line">        &lt;FormItem label=<span class="string">""</span>&gt;</span><br><span class="line">          &lt;EnNumPicker</span><br><span class="line">            name=&#123;relativeDays&#125;</span><br><span class="line">            min=&#123;<span class="number">1</span>&#125;</span><br><span class="line">            max=&#123;<span class="number">9999</span>&#125;</span><br><span class="line">            hasTrigger=&#123;<span class="literal">false</span>&#125;</span><br><span class="line">            disabled=&#123;extraProps?.disabled || isEqual(radioValue, absoluteTime)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/FormItem&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span className=&#123;styles.text&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div className=&#123;styles.tip&#125;&gt;</span></span><br><span class="line"><span class="regexp">            test test</span></span><br><span class="line"><span class="regexp">          &lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Radio&gt;</span><br><span class="line">    &lt;<span class="regexp">/Radio.Group&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="组件模式使用场景"><a href="#组件模式使用场景" class="headerlink" title="组件模式使用场景"></a>组件模式使用场景</h4><p>对一些常用组件，如select，进行了项目业务逻辑的二次封装<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"select"</span>: &#123;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">       &lt;EnSelect</span><br><span class="line">         style=&#123;style&#125;</span><br><span class="line">         &#123;...fieldInfo&#125;</span><br><span class="line">         formAction=&#123;formAction&#125;</span><br><span class="line">         formType=&#123;formType&#125;</span><br><span class="line">       /&gt;</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>不太推荐，一些业务才有的自定义组件，在config中直接写，如果要这样做，就采取下面的方式：render props内定义自定义组件</p><h4 id="render-props内定义自定义组件"><a href="#render-props内定义自定义组件" class="headerlink" title="render props内定义自定义组件"></a>render props内定义自定义组件</h4><p>使用render props模式，在render props内return一个自定义组件，这种方式非常灵活：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getProject = <span class="function">(<span class="params">&#123; name &#125;, formField, &#123; store, action &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//name=&#123;name&#125; 注入name，就完成了将自定义组件ValidaTerm集成到form</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ValTerm</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span> <span class="attr">action</span>=<span class="string">&#123;action&#125;</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure></p><h3 id="单列和多列布局"><a href="#单列和多列布局" class="headerlink" title="单列和多列布局"></a>单列和多列布局</h3><p>单列表单一般为新增表单。<br>另外一些就是多列表单。<br>默认根据field的数量，需要展示的列数量，form自动计算一个ColSpan<br>达到自动分列。<br>对应优先级如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getColSpan = <span class="function"><span class="params">col</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; columns = <span class="number">1</span>, colSpan, type &#125; = <span class="keyword">this</span>.props.config;</span><br><span class="line">  <span class="keyword">if</span> (col?.span) <span class="keyword">return</span> col?.span;</span><br><span class="line">  <span class="keyword">if</span> (colSpan) <span class="keyword">return</span> colSpan;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">"singleColumns"</span>) <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">24</span> / columns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="注入能力"><a href="#注入能力" class="headerlink" title="注入能力"></a>注入能力</h3><p>每一个config field 注入 store, action, formAction,this.field 能力。</p><h3 id="切换-详情表单"><a href="#切换-详情表单" class="headerlink" title="切换 详情表单"></a>切换 详情表单</h3><h4 id="要切换成详情表单，比较简单："><a href="#要切换成详情表单，比较简单：" class="headerlink" title="要切换成详情表单，比较简单："></a>要切换成详情表单，比较简单：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;EnForm</span><br><span class="line">  formType=&#123;<span class="string">"detailForm"</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h4 id="form内，统一写了一个详情field："><a href="#form内，统一写了一个详情field：" class="headerlink" title="form内，统一写了一个详情field："></a>form内，统一写了一个详情field：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (formType === <span class="string">"detailForm"</span> &amp;&amp; isUseDetail(fieldInfo)) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;DetailField</span><br><span class="line">      name=&#123;name&#125;</span><br><span class="line">      fieldInfo=&#123;fieldInfo&#125;</span><br><span class="line">      formStoreField=&#123;formStoreField&#125;</span><br><span class="line">      formAction=&#123;formAction&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>form内的二次封装组件比如EnSelect，也封装了其详情模式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnSelect</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">  render() &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (formType === <span class="string">"detailForm"</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> opt = options.find(<span class="function"><span class="params">item</span> =&gt;</span> isEqual(item.value, rest.value));</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">lineHeight:</span> "<span class="attr">32px</span>" &#125;&#125;&gt;</span>&#123;opt?.label || ""&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Select</span><br><span class="line">        ...</span><br><span class="line">      &gt;</span><br><span class="line">       ...</span><br><span class="line">      &lt;<span class="regexp">/Select&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="对于业务自定义组件，则自行写好详情态渲染模式。"><a href="#对于业务自定义组件，则自行写好详情态渲染模式。" class="headerlink" title="对于业务自定义组件，则自行写好详情态渲染模式。"></a>对于业务自定义组件，则自行写好详情态渲染模式。</h4><p>如题。</p><h3 id="form设计为class组件重要"><a href="#form设计为class组件重要" class="headerlink" title="form设计为class组件重要"></a>form设计为class组件重要</h3><h4 id="关于form组件本身"><a href="#关于form组件本身" class="headerlink" title="关于form组件本身"></a>关于form组件本身</h4><ul><li>兼容next</li><li>兼容Field</li><li>暴露ref给父亲组件，以便外层获取Enform的instance<h4 id="关于其他大组件设计注意"><a href="#关于其他大组件设计注意" class="headerlink" title="关于其他大组件设计注意"></a>关于其他大组件设计注意</h4>以Form组件封装经验来看，其他大组件，如Table组件封装，也推荐使用class，而不是hooks，以便外层获取Enform的instance，<br>以便在特殊情况，对外暴露Instance。<br>注意上面说的是大组件，对于小组件，我还是推荐使用hooks。</li></ul><h2 id="config配置"><a href="#config配置" class="headerlink" title="config配置"></a>config配置</h2><h3 id="自定义validator建议使用deepcustom"><a href="#自定义validator建议使用deepcustom" class="headerlink" title="自定义validator建议使用deepcustom"></a>自定义validator建议使用deepcustom</h3><p>因为自定义validator要写在Form.Item上，因此推荐deepcustom。</p><h3 id="extraProps"><a href="#extraProps" class="headerlink" title="extraProps"></a>extraProps</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      label: <span class="string">"每人数量"</span>,</span><br><span class="line">      name: <span class="string">"takenum"</span>,</span><br><span class="line">      type: <span class="string">"numberPicker"</span>,</span><br><span class="line">      placeholder: <span class="string">"请输入每人数量"</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      extraProps: &#123;</span><br><span class="line">        innerAfter: <span class="string">"张"</span>,</span><br><span class="line">        min: <span class="number">1</span>,</span><br><span class="line">        max: <span class="number">99</span>,</span><br><span class="line">        hasTrigger: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>还有很多其他属性，根据不同的组件，能够定义的属性不一样：</p><ul><li>wrapperCol: { span: 16 } 这是通用的</li><li>col: { className: “valid-term” }这是通用的</li><li><p>checkbox 的 getOpts</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     label: <span class="string">"看赛方式"</span>,</span><br><span class="line">     name: <span class="string">"shows"</span>,</span><br><span class="line">     required: <span class="literal">true</span>,</span><br><span class="line">     type: <span class="string">"checkbox"</span>,</span><br><span class="line">     getOpts: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure></li><li><p>select 的 post</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     label: &quot;渠道&quot;,</span><br><span class="line">     name: &quot;chaList&quot;,</span><br><span class="line">     type: &quot;select&quot;,</span><br><span class="line">     post: getcannel,</span><br><span class="line">     extraProps: &#123;</span><br><span class="line">       mode: &quot;multiple&quot;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="一些思路或待实现"><a href="#一些思路或待实现" class="headerlink" title="一些思路或待实现"></a>一些思路或待实现</h2><h3 id="显示和隐藏，"><a href="#显示和隐藏，" class="headerlink" title="显示和隐藏，"></a>显示和隐藏，</h3><h4 id="简单的显示隐藏"><a href="#简单的显示隐藏" class="headerlink" title="简单的显示隐藏"></a>简单的显示隐藏</h4><p>可以定义在config内，通过一个函数，获取form的所有能力，判断显示隐藏或者hidden show；</p><h4 id="复杂的显示隐藏"><a href="#复杂的显示隐藏" class="headerlink" title="复杂的显示隐藏"></a>复杂的显示隐藏</h4><p>这个考虑下通过config的函数，还是config与jsx(render props)混用<br>可考虑借鉴 table 的column形式，在render中写cell；</p><h3 id="config与jsx-render-props-并行"><a href="#config与jsx-render-props-并行" class="headerlink" title="config与jsx(render props)并行"></a>config与jsx(render props)并行</h3><p>考虑如何设计，让config配置与手写form item 并行，可借鉴table的cell模式。</p><h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><h3 id="不执念封装"><a href="#不执念封装" class="headerlink" title="不执念封装"></a>不执念封装</h3><p>封装带来简便的同时，也带来了定制化弱，灵活度低的特点。<br>封装一时爽，后期业务叠加需求时，支持度差时，非常麻烦。<br>所有推荐简单的表单使用封装。<br>我希望在项目开发时，封装form与next原生from并行使用。</p><h3 id="封装form与next原生from并行使用"><a href="#封装form与next原生from并行使用" class="headerlink" title="封装form与next原生from并行使用"></a>封装form与next原生from并行使用</h3><p>参考上面</p><h3 id="推荐简单的表单使用封装"><a href="#推荐简单的表单使用封装" class="headerlink" title="推荐简单的表单使用封装"></a>推荐简单的表单使用封装</h3><p>参考上面</p><h3 id="满足百分之七十五的需求"><a href="#满足百分之七十五的需求" class="headerlink" title="满足百分之七十五的需求"></a>满足百分之七十五的需求</h3><p>理论上封装的form能够满足百分之百的需求，因为封装的写法与原生的写法，没有根本差别，只是换一种形式。<br>但满足权衡成本与收益，覆盖率越大，反而还不好。</p><h3 id="谁掌握了数据，就掌握了所有能力"><a href="#谁掌握了数据，就掌握了所有能力" class="headerlink" title="谁掌握了数据，就掌握了所有能力"></a>谁掌握了数据，就掌握了所有能力</h3><p>react的世界，是数据的世界，谁掌握了数据，就掌握了所有能力</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="集成form时，使用class而不是hooks"><a href="#集成form时，使用class而不是hooks" class="headerlink" title="集成form时，使用class而不是hooks"></a>集成form时，使用class而不是hooks</h3><p>from.Item组件在next源码中，引用了子组件的ref，因此最好定义class组件，用hooks组件，将报warning，虽然不影响使用。<br>不过从另一个角度来看，ref一般用于一些next已知组件的特殊操作，因此自定义组件，使用hooks或class关系不大，至少不会影响使用，只是会报一个丑的warning。<br>如果实在想写成一个hooks，可用class组件再包一层，转发下。<strong>不要使用Forward.Ref，它与Form.Item无法兼容，和集成。</strong></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> form </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ListBuilder引发的React暗黑思考</title>
      <link href="/2021/01/03/react_listBuilder/"/>
      <url>/2021/01/03/react_listBuilder/</url>
      
        <content type="html"><![CDATA[<h2 id="edit与search的无法调和是一切暗黑的源头"><a href="#edit与search的无法调和是一切暗黑的源头" class="headerlink" title="edit与search的无法调和是一切暗黑的源头"></a>edit与search的无法调和是一切暗黑的源头</h2><h3 id="需求：edit-与-search-功能"><a href="#需求：edit-与-search-功能" class="headerlink" title="需求：edit 与 search 功能"></a>需求：edit 与 search 功能</h3><p>场景为：edit 功能只能定义在业务组建内，且 edit 功能每次都要setState ListBuilder的data。<br><strong>search功能必须放在ListBuilder内</strong>，search功能每次也要改变ListBuilder的data。</p><h3 id="为什么无法调和"><a href="#为什么无法调和" class="headerlink" title="为什么无法调和"></a>为什么无法调和</h3><p>二者无法调和是在于，edit与search要求同时都完全控制state，但edit必须位于组件外层，search必须位于组件内层，<br>由于edit位于外层，你必须将listBuilder组件做成完全受控组件，要求组件内部使用props渲染；<br>由于search位于内层，且要求完全操控数据，因为组件必须做成state方式，不能响应外层props数据变动；<br>解决方法（也是下面的 <strong>终极方案</strong>）：</p><ul><li>将组件做成完全受控，完成edit功能；</li><li>将组件的数据做成对象方式，search时，实时改动对象，利用对象引用特征，改动完后 使用forceUpdate，渲染组件，在render上每次 function重新组件props数据；</li></ul><p>这样组件就可以同时响应edit和search的变动。</p><h3 id="方案一-否定"><a href="#方案一-否定" class="headerlink" title="方案一(否定)"></a>方案一(否定)</h3><p>search和edit都放在业务组建内写，此时就不会有问题，但是明显违背了上面说的 <strong>search功能必须放在ListBuilder内</strong>。此方案不行。</p><h3 id="方案二-否定"><a href="#方案二-否定" class="headerlink" title="方案二(否定)"></a>方案二(否定)</h3><p>在ListBuilder内部维护state，同时用 getDerivedStateFromProps 让ListBuilder组件完全受控：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(props,state)&#123;    </span><br><span class="line">    <span class="keyword">if</span>(props.value !== state.value)&#123;      </span><br><span class="line">        <span class="keyword">return</span> &#123;        </span><br><span class="line">            value:props.value      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，我们通过edit 来维护props，用search 维护自身的state，这样说起来，貌似完美解决来问题。<br>但你注意看上面的代码，你会发现，这种模式有一下弊端：</p><ul><li>我们希望是当有props改动的时候，state值为props；state自身改动时，state值响应为自身state；但上面的getDerivedStateFromProps代码实际上只响应props，state完全响应props的变化，自身state的值无法注入给自己。</li><li>就算通过各种if else 让组件能够达到同时响应props和state，这个过程痛苦不说，也会有很多弊端，其中之一就是，父层如何实时知道ListBuilder最新渲染的data值。</li><li>这种写出来的组件，后期扩展时同时要测试 getDerivedStateFromProps，麻烦不说，还容易出现意想不到的bug。<h3 id="终极方案–forceUpdate-实时生成render最新props-对象引用"><a href="#终极方案–forceUpdate-实时生成render最新props-对象引用" class="headerlink" title="终极方案–forceUpdate+实时生成render最新props+对象引用"></a>终极方案–forceUpdate+实时生成render最新props+对象引用</h3>已知，data为下面的形式：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'row1'</span>, <span class="attr">value</span>: <span class="string">'r1'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'row2'</span>, <span class="attr">value</span>: <span class="string">'r3'</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><p>以上方案都不行，还有什么方法了，没办法，只能开启暗黑方式了：</p><ul><li>我们可以在 edit 时还是setState ListBuilder的data，</li><li><p>然后在ListBuilder组件内部，search功能时，我们给data的每条数据<code>{name: &#39;row1&#39;, value: &#39;r1&#39;}</code>，添加一个 visable属性，按条件重置为true或false，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'row1'</span>, <span class="attr">value</span>: <span class="string">'r1'</span>, <span class="attr">visable</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'row2'</span>, <span class="attr">value</span>: <span class="string">'r3'</span>, <span class="attr">visable</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>search完后，在ListBuilder内部，执行一次，此时ListBuilder内部render函数就会执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.forceUpdate()</span><br></pre></td></tr></table></figure></li><li><p>然后在ListBuilder的内部render方法内定义一个function，过滤掉false的，只留下 <code>visable: true</code>;</p></li><li>由于search操作的是data内的每条数据，而每条数据又是一个对象，利用对象的引用类型特性，一处改变，其他地方都会改变，因此根本不需要setState，在render使用data放在function上过滤时，就已经有visable属性了。</li><li>这样给render内的组件如(grid 或 TreeList)传的值就达到预期要求。</li></ul><p>这一种方案太妙了，因为其功能的强大性，用起来很爽，但又是一种反模式运用，让用起来的时候很由于，故称暗黑。</p><p>这种方案，关键在于利用了对象引用特征，在修改完数据后，使用forceUpdate，触发render，然后在render中 实时生成props.</p><h3 id="完全受控组件如何自己改变状态"><a href="#完全受控组件如何自己改变状态" class="headerlink" title="完全受控组件如何自己改变状态"></a>完全受控组件如何自己改变状态</h3><p>上面的《终极方案–forceUpdate+实时生成render最新props+对象引用》为我们提供了一种思路，当我们面临 像上面需求一样，<br>父层要实时操控一个完全受控的子组件，而完全受控的子组件同时又想在内部自己改变状态。<br>此时我们可以像上面一样，利用引用类型特性，render时每次生成最新状态的方案。</p><h3 id="如何让父组件和子组件同时可以改变子组件的state"><a href="#如何让父组件和子组件同时可以改变子组件的state" class="headerlink" title="如何让父组件和子组件同时可以改变子组件的state"></a>如何让父组件和子组件同时可以改变子组件的state</h3><p>其实我们也可以这样描述上面的需要，如何让父组件和子组件同时可以改变子组件的state。</p><h3 id="setState之外的setState方案"><a href="#setState之外的setState方案" class="headerlink" title="setState之外的setState方案"></a>setState之外的setState方案</h3><p>我们可以将上面 《终极方案–forceUpdate+实时生成render最新props+对象引用》称之为 setState之外的setState方案，毕竟它让ListBuilder内部实现了一次setState，而又不通过任何setState方法。</p><h3 id="如果data的每条数据是一个字符串"><a href="#如果data的每条数据是一个字符串" class="headerlink" title="如果data的每条数据是一个字符串"></a>如果data的每条数据是一个字符串</h3><p>如下，如题，此时，我们可以将data在使用之前使用一个方法将data转化为一个每条数据为对象的data结构，然后就可以使用上面的方案了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [<span class="string">'row1'</span>, <span class="string">'row2'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="listRow"><a href="#listRow" class="headerlink" title="listRow"></a>listRow</h2><h3 id="需求：内容可以是TreeList-与-Grid"><a href="#需求：内容可以是TreeList-与-Grid" class="headerlink" title="需求：内容可以是TreeList 与 Grid"></a>需求：内容可以是TreeList 与 Grid</h3><p>由 《edit与search的无法调和是一切暗黑的源头》决定了 demo采用 《终极方案–forceUpdate+实时生成render最新props+对象引用》的方式。<br>接着考虑下面的需求：ListBuilder内的组件可以是 TreeList 与 Grid，且 ListBuilder要将向左向右移动的公共逻辑抽象出来。</p><h3 id="TreeList与Grid数据结构不一样"><a href="#TreeList与Grid数据结构不一样" class="headerlink" title="TreeList与Grid数据结构不一样"></a>TreeList与Grid数据结构不一样</h3><p>此时我们面临着一个问题，TreeList与Grid的数据结构是不一样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> gridData = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'row1'</span>, <span class="attr">value</span>: <span class="string">'r1'</span>, <span class="attr">visable</span>: ture&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'row2'</span>, <span class="attr">value</span>: <span class="string">'r3'</span>, <span class="attr">visable</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> treeData = [</span><br><span class="line">    &#123;<span class="attr">isBranch</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">'branch-name'</span>, <span class="attr">children</span>: [<span class="string">'tree-cell1'</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">isBranch</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">'tree-cell1'</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="ListBuilder向左-右移动逻辑不需关心数据结构"><a href="#ListBuilder向左-右移动逻辑不需关心数据结构" class="headerlink" title="ListBuilder向左\右移动逻辑不需关心数据结构"></a>ListBuilder向左\右移动逻辑不需关心数据结构</h3><p>不过另外一个方面，向左，向右但移动逻辑根本不需要关心TreeList与Grid所用的数据结构，我们是不是可以新建一种专门用于左右移动的数据结构呢。在ListBuilder内使用ListRow数据的state进行左右移动，在给具体TreeList、Grid时，在Render函数内，将ListRow转换为上面格式的gridData、treeData。<br>基于此想法，我们创建了ListRow这种数据结构。</p><h3 id="创建ListRow的data"><a href="#创建ListRow的data" class="headerlink" title="创建ListRow的data"></a>创建ListRow的data</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListRow</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key, row)&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataRow= row;</span><br><span class="line">        <span class="keyword">this</span>._id_ = key;</span><br><span class="line">        <span class="keyword">this</span>.visable = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = data.map(<span class="function"><span class="params">row</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newRow = <span class="keyword">new</span> ListRow(row);</span><br><span class="line">    newRow.visable = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> newRow;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="标记删除而不直接删除-左右移动"><a href="#标记删除而不直接删除-左右移动" class="headerlink" title="标记删除而不直接删除 - 左右移动"></a>标记删除而不直接删除 - 左右移动</h3><p>由于我们在render的时候总是通过function 读取 data，重新生成 grid等真正使用的data，所以，我们并不需要直接删除data，而只需给data内的ListRow加一个visable属性，来标记删除。</p><h3 id="visable可用于search、左右移动。"><a href="#visable可用于search、左右移动。" class="headerlink" title="visable可用于search、左右移动。"></a>visable可用于search、左右移动。</h3><p>见上面的分析。</p><h3 id="必须配合render时实时重新生成props"><a href="#必须配合render时实时重新生成props" class="headerlink" title="必须配合render时实时重新生成props"></a>必须配合render时实时重新生成props</h3><p>由上面分析可知，专门创建一个ListRow数据来做左右移动，然后在render的时候，必须同时使用function重新生成Grid或TreeList需要的数据，以传给它们。</p><h3 id="ListRow的好处"><a href="#ListRow的好处" class="headerlink" title="ListRow的好处"></a>ListRow的好处</h3><h4 id="隔绝了业务逻辑影响"><a href="#隔绝了业务逻辑影响" class="headerlink" title="隔绝了业务逻辑影响"></a>隔绝了业务逻辑影响</h4><p>创建一个listRow后，ListBuilder组件不需要关心业务当中到底是Grid或TreeList。</p><h4 id="ListBuilder可凭ListRow专心抽象公共逻辑"><a href="#ListBuilder可凭ListRow专心抽象公共逻辑" class="headerlink" title="ListBuilder可凭ListRow专心抽象公共逻辑"></a>ListBuilder可凭ListRow专心抽象公共逻辑</h4><p>ListRow是专门为了search、左右移动而创建的数据结构，ListBuilder可以因此专心抽象这部分的公共逻辑。</p><h4 id="注意，必须配合render时实时重新生成props"><a href="#注意，必须配合render时实时重新生成props" class="headerlink" title="注意，必须配合render时实时重新生成props"></a>注意，必须配合render时实时重新生成props</h4><p>这不是listRow的好处，但此时再次提醒，说明了创建ListRow的代价也好，使用特点也好，都render具体组件时，都需要render函数内实时重新生成props。<br><figure class="image-box">                <img src="/image/react/list_row.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="使用特点与弊端"><a href="#使用特点与弊端" class="headerlink" title="使用特点与弊端"></a>使用特点与弊端</h3><p>参考 《ListRow的好处 — 注意，必须配合render时实时重新生成props》，render函数内实时重新生成props是一种反模式运用。可能也是一个弊端，但当前浏览器对于同步代码执行效率太好，感觉总是谈性能的，就好像一个伪命题一样</p><h2 id="组件的模版设计"><a href="#组件的模版设计" class="headerlink" title="组件的模版设计"></a>组件的模版设计</h2><h3 id="组件模版设计图"><a href="#组件模版设计图" class="headerlink" title="组件模版设计图"></a>组件模版设计图</h3><figure class="image-box">                <img src="/image/react/comp.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="暴露给外层的设计"><a href="#暴露给外层的设计" class="headerlink" title="暴露给外层的设计"></a>暴露给外层的设计</h3><p>如上图，因为ListBuilder在内部会封装左右移动，所以外层使用的时候，只需定义业务组件的grid等等这些左右两边面板。</p><h3 id="ListBuilder本身设计"><a href="#ListBuilder本身设计" class="headerlink" title="ListBuilder本身设计"></a>ListBuilder本身设计</h3><p>此处抽象左右移动的公共逻辑</p><h3 id="listPanel设计"><a href="#listPanel设计" class="headerlink" title="listPanel设计"></a>listPanel设计</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>面板的渲染统统在ListPanel组件内，不同的业务组件，如Grid、TreeList，在render函数内，在此使用一个function 生成对应的props，</p><h4 id="render实时重新生成props的好处"><a href="#render实时重新生成props的好处" class="headerlink" title="render实时重新生成props的好处"></a>render实时重新生成props的好处</h4><p>listPanel组件内可以非常方便地获取ListBuilder所有的信息，在实时生成props时，比如生成双击事件的props时，可以将ListBuilder所有的信息可以非常方便的传给双击事件这个props属性。</p><h4 id="业务代码通过function-config注入"><a href="#业务代码通过function-config注入" class="headerlink" title="业务代码通过function config注入"></a>业务代码通过function config注入</h4><p>Grid、TreeList组件的特定props(业务层面逻辑)可在此通过config配置的方式注入，由render 时，每次执行function(config)注入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ListPanel</span></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">const</span> allProps = Fn(config)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;SearchBox /&gt;</span><br><span class="line">      &lt;Grid &#123;...allProps&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="React-cloneElement"><a href="#React-cloneElement" class="headerlink" title="React.cloneElement"></a>React.cloneElement</h2><h3 id="cloneElement让模版设计成为可能"><a href="#cloneElement让模版设计成为可能" class="headerlink" title="cloneElement让模版设计成为可能"></a>cloneElement让模版设计成为可能</h3><h4 id="只要传组件进来，我就能给你组装"><a href="#只要传组件进来，我就能给你组装" class="headerlink" title="只要传组件进来，我就能给你组装"></a>只要传组件进来，我就能给你组装</h4><p>无论你通过什么方式将组件传给ListBuilder，通过props也好，还是child也好，在ListBuilder内部都可以通过React.cloneElement将组件再次组装，重新render。</p><h4 id="cloneElement再次组装props非常方便"><a href="#cloneElement再次组装props非常方便" class="headerlink" title="cloneElement再次组装props非常方便"></a>cloneElement再次组装props非常方便</h4><p>这是cloneElement的特性。</p><h3 id="cloneElement的其他好处"><a href="#cloneElement的其他好处" class="headerlink" title="cloneElement的其他好处"></a>cloneElement的其他好处</h3><h4 id="很方便地给props增加其他组件的数据"><a href="#很方便地给props增加其他组件的数据" class="headerlink" title="很方便地给props增加其他组件的数据"></a>很方便地给props增加其他组件的数据</h4><p>比如可以很方便地将父层的function，state，props，注入到被组装的组件中。</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="props同时为function和string"><a href="#props同时为function和string" class="headerlink" title="props同时为function和string"></a>props同时为function和string</h3><p>比如给一个ListRow指定一个唯一Id，假如有identity 这个props，定义identity为 str时， id为 <code>ListRow[identity]</code>,当为function时，id为identity(ListRow).<br>我们在设置props属性时，一般希望此属性最好是一种类型，不要设置多种，但是可以function是一个例外，可以给props设置多一个function属性，因为很function让程序<strong>更灵活，扩展性强</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123;identity&#125; = this.props;</span><br><span class="line">typeof identity === &apos;function&apos; ? identity(ListRow) : ListRow[identity]</span><br></pre></td></tr></table></figure></p><h3 id="map的使用"><a href="#map的使用" class="headerlink" title="map的使用"></a>map的使用</h3><p>如果左右两边的数据有映射关系，要关注下map的方式来做数据映射信息存储。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>listBuilder最精彩的运用之一在于：</p><ul><li>通过render实时生成最新props代替setState，</li><li>通过创建一个全新的数据结构ListRow 来隔离业务逻辑，专心公共逻辑的抽象</li><li>React.cloneElement精彩运用</li><li>不要认为render实时生成最新props会影响性能，要想功能丰富，可以考虑此方案。<br>诚然，这样写，会导致多次渲染和不必要计算，貌似会影响性能，但相比高效的浏览器来，静态代码的执行，可能是一个伪命题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react-redux笔记</title>
      <link href="/2021/01/03/react_redux/"/>
      <url>/2021/01/03/react_redux/</url>
      
        <content type="html"><![CDATA[<h2 id="react-redux-源码解读"><a href="#react-redux-源码解读" class="headerlink" title="react-redux 源码解读"></a>react-redux 源码解读</h2><p>这些博客是我以前写在csdn的，现在将博客地址放在这里。阅读的react-redux的版本为5.0.7</p><h3 id="react-redux-源码解读之connect的selector布局"><a href="#react-redux-源码解读之connect的selector布局" class="headerlink" title="react-redux 源码解读之connect的selector布局"></a>react-redux 源码解读之connect的selector布局</h3><p>参考<a href="https://blog.csdn.net/ybdt1201/article/details/83759641" target="_blank" rel="noopener">react-redux 源码解读之connect的selector布局</a></p><h3 id="react-redux-源码解读之connect的mapStateToProps"><a href="#react-redux-源码解读之connect的mapStateToProps" class="headerlink" title="react-redux 源码解读之connect的mapStateToProps"></a>react-redux 源码解读之connect的mapStateToProps</h3><p>参考<a href="https://blog.csdn.net/ybdt1201/article/details/84201064" target="_blank" rel="noopener">react-redux 源码解读之connect的mapStateToProps</a></p><h3 id="react-redux-源码解读之connect的mapDispatchToProps"><a href="#react-redux-源码解读之connect的mapDispatchToProps" class="headerlink" title="react-redux 源码解读之connect的mapDispatchToProps"></a>react-redux 源码解读之connect的mapDispatchToProps</h3><p>参考<a href="https://blog.csdn.net/ybdt1201/article/details/84279996" target="_blank" rel="noopener">react-redux 源码解读之connect的mapDispatchToProps</a></p><h3 id="react-redux-源码解读体会拾遗"><a href="#react-redux-源码解读体会拾遗" class="headerlink" title="react-redux 源码解读体会拾遗"></a>react-redux 源码解读体会拾遗</h3><p>参考<a href="https://blog.csdn.net/ybdt1201/article/details/84350232" target="_blank" rel="noopener">react-redux 源码解读体会拾遗</a></p><h2 id="为什么要整理笔记"><a href="#为什么要整理笔记" class="headerlink" title="为什么要整理笔记"></a>为什么要整理笔记</h2><p>原本以为有过这么多的项目经验，加上前年的时候也看过react-redux的源码，我对react-redux应该记忆是深刻的。<br>无奈，最近使用了react-redux的hooks，发现了一些疑问，需要与之前非hooks的方式进行对比，可却发现我对以前的非hooks版本细节忘得差不多了，细节觉得成败啊。<br>于是今天花了小半天对比了5.0.7与最新react-redux版本，对知识做了梳理，为免再次忘却，也为了便于下次查阅，秉着好记性不如烂笔头，特此笔记之。<br><strong>注意的是，我对react-redux 5.0.7版本源码熟悉，对hooks 版本的react-redux 还没有看过，以下结论，涉及到hooks，都是从试验中得出</strong></p><h2 id="react-redux知识概要"><a href="#react-redux知识概要" class="headerlink" title="react-redux知识概要"></a>react-redux知识概要</h2><h3 id="shallowEqual-与-props的浅比较"><a href="#shallowEqual-与-props的浅比较" class="headerlink" title="shallowEqual 与 props的浅比较"></a>shallowEqual 与 props的浅比较</h3><p>shallowEqual是react-redux用于比较props各个属性的，react-redux比较props时，通过 shallowEqual 只比较props的每个属性，一种浅比较方式。<br>shallowEqual除了react-redux自己使用，也可作为工具函数使用，是一个react-redux对外的API，其代码比较简洁，是一个考虑很周全的对象属性比较工具函数。</p><h3 id="connect-拥有的能力"><a href="#connect-拥有的能力" class="headerlink" title="connect 拥有的能力"></a>connect 拥有的能力</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>connect就是一个高阶组件，每个使用了connect的组件形式如下，每个组件如果结合connect后，将具备如下能力(这些能力也是connect的能力)：</p><ul><li>shouldComponentUpdate 结合shallowEqual函数对props进行浅层比较优化</li><li>监听store变化的能力<br>如下代码中，通过 new Subscription 可监听store的变化，当你发送一个dispatch后，每个使用connect的组件有能力监听到store是否变化。</li><li>若全局的store变化，整个项目所有组件的mapStatetoProps都会被执行<br>因为disptch必然导致全局的store数据变化，因此dispatch后，整个项目的所有mapStateToProps会被执行，当然了，有些dispatch并不会改变store，那么。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapWithConnect</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>(props, context) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props, context)</span><br><span class="line">        <span class="keyword">this</span>.initSelector()</span><br><span class="line">        <span class="keyword">this</span>.initSubscription()</span><br><span class="line">      &#125;</span><br><span class="line">      componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">          <span class="comment">//this.selector.run做以下几个事情：</span></span><br><span class="line">            <span class="comment">//   1.通过shallowEqual对props各属性比较后得出this.selector.shouldComponentUpdate值；</span></span><br><span class="line">            <span class="comment">//   2.执行mapStateToProps，因为要比较mapStateToProps执行后得到的props；</span></span><br><span class="line">        <span class="keyword">this</span>.selector.run(nextProps)</span><br><span class="line">      &#125;</span><br><span class="line">      shouldComponentUpdate() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.selector.shouldComponentUpdate</span><br><span class="line">      &#125;</span><br><span class="line">      initSubscription() &#123;</span><br><span class="line">           <span class="comment">//初始化store变化的监听：</span></span><br><span class="line">        <span class="keyword">this</span>.subscription = <span class="keyword">new</span> Subscription(<span class="keyword">this</span>.store, parentSub, <span class="keyword">this</span>.onStateChange.bind(<span class="keyword">this</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      onStateChange() &#123;</span><br><span class="line">        <span class="comment">//   若变化，将执行 run，获取 shouldComponentUpdate 的值，并是否通过setState让组件render</span></span><br><span class="line">        <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.selector.shouldComponentUpdate) &#123;</span><br><span class="line">          <span class="keyword">this</span>.notifyNestedSubs()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.componentDidUpdate = <span class="keyword">this</span>.notifyNestedSubsOnComponentDidUpdate</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">const</span> selector = <span class="keyword">this</span>.selector</span><br><span class="line">        <span class="comment">//render后，记得将 shouldComponentUpdate 值重置为 false</span></span><br><span class="line">        selector.shouldComponentUpdate = <span class="literal">false</span></span><br><span class="line">         <span class="keyword">return</span> createElement(WrappedComponent, <span class="keyword">this</span>.addExtraProps(selector.props))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="shouldComponentUpdate优化"><a href="#shouldComponentUpdate优化" class="headerlink" title="shouldComponentUpdate优化"></a>shouldComponentUpdate优化</h4><p>参考上面的《概要》</p><h4 id="监听store变化的能力"><a href="#监听store变化的能力" class="headerlink" title="监听store变化的能力"></a>监听store变化的能力</h4><p>参考上面的《概要》</p><h4 id="比较props并判断是否render的能力"><a href="#比较props并判断是否render的能力" class="headerlink" title="比较props并判断是否render的能力"></a>比较props并判断是否render的能力</h4><p>参考上面的《概要》</p><h3 id="分清props类别很必要"><a href="#分清props类别很必要" class="headerlink" title="分清props类别很必要"></a>分清props类别很必要</h3><p>参考下面《ownerprops、mapState props、dispatch props》<br>参考下面《 render与否参考mapStatetoprops的结果，而非组件所有的props》</p><h3 id="ownerprops、mapState-props、dispatch-props"><a href="#ownerprops、mapState-props、dispatch-props" class="headerlink" title="ownerprops、mapState props、dispatch props"></a>ownerprops、mapState props、dispatch props</h3><p>connect组件的props有： ownerprops、mapState的props、dispatch的props：</p><p>ownerprops是指父组件引用组件时定义在react元素上的props属性；<br>mapState props是指 mapStatetoprops函数执行完后形成的props；<br>dispatch props是指 mapDispatchToProps定义的props；<br>三者定义的不同导致了一些特性：<br>ownnerprops基本上受父亲组件render时而变化；<br>mapState props 受dispatch时变化；<br>dispatch props 在组件装载时就确定好了，直到组件卸载都不会变化。</p><h3 id="dispatch后相关的事情"><a href="#dispatch后相关的事情" class="headerlink" title="dispatch后相关的事情"></a>dispatch后相关的事情</h3><h4 id="父层和子层的是否会render"><a href="#父层和子层的是否会render" class="headerlink" title="父层和子层的是否会render"></a>父层和子层的是否会render</h4><p>这里的dispatch指的是会改变store变化的那种，dispatch后，项目中无论祖先父子儿孙兄弟组件，只要你使用了connect，那么都会触发connect组件内的监听Subscription，<br>组件就会让mapStatetoprops执行，获取到执行结果后，组件将得到ownerprops、mapState props、 dispatch props；<br>由于ownerprops只有父亲组件render时才会改变；dispatch props只有在组件装载时才会改变；<br>这两种props在dispatch的时候，都不会改变；<br>因此是否render将只与mapState props有关，也就是mapStatetoprops执行结果有关。<br>不过凡事有例外，万一其他两中props改变来呢，具体情况需要具体看待。<br>如果mapStatetoprops执行的结果跟上次的结果不一样，那么就会触发本组件render。</p><p>小结下：当dispatch后，<strong>改变了store的state</strong>，那么一定会触发 mapStatetoprops 的执行，而且是项目内所有connect组件的mapStatetoprops，不分父子兄弟，都将执行，render与否，只与本组件的mapStatetoprops的结果对比有关</p><h4 id="dispatch后会触发mapStatetoprops"><a href="#dispatch后会触发mapStatetoprops" class="headerlink" title="dispatch后会触发mapStatetoprops"></a>dispatch后会触发mapStatetoprops</h4><p>为什么dispatch后会触发mapStatetoprops的执行。<br>其实这句话，说的不严谨，dispatch后，只有改变了store.getState才会触发 mapStateToProps；<br>这是react-redux机制，dispatch后，如果改变了 store.getState，才会触发Connect组件内的状态改变监听事件，<br>该监听事件会比较两次的props，从而决定是否render；<br>要比较就要获取props，其中在获取mapState props时，react-redux会比较store.getState，如果store没有改变，就认为mapState没有改变，就返回上一次的mapState；如果store改变了，需要从 mapStateToProps 执行得来最新的mapState，从而触发了 mapStateToProps的执行；</p><p>因此，只要dispatch改变了store，就一定触发每个组件的 mapStateToProps执行。<br>如果没有改变store，也不会触发 mapStateToProps的执行。</p><h4 id="dispatch不一定会触发mapStatetoprops"><a href="#dispatch不一定会触发mapStatetoprops" class="headerlink" title="dispatch不一定会触发mapStatetoprops"></a>dispatch不一定会触发mapStatetoprops</h4><p>参考《为什么dispatch后会触发mapStatetoprops》</p><h4 id="render与否可认为只看mapStatetoprops的结果"><a href="#render与否可认为只看mapStatetoprops的结果" class="headerlink" title="render与否可认为只看mapStatetoprops的结果"></a>render与否可认为只看mapStatetoprops的结果</h4><p>render与否本来是要对比 所有种类的props，但由于dispatch的时候，ownerprops与dispatch props 不会改变，因此只与剩下的 mapState props有关。<br>因此render与否 可认为只看mapStatetoprops的结果。<br>更多参考《父层和子层的是否会render》</p><h4 id="render与否不受外界-Connect-影响"><a href="#render与否不受外界-Connect-影响" class="headerlink" title="render与否不受外界(Connect)影响"></a>render与否不受外界(Connect)影响</h4><p>有些人认为在祖先、父亲、子孙 组件内可能也使用了Connect；<br>那么自己的Connect组件，在自己dispatch的时候，自己组件是否render会受他们的影响吗；<br>这肯定是不影响的，因为自己dispatch的时候，改变的是全局变量Store.getState，当dispatch完后，你就与其他组件是一样的了，<br>你就会跟其他Connect组件一样，利用监听是否有变化，执行mapstatetoprops，比对masState props，若变化自己将render，反之则不render，根本不受其他组件是否有Connect影响。<br>更多参考《父层和子层的是否会render》</p><h4 id="是不是所有-mapStatetoprops-会执行"><a href="#是不是所有-mapStatetoprops-会执行" class="headerlink" title="是不是所有 mapStatetoprops 会执行"></a>是不是所有 mapStatetoprops 会执行</h4><p>是的，参考《父层和子层的是否会render》</p><h3 id="反模式下-父级与dispatch驱动的render的奇怪差异"><a href="#反模式下-父级与dispatch驱动的render的奇怪差异" class="headerlink" title="反模式下 父级与dispatch驱动的render的奇怪差异"></a>反模式下 父级与dispatch驱动的render的奇怪差异</h3><p>一个Connect组件，如下在父组件下引用时定义了一个反模式的test1属性：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connect test1=&#123;[]&#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>此时，只要父组件render，都会导致Connect组件render；<br>但是，在Connect组件内，如果你dispatch，如果你的mapState的props没有变化，就不会导致组件render，这就是二者render的差异性所在；<br>原因在于，父组件render时，给test1每次都赋值一个新的数组，造成ownerProps改变；<br>dispatch的时候，父组件不会render，test1的数组一直指向上一次父组件render创建的数组，因此不会render；</p><h3 id="mapStatetoprops的触发时机"><a href="#mapStatetoprops的触发时机" class="headerlink" title="mapStatetoprops的触发时机"></a>mapStatetoprops的触发时机</h3><h4 id="父级驱动的render不触发mapStatetoprops执行"><a href="#父级驱动的render不触发mapStatetoprops执行" class="headerlink" title="父级驱动的render不触发mapStatetoprops执行"></a>父级驱动的render不触发mapStatetoprops执行</h4><p>父级与dispatch驱动的render都会执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.selector.run(nextProps)</span><br></pre></td></tr></table></figure></p><p>可以通过上面wrapWithConnect组件的代码看出：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">   <span class="keyword">this</span>.selector.run(nextProps)</span><br><span class="line"> &#125;</span><br><span class="line"> initSubscription() &#123;</span><br><span class="line">   <span class="keyword">this</span>.subscription = <span class="keyword">new</span> Subscription(<span class="keyword">this</span>.store, parentSub, <span class="keyword">this</span>.onStateChange.bind(<span class="keyword">this</span>))</span><br><span class="line"> &#125;</span><br><span class="line"> onStateChange() &#123;</span><br><span class="line">   <span class="keyword">this</span>.selector.run(<span class="keyword">this</span>.props)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>为什么父级驱动render不触发mapStatetoprops执行，而dispatch会触发呢。<br>这与react-redux的机制有关，在run的后续一系列代码中，会比较store.getState()，如果发生变化，就会进一步执行 mapStatetoprops 来获取最新的mapState props；如果没有变化就不执行；<br>这两种render中，只有dispatch会导致store的变化。而父级驱动的render则不会。</p><h4 id="dispatch驱动的render触发mapStatetoprops执行"><a href="#dispatch驱动的render触发mapStatetoprops执行" class="headerlink" title="dispatch驱动的render触发mapStatetoprops执行"></a>dispatch驱动的render触发mapStatetoprops执行</h4><p>参考《父级驱动的render不触发mapStatetoprops执行》</p><h4 id="store改变肯定触发mapStatetoprops执行"><a href="#store改变肯定触发mapStatetoprops执行" class="headerlink" title="store改变肯定触发mapStatetoprops执行"></a>store改变肯定触发mapStatetoprops执行</h4><p>要想store改变只有dispatch，dispatch不一定产生store变动，一旦store改变，一定触发mapStatetoprops执行。<br>更多参考《父级驱动的render不触发mapStatetoprops执行》</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>有上面分析可知，mapStateToProp只在store改变时才会执行，而store的改变只与dispatch有关，因此只有dispatch时，且改变了store时，才会触发mapStateToProp的执行。</p><h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><h3 id="hooks、Connect-原理基本一致"><a href="#hooks、Connect-原理基本一致" class="headerlink" title="hooks、Connect 原理基本一致"></a>hooks、Connect 原理基本一致</h3><p>react-redux的用法有 传统的Connect用法，以及 新的hooks用法。<br>他们二者的原理基本一致，</p><h3 id="useDispatch"><a href="#useDispatch" class="headerlink" title="useDispatch"></a>useDispatch</h3><p>useDispatch 时，<br>如果改变了store，则会触发所有的 useSelector 与 mapStateToProp 的执行；<br>组件是否render，根据各自的 useSelector、mapStateToProp执行结果决定；</p><h3 id="useSelector-触发时机："><a href="#useSelector-触发时机：" class="headerlink" title="useSelector 触发时机："></a>useSelector 触发时机：</h3><p>当组件render时；<br>当有组件dipatch时，无论是否改变store，都会执行；<br>与mapStateToProp不一样的地方：<br>第一：mapStateToProp不会在render的时候执行； 第二：mapStateToProp 只会在store变化时才执行  参考《mapStatetoprops的触发时机》。<br>因此如果同一个项目中，有的组件你用的是Connect，有些用的是useSelector，当你dispatch，不过未改变store的时候，你会发现useSelector执行了，mapStateToProp未执行。</p><h3 id="useSelector-产生的作用"><a href="#useSelector-产生的作用" class="headerlink" title="useSelector 产生的作用"></a>useSelector 产生的作用</h3><p>ccc与mapStateToProp这点一样，执行的结果如果改变，将会触发组件render，否则就不会。</p><h3 id="useSelector-常用错误用法"><a href="#useSelector-常用错误用法" class="headerlink" title="useSelector 常用错误用法"></a>useSelector 常用错误用法</h3><h4 id="返回一个新构造的对象"><a href="#返回一个新构造的对象" class="headerlink" title="返回一个新构造的对象"></a>返回一个新构造的对象</h4><p>以下两种错误用法，会导致组件在dispatch的时候，总是刷新，因为下面两种方式useSelector执行的结果都是一个新建的对象。这样造成前后两次比较的时候认为变化了： <code>{} !== {}</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> courses = useSelector(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;test, data&#125; = useSelector(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">test</span>:state.test, <span class="attr">data</span>:state.data&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="hooks与Connect的区别"><a href="#hooks与Connect的区别" class="headerlink" title="hooks与Connect的区别"></a>hooks与Connect的区别</h3><p>hooks组件其行为还是类似一个纯函数组件，没有像Connect一样对组件以高阶组件的形式包裹，没有做shouldComponentUpdate优化。</p><h3 id="新旧版本的Connect异同"><a href="#新旧版本的Connect异同" class="headerlink" title="新旧版本的Connect异同"></a>新旧版本的Connect异同</h3><p>新版本的react-redux的Connect与旧版本的Connect，使用方法及产生的现象没有什么差别。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a><a href="">官网</a></h3><h3 id="React-Redux-官方-Hooks-文档说明"><a href="#React-Redux-官方-Hooks-文档说明" class="headerlink" title="React-Redux 官方 Hooks 文档说明"></a><a href="http://react-china.org/t/topic/34076/1" target="_blank" rel="noopener">React-Redux 官方 Hooks 文档说明</a></h3><h3 id="react-redux-hooks-demo"><a href="#react-redux-hooks-demo" class="headerlink" title="react-redux-hooks demo"></a><a href="https://github.com/YeWills/react-redux-hooks-demo/commits/blog-demo" target="_blank" rel="noopener">react-redux-hooks demo</a></h3><h3 id="react-redux-5-0-7-demo"><a href="#react-redux-5-0-7-demo" class="headerlink" title="react-redux 5.0.7 demo"></a><a href="https://github.com/YeWills/test-react-redux" target="_blank" rel="noopener">react-redux 5.0.7 demo</a></h3>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
          <category> react-redux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react react-redux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则表达式</title>
      <link href="/2021/01/03/regex/"/>
      <url>/2021/01/03/regex/</url>
      
        <content type="html"><![CDATA[<p>用正则久矣，一直想出一篇这方面的笔记，用来记录<strong>重难点</strong>。<br>博客重度参考慕课教程<a href="https://www.imooc.com/coursescore/706" target="_blank" rel="noopener">JavaScript正则表达式</a></p><h3 id="regexper-com"><a href="#regexper-com" class="headerlink" title="regexper.com"></a>regexper.com</h3><p>这是一个很好的正则网址，此网不会用，可能显得不上档次？<a href="https://regexper.com/" target="_blank" rel="noopener">regexper.com</a>，这个网址如果受外网限制不好访问的话，也可通过npm安装到本地访问，具体谷歌或看上面的慕课教程。<br><figure class="image-box">                <img src="/image/regex/com.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="m-多行搜索"><a href="#m-多行搜索" class="headerlink" title="m 多行搜索"></a>m 多行搜索</h3><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>正则有如下修饰符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g:global 全文搜索 不添加只搜索第一个匹配即停止</span><br><span class="line">i : ignore case 忽略大小写 默认是大小写敏感</span><br><span class="line">m: multiple lines  多行搜索</span><br></pre></td></tr></table></figure></p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>使用多行修饰符后，就可以匹配每一行的^开头字符。<br><figure class="image-box">                <img src="/image/regex/mult.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><h4 id="t-tab"><a href="#t-tab" class="headerlink" title="\t tab"></a>\t tab</h4><p>此符号，在mac下按下一个tab键，使用下面表达式不成立，在有些电脑上又可以，目前尚不知原因。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\t/.test(&apos;    &apos;)</span><br></pre></td></tr></table></figure></p><h3 id="字符类-的概念"><a href="#字符类-的概念" class="headerlink" title="字符类 的概念"></a>字符类 的概念</h3><ul><li>我们可以使用元字符[]来构建一个简单类；</li><li>所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符</li><li>表达式[abc]把字符a或b或c归为一类，表达式可以匹配这类字符。</li></ul><h3 id="字符类取反"><a href="#字符类取反" class="headerlink" title="字符类取反"></a>字符类取反</h3><ul><li>使用元字符^创建 反向类／负向类</li><li>反向类的意思是不属于某类的内容</li><li>表达式[^abc]表示 不是字符a或b或c的内容；</li></ul><h3 id="与-范围类"><a href="#与-范围类" class="headerlink" title="- 与 范围类"></a>- 与 范围类</h3><h4 id="常见范围类-a-zA-Z"><a href="#常见范围类-a-zA-Z" class="headerlink" title="常见范围类 [a-zA-Z]"></a>常见范围类 [a-zA-Z]</h4><p>如上，它们通过-来拼接一个范围类；<br>下面的形式通常可以表示一个范围类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符-字符</span><br></pre></td></tr></table></figure></p><p>假如前后字符为 0、9，a、z；那么就被识别，构成一个常见的范围类；<br>因此当-位于两个字符之间时，如果两个字符可以被识别，那么此-具有特殊意义，表示范围类的意思；<br>如果不是位于两个字符之间，-匹配自身-；</p><h4 id="位于两个字符之间时的特殊意义"><a href="#位于两个字符之间时的特殊意义" class="headerlink" title="-位于两个字符之间时的特殊意义"></a>-位于两个字符之间时的特殊意义</h4><p>见上面的说明。</p><h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><p>既然[0-9]表示范围类，正则使用预定义类来预先规定好逻辑直接表示这个范围类，下面是常见预定义类：<br><figure class="image-box">                <img src="/image/regex/before.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="贪婪-非贪婪模式"><a href="#贪婪-非贪婪模式" class="headerlink" title="贪婪\非贪婪模式"></a>贪婪\非贪婪模式</h3><h4 id="贪婪模式-默认"><a href="#贪婪模式-默认" class="headerlink" title="贪婪模式(默认)"></a>贪婪模式(默认)</h4><p>如下，正则可以匹配3到6个，默认情况下正则匹配最大数6，是为贪婪模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;12345678&apos;.replace(/\d&#123;3,6&#125;/g,&apos;X&apos;) //X78</span><br></pre></td></tr></table></figure></p><h4 id="量词后加？变成非贪婪模式"><a href="#量词后加？变成非贪婪模式" class="headerlink" title="量词后加？变成非贪婪模式"></a>量词后加？变成非贪婪模式</h4><p>非贪婪模式指可以匹配3到6个时，指匹配最小值3，{3,6}是量词：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;12345678&apos;.replace(/\d&#123;3,6&#125;?/g,&apos;X&apos;) //XX78</span><br></pre></td></tr></table></figure></p><h3 id="分组与或"><a href="#分组与或" class="headerlink" title="分组与或"></a>分组与或</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><figure class="image-box">                <img src="/image/regex/group2.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="忽略分组"><a href="#忽略分组" class="headerlink" title="忽略分组 (?:)"></a>忽略分组 (?:)</h4><figure class="image-box">                <img src="/image/regex/group3.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="或与分组"><a href="#或与分组" class="headerlink" title="或与分组"></a>或与分组</h4><figure class="image-box">                <img src="/image/regex/group1.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><figure class="image-box">                <img src="/image/regex/above.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a2*aa'</span>.replace(<span class="regexp">/\w(?=\d)/</span>,<span class="string">'H'</span>)    <span class="comment">//正向前瞻 "H2*aa"单词字符后面是数字的</span></span><br><span class="line"></span><br><span class="line"><span class="string">'dd4sfc'</span>.replace(<span class="regexp">/\w(?!\d)/</span>,<span class="string">'G'</span>);    <span class="comment">//负向前瞻 "Gd4sfc"单词字符后面不是数字的</span></span><br></pre></td></tr></table></figure><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>如上图片里面的 assert就是断言，断言是一个表达式，可运用与 正向前瞻和后向前瞻。</p><h4 id="正向与负向的难理解性"><a href="#正向与负向的难理解性" class="headerlink" title="正向与负向的难理解性"></a>正向与负向的难理解性</h4><p>刚开始听到正向负向会理解成其他意思，其实就是后面匹配断言assert与匹配相反的断言assert；<br>也可以说成是后面匹配断言的正向表达意思，和匹配 断言的负向（相反方向）的表达意思；</p><h4 id="正向前瞻"><a href="#正向前瞻" class="headerlink" title="正向前瞻?="></a>正向前瞻?=</h4><p>参考上面概述</p><h4 id="负向前瞻"><a href="#负向前瞻" class="headerlink" title="负向前瞻?!"></a>负向前瞻?!</h4><p>参考上面概述</p><h3 id="正则式的对象性"><a href="#正则式的对象性" class="headerlink" title="正则式的对象性"></a>正则式的对象性</h3><p>每一个正则式都是一个对象（ new RegExp() ）,因此都具有如下属性。</p><ul><li>global：是否全文搜索，默认false</li><li>ignore case：是否大小写敏感，默认是false</li><li>multiline：多行搜索，默认值是false</li><li>lastIndex：当前表达式匹配内容的最后一个字符的下一个位置</li><li>source：正则表达式的文本字符串<figure class="image-box">                <img src="/image/regex/attr.jpg" alt="" title="" class="">                <p></p>            </figure></li></ul><h3 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h3><p>子表达式为正则内的分组，如下有两个子表达式(\w)与(abc)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg4 = /\d(\w)(abc)\d/g;</span><br></pre></td></tr></table></figure></p><h3 id="lastIndex让你怀疑人生"><a href="#lastIndex让你怀疑人生" class="headerlink" title="lastIndex让你怀疑人生"></a>lastIndex让你怀疑人生</h3><h4 id="test的现象"><a href="#test的现象" class="headerlink" title="test的现象"></a>test的现象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//每次执行下面代码都是对的</span><br><span class="line">/\w/g.test(&apos;a&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//每次执行下面代码都是对的</span><br><span class="line">var reg = /\w/g;</span><br><span class="line">reg.test(&apos;a&apos;) //true</span><br><span class="line">reg.test(&apos;a&apos;) //false</span><br><span class="line">reg.test(&apos;a&apos;) //true</span><br><span class="line">reg.test(&apos;a&apos;) //false</span><br></pre></td></tr></table></figure><h4 id="每次test后正则式的lastIndex改变"><a href="#每次test后正则式的lastIndex改变" class="headerlink" title="每次test后正则式的lastIndex改变"></a>每次test后正则式的lastIndex改变</h4><p>如下，reg不仅是正则式，而且是对象，每执行完一次test，都会让reg的lastIndex发生变化，从而在下次匹配时有所不同，产生了不同结果。<br>每一次匹配成功后lastIndex会得到一个非零值，当匹配失败后，lastIndex值将置为零。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//每次执行下面代码都是对的</span><br><span class="line">var reg = /\w/g;  //reg.lastIndex=0</span><br><span class="line">reg.test(&apos;a&apos;) //true //reg.lastIndex=1</span><br><span class="line">reg.test(&apos;a&apos;) //false //reg.lastIndex=1 --&gt; reg.lastIndex=0</span><br><span class="line">reg.test(&apos;a&apos;) //true //reg.lastIndex=1</span><br><span class="line">reg.test(&apos;a&apos;) //false //reg.lastIndex=1 --&gt; reg.lastIndex=0</span><br></pre></td></tr></table></figure></p><h4 id="目前只发现在全局g的正则存在此现象"><a href="#目前只发现在全局g的正则存在此现象" class="headerlink" title="目前只发现在全局g的正则存在此现象"></a>目前只发现在全局g的正则存在此现象</h4><p>如上，目前只存在于g的正则式，非全局尚未发现此现象。因为非全局的lastIndex值都是0，而0有两成意思：第一 从0位置开始匹配；第二 lastIndex无效；所以在非全局下lastIndex可能无效(待考证)</p><h4 id="非全局下lastIndex无效？"><a href="#非全局下lastIndex无效？" class="headerlink" title="非全局下lastIndex无效？"></a>非全局下lastIndex无效？</h4><p>参考上面分析。</p><h4 id="exec也有此现象"><a href="#exec也有此现象" class="headerlink" title="exec也有此现象"></a>exec也有此现象</h4><p>exec也有此现象，其他方法可能还有此现象，原因同test方法一样分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//每次exec执行的结果不一样</span><br><span class="line">var reg4 = /\d(\w)(\w)\d/g;</span><br><span class="line">var str = &quot;$1az2bb3cy4dd5ee&quot;;</span><br><span class="line">reg4.exec(str) //[&quot;1az2&quot;, &quot;a&quot;, &quot;z&quot;] //index: 1</span><br><span class="line">reg4.exec(str) //[&quot;3cy4&quot;, &quot;c&quot;, &quot;y&quot;] //index: 7</span><br></pre></td></tr></table></figure></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>每次匹配前，手动地把lastIndex属性重置为0。</p><h4 id="lastIndex为0的双重意思"><a href="#lastIndex为0的双重意思" class="headerlink" title="lastIndex为0的双重意思"></a>lastIndex为0的双重意思</h4><p>参考《目前只发现在全局g的正则存在此现象》</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><figure class="image-box">                <img src="/image/regex/exec.jpg" alt="" title="" class="">                <p></p>            </figure><p>在非全局匹配模式下，此函数的作用和match()函数是一样的，只能够在字符串中匹配一次，如果没有找到匹配的字符串，那么返回null，否则将返回一个数组。</p><h4 id="子表达式-1"><a href="#子表达式-1" class="headerlink" title="子表达式"></a>子表达式</h4><p>参考《子表达式》</p><h4 id="返回数组内容"><a href="#返回数组内容" class="headerlink" title="返回数组内容"></a>返回数组内容</h4><ul><li>数组的第0个元素存储的是匹配字符串</li><li>第1个元素存放的是第一个引用型分组(子表达式)匹配的字符串，</li><li>第2个元素存放的是第二个引用型分组(子表达式)匹配的字符串，依次类推。<h4 id="返回数组属性"><a href="#返回数组属性" class="headerlink" title="返回数组属性"></a>返回数组属性</h4>返回数组还包括两个对象属性，</li><li>index属性声明的是匹配字符串的起始字符在要匹配的完整字符串中的位置，</li><li>input属性声明的是对要匹配的完整字符串的引用。</li></ul><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><h4 id="是否全局影响很大"><a href="#是否全局影响很大" class="headerlink" title="是否全局影响很大"></a>是否全局影响很大</h4><p>match（）方法将检索字符串，以找到一个或多个与regexp匹配的文本<br>regexp是否具有标志g对结果影响很大</p><h4 id="非全局模式"><a href="#非全局模式" class="headerlink" title="非全局模式"></a>非全局模式</h4><p>如果regexp没有标志g，那么match（）方法就只能在字符串中执行一次匹配，没找到任何匹配文本将返回null，否则将返回一个数组，数组存放了与它找到的匹配文本有关的信息<br>返回数组内容与exec的一致，请参考《exec – 返回数组内容》《exec – 返回数组属性》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var reg4 = /\d(\w)(\w)\d/;</span><br><span class="line">var str = &quot;$1az2bb3cy4dd5ee&quot;;</span><br><span class="line">str.match(reg3) //[&quot;1az2&quot;, &quot;a&quot;, &quot;z&quot;] //index: 1 input: &quot;$1az2bb3cy4dd5ee&quot;</span><br></pre></td></tr></table></figure></p><h4 id="全局模式"><a href="#全局模式" class="headerlink" title="全局模式"></a>全局模式</h4><p>如果regexp具有标志g则match（）方法将执行全局检索，找到字符串中的所有匹配子字符串：没有找到任何匹配的子穿，则返回null，<br>否则返回一个数组，数组元素中存放的是字符串中所有匹配子串，而且也没有index属性或input属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var reg4 = /\d(\w)(\w)\d/g;</span><br><span class="line">var str = &quot;$1az2bb3cy4dd5ee&quot;;</span><br><span class="line">str.match(reg3) //[&quot;1az2&quot;, &quot;3cy4&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="match与exec异同"><a href="#match与exec异同" class="headerlink" title="match与exec异同"></a>match与exec异同</h3><h4 id="在非全局下-二者结果相同"><a href="#在非全局下-二者结果相同" class="headerlink" title="在非全局下 二者结果相同"></a>在非全局下 二者结果相同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg4 = /\d(\w)(\w)\d/;</span><br><span class="line">var str = &quot;$1az2bb3cy4dd5ee&quot;;</span><br><span class="line">reg4.exec(str) //[&quot;1az2&quot;, &quot;a&quot;, &quot;z&quot;, index: 1, input: &quot;$1az2bb3cy4dd5ee&quot;, groups: undefined]</span><br><span class="line">str.match(reg4) //[&quot;1az2&quot;, &quot;a&quot;, &quot;z&quot;, index: 1, input: &quot;$1az2bb3cy4dd5ee&quot;, groups: undefined]</span><br></pre></td></tr></table></figure><h4 id="在全局下，有差别"><a href="#在全局下，有差别" class="headerlink" title="在全局下，有差别"></a>在全局下，有差别</h4><p>全局下，exec返回的结果格式与非全局下一样；但match却只返回匹配的文本，不再返回子表达式信息。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="s匹配空白而不仅仅空格"><a href="#s匹配空白而不仅仅空格" class="headerlink" title="\s匹配空白而不仅仅空格"></a>\s匹配空白而不仅仅空格</h4><p>以下都成立：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/\s/.test(<span class="string">'\n'</span>)</span><br><span class="line">/\s/.test(<span class="string">'\r'</span>) <span class="comment">//回车</span></span><br><span class="line">/\s/.test(<span class="string">' '</span>)</span><br><span class="line">/\s/.test(<span class="string">'\xA0'</span>) <span class="comment">//\xA0就是&amp;nbsp;</span></span><br></pre></td></tr></table></figure></p><h4 id="常见元字符"><a href="#常见元字符" class="headerlink" title="常见元字符"></a>常见元字符</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">点击mdn查看</a></p><h4 id="split-reg"><a href="#split-reg" class="headerlink" title="split(reg)"></a>split(reg)</h4><p>除了字符串，也可以使用正则来split。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;1b3c4d&apos;.split(/\d/) //[&quot;&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">mdn</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>svg笔记</title>
      <link href="/2021/01/03/svg/"/>
      <url>/2021/01/03/svg/</url>
      
        <content type="html"><![CDATA[<h2 id="svg知识"><a href="#svg知识" class="headerlink" title="svg知识"></a>svg知识</h2><h3 id="常见的svg标签"><a href="#常见的svg标签" class="headerlink" title="常见的svg标签"></a>常见的svg标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;600&quot; height=&quot;600&quot; version=&quot;1.1&quot;&gt;</span><br><span class="line">    &lt;defs&gt;</span><br><span class="line">        &lt;marker id=&quot;marker&quot; markerWidth=&quot;10&quot; markerHeight=&quot;10&quot; refX=&quot;4&quot; refY=&quot;4&quot; orient=&quot;auto&quot;&gt;</span><br><span class="line">            &lt;path d=&quot;M 0 0 4 4 0 8&quot; style=&quot;fill:none;stroke:black;&quot;/&gt;</span><br><span class="line">        &lt;/marker&gt;</span><br><span class="line">    &lt;/defs&gt;</span><br><span class="line">    //矩形  --可用于生成直方图</span><br><span class="line">    &lt;rect width=&quot;200&quot; height=&quot;100&quot; x=&quot;20&quot; y=&quot;20&quot; style=&quot;fill:red;stroke:blue;stroke-width:4&quot;/&gt;</span><br><span class="line">    &lt;rect width=&quot;200&quot; height=&quot;100&quot; x=&quot;250&quot; y=&quot;20&quot; rx=&quot;20&quot; ry=&quot;20&quot; style=&quot;fill:red;stroke:blue;stroke-width:4&quot;/&gt;</span><br><span class="line">    &lt;circle cx=&quot;100&quot; cy=&quot;280&quot; r=&quot;80&quot; style=&quot;fill:yellow&quot;/&gt;</span><br><span class="line">    //椭圆</span><br><span class="line">    &lt;ellipse cx=&quot;330&quot; cy=&quot;280&quot; rx=&quot;100&quot; ry=&quot;80&quot; style=&quot;fill:yellow&quot;/&gt;</span><br><span class="line">    //直线</span><br><span class="line">    &lt;line x1=&quot;0&quot; x2=&quot;360&quot; y1=&quot;0&quot; y2=&quot;360&quot; style=&quot;stroke:#000;stroke-width:4;marker-end:url(#marker);&quot;/&gt;</span><br><span class="line">    //多边形比如三角形、矩形、梯形、多边形，会自动闭合</span><br><span class="line">    &lt;polygon points=&quot;25 10,10 40, 50 27&quot; style=&quot;fill:green;stroke:orange;stroke-width:4&quot;/&gt;</span><br><span class="line">    //折线 也可以画多边形， 不会自动闭合</span><br><span class="line">    &lt;polyline points=&quot;25 10,10 40, 50 27&quot; style=&quot;fill:green;stroke:orange;stroke-width:4&quot; transform=&quot;translate(100,0)&quot;/&gt;</span><br><span class="line">    &lt;text x=&quot;200&quot; y=&quot;150&quot; style=&quot;fill:purple;font-size:60;&quot; textLength=&quot;300&quot;&gt;</span><br><span class="line">        I love &lt;tspan fill=&quot;green&quot;&gt;D3.js&lt;/tspan&gt;</span><br><span class="line">    &lt;/text&gt;</span><br><span class="line">    //万能path，能画任何线条</span><br><span class="line">    &lt;path d=&quot;M 200 200 A 200 200 0 0 1 400 400&quot; style=&quot;fill:none;stroke:orange;stroke-width:10;&quot; /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><h3 id="xmlns-与-version"><a href="#xmlns-与-version" class="headerlink" title="xmlns 与 version"></a>xmlns 与 version</h3><p>xmlns是固定写法，固定值如下，version也是固定写法，最近的版本就是1.1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;600&quot; height=&quot;600&quot; version=&quot;1.1&quot;&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></p><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><h4 id="path命令基本规律："><a href="#path命令基本规律：" class="headerlink" title="path命令基本规律："></a>path命令基本规律：</h4><p>1.区分大小写：大写表示坐标参数为绝对位置，小写为相对位置<br>2.最后的参数表示最终要到达的位置<br>3.上一个命令结束的位置就是下一个命令开始的位置<br>4.命令可以重复参数表示重复执行同一条命令</p><h4 id="小写-相对坐标-与-大写-绝对坐标"><a href="#小写-相对坐标-与-大写-绝对坐标" class="headerlink" title="小写 相对坐标 与 大写 绝对坐标"></a>小写 相对坐标 与 大写 绝对坐标</h4><p>上面介绍的都是用绝对坐标，其实一般画图都使用相对坐标小写的，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//效果跟上面的 《path指令 M 、V、 H、Z、L --- demo2》是一样的，但增加了灵活性，</span><br><span class="line">//当随意改变起始点坐标是，图形不被破坏，这是绝对坐标做不到的。</span><br><span class="line">&lt;path stroke=&apos;orange&apos; stroke-width=&apos;.8&apos; fill=&apos;orange&apos; d=&apos;M 20 70 h 30 v -10 l 10 20 l -10 20 v -10 h -30 z&apos; /&gt;</span><br></pre></td></tr></table></figure></p><h4 id="逗号有没有不影响"><a href="#逗号有没有不影响" class="headerlink" title="逗号有没有不影响"></a>逗号有没有不影响</h4><p>比如下面两个代码，一个有逗号，一个没有，对于电脑而言都能正常识别，加逗号只是为了人能够识别理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;polygon points=&quot;25 10,10 40, 50 27&quot; style=&quot;fill:green;stroke:orange;stroke-width:4&quot;/&gt;</span><br><span class="line">&lt;polygon points=&quot;25  10 10 40  50 27&quot; style=&quot;fill:green;stroke:orange;stroke-width:4&quot;/&gt;</span><br></pre></td></tr></table></figure></p><h4 id="path-指令"><a href="#path-指令" class="headerlink" title="path 指令"></a>path 指令</h4><p>这里只列举部分，<a href="https://www.bbsmax.com/A/A7zgmMwW54/" target="_blank" rel="noopener">更多参考</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">指令 参数 说明</span><br><span class="line">Mx y将画笔移动到点(x,y)</span><br><span class="line">Lx y画笔从当前的点绘制线段到点(x,y)</span><br><span class="line">Hx画笔从当前的点绘制水平线段到点(x,y0)</span><br><span class="line">Vy 画笔从当前的点绘制竖直线段到点(x0,y)</span><br><span class="line">Arx ry x-axis-rotation large-arc-flag sweep-flag x y画笔从当前的点绘制一段圆弧到点(x,y)</span><br><span class="line">Cx1 y1, x2 y2, x y画笔从当前的点绘制一段三次贝塞尔曲线到点(x,y)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=&quot;M 200 200 A 200 200 0 0 1 400 400&quot; style=&quot;fill:none;stroke:orange;stroke-width:10;&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="path的贝塞尔曲线"><a href="#path的贝塞尔曲线" class="headerlink" title="path的贝塞尔曲线"></a>path的贝塞尔曲线</h4><p>ps工具中的钢笔工具就是一个贝塞尔曲线，贝塞尔曲线由几个点组成，<a href="https://www.bilibili.com/video/av13105102/?spm_id_from=333.788.videocard.3" target="_blank" rel="noopener">具体参考这个视频的末尾段的介绍</a></p><h4 id="path指令-M-、V、-H、Z、L"><a href="#path指令-M-、V、-H、Z、L" class="headerlink" title="path指令 M 、V、 H、Z、L"></a>path指令 M 、V、 H、Z、L</h4><h5 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h5><ul><li>M 坐标点</li><li>V 垂直</li><li>H 水平</li><li>Z 闭合</li><li>L 连线到坐标点<h5 id="demo-1"><a href="#demo-1" class="headerlink" title="demo 1"></a>demo 1</h5>如下，viewBox代表从原点 0 0 开始，像x、y轴各延伸100；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg viewBox=&apos;0 0 100 100&apos; style=&apos;border:green solid&apos;&gt;</span><br><span class="line">//d=&apos;M 10 0 V 100&apos; 从坐标x 10 、 y 0开始，垂直方向延伸y 100；</span><br><span class="line">&lt;path stroke=&apos;green&apos; stroke-width=&apos;.2&apos; d=&apos;M 10 0 V 100&apos;/&gt;</span><br><span class="line">//d=&apos;M 0 10 H 100&apos; 从坐标x 0 、 y 10开始，水平方向延伸x 100；</span><br><span class="line">&lt;path stroke=&apos;green&apos; stroke-width=&apos;.2&apos; d=&apos;M 20 0 H 100&apos;/&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//在坐标点20 10 开始，水平移到 x50，再垂直移到y0，然后连线到坐标点60 20，再连线到坐标点 50 40，然后垂直移动到y30</span><br><span class="line">//然后水平移到x20，然后连接到起始点闭合。</span><br><span class="line">&lt;path stroke=&apos;blue&apos; stroke-width=&apos;.8&apos; fill=&apos;blue&apos; d=&apos;M 20 10 H 50 V 0 L 60 20 L 50 40 V 30 H 20 Z&apos; /&gt;</span><br></pre></td></tr></table></figure><p>效果：<br><figure class="image-box">                <img src="/image/d3/all/svg1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="polygon-与-polyline"><a href="#polygon-与-polyline" class="headerlink" title="polygon 与 polyline"></a>polygon 与 polyline</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//多边形比如三角形、矩形、梯形、多边形，会自动闭合</span><br><span class="line">//坐标 25 10， 坐标点10，40， 坐标点 50，27 形成三角形</span><br><span class="line"> &lt;polygon points=&quot;25 10,10 40, 50 27&quot; style=&quot;fill:green;stroke:orange;stroke-width:4&quot;/&gt;</span><br><span class="line"> //折线 也可以画多边形， 不会自动闭合</span><br><span class="line"> &lt;polyline points=&quot;25 10,10 40, 50 27&quot; style=&quot;fill:green;stroke:orange;stroke-width:4&quot; transform=&quot;translate(100,0)&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="polygon-画多边形"><a href="#polygon-画多边形" class="headerlink" title="polygon 画多边形"></a>polygon 画多边形</h4><p>参考上面代码</p><h4 id="polyline-画折线"><a href="#polyline-画折线" class="headerlink" title="polyline 画折线"></a>polyline 画折线</h4><p>参考上面代码</p><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><p>polygon 会自动闭合，画多边形比较方便，polyline不会自动闭合，可以画多边形，当不方便，更多用于画折线。</p><h3 id="指令Q-quadratic-二次曲线"><a href="#指令Q-quadratic-二次曲线" class="headerlink" title="指令Q - quadratic 二次曲线"></a>指令Q - quadratic 二次曲线</h3><h4 id="Q指令"><a href="#Q指令" class="headerlink" title="Q指令"></a>Q指令</h4><p>如下 Q 后面跟两个坐标点，第一个点为曲线最高或最低点，第二个点为曲线终点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path stroke=&apos;red&apos; stroke-width=&apos;.8&apos; fill=&apos;none&apos; d=&apos;M 20 30 Q 25 0, 50 30 &apos; /&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Q第一个点y轴实际位置为-自身y-起始点y-2"><a href="#Q第一个点y轴实际位置为-自身y-起始点y-2" class="headerlink" title="Q第一个点y轴实际位置为 (自身y+起始点y)/2"></a>Q第一个点y轴实际位置为 (自身y+起始点y)/2</h4><p>比如上面代码<code>d=&#39;M 20 30 Q 25 0, 50 30 &#39;</code> q的第一个点为 25 0，自身的y值为0，起始点M的y值为30，那么实际位置为15.<br>不需知道为什么，知道是这个规律就行。</p><h4 id="Q-的镜像指令-T指令"><a href="#Q-的镜像指令-T指令" class="headerlink" title="Q 的镜像指令 T指令"></a>Q 的镜像指令 T指令</h4><p>T跟着的坐标点为终点。终点恰当与否，决定镜像是否更像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path stroke=&apos;red&apos; stroke-width=&apos;.8&apos; fill=&apos;none&apos; d=&apos;M 20 50 Q 25 10, 50 50 T80 50&apos; /&gt;</span><br></pre></td></tr></table></figure></p><p><a href="">参考demo</a></p><h3 id="指令C-curve-曲线"><a href="#指令C-curve-曲线" class="headerlink" title="指令C - curve 曲线"></a>指令C - curve 曲线</h3><h4 id="C指令"><a href="#C指令" class="headerlink" title="C指令"></a>C指令</h4><p>如下 C 后面跟三个坐标点，第一和第二个点用来控制曲线的弧度，第三个点为终点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path stroke=&apos;blue&apos; stroke-width=&apos;.8&apos; fill=&apos;none&apos; d=&apos;M 20 50 C 40 40, 60 40, 80 50&apos; /&gt;</span><br></pre></td></tr></table></figure></p><h4 id="C指令-与-Q指令关系"><a href="#C指令-与-Q指令关系" class="headerlink" title="C指令 与 Q指令关系"></a>C指令 与 Q指令关系</h4><p>二者都用来画曲线，能达到一样效果，不过，c后面跟着三个点，所以相比Q（两个点），更能精确控制曲线弧度。</p><h4 id="C-的镜像指令-S指令"><a href="#C-的镜像指令-S指令" class="headerlink" title="C 的镜像指令 S指令"></a>C 的镜像指令 S指令</h4><p>相比Q的镜像T指令，C时只能用S进行镜像，S的最后一个点为终点，之前的点用来调节镜像弧度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path stroke=&apos;yellow&apos; stroke-width=&apos;.8&apos; fill=&apos;none&apos; d=&apos;M 20 50 C 30 40, 40 40, 50 50 S 70 60 80 50&apos; /&gt;</span><br></pre></td></tr></table></figure></p><p><a href="">参考demo</a></p><h3 id="指令A-Arc-圆弧"><a href="#指令A-Arc-圆弧" class="headerlink" title="指令A - Arc 圆弧"></a>指令A - Arc 圆弧</h3><h4 id="A指令"><a href="#A指令" class="headerlink" title="A指令"></a>A指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path stroke=&apos;blue&apos; stroke-width=&apos;.8&apos; fill=&apos;gray&apos; d=&apos;M 30 50 A 1 1, 0 , 0 0, 70 50&apos; /&gt;</span><br></pre></td></tr></table></figure><p>如上 C 后面跟7个参数。</p><ul><li>最后两个参数：70 50为终点</li><li>第一、二个参数：<br>情况一：比如本例： 1 1 ，为圆弧的x、y轴比例，M30 50 与终点70 50，已经确定了圆半径，此时圆弧xy比例不一样，就形成对应比例的圆或椭圆。<br>情况二：当值大于圆弧半径时，此参数就不是比例了，就是圆弧的圆心，此种情况就有些复杂了。</li><li><p>第五个参数： 0 ，后面的0代表画下半圆，如果是1就是画上半圆,如下上下两句各画半个圆，一起拼起来就是一个圆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;path stroke=&apos;blue&apos; stroke-width=&apos;.8&apos; fill=&apos;gray&apos; d=&apos;M 30 50 A 1 1, 0 , 0 0, 70 50&apos; /&gt;</span><br><span class="line">  &lt;path stroke=&apos;blue&apos; stroke-width=&apos;.8&apos; fill=&apos;purple&apos; d=&apos;M 30 50 A 1 1, 0 , 0 1, 70 50&apos; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>第三个参数： 0 是圆弧的旋转角度，类似transform的scal，当大于45时，圆弧的x、y轴值将颠倒。</p></li><li>第四个参数： 当为0时，显示圆弧，当为1时，显示圆弧剩余部分。：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path stroke=&apos;blue&apos; stroke-width=&apos;.8&apos; fill=&apos;purple&apos; d=&apos;M 30 50 A 50 50, 0 , 1 1, 70 50&apos; /&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="C指令-与-Q指令关系-1"><a href="#C指令-与-Q指令关系-1" class="headerlink" title="C指令 与 Q指令关系"></a>C指令 与 Q指令关系</h4><p>二者都用来画曲线，能达到一样效果，不过，c后面跟着三个点，所以相比Q（两个点），更能精确控制曲线弧度。</p><h4 id="C-的镜像指令-S指令-1"><a href="#C-的镜像指令-S指令-1" class="headerlink" title="C 的镜像指令 S指令"></a>C 的镜像指令 S指令</h4><p>相比Q的镜像T指令，C时只能用S进行镜像，S的最后一个点为终点，之前的点用来调节镜像弧度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path stroke=&apos;yellow&apos; stroke-width=&apos;.8&apos; fill=&apos;none&apos; d=&apos;M 20 50 C 30 40, 40 40, 50 50 S 70 60 80 50&apos; /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><h4 id="dx-与-dy"><a href="#dx-与-dy" class="headerlink" title="dx 与 dy"></a>dx 与 dy</h4><p>dx与dy 表示的是相对于前一个字符的长度，<a href="https://www.w3cplus.com/svg/how-to-manipulate-svg-text.html" target="_blank" rel="noopener">参考</a></p><h3 id="g-与-坐标系"><a href="#g-与-坐标系" class="headerlink" title="g 与 坐标系"></a>g 与 坐标系</h3><h4 id="元素的x是相对于父层的g，而非原始坐标"><a href="#元素的x是相对于父层的g，而非原始坐标" class="headerlink" title="元素的x是相对于父层的g，而非原始坐标"></a>元素的x是相对于父层的g，而非原始坐标</h4><p>如下rect的坐标 0 0 ，相对的是g形成的坐标系，而非原始坐标，<br><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter6/6.8/6-8-1-lineChart.html" target="_blank" rel="noopener">详细demo</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node.append(&quot;g&quot;)</span><br><span class="line">    .append(&quot;rect&quot;)</span><br><span class="line">    .attr(&quot;x&quot;,0)</span><br><span class="line">    .attr(&quot;y&quot;,0)</span><br></pre></td></tr></table></figure></p><h3 id="参考demo"><a href="#参考demo" class="headerlink" title="参考demo"></a>参考demo</h3><p><a href="https://github.com/YeWills/d3-note-demo/tree/d3-demo/pages/mars" target="_blank" rel="noopener">参考demo -里面的几个svg html</a></p><h2 id="svg进阶知识"><a href="#svg进阶知识" class="headerlink" title="svg进阶知识"></a>svg进阶知识</h2><h3 id="viewport-viewbox-preserveAspectRatio"><a href="#viewport-viewbox-preserveAspectRatio" class="headerlink" title="viewport viewbox preserveAspectRatio"></a>viewport viewbox preserveAspectRatio</h3><h4 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h4><p>其实三者关系很好理解，也很简单，不过网上有很多博客或教程将此复杂化了，如下图：<br>在坐标系上画了一个矩形，现在只想显示阴影部分，取 viewbox 100 100 20 20；<br>现在设置svg的viewport 为200 200；<br>在显示时，<br>svg的机制，会让viewbox自动缩小或放大以填充整个viewport；<br>放大后，viewport显示了刚才viewbox的内容。<br><a href="http://127.0.0.1:3000/multy/SVG/Lesson2/viewbox.html" target="_blank" rel="noopener">demo参考</a><br><figure class="image-box">                <img src="/image/svg/viewbox.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="viewbox会缩小或者扩大填满viewport"><a href="#viewbox会缩小或者扩大填满viewport" class="headerlink" title="viewbox会缩小或者扩大填满viewport"></a>viewbox会缩小或者扩大填满viewport</h4><p>参考上面。</p><h4 id="preserveAspectRatio"><a href="#preserveAspectRatio" class="headerlink" title="preserveAspectRatio"></a>preserveAspectRatio</h4><p>可网上查询，机制跟css 的background 的图片填充一样。</p><h3 id="defs"><a href="#defs" class="headerlink" title="defs"></a>defs</h3><p><a href="https://blog.csdn.net/chy555chy/article/details/53364561" target="_blank" rel="noopener">参考这里</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/av13492121/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">视频教程有7个，在这个网站上是能找到这七个视频的</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>typescript 笔记</title>
      <link href="/2021/01/03/ts/"/>
      <url>/2021/01/03/ts/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文是主要参考 <a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript 入门教程</a>，记得很随意，断断续续，不完整，可能后期此篇笔记会删除，聊当暂时性自用。</p><h2 id="把玩ts的正确姿势"><a href="#把玩ts的正确姿势" class="headerlink" title="把玩ts的正确姿势"></a>把玩ts的正确姿势</h2><p>任意目录下，使用tsc命令来，很纯粹，剔除其他因素导致的理解偏差，不需要配合webpack等等，更多参考：《tsc命令的使用》</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="可以描述的类型"><a href="#可以描述的类型" class="headerlink" title="可以描述的类型"></a>可以描述的类型</h3><h4 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h4><h5 id="有很多个属性时，定义一个任意属性"><a href="#有很多个属性时，定义一个任意属性" class="headerlink" title="有很多个属性时，定义一个任意属性"></a>有很多个属性时，定义一个任意属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test:Person=&#123;</span><br><span class="line">    name:<span class="string">'qianqian'</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    intrest:<span class="string">'dance'</span>,</span><br><span class="line">    beatiful:<span class="string">'yes'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义class类（implements）"><a href="#定义class类（implements）" class="headerlink" title="定义class类（implements）"></a>定义class类（implements）</h4><p>用于给类定义属性的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Car alert'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义函数（范型接口、普通接口）"><a href="#定义函数（范型接口、普通接口）" class="headerlink" title="定义函数（范型接口、普通接口）"></a>定义函数（范型接口、普通接口）</h4><p>参考《范型》</p><h4 id="约束范型类型"><a href="#约束范型类型" class="headerlink" title="约束范型类型"></a>约束范型类型</h4><p>参考《范型》</p><h3 id="接口定义方式"><a href="#接口定义方式" class="headerlink" title="接口定义方式"></a>接口定义方式</h3><h4 id="常规接口定义"><a href="#常规接口定义" class="headerlink" title="常规接口定义"></a>常规接口定义</h4><p>这里就不写了，比较简单。</p><h4 id="用类修饰接口（接口可以继承类）"><a href="#用类修饰接口（接口可以继承类）" class="headerlink" title="用类修饰接口（接口可以继承类）"></a>用类修饰接口（接口可以继承类）</h4><p>常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">    <span class="keyword">constructor</span>(x: number, y: number) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Point看成实例就很好理解了</span></span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">    z: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="用接口定义函数的形状"><a href="#用接口定义函数的形状" class="headerlink" title="用接口定义函数的形状"></a>用接口定义函数的形状</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, <span class="attr">subString</span>: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: string, subString: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此相对应：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySum: <span class="function">(<span class="params">x: number, y: number</span>) =&gt;</span> number = <span class="function"><span class="keyword">function</span> (<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="class类作为类型"><a href="#class类作为类型" class="headerlink" title="class类作为类型"></a>class类作为类型</h2><p><a href="https://ts.xcatliu.com/basics/type-assertion.html" target="_blank" rel="noopener">参考 - 将一个父类断言为更加具体的子类</a></p><h3 id="直接用类作为类型"><a href="#直接用类作为类型" class="headerlink" title="直接用类作为类型"></a>直接用类作为类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    code: number = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    statusCode: number = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isApiError</span>(<span class="params">error: Error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> ApiError) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><p>参考 <a href="https://www.imooc.com/video/21306" target="_blank" rel="noopener">慕课视频</a></p><h3 id="范型类型"><a href="#范型类型" class="headerlink" title="范型类型"></a>范型类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;T&gt;(arg1:T,arg2:T)=&gt;T 这个表达式称之为 数据类型／范型类型／范型函数</span></span><br></pre></td></tr></table></figure><h4 id="范型类型是干嘛的"><a href="#范型类型是干嘛的" class="headerlink" title="范型类型是干嘛的"></a>范型类型是干嘛的</h4><p>我们知道声明变量时，我们需要定义类型，普通的类型如 number string等；<br>还有高级点的类型，如范型类型；<br>因此范型类型与 number一样，都是用于定义变量的类型。</p><p>以下两种方式都可以定义一个范型类型<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;T&gt;(arg1:T,arg2:T)=&gt;T 这个表达式称之为 数据类型／范型类型／范型函数</span></span><br><span class="line"><span class="comment">// let addFunc : &lt;T&gt;(arg1:T,arg2:T)=&gt;T; //不使用花括号</span></span><br><span class="line"><span class="comment">// let addFunc : &#123;&lt;T&gt;(arg1:T,arg2:T):T&#125;; //使用花括号，将=&gt;改为冒号:</span></span><br></pre></td></tr></table></figure></p><h4 id="不使用花括号"><a href="#不使用花括号" class="headerlink" title="不使用花括号"></a>不使用花括号</h4><p>如上</p><h4 id="使用花括号"><a href="#使用花括号" class="headerlink" title="使用花括号"></a>使用花括号</h4><p>如上，它的特征是，将=&gt;改为冒号:。</p><h4 id="范型类型与number等一样"><a href="#范型类型与number等一样" class="headerlink" title="范型类型与number等一样"></a>范型类型与number等一样</h4><p>范型类型与number等一样，同属于变量类型，参考上面讲解，这里单独提出来是让对范型类型有一个更加直观认识；</p><h3 id="范型接口"><a href="#范型接口" class="headerlink" title="范型接口"></a>范型接口</h3><h4 id="为什么要有范型接口"><a href="#为什么要有范型接口" class="headerlink" title="为什么要有范型接口"></a>为什么要有范型接口</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addFunc : &#123;&lt;T&gt;(arg1:T,arg2:T):T&#125;;</span><br></pre></td></tr></table></figure><p>如上，给变量定义类型，太不优雅了，是否可以将范型类型赋给一个变量呢:<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ftype = &#123;&lt;T&gt;(arg1:T,arg2:T):T&#125; <span class="comment">//语法报错</span></span><br><span class="line"><span class="comment">//const ftype = &lt;T&gt;(arg1:T,arg2:T)=&gt;T //语法报错</span></span><br><span class="line"><span class="keyword">let</span> addFunc : ftype;</span><br></pre></td></tr></table></figure></p><p>噢，终于知道无法将范型类型赋值给一个变量，因为范型类型只能通过接口来定义，<br>这种定义范型类型的接口，我们称之为 范型接口或含范型的普通接口。</p><p>我们将上面的范型类型赋值给接口GenAdder：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenAdder &#123;&lt;T&gt;(arg1:T,arg2:T):T&#125;;</span><br><span class="line"><span class="keyword">let</span> addFunc : GenAdder;</span><br></pre></td></tr></table></figure></p><h4 id="含范型的普通接口"><a href="#含范型的普通接口" class="headerlink" title="含范型的普通接口"></a>含范型的普通接口</h4><p>这是普通接口，虽然接口内有范型T，但，接口名后未紧随<code>&lt;T&gt;</code>;<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenAdder &#123;&lt;T&gt;(arg1:T,arg2:T):T&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="转化为范型接口"><a href="#转化为范型接口" class="headerlink" title="转化为范型接口"></a>转化为范型接口</h4><p>我们也可以将上面普通接口的T从花括号后，提取出来，放在GenAdder后，GenAdder即转化为范型接口；<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenAdder&lt;T&gt; &#123;(arg1:T,arg2:T):T&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="含范型的普通接口的使用"><a href="#含范型的普通接口的使用" class="headerlink" title="含范型的普通接口的使用"></a>含范型的普通接口的使用</h4><p>二者在ts中应用的区别：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通接口</span></span><br><span class="line"><span class="keyword">interface</span> GenAdder &#123;&lt;T&gt;(arg1:T,arg2:T):T&#125;;</span><br><span class="line"><span class="keyword">let</span> addFunc : GenAdder;</span><br><span class="line">addFunc = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1+arg2;<span class="comment">//ts报错，当参数为number或string时，成立，当参数为undefined、null时候不成立；</span></span><br><span class="line">&#125;;</span><br><span class="line">addFunc(<span class="string">''</span>,<span class="string">''</span>)</span><br></pre></td></tr></table></figure></p><h4 id="范型接口的使用"><a href="#范型接口的使用" class="headerlink" title="范型接口的使用"></a>范型接口的使用</h4><p>为了解决上面的ts报错，必须将普通接口转化为范型接口，因为范型接口在声明类型时，会预设上类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenAdder&lt;T&gt; &#123;(arg1:T,arg2:T):T&#125;;</span><br><span class="line"><span class="comment">//预设上类型为number</span></span><br><span class="line"><span class="keyword">let</span> addFunc : GenAdder&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">addFunc = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1+arg2;</span><br><span class="line">&#125;;</span><br><span class="line">addFunc(<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h4 id="范型接口的使用说明"><a href="#范型接口的使用说明" class="headerlink" title="范型接口的使用说明"></a>范型接口的使用说明</h4><p><strong>范型接口使用时，必须在接口后定义好<code>&lt;类型&gt;</code></strong>，<br>我们也可从接口定义的外观来理解：<br>定义接口时，若接口后紧挨着一个<code>&lt;T&gt;</code>，则使用此接口时，必须是 <code>接口名&lt;T&gt;</code>；<br>若接口后是干干净净的，没有任何其他东西，则使用此接口时，应该为单纯的 <code>接口名</code><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">interface</span> GenAdder&lt;T&gt; &#123;(arg1:T,arg2:T):T&#125;;</span><br><span class="line"><span class="comment">//使用范型接口时，需定义好T类型</span></span><br><span class="line"> <span class="keyword">let</span> addFunc : GenAdder&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> nomalGenAdder&#123; name:<span class="built_in">string</span>;&#125;;</span><br><span class="line"><span class="comment">//使用普通接口时，不需定义好T类型，因为没有T</span></span><br><span class="line"> <span class="keyword">let</span> addObj : nomalGenAdder;</span><br></pre></td></tr></table></figure></p><h3 id="范型类"><a href="#范型类" class="headerlink" title="范型类"></a>范型类</h3><h4 id="包含范型类型的普通类"><a href="#包含范型类型的普通类" class="headerlink" title="包含范型类型的普通类"></a>包含范型类型的普通类</h4><p>如下Adder是个普通类，因为它的属性add使用了范型类，它还是一个普通类，只是内部包含了范型类型定义。<br>这样的写法在某些情况下写起来比较费劲，也有些情况需要避免一些报错，等等，于是就想将普通类改造成范型类。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Adder&#123;</span><br><span class="line">    add:&lt;T&gt;<span class="function">(<span class="params">arg1:T, arg2:T</span>)=&gt;</span>T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> adder = <span class="keyword">new</span> Adder();</span><br><span class="line">adder.add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1+arg2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原则上需要定义&lt;number&gt;</span></span><br><span class="line">adder.add&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">adder.add&lt;<span class="built_in">string</span>&gt;(<span class="string">''</span>,<span class="string">''</span>)</span><br><span class="line"><span class="comment">// 不定义&lt;number&gt;也可以，ts默认给定义</span></span><br><span class="line">adder.add(<span class="string">''</span>,<span class="string">''</span>)</span><br></pre></td></tr></table></figure></p><h4 id="范型类-1"><a href="#范型类-1" class="headerlink" title="范型类"></a>范型类</h4><p>改造上面的代码，经过改造后如下，Adder就是一个范型类了。<br>将普通类改成范型类的好处是，写起来可能会优雅点，然后可以处理一些普通类会遇到的ts报错。<br>另外一方面，从下面我们也知道，一旦定义成范型类，那么调用类时，就需要马上指定好类型。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将范型提取出来挨着Adder</span></span><br><span class="line"><span class="keyword">class</span> Adder&lt;T&gt;&#123;</span><br><span class="line">    add:<span class="function">(<span class="params">arg1:T, arg2:T</span>)=&gt;</span>T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用的时候需要&lt;number&gt;，一旦定义成范型类，那么调用类时，就需要马上指定好类型。</span></span><br><span class="line"><span class="keyword">const</span> adder = <span class="keyword">new</span> Adder&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">adder.add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1+arg2;</span><br><span class="line">&#125;</span><br><span class="line">adder.add(<span class="number">1</span>,<span class="number">3</span>)<span class="comment">//正确</span></span><br><span class="line">adder.add(<span class="number">1</span>,<span class="string">''</span>)<span class="comment">//报错</span></span><br></pre></td></tr></table></figure></p><h4 id="范型类调用方式–需指定好类型"><a href="#范型类调用方式–需指定好类型" class="headerlink" title="范型类调用方式–需指定好类型"></a>范型类调用方式–需指定好类型</h4><p>如上面的普通类，调用时，直接调用，改成范型类时，就需要指定好类型了：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> adder = <span class="keyword">new</span> Adder&lt;<span class="built_in">number</span>&gt;();</span><br></pre></td></tr></table></figure></p><h4 id="扩展-范型函数"><a href="#扩展-范型函数" class="headerlink" title="扩展-范型函数"></a>扩展-范型函数</h4><p>既然有普通类和范型类，那么就有普通函数和范型函数，用法可以类推范型类。</p><h3 id="范型约束"><a href="#范型约束" class="headerlink" title="范型约束"></a>范型约束</h3><h4 id="为什么要有范型约束"><a href="#为什么要有范型约束" class="headerlink" title="为什么要有范型约束"></a>为什么要有范型约束</h4><p><a href="https://ts.xcatliu.com/advanced/generics.html#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F" target="_blank" rel="noopener">参考ts入门教程-范型约束</a><br>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'.</span></span><br></pre></td></tr></table></figure></p><h4 id="范型的特性导致了必然需要范型约束"><a href="#范型的特性导致了必然需要范型约束" class="headerlink" title="范型的特性导致了必然需要范型约束"></a>范型的特性导致了必然需要范型约束</h4><p>参考上面。</p><h4 id="使用普通接口做范型约束"><a href="#使用普通接口做范型约束" class="headerlink" title="使用普通接口做范型约束"></a>使用普通接口做范型约束</h4><p>注意的是，范型约束使用<strong>普通接口</strong>而非什么范型接口来约束范型。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><p>用于约束范型的关键字，参考上面。</p><h4 id="进阶-keyof"><a href="#进阶-keyof" class="headerlink" title="进阶 - keyof"></a>进阶 - keyof</h4><p>使用keyof进行范型约束，<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">obj:T,key:K</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key]<span class="comment">//ts error,obj内不一定有key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时可通过 keyof来约束 K，改造如下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj:T,key:K</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line">getProp(&#123;name:<span class="number">1</span>&#125;, <span class="string">'name'</span>)</span><br></pre></td></tr></table></figure></p><p>keyof主要表示 k是T内的属性。<br><a href="https://www.imooc.com/video/21306/0" target="_blank" rel="noopener">参考</a></p><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><h3 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h3><p>严格类型，让代码区分null undefined的空与非空类型；不再有包含；</p><h3 id="开启tsx的支持"><a href="#开启tsx的支持" class="headerlink" title="开启tsx的支持"></a>开启tsx的支持</h3><p>定义tsconfig.json的 jsx为preserve；</p><h3 id="esModuleInterop-开启export-default"><a href="#esModuleInterop-开启export-default" class="headerlink" title="esModuleInterop 开启export default"></a>esModuleInterop 开启export default</h3><p>当ts报错import或export时；<br>或者ts混合使用commonjs与es6模块报错时；<br>可能是没有export default有关，此时可以设置不同的esModuleInterop来解决；</p><h3 id="noImplicitAny-定义对象不能有any类型属性"><a href="#noImplicitAny-定义对象不能有any类型属性" class="headerlink" title="noImplicitAny 定义对象不能有any类型属性"></a>noImplicitAny 定义对象不能有any类型属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> key = <span class="string">'name'</span>;</span><br><span class="line">student[key] = <span class="string">'qianqian'</span><span class="comment">//ts error</span></span><br></pre></td></tr></table></figure><h2 id="tsc命令的使用"><a href="#tsc命令的使用" class="headerlink" title="tsc命令的使用"></a>tsc命令的使用</h2><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install typescript -g</span><br><span class="line">tsc -v</span><br></pre></td></tr></table></figure><h3 id="生成tsconfig-json"><a href="#生成tsconfig-json" class="headerlink" title="生成tsconfig.json"></a>生成tsconfig.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><h3 id="编译ts文件"><a href="#编译ts文件" class="headerlink" title="编译ts文件"></a>编译ts文件</h3><p>在根目录下，新建一个test.ts，运行如下命令，就会在根目录下生成编译后生成的文件 test.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc test.ts</span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="d-ts文件"><a href="#d-ts文件" class="headerlink" title="d.ts文件"></a>d.ts文件</h3><p>详见《ts中使用commonjs规范与es6规范的不同》</p><h3 id="as的使用-类型断言"><a href="#as的使用-类型断言" class="headerlink" title="as的使用 - 类型断言"></a>as的使用 - 类型断言</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCacheData</span>(<span class="params">key: string</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">window</span> <span class="keyword">as</span> any).cache[key];</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    run(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tom = getCacheData(<span class="string">'tom'</span>) <span class="keyword">as</span> Cat;</span><br><span class="line">tom.run();</span><br></pre></td></tr></table></figure><h3 id="type-别名"><a href="#type-别名" class="headerlink" title="type 别名"></a>type 别名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Name = string;</span><br><span class="line">type NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> string;</span><br><span class="line">type NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type EventNames = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>), <span class="string">'scroll'</span>);  <span class="comment">// 没问题</span></span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'world'</span>), <span class="string">'dbclick'</span>); <span class="comment">// 报错，event 不能为 'dbclick'</span></span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="ts中使用commonjs规范与es6规范的不同"><a href="#ts中使用commonjs规范与es6规范的不同" class="headerlink" title="ts中使用commonjs规范与es6规范的不同"></a>ts中使用commonjs规范与es6规范的不同</h3><p><a href="https://www.imooc.com/video/21605/0" target="_blank" rel="noopener">参考慕课网</a><br>如下图，使用commonjs时，可以正常使用css module；<br>但使用es6的import来css module时，必须定义d.ts文件；<br>还有一个情况，就是下图中第一行 全局css的写法，import单纯引入一个文件时，也是不报错的；</p><p>这是因为，当ts import 一个css文件时，这样是没问题的；<br>但使用es6语法，需要ts 将一个css文件当成对象，将此css文件抽象成一个styles对象时；<br>ts是不认识的，此时，就需要告诉ts，这个css文件暴露出来的是一个styles对象；如何告诉呢，就是通过d.ts文件；<br>另外一方面，如果ts中使用commonjs的语法来获取styles时，则不需要定义d.ts文件，因为commonjs规范时webpack默认的规范；</p><p>css modlue 折射了 ts 通过es6 将一个文件当成一个对象引入时，需要定义dts文件；为此，其他的比如jquery，lodash都需要做声明文件d.ts.<br><figure class="image-box">                <img src="/image/ts/cssmodule.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/ts/css.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/ts/dts.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="ts中引入css-modlue异常的问题"><a href="#ts中引入css-modlue异常的问题" class="headerlink" title="ts中引入css modlue异常的问题"></a>ts中引入css modlue异常的问题</h3><p>详见《ts中使用commonjs规范与es6规范的不同》</p><h3 id="null-undefined-是所有类型子集"><a href="#null-undefined-是所有类型子集" class="headerlink" title="null undefined 是所有类型子集"></a>null undefined 是所有类型子集</h3><p>一个变量定义为number后，再定义成string，会报错，但定义为undefined或null不报错；<br>因为undefined和null都是空类型，其他非空类型都包含此空类型；<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> height:<span class="built_in">number</span></span><br><span class="line">height = <span class="number">100</span>;</span><br><span class="line">height = <span class="string">'str'</span>;<span class="comment">//error</span></span><br><span class="line">height = <span class="literal">undefined</span>;<span class="comment">//不报错</span></span><br><span class="line">height = <span class="literal">null</span>;<span class="comment">//不报错</span></span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.imooc.com/learn/1243" target="_blank" rel="noopener">慕课网 - TS封装播放器组件</a><br><a href="https://www.imooc.com/learn/1234" target="_blank" rel="noopener">当React遇上TypeScript开发Antd组件</a><br><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript 入门教程</a></p>]]></content>
      
      
      <categories>
          
          <category> typescript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>wills-react-pro项目笔记</title>
      <link href="/2021/01/03/wills_react_pro/"/>
      <url>/2021/01/03/wills_react_pro/</url>
      
        <content type="html"><![CDATA[<p>本篇博客针对 github 的<a href="https://github.com/YeWills/react-redux-demo" target="_blank" rel="noopener">react_redux_demo项目</a>一些知识点讲解。</p><h2 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h2><p>项目使用了redux-thunk来处理异步请求，redux-thunk最重要的思想，就是可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。<br>正因为这个action creator可以返回一个函数，那么就可以在这个函数中执行一些异步的操作。<br><a href="https://www.jianshu.com/p/a27ab19d3657" target="_blank" rel="noopener">参考</a><br>详细示例可参考 项目的tag login_pro_v1.0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//src/views/login/index.js</span><br><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line">  loginUser: appAction.loginUser,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="ajax封装"><a href="#ajax封装" class="headerlink" title="ajax封装"></a>ajax封装</h2><h3 id="什么时候需要success提示"><a href="#什么时候需要success提示" class="headerlink" title="什么时候需要success提示"></a>什么时候需要success提示</h3><p>ajax分为两种：<br>一种是进入页面请求数据渲染页面的，此时不需要提示接口响应成功，只需loading即可。<br>一种是与后台交互，需要响应结果的，如交易、删除、编辑等，提交到后台，后台告知是否成功。<br>因此在做ajax封装时，可以不用配置success 的提示处理，需要提示的接口自行配置success提示处理。</p><h3 id="什么时候需要loading"><a href="#什么时候需要loading" class="headerlink" title="什么时候需要loading"></a>什么时候需要loading</h3><p>原则上每个请求都应该有loading，但是有很多组件有自己的loading样式，例如在非刷新整个页面的情况下，组件内刷新gird，只需在grid内显示loading，不需要统一的loading格式。<br>因此ajax封装时，配置可选的 loading标识是否loading。</p><h3 id="什么时候需要error提示"><a href="#什么时候需要error提示" class="headerlink" title="什么时候需要error提示"></a>什么时候需要error提示</h3><p>ajax封装需要封装请求异常处理并提示，统一的异常处理和提示应该放在最后，为了不同接口个性化errorhandle，配置errorhandle，优先级高于统一处理模式。</p><h3 id="断网时、请求超时的的error提示"><a href="#断网时、请求超时的的error提示" class="headerlink" title="断网时、请求超时的的error提示"></a>断网时、请求超时的的error提示</h3><p>断网和请求响应超时时，应该统一处理，并优先级最高。</p><h3 id="使用options"><a href="#使用options" class="headerlink" title="使用options"></a>使用options</h3><p>loading，errorhandle等等，有很多参数，使用一个对象参数options。</p><h3 id="ajax设计"><a href="#ajax设计" class="headerlink" title="ajax设计"></a>ajax设计</h3><p>项目通过两方面来封装 ajax：</p><ul><li>通过api.js 封装三个常用的ajax方法 post、get、delete，在此js上，主要封装axios相关。</li><li>通过createAsyncAction.js 抽象出 公共的请求的成功和异常处理。<br>这样的设计好处在于<br>可以将axios与 回调处理的代码分离管理，减少耦合性。<br>详细示例可参考 项目的tag login_pro_v1.0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//src/views/login/index.js</span><br><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line">  loginUser: appAction.loginUser,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ajax过程的三次dispatch"><a href="#ajax过程的三次dispatch" class="headerlink" title="ajax过程的三次dispatch"></a>ajax过程的三次dispatch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch(&#123;</span><br><span class="line">    meta,</span><br><span class="line">    type: `$&#123;name&#125;_REQUEST`,</span><br><span class="line">  &#125;);</span><br><span class="line">dispatch(&#123;</span><br><span class="line">  meta,</span><br><span class="line">  type: `$&#123;name&#125;_SUCCESS`,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch(&#123;</span><br><span class="line">  meta,</span><br><span class="line">  type: `$&#123;name&#125;_ERROR`,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这三次dispatch可以用作如loading的控制等等。</p><h2 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h2><h3 id="eslint-配合-vscode-使用"><a href="#eslint-配合-vscode-使用" class="headerlink" title="eslint 配合 vscode 使用"></a>eslint 配合 vscode 使用</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>eslint在vscode生效：<br>安装eslint插件在vscode中；<br>如果用到airbnb的，就安装相关的airbnb 的 node_module包即可。<br>不用设置什么setting。json。<br>任意打开一个js文件，不能是ts文件哦，看是否生效。</p><h4 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h4><p>很多人以为eslint要设置一大堆的vscode插件，其实不然，只需要安装一个eslint插件即可。</p><h3 id="禁用规则"><a href="#禁用规则" class="headerlink" title="禁用规则"></a>禁用规则</h3><p>基本上所有的规则都可以通过设置 值为 0的数组来禁用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;no-unused-expressions&quot;: [0]</span><br></pre></td></tr></table></figure></p><h3 id="eslint-不生效"><a href="#eslint-不生效" class="headerlink" title="eslint 不生效"></a>eslint 不生效</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>想要vscode的fix all autoFixable problem；配置airbnb后 eslint不生效；<br>首先eslint除了上面说的 vscode 可能需要安装linter-eslint外，因为用了 airbnb，所有一定要在安装airbnb相关的两个node_module:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;eslint-config-airbnb&quot;: &quot;^17.0.0&quot;,</span><br><span class="line">&quot;eslint-import-resolver-babel-module&quot;: &quot;^4.0.0&quot;,</span><br></pre></td></tr></table></figure></p><p>当然还要安装其他相关的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;babel-eslint&quot;: &quot;^8.2.6&quot;,</span><br><span class="line"></span><br><span class="line">&quot;eslint-plugin-import&quot;: &quot;^2.13.0&quot;,</span><br><span class="line">&quot;eslint-plugin-jsx-a11y&quot;: &quot;^6.1.1&quot;,</span><br><span class="line">&quot;eslint-plugin-react&quot;: &quot;^7.10.0&quot;,</span><br><span class="line">&quot;eslint-plugin-react-hooks&quot;: &quot;^3.0.0&quot;,</span><br></pre></td></tr></table></figure></p><p>之所以在webpack未运行时，eslint能够起作用，估计是eslint默认直接通过 ‘/node_module/eslint-config-airbnb/index.js’等的方式引用了相关文件，如果这些引用存在，eslint将开启实时监听。</p><h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><p>注意的是，vscode使用eslint时，必须安装 linter-eslint 插件才能生效，装了插件后才能识别根目录下的eslint配置文件。</p><h4 id="ts-tsx不生效，js生效"><a href="#ts-tsx不生效，js生效" class="headerlink" title="ts tsx不生效，js生效"></a>ts tsx不生效，js生效</h4><p>如果你的项目中使用了ts，可能对于ts tsx的文件，ts自带的验证规则将优先于eslint，此时eslint可能在js文件中生效，ts文件中不生效。<br>不过ts文件中有ts自带的验证规则生效。</p><h4 id="没有安装prettier"><a href="#没有安装prettier" class="headerlink" title="没有安装prettier"></a>没有安装prettier</h4><p>没有安装一下两个依赖是不生效的，用vscode的时候，你如果注意观察vscode给予的错误提示，会发现，错误提示基本上都是prettier报错的，因此相关的包不安装肯定不生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;eslint-config-prettier&quot;: &quot;^4.3.0&quot;,</span><br><span class="line"> &quot;eslint-plugin-prettier&quot;: &quot;^3.1.4&quot;,</span><br></pre></td></tr></table></figure><h3 id="eslintc-配置与package-json联系"><a href="#eslintc-配置与package-json联系" class="headerlink" title=".eslintc 配置与package.json联系"></a>.eslintc 配置与package.json联系</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//package.json</span><br><span class="line">"eslint": "^5.16.0",</span><br><span class="line">"babel-eslint": "^8.2.3",</span><br><span class="line">"eslint-config-airbnb": "^17.1.0",</span><br><span class="line">"eslint-config-prettier": "^4.3.0",</span><br><span class="line">"eslint-plugin-compat": "^2.2.0",</span><br><span class="line">"eslint-plugin-import": "^2.20.2",</span><br><span class="line">"eslint-plugin-jsx-a11y": "^6.0.3",</span><br><span class="line">"eslint-plugin-prettier": "^3.1.4",</span><br><span class="line">"eslint-plugin-react": "^7.20.0",</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//.eslintc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"react"</span>, //对应上面 eslint-plugin-react</span><br><span class="line">    <span class="string">"jsx-a11y"</span>, //对应上面 eslint-plugin-jsx-a11y</span><br><span class="line">    <span class="string">"import"</span> //对应上面 eslint-plugin-import</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"extends"</span>: [</span><br><span class="line">    <span class="string">"airbnb"</span>, //对应上面 eslint-config-airbnb</span><br><span class="line">    <span class="string">"prettier"</span> //对应上面 eslint-config-prettier</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><h3 id="eslint对webpack别名报错"><a href="#eslint对webpack别名报错" class="headerlink" title="eslint对webpack别名报错"></a>eslint对webpack别名报错</h3><p>安装插件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;eslint-import-resolver-webpack&quot;: &quot;^0.13.0&quot;,</span><br></pre></td></tr></table></figure></p><p>在.eslintrc中配置：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"settings": &#123;</span><br><span class="line">   "import/resolver": &#123;</span><br><span class="line">     "webpack": &#123;</span><br><span class="line">       "config": "./webpack.config.base.js"//这里导入webpack中关于别名的配置</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="存疑airbnb"><a href="#存疑airbnb" class="headerlink" title="存疑airbnb"></a>存疑airbnb</h3><p>在我用的项目中，貌似不必直接安装 airbnb包，一般都是安装”eslint-config-airbnb”包就可以了。就可以生效eslint了。</p><h2 id="配置文件或相关"><a href="#配置文件或相关" class="headerlink" title="配置文件或相关"></a>配置文件或相关</h2><h3 id="jsconfig-json"><a href="#jsconfig-json" class="headerlink" title="jsconfig.json"></a>jsconfig.json</h3><h4 id="解决webpack别名点击不跳转问题"><a href="#解决webpack别名点击不跳转问题" class="headerlink" title="解决webpack别名点击不跳转问题"></a>解决webpack别名点击不跳转问题</h4><p><a href="https://www.jianshu.com/p/4ea2c5571123" target="_blank" rel="noopener">参考</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;baseUrl&quot;: &quot;.&quot;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">      &quot;@/*&quot;: [</span><br><span class="line">        &quot;./src/*&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="vscode对webpack别名提示补全"><a href="#vscode对webpack别名提示补全" class="headerlink" title="vscode对webpack别名提示补全"></a>vscode对webpack别名提示补全</h3><p>配置与 《解决webpack别名点击不跳转问题》类似，可自行网上查询。</p><h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><h4 id="解决webpack别名点击不跳转问题-1"><a href="#解决webpack别名点击不跳转问题-1" class="headerlink" title="解决webpack别名点击不跳转问题"></a>解决webpack别名点击不跳转问题</h4><p>道理同《jsconfig.json》</p><h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><p>待研究</p><h2 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h2><h3 id="mock的用法"><a href="#mock的用法" class="headerlink" title="mock的用法"></a>mock的用法</h3><p>示例见 <a href="https://github.com/YeWills/wills-react-pro" target="_blank" rel="noopener">wills-react-pro 的 Login.test.js</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const mockPost = jest.fn(testPost(&#123; success: false &#125;));</span><br></pre></td></tr></table></figure></p><h2 id="enzyme"><a href="#enzyme" class="headerlink" title="enzyme"></a>enzyme</h2><h3 id="shallow的两种情况"><a href="#shallow的两种情况" class="headerlink" title="shallow的两种情况"></a>shallow的两种情况</h3><p>shallow一个组件时，和shallow组件内一个返回div的函数用法稍微有区别，<br>前者需要通过’&lt;&gt;‘括号起来，后者不需要。<br>示例见 <a href="https://github.com/YeWills/wills-react-pro" target="_blank" rel="noopener">wills-react-pro 的 Login.test.js</a></p><h4 id="shallow一个组件"><a href="#shallow一个组件" class="headerlink" title="shallow一个组件"></a>shallow一个组件</h4><p>这种情况最通用，不多说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shallow(&lt;Login /&gt;);</span><br></pre></td></tr></table></figure></p><h4 id="shallow组件内的函数返回的div"><a href="#shallow组件内的函数返回的div" class="headerlink" title="shallow组件内的函数返回的div"></a>shallow组件内的函数返回的div</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">renderErrorMsg = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&#123;`$&#123;prefixCls&#125;-errorMsg`&#125;&gt;</span><br><span class="line">          &#123;errorMsg&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  //测试代码如下：</span><br><span class="line">  const ErrorComponent = warpInstance.renderErrorMsg();</span><br><span class="line">  const errorWrap = shallow(ErrorComponent);</span><br><span class="line">  expect(errorWrap.exists(&apos;.view-login-errorMsg&apos;)).toBeTruthy();</span><br></pre></td></tr></table></figure><h3 id="shallow测试hoc"><a href="#shallow测试hoc" class="headerlink" title="shallow测试hoc"></a>shallow测试hoc</h3><p>shallow一个经过hoc的组件时，只能shallow到hoc层面，为了能直接测试该组件时，需要特殊处理；<br>在hoc层面上，要写一句这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FinalComponent.WrappedComponent = WrappedComponent;</span><br></pre></td></tr></table></figure></p><p>然后通过type属性，可以捕捉这个组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const getComponentFromHoc = warp =&gt; (warp.type &amp;&amp; warp.type.WrappedComponent</span><br><span class="line">  ? &lt;warp.type.WrappedComponent &#123;...warp.props&#125; /&gt; : warp);</span><br></pre></td></tr></table></figure></p><p>详细demo见:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/YeWills/wills-react-pro/blob/master/src/utils/testUtil.js</span><br><span class="line">https://github.com/YeWills/wills-react-pro/blob/master/src/utils/connectWills.js</span><br><span class="line">https://github.com/YeWills/wills-react-pro/blob/master/test/Login.test.js</span><br></pre></td></tr></table></figure></p><h2 id="connected-react-router-与-history"><a href="#connected-react-router-与-history" class="headerlink" title="connected-react-router 与 history"></a>connected-react-router 与 history</h2><p>这是一种固定写法，不用过多关注：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//参考 项目的tag login_pro_v1.0</span><br><span class="line">//src/app/init/createStore.js</span><br><span class="line">import &#123; connectRouter, routerMiddleware &#125; from &apos;connected-react-router&apos;;</span><br><span class="line"></span><br><span class="line">connectRouter(history)(combineReducers(reducers)),</span><br></pre></td></tr></table></figure></p><h2 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h2><h3 id="ConnectedRouter配置"><a href="#ConnectedRouter配置" class="headerlink" title="ConnectedRouter配置"></a>ConnectedRouter配置</h3><p>ConnectedRouter类似BrowserRouter。MultiIntlProvider可以不用管就是一个高阶组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ConnectedRouter history=&#123;history&#125;&gt;</span><br><span class="line">    &lt;MultiIntlProvider defaultLocale=&#123;locale&#125; messageMap=&#123;messages&#125; &gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;Route key=&#123;path&#125; path=&quot;/dashboard/analysis/realtime&quot; component=&#123;Page&#125; /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    &lt;/MultiIntlProvider&gt;</span><br><span class="line"> &lt;/ConnectedRouter&gt;</span><br></pre></td></tr></table></figure><h3 id="使用BrowserRouter"><a href="#使用BrowserRouter" class="headerlink" title="使用BrowserRouter"></a>使用BrowserRouter</h3><p>项目的具体布局主要看 src/src-acl-router/AclRouter.jsx;<br>本项目应该用的是BrowserRouter，而非HashRouter，因为页面的路由都没有#。<br>整理出来如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter history=&#123;history&#125;&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/&quot;</span><br><span class="line">        render=&#123;() =&gt; &lt;Redirect to=&quot;/outlets&quot; /&gt;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/login&quot;</span><br><span class="line">        render=&#123;props =&gt; (</span><br><span class="line">          &lt;NormalLayout &#123;...props&#125;&gt;</span><br><span class="line">            &lt;RouteComponent &#123;...props&#125; /&gt;</span><br><span class="line">          &lt;/NormalLayout&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/outlets&quot;</span><br><span class="line">        render=&#123;props =&gt; (</span><br><span class="line">          &lt;BasicLayout &#123;...props&#125;&gt;</span><br><span class="line">            &lt;RouteComponent &#123;...props&#125; /&gt;</span><br><span class="line">          &lt;/BasicLayout&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/exception/403&quot;</span><br><span class="line">        render=&#123;props =&gt; (</span><br><span class="line">          &lt;BasicLayout &#123;...props&#125;&gt;</span><br><span class="line">            &lt;Unauthorized &#123;...props&#125; /&gt;</span><br><span class="line">          &lt;/BasicLayout&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        render=&#123;props =&gt; (</span><br><span class="line">          &lt;NotFound &#123;...props&#125; /&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line"> &lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure></p><h3 id="页面权限管理"><a href="#页面权限管理" class="headerlink" title="页面权限管理"></a>页面权限管理</h3><p>通过 permissions 配置，通过比对 登陆后 个人的权限user.authorities 与 页面的 permissions，来重组拼合 上面的 《使用BrowserRouter》：<br><strong>本项目在登陆后会重新重组渲染上面的 《使用BrowserRouter》</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &apos;/dashboard/analysis/offline&apos;,</span><br><span class="line">  exact: true,</span><br><span class="line">  permissions: [&apos;admin&apos;, &apos;user&apos;],</span><br><span class="line">  redirect: &apos;/login&apos;,</span><br><span class="line">  component: W11orkInProgress,</span><br><span class="line">  pageTitle: &apos;&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>场景一：当用户对某个页面没有权限时，AclRouter会将此页面 重定向到403页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route</span><br><span class="line">        path=&quot;/outlets&quot;</span><br><span class="line">        render=&#123;() =&gt; &lt;Redirect to=&quot;/exception/403&quot; /&gt;&#125;</span><br><span class="line">      /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="NotFound"><a href="#NotFound" class="headerlink" title="NotFound"></a>NotFound</h3><p>在《使用BrowserRouter》中的NotFound页面的路由设计挺好，此路由没有配置path，当上面的路由都未匹配时，就顺延到NotFound页面。</p><h3 id="路由配置项介绍"><a href="#路由配置项介绍" class="headerlink" title="路由配置项介绍"></a>路由配置项介绍</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &apos;/outlets&apos;,</span><br><span class="line">  exact: true,</span><br><span class="line">  //权限</span><br><span class="line">  permissions: [&apos;admin&apos;, &apos;user&apos;],</span><br><span class="line">  //当有权限时，一切正常时显示Outlets</span><br><span class="line">  component: Outlets,</span><br><span class="line">  //当没有权限时，换成显示Unauthorized</span><br><span class="line">  unauthorized: Unauthorized,</span><br><span class="line">  pageTitle: &apos;pageTitle_outlets&apos;,</span><br><span class="line">  //面包屑</span><br><span class="line">  breadcrumb: [&apos;/outlets&apos;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AclRouter"><a href="#AclRouter" class="headerlink" title="AclRouter"></a>AclRouter</h3><p>所有路由重组，全部在 AclRouter.js.<br>这个js亮点在于，在登陆前与登陆后，改变 mapStateToProps 中的 user props值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const Router = (&#123; history, user &#125;) =&gt; (</span><br><span class="line">  &lt;ConnectedRouter history=&#123;history&#125;&gt;</span><br><span class="line">    &lt;MultiIntlProvider</span><br><span class="line">      defaultLocale=&#123;locale&#125;</span><br><span class="line">      messageMap=&#123;messages&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;AclRouter</span><br><span class="line">        authorities=&#123;user.authorities&#125;</span><br><span class="line">        authorizedRoutes=&#123;authorizedRoutes&#125;</span><br><span class="line">        authorizedLayout=&#123;BasicLayout&#125;</span><br><span class="line">        normalRoutes=&#123;normalRoutes&#125;</span><br><span class="line">        normalLayout=&#123;NormalLayout&#125;</span><br><span class="line">        notFound=&#123;NotFound&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/MultiIntlProvider&gt;</span><br><span class="line">  &lt;/ConnectedRouter&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const mapStateToProps = state =&gt; (&#123;</span><br><span class="line">  user: state.app.user,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Router.propTypes = propTypes;</span><br><span class="line">export default connect(mapStateToProps)(Router);</span><br></pre></td></tr></table></figure></p><p>根据登陆前后的user props值在 AclRouter.js中重组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter history=&#123;history&#125;&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/&quot;</span><br><span class="line">        render=&#123;() =&gt; &lt;Redirect to=&quot;/outlets&quot; /&gt;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Route</span><br><span class="line">        path=&quot;/login&quot;</span><br><span class="line">        render=&#123;props =&gt; (</span><br><span class="line">          &lt;NormalLayout &#123;...props&#125;&gt;</span><br><span class="line">            &lt;RouteComponent &#123;...props&#125; /&gt;</span><br><span class="line">          &lt;/NormalLayout&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      ......</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line"> &lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure></p><p>真正做到了根据用户权限，动态改变重组整个BrowserRouter组件。</p><h3 id="BrowserRouter是组件"><a href="#BrowserRouter是组件" class="headerlink" title="BrowserRouter是组件"></a>BrowserRouter是组件</h3><p>如上，BrowserRouter 可通过connect 的 mapStateToProps 中的 user props值 重新渲染 BrowserRouter。<br>这也验证了 react-router中说的所有router都是组件的说法。</p><h3 id="因为BrowserRouter是组件，所以能理所当然地使用connect"><a href="#因为BrowserRouter是组件，所以能理所当然地使用connect" class="headerlink" title="因为BrowserRouter是组件，所以能理所当然地使用connect"></a>因为BrowserRouter是组件，所以能理所当然地使用connect</h3><p>见《BrowserRouter是组件》<br>参考demo /src/app/init/Router.js</p><h2 id="redux-设计"><a href="#redux-设计" class="headerlink" title="redux 设计"></a>redux 设计</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>在初始化公共目录下的js中统一注入reducer，并写了一个公共的action和reducer，此公共的action和reducer可能很多页面都要用，因此写在公共目录下，供很多页面使用<br>：参考：src/app.<br>每个页面的reducer与action写在每个页面目录下,例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- outlets</span><br><span class="line">  - action.js</span><br><span class="line">  - index.js</span><br><span class="line">  - index.scss</span><br><span class="line">  - reducer.js</span><br></pre></td></tr></table></figure></p><h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>在初始化js中，统一注入reducer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import outlets from &apos;views/outlets/reducer&apos;;</span><br><span class="line">import outletDetail from &apos;views/outletDetail/reducer&apos;;</span><br><span class="line">import app from &apos;../reducer&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  app,</span><br><span class="line">  outlets,</span><br><span class="line">  outletDetail,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>每个页面的reducer写在每个页面的目录下。</p><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>参考上面。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>每个页面都要处理 connect(mapStateToProps, mapDispatchToProps)(injectIntl(OutletDetail));</p><h3 id="等待改进部分"><a href="#等待改进部分" class="headerlink" title="等待改进部分"></a>等待改进部分</h3><p>connect 和 公共的action 单独整理 成connect高阶件，然后对比 考虑如何将post等继承其中</p><h2 id="待做"><a href="#待做" class="headerlink" title="待做"></a>待做</h2><ul><li>js源码调试</li><li>css-source map</li><li>mock</li><li>跨域请求 koa</li><li>webpack 代码分离 DllPlugin</li></ul><h1 id="版本v0-01"><a href="#版本v0-01" class="headerlink" title="版本v0.01"></a>版本v0.01</h1><h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><p>此版本是一个最简单的工程配置版本，指包含一个简单界面和项目最基本的html js css webpack处理。</p><h2 id="如何开始从0启动一个webpack项目"><a href="#如何开始从0启动一个webpack项目" class="headerlink" title="如何开始从0启动一个webpack项目"></a>如何开始从0启动一个webpack项目</h2><h3 id="注重-webpack-入口-："><a href="#注重-webpack-入口-：" class="headerlink" title="注重 webpack 入口 ："></a>注重 webpack 入口 ：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="项目最基本配置："><a href="#项目最基本配置：" class="headerlink" title="项目最基本配置："></a>项目最基本配置：</h3><p>一个项目无非围绕 html，css，js，图片，axios进行，因此对应的配置如下，本版本下的package.json配置的依赖都是基于以下最基本的配置：</p><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><p>html模版插件</p><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><p>scss、css、图片 loader<br>css、图片与html分离<br>css3加兼容性前缀</p><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><p>es6、es7编译成es5<br>es6、es7的api(如Promise等等)运行profill<br>一些es6等相关的babel js插件</p><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>webpack无非就是对html css js 图片文件的打包，因为又多了babel对js的打包，可以说工程项目中对js的打包是最丰富的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> redux-thunk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html笔记</title>
      <link href="/2021/01/03/html/"/>
      <url>/2021/01/03/html/</url>
      
        <content type="html"><![CDATA[<h2 id="html知识"><a href="#html知识" class="headerlink" title="html知识"></a>html知识</h2><h3 id="html语义化"><a href="#html语义化" class="headerlink" title="html语义化"></a>html语义化</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>js有语义化，html也有语义化，<br>HTML的语义化强调不要都使用div，建议使用header\footer\nav\section\input num\input email…..</p><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><h5 id="利于阅读；"><a href="#利于阅读；" class="headerlink" title="利于阅读；"></a>利于阅读；</h5><h5 id="利于seo"><a href="#利于seo" class="headerlink" title="利于seo"></a>利于seo</h5><h5 id="响应不同移动端弹框键盘"><a href="#响应不同移动端弹框键盘" class="headerlink" title="响应不同移动端弹框键盘"></a>响应不同移动端弹框键盘</h5><p>移动设备会根据不同的input 如何number、email、text、password；弹出不同的键盘，这是很多移动开发使用input语义化编写的重要原因。</p><h3 id="input元素为什么用自闭合的写法"><a href="#input元素为什么用自闭合的写法" class="headerlink" title="input元素为什么用自闭合的写法"></a>input元素为什么用自闭合的写法</h3><p>因为input不能再嵌套其他元素，所以用自闭合的写法，同样的元素有 img br hr meta link。</p><h3 id="HTML4-XML-HTML5的关系"><a href="#HTML4-XML-HTML5的关系" class="headerlink" title="HTML4 XML HTML5的关系"></a>HTML4 XML HTML5的关系</h3><p>XML其实就是xhtml。<br>html4的写法是一种比较宽松的写法，容错性高，你怎么写，基本上浏览器都不报错，约束性不强；<br>社区为了对html约束性更强，因此产生了xhtml，xhtml的约束性很强，但是对开发者不友好；<br>由于xml约束性太强对开发者写法要求高，不友好，因此逐渐被社区抛弃，重新回到html4，并因此产生了新对标准 html5.</p><p>因此html4和html5一样，只是5的标签和js api更丰富。<br>xml则与html差别较大，约束强，现在逐渐没有被使用了。</p><h3 id="值得使用元素"><a href="#值得使用元素" class="headerlink" title="值得使用元素"></a>值得使用元素</h3><p>section article header footer</p><h3 id="语义化意义"><a href="#语义化意义" class="headerlink" title="语义化意义"></a>语义化意义</h3><ul><li>开发者容易理解</li><li>机器容易理解结构，如搜索和毒屏软件；</li><li>利于seo<h3 id="html和Dom的关系"><a href="#html和Dom的关系" class="headerlink" title="html和Dom的关系"></a>html和Dom的关系</h3>Dom是由浏览器解析html解析而来的。<h3 id="form的作用"><a href="#form的作用" class="headerlink" title="form的作用"></a>form的作用</h3></li><li>可直接进行GET POST 方式 提交表单</li><li>可使用submit ／ reset按钮 提交表单</li><li>第三方库可整体提取form值，如jq。</li><li>第三方库只能通过form进行表单验证，例如angular 只能验证form标签的表单。</li></ul><h2 id="html-element"><a href="#html-element" class="headerlink" title="html element"></a>html element</h2><p>由于标签非html5新标签，但其属性可能是html5新属性，因此标签不分开成html与html5讲。</p><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><h4 id="download属性"><a href="#download属性" class="headerlink" title="download属性"></a>download属性</h4><p>属于html5特性，除ie不兼容外，其他浏览器都可兼容。<br>配置download时，告诉浏览器，表明a不是一个导航url，而是一个下载按钮</p><h4 id="href-”-top”-与-href-”-”"><a href="#href-”-top”-与-href-”-”" class="headerlink" title="href=”#top” 与 href=”#”"></a>href=”#top” 与 href=”#”</h4><p>属于html5属性，返回页面顶部。</p><h4 id="mailto-创建一个email链接"><a href="#mailto-创建一个email链接" class="headerlink" title="mailto :创建一个email链接"></a>mailto :创建一个email链接</h4><p>这是常见的创建按钮或链接，将用户的电子邮件程序打开，让他们发送新邮件。这是通过使用一个<strong>mailto</strong>链接完成的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;mailto:nowhere@mozilla.org&quot;&gt;Send email to nowhere&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><h4 id="tel-创建电话链接"><a href="#tel-创建电话链接" class="headerlink" title="tel :创建电话链接"></a>tel :创建电话链接</h4><p>这是通过使用一个<strong>tel</strong>链接完成的<br>提供电话链接有助于用户查看连接到手机的网络文档和笔记本电脑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;tel:+491570156&quot;&gt;+49 157 0156&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><h3 id="input与form"><a href="#input与form" class="headerlink" title="input与form"></a>input与form</h3><h4 id="name-与-form-结合"><a href="#name-与-form-结合" class="headerlink" title="name 与 form 结合"></a>name 与 form 结合</h4><p>name配合submit，再结合form的action使用。<br>点击下面的submit后，浏览器跳转url到 /submit.action?firstname=Mickey&amp;lastname=Mouse<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/submit.action&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;Mickey&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; name=&quot;lastname&quot; value=&quot;Mouse&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></figure></p><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p><code>&lt;base&gt;</code>元素 指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个<code>&lt;base&gt;</code>元素。</p><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><p><code>&lt;meta&gt;</code>元素表示那些不能由其它HTML<strong>元</strong>相关元素 (<code>&lt;base&gt;, &lt;link&gt;, &lt;script&gt;, &lt;style&gt; 或 &lt;title&gt;</code>) 之一表示的任何元数据信息.</p><h3 id="caption"><a href="#caption" class="headerlink" title="caption"></a>caption</h3><p>根table一起使用，caption用来显示表格的标题</p><h3 id="del-与-ins"><a href="#del-与-ins" class="headerlink" title="del 与 ins"></a>del 与 ins</h3><p>del标签表示一些被从文档中删除的文字内容<br>ins元素定义已经被插入文档中的文本(文字下划线效果)。<br><figure class="image-box">                <img src="/image/html/del_ins.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">del,</span><br><span class="line">ins &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    text-decoration: none;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">del &#123;</span><br><span class="line">    background-color: #fbb;</span><br><span class="line">&#125;</span><br><span class="line">ins &#123;</span><br><span class="line">    background-color: #d4fcbc;</span><br><span class="line">&#125;</span><br><span class="line">del::before,</span><br><span class="line">ins::before &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: .5rem;</span><br><span class="line">    font-family: monospace;</span><br><span class="line">&#125;</span><br><span class="line">del::before &#123;</span><br><span class="line">    content: &apos;−&apos;;</span><br><span class="line">&#125;</span><br><span class="line">ins::before &#123;</span><br><span class="line">    content: &apos;+&apos;;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">    margin: 0 1.8rem 0;</span><br><span class="line">    font-family: Georgia, serif;</span><br><span class="line">    font-size: 1rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;“You&apos;re late!”&lt;/p&gt;</span><br><span class="line">&lt;del&gt;</span><br><span class="line">    &lt;p&gt;“I apologize for the delay.”&lt;/p&gt;</span><br><span class="line">&lt;/del&gt;</span><br><span class="line">&lt;ins cite=&quot;../howtobeawizard.html&quot; datetime=&quot;2018-05&quot;&gt;</span><br><span class="line">    &lt;p&gt;“A wizard is never late …”&lt;/p&gt;</span><br><span class="line">&lt;/ins&gt;</span><br></pre></td></tr></table></figure></p><h3 id="fieldset-与-legend"><a href="#fieldset-与-legend" class="headerlink" title="fieldset 与 legend"></a>fieldset 与 legend</h3><p>元素通常用来对表单中的控制元素进行分组，二者需配合使用，可以放在form下面，也可以二者配合单独使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;#&quot;&gt;</span><br><span class="line">  &lt;fieldset&gt;</span><br><span class="line">    &lt;legend&gt;Simple fieldset&lt;/legend&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; id=&quot;radio&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;radio&quot;&gt;Spirit of radio&lt;/label&gt;</span><br><span class="line">  &lt;/fieldset&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/html/fieldset.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="hr"><a href="#hr" class="headerlink" title="hr"></a>hr</h3><p>可以来做分割线，也可以做双层分割线。<br><figure class="image-box">                <img src="/image/html/hr.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">  This is the first paragraph of text.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  This is the second paragraph of text.</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><h3 id="i"><a href="#i" class="headerlink" title="i"></a>i</h3><p><code>&lt;i&gt;</code>用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。<br>在html5 标准中，i 元素更多被用于表示icon。</p><h3 id="optgroup"><a href="#optgroup" class="headerlink" title="optgroup"></a>optgroup</h3><p>与 select配合使用，可创建带分组的option选项，十分好用，optgroup有两个属性：label和disabled。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">  &lt;optgroup label=&quot;Group 1&quot;&gt;</span><br><span class="line">    &lt;option&gt;Option 1.1&lt;/option&gt;</span><br><span class="line">  &lt;/optgroup&gt; </span><br><span class="line">  &lt;optgroup label=&quot;Group 2&quot;&gt;</span><br><span class="line">    &lt;option&gt;Option 2.1&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;Option 2.2&lt;/option&gt;</span><br><span class="line">  &lt;/optgroup&gt;</span><br><span class="line">  &lt;optgroup label=&quot;Group 3&quot; disabled&gt;</span><br><span class="line">    &lt;option&gt;Option 3.1&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;Option 3.2&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;Option 3.3&lt;/option&gt;</span><br><span class="line">  &lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><h3 id="option"><a href="#option" class="headerlink" title="option"></a>option</h3><p><code>&lt;option&gt;</code> 用于定义在<code>&lt;select&gt;,  &lt;optgroup&gt; 或&lt;datalist&gt;</code>元素中包含的项.<br>属性有：</p><ul><li>disabled</li><li>label</li><li>selected</li><li>value</li></ul><h3 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h3><p>可以将字符间的空格都能完整保留，非常不错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;rrrrr iiii     &lt;/pre&gt;</span><br></pre></td></tr></table></figure></p><h3 id="small"><a href="#small" class="headerlink" title="small"></a>small</h3><p>將使文本的字体变小一号</p><h2 id="html5-elemnt"><a href="#html5-elemnt" class="headerlink" title="html5 elemnt"></a>html5 elemnt</h2><h3 id="datalist-做可选值的输入框"><a href="#datalist-做可选值的输入框" class="headerlink" title="datalist :做可选值的输入框"></a>datalist :做可选值的输入框</h3><p><strong>此element 除移动端的安卓不支持（ios是支持的），pc完美支持</strong><br>input配合datalist 以及 option使用，可做出原生的可选值输入框，非常棒。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;label for=&quot;ice-cream-choice&quot;&gt;Choose a flavor:&lt;/label&gt;</span><br><span class="line">&lt;input list=&quot;ice-cream-flavors&quot; id=&quot;ice-cream-choice&quot; name=&quot;ice-cream-choice&quot; /&gt;</span><br><span class="line">&lt;datalist id=&quot;ice-cream-flavors&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;Chocolate&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;Coconut&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;Vanilla&quot;&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure></p><h3 id="details-与-summary-创建挂件"><a href="#details-与-summary-创建挂件" class="headerlink" title="details 与 summary :创建挂件"></a>details 与 summary :创建挂件</h3><p><strong>除ie外，其他都支持</strong><br>二者需配合使用才可达到创建挂件toggle的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;Details&lt;/summary&gt;</span><br><span class="line">    Something small enough to escape casual notice.</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure></p><h3 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h3><p><strong>全部兼容。</strong><br>可用来显示进度条。与 下面的meter相比，前者是圆角形状，后者是无圆角的长方条，相比之下，progress更适合进度条。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;progress value=&quot;70&quot; max=&quot;100&quot;&gt;70 %&lt;/progress&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/html/progress.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="meter"><a href="#meter" class="headerlink" title="meter"></a>meter</h3><p><strong>除ie外，其他都支持(包含edge)</strong><br>可用来显示进度条。<br><figure class="image-box">                <img src="/image/html/meter.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meter id=&quot;fuel&quot; name=&quot;fuel&quot;</span><br><span class="line">       min=&quot;0&quot; max=&quot;100&quot;</span><br><span class="line">       low=&quot;33&quot; high=&quot;66&quot; optimum=&quot;80&quot;</span><br><span class="line">       value=&quot;81&quot;&gt;</span><br><span class="line">    at 50/100</span><br><span class="line">&lt;/meter&gt;</span><br></pre></td></tr></table></figure></p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p><strong>除ie外，其他都支持(包含edge)</strong><br>output主要作用在于不用js，自动计算多个input的值，并显示。<br>output 必须配合form使用，以下代码要点：<br>定义output的name为result<br>在form中定义事件oninput，并定义result.value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form oninput=&quot;result.value=parseInt(a.value)+parseInt(b.value)&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;range&quot; name=&quot;b&quot; value=&quot;50&quot; /&gt; +</span><br><span class="line">  &lt;input type=&quot;number&quot; name=&quot;a&quot; value=&quot;10&quot; /&gt; =</span><br><span class="line">  &lt;output name=&quot;result&quot;&gt;60&lt;/output&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/html/meter.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="input-range"><a href="#input-range" class="headerlink" title="input range"></a>input range</h3><p><strong>所有浏览器兼容，ie支持到10</strong><br>定义划块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;range&quot; id=&quot;cowbell&quot; name=&quot;cowbell&quot; </span><br><span class="line">         min=&quot;0&quot; max=&quot;100&quot; value=&quot;90&quot; step=&quot;10&quot;&gt;</span><br></pre></td></tr></table></figure></p><h3 id="s"><a href="#s" class="headerlink" title="s"></a>s</h3><p><strong>全部兼容。</strong><br>与<code>&lt;del&gt;</code>一样，都是表示删除的划线效果，只是表示单纯的删除时可用<code>&lt;s&gt;</code>，但是表示编辑（有删除和添加时）推荐用del和ins<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;s&gt;There will be a few tickets available at the box office tonight.&lt;/s&gt;</span><br></pre></td></tr></table></figure></p><h3 id="sub-sup"><a href="#sub-sup" class="headerlink" title="sub sup"></a>sub sup</h3><p><strong>兼容所有浏览器</strong><br>分别代表上标和下标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Almost every developer&apos;s favorite molecule is</span><br><span class="line">  C&lt;sub&gt;8&lt;/sub&gt;H&lt;sub&gt;10&lt;/sub&gt;N&lt;sub&gt;4&lt;/sub&gt;O&lt;sub&gt;2&lt;/sub&gt;UU&lt;sup&gt;2&lt;/sup&gt;, also known as &quot;caffeine.&quot;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/html/sub.jpg" alt="" title="" class="">                <p></p>            </figure><h2 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h2><p>以下讲的都是全局属性：</p><h3 id="contenteditable"><a href="#contenteditable" class="headerlink" title="contenteditable"></a>contenteditable</h3><p>表示元素是否可被用户编辑。 如果可以，浏览器会修改元素的部件以允许编辑。<br>该属性是一个枚举属性，而非布尔属性。<br>这意味着必须显式设置其值为 true、false 或空字符串中的一个，并且不允许简写为 <code>&lt;label contenteditable&gt;Example Label&lt;/label&gt;</code>正确的用法是 <code>&lt;label contenteditable=&quot;true&quot;&gt;Example Label&lt;/label&gt;</code>。</p><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>可用于tooltip。</p><h3 id="data"><a href="#data" class="headerlink" title="data-*"></a>data-*</h3><p>是一类被称为自定义数据属性的属性，它赋予我们在所有 HTML 元素上嵌入自定义数据属性的能力，并可以通过脚本(一般指JavaScript：例如通过 HTMLElement.dataset获取属性值) 与 HTML 之间进行专有数据的交换。</p><h4 id="HTMLElement-dataset"><a href="#HTMLElement-dataset" class="headerlink" title="HTMLElement.dataset"></a>HTMLElement.dataset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;img class=&quot;spaceship cruiserX3&quot; src=&quot;shipX3.png&quot;</span><br><span class="line">  data-ship-id=&quot;324&quot; data-weapons=&quot;laserI laserII&quot; data-shields=&quot;72%&quot;</span><br><span class="line">  data-x=&quot;414354&quot; data-y=&quot;85160&quot; data-z=&quot;31940&quot;</span><br><span class="line">  onclick=&quot;spaceships[this.dataset.shipId].blasted()&quot;&gt;</span><br><span class="line">&lt;/img&gt;</span><br></pre></td></tr></table></figure><h4 id="css-伪元素-content：data（）"><a href="#css-伪元素-content：data（）" class="headerlink" title="css 伪元素 content：data（）"></a>css 伪元素 content：data（）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attr(data-abc);</span><br></pre></td></tr></table></figure><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p>是一个指示元素中文本方向的枚举属性</p><h3 id="lang"><a href="#lang" class="headerlink" title="lang"></a>lang</h3><p>这个语言是不可编辑元素写入的语言，或者可编辑元素应该写入的语言。<br>设置lang语言时，在文字开始位置会有一个对应语言的国旗logo</p><h2 id="HTML5属性"><a href="#HTML5属性" class="headerlink" title="HTML5属性"></a>HTML5属性</h2><h3 id="tabindex"><a href="#tabindex" class="headerlink" title="tabindex"></a>tabindex</h3><p>tabindex 是html5属性 ，非常好用， 指示其元素是否可以聚焦,<br>在html4中，不是每个标签都拥有focus属性，在html5中，通过tabindex，每个标签都可以定义focus属性。<br>比如input text，可直接在input元素定义onfocus，在任意的div中，要想使用onfocus等，定义tabindex就可使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div tabindex=&quot;0&quot;&gt;Tabbable due to tabindex.&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="draggable"><a href="#draggable" class="headerlink" title="draggable"></a>draggable</h3><p>是一个枚举类型的属性，用于标识元素是否允许使用 拖放操作API 拖动。</p><h2 id="HTML5-API"><a href="#HTML5-API" class="headerlink" title="HTML5 API"></a>HTML5 API</h2><h3 id="FormData-与-FileReader"><a href="#FormData-与-FileReader" class="headerlink" title="FormData 与 FileReader"></a>FormData 与 FileReader</h3><p>FormData 将数据表单序列化以便得到可以作为请求的参数;<br>FileReader 读取文件，比如实现图片预览；<br>详细参考《文件上传-file和drap拖拽两种方式》</p><h3 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h3><p>blob想象起来复制，其实也简单，目前对于blob无非就是文件下载或者是图片展示两种运用。<br><a href="https://github.com/YeWills/koa-demo/tree/response-file" target="_blank" rel="noopener">参考demo</a></p><h4 id="blob-与-FileReader"><a href="#blob-与-FileReader" class="headerlink" title="blob 与 FileReader"></a>blob 与 FileReader</h4><p>FileReader是能够操作blob的两种方式之一</p><h4 id="blob-与-window-URL-createObjectURL"><a href="#blob-与-window-URL-createObjectURL" class="headerlink" title="blob 与 window.URL.createObjectURL"></a>blob 与 window.URL.createObjectURL</h4><p>window.URL是能够操作blob的两种方式之一</p><h2 id="GlobalEventHandlers"><a href="#GlobalEventHandlers" class="headerlink" title="GlobalEventHandlers"></a>GlobalEventHandlers</h2><p>这里的浏览器主要指：ie edge 谷歌 火狐，注意 ie 和edge是分开讨论。下面说到所有浏览器时，指的就是这里的四个浏览器。</p><h3 id="右击-oncontextmenu"><a href="#右击-oncontextmenu" class="headerlink" title="右击 oncontextmenu"></a>右击 oncontextmenu</h3><p>ie不支持外，不过edge支持，且其他浏览器都支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在下面div右击时，就会执行console.log</span><br><span class="line"> &lt;div onclick=&quot;dd()&quot; oncontextmenu=&quot;console.log(123)&quot; class=&quot;aa left&quot;&gt;111&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="双击-ondblclick"><a href="#双击-ondblclick" class="headerlink" title="双击 ondblclick"></a>双击 ondblclick</h3><p>ie不支持外，其他都支持。</p><h3 id="错误-onerror"><a href="#错误-onerror" class="headerlink" title="错误 onerror"></a>错误 onerror</h3><p>ie edge 支持存疑，其他支持<br>可以收集节点元素的错误信息（几乎所有类型错误都能收集），通常用于window.onerror()，来收集错误报告，比较有用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = function (msg, url, lineNo, columnNo, error) &#123;</span><br><span class="line">    var string = msg.toLowerCase();</span><br><span class="line">    var substring = &quot;script error&quot;;</span><br><span class="line">    if (string.indexOf(substring) &gt; -1)&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = function(message, source, lineno, colno, error) &#123; ... &#125;</span><br><span class="line">函数参数：</span><br><span class="line">message：错误信息（字符串）。可用于HTML onerror=&quot;&quot;处理程序中的event。</span><br><span class="line">source：发生错误的脚本URL（字符串）</span><br><span class="line">lineno：发生错误的行号（数字）</span><br><span class="line">colno：发生错误的列号（数字）</span><br></pre></td></tr></table></figure><h3 id="按键down-onkeydown"><a href="#按键down-onkeydown" class="headerlink" title="按键down onkeydown"></a>按键down onkeydown</h3><p>除ie存疑外，其他都支持。<br>可以捕获按键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const input = document.querySelector(&apos;input&apos;);</span><br><span class="line">input.onkeydown = logKey;</span><br><span class="line">function logKey(e) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="按键up-onkeyup"><a href="#按键up-onkeyup" class="headerlink" title="按键up onkeyup"></a>按键up onkeyup</h3><p>除ie存疑外，其他都支持。<br>可以捕获按键 用法同上面的 onkeydown</p><h3 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h3><p>所有浏览器全部支持<br>用于处理Window, XMLHttpRequest, <img> 等元素的加载事件，当资源已加载时被触发。<br>注意，不仅可用于dom的onload，还可以用于ajax，img的加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;</span><br><span class="line">  init();</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;element onload=&quot;myScript&quot;&gt;</span><br><span class="line"></span><br><span class="line">object.onload = function()&#123;myScript&#125;;</span><br><span class="line"></span><br><span class="line">object.addEventListener(&quot;load&quot;, myScript);</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;w3javascript.gif&quot; onload=&quot;loadImage()&quot; width=&quot;100&quot; height=&quot;132&quot;&gt;</span><br><span class="line"></span><br><span class="line">var img = new Image();</span><br><span class="line">img.onload = function () &#123;</span><br><span class="line">   alert(&quot;image is loaded&quot;);</span><br><span class="line">&#125;</span><br><span class="line">img.src = &quot;img.jpg&quot;;</span><br></pre></td></tr></table></figure></p><p>在文档装载完成后会触发  load 事件。此时，在文档中的所有对象都在DOM中，所有图片，脚本，链接以及子框都完成了装载。<br>同时也会有 Gecko-指定 DOM事件，如 DOMContentLoaded 和 DOMFrameContentLoaded (它们可以使用 EventTarget.addEventListener() 来处理 ) ， 这些事件在页面DOM构建起来后就会触发，而不会等到其他的资源都装载完成。 </p><h3 id="onloadstart"><a href="#onloadstart" class="headerlink" title="onloadstart"></a>onloadstart</h3><p>浏览器全部兼容，不过谷歌中的img标签不支持unloadstart事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;myImage.jpg&quot;&gt;</span><br><span class="line">image.addEventListener(&apos;load&apos;, function(e) &#123;</span><br><span class="line">  console.log(&apos;Image loaded&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">image.addEventListener(&apos;loadstart&apos;, function(e) &#123;</span><br><span class="line">  console.log(&apos;Image load started&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">image.addEventListener(&apos;loadend&apos;, function(e) &#123;</span><br><span class="line">  console.log(&apos;Image load finished&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="鼠标事件-onmousedown-onmouseenter-onmouseleave-onmousemove-onmouseout-onmouseover-onmouseup"><a href="#鼠标事件-onmousedown-onmouseenter-onmouseleave-onmousemove-onmouseout-onmouseover-onmouseup" class="headerlink" title="鼠标事件 onmousedown onmouseenter onmouseleave onmousemove onmouseout onmouseover onmouseup"></a>鼠标事件 onmousedown onmouseenter onmouseleave onmousemove onmouseout onmouseover onmouseup</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>浏览器全兼容。<br>鼠标 按下、松开、划过、划出、划动、离开等等，各种鼠标动作，应有尽有。<br>能做出的效果：<br>如模拟 hover，但做出比hover更高级效果；<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onmousedown" target="_blank" rel="noopener">图片按住显示（onmousedown onmousemove onmouseup 示例）</a><br>图片鼠标选中后，放大显示；<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onmousemove" target="_blank" rel="noopener">跟随鼠标，实时显示</a></p><h4 id="onmouseleave-与-onmouseout-区别"><a href="#onmouseleave-与-onmouseout-区别" class="headerlink" title="onmouseleave 与  onmouseout 区别"></a>onmouseleave 与  onmouseout 区别</h4><p>onmouseleave 事件类似于 onmouseout 事件。 唯一的区别是 onmouseleave 事件不支持冒泡 ，更多说明参考<a href="https://www.runoob.com/jsref/event-onmouseleave.html" target="_blank" rel="noopener">菜鸟教程</a></p><h4 id="onmouseenter-与-onmouseove-区别"><a href="#onmouseenter-与-onmouseove-区别" class="headerlink" title="onmouseenter  与 onmouseove 区别"></a>onmouseenter  与 onmouseove 区别</h4><p>二者区别同 《onmouseleave 与  onmouseout 区别》，请参考<a href="https://www.runoob.com/jsref/event-onmouseleave.html" target="_blank" rel="noopener">菜鸟教程</a>。</p><p>更多示例 <a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onmousemove" target="_blank" rel="noopener">跟随鼠标，实时显示</a><br>示例中的方案应该可以实现淘宝页面中的 图片鼠标划动，放大显示；</p><h4 id="区别使用onmouseleave与onmouseout很重要"><a href="#区别使用onmouseleave与onmouseout很重要" class="headerlink" title="区别使用onmouseleave与onmouseout很重要"></a>区别使用onmouseleave与onmouseout很重要</h4><p>二者表达意思虽一样，但leave只触发一次，out会触发多次，因此一定要区别使用，避免代码多余执行。<br>onmouseenter  与 onmouseove同理。<br>详见 <a href="https://www.runoob.com/jsref/event-onmouseleave.html" target="_blank" rel="noopener">菜鸟教程</a>中的例子。</p><h3 id="onscroll"><a href="#onscroll" class="headerlink" title="onscroll"></a>onscroll</h3><p>ie存疑外，其他都支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const textarea = document.querySelector(&apos;textarea&apos;);</span><br><span class="line">const log = document.getElementById(&apos;log&apos;);</span><br><span class="line">textarea.onscroll = logScroll;</span><br><span class="line">function logScroll(e) &#123;</span><br><span class="line">  log.textContent = `Scroll position: $&#123;e.target.scrollTop&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="onselect"><a href="#onselect" class="headerlink" title="onselect"></a>onselect</h3><p>ie存疑外，其他都支持<br>只有在文本框和文本域内选择文本才会触发select事件.<br>非常好用的事件，<a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onselect" target="_blank" rel="noopener">demo</a>；<br>在输入框内选中一段文字，会将这段文字捕获作为参数。</p><h3 id="表单事件-onreset-onsubmit"><a href="#表单事件-onreset-onsubmit" class="headerlink" title="表单事件 onreset onsubmit"></a>表单事件 onreset onsubmit</h3><p>表单重置、表单提交。</p><h3 id="onwheel"><a href="#onwheel" class="headerlink" title="onwheel"></a>onwheel</h3><p>所有浏览器全部支持；<br>onwheel 特性指向当前元素的滑轮滑动事件函数 EventHandler。<br>当双指划动时，会触发onwheel：<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onwheel" target="_blank" rel="noopener">双指缩放显示 demo</a></p><h3 id="拖拽事件-ondrag-ondragend-ondrop-ondragstart-ondragover-ondragleave-ondragexit"><a href="#拖拽事件-ondrag-ondragend-ondrop-ondragstart-ondragover-ondragleave-ondragexit" class="headerlink" title="拖拽事件 ondrag ondragend ondrop ondragstart ondragover ondragleave ondragexit"></a>拖拽事件 ondrag ondragend ondrop ondragstart ondragover ondragleave ondragexit</h3><p>所有浏览器都支持</p><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="noopener">拖放 API</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dragondrag当拖动元素或选中的文本时触发。</span><br><span class="line">dragendondragend当拖拽操作结束时触发 (比如松开鼠标按键或敲“Esc”键). (见结束拖拽)</span><br><span class="line">dragenterondragenter当拖动元素或选中的文本到一个可释放目标时触发（见 指定释放目标）。</span><br><span class="line">dragexitondragexit当元素变得不再是拖动操作的选中目标时触发。</span><br><span class="line">dragleaveondragleave当拖动元素或选中的文本离开一个可释放目标时触发。</span><br><span class="line">dragoverondragover当元素或选中的文本被拖到一个可释放目标上时触发（每100毫秒触发一次）。</span><br><span class="line">dragstartondragstart当用户开始拖动一个元素或选中的文本时触发（见开始拖动操作）。</span><br><span class="line">dropondrop当元素或选中的文本在可释放目标上被释放时触发（见执行释放）。</span><br></pre></td></tr></table></figure></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/ondrag" target="_blank" rel="noopener">直接看mdn demo,对应api都有demo</a></p><h4 id="drap与mouse"><a href="#drap与mouse" class="headerlink" title="drap与mouse"></a>drap与mouse</h4><p>drap相关事件与上面的mouse事件相似；<br>只不过，mouse事件是将鼠标光标移动到element区域触发；drap是将拖拽的element移动到element区域触发；<br>将拖拽的element看成是光标，那么drap与mouse理解起来就差不多一样了。</p><h4 id="drap-与-event-dataTransfer-setData"><a href="#drap-与-event-dataTransfer-setData" class="headerlink" title="drap 与 event.dataTransfer.setData"></a>drap 与 event.dataTransfer.setData</h4><p>非常好的数据传输方法，drap事件的event对象都有dataTransfer API。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function dragstart_handler(ev) &#123;</span><br><span class="line"> console.log(&quot;dragStart&quot;);</span><br><span class="line"> ev.dataTransfer.setData(&quot;text&quot;, ev.target.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function drop_handler(ev) &#123;</span><br><span class="line"> console.log(&quot;Drop&quot;);</span><br><span class="line"> ev.currentTarget.style.background = &quot;lightyellow&quot;;</span><br><span class="line"></span><br><span class="line"> ev.preventDefault();</span><br><span class="line"> var data = ev.dataTransfer.getData(&quot;text&quot;);</span><br><span class="line"> ev.target.appendChild(document.getElementById(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/ondrag" target="_blank" rel="noopener">直接看mdn demo,对应api都有demo</a></p><h2 id="应用demo"><a href="#应用demo" class="headerlink" title="应用demo"></a>应用demo</h2><h3 id="文件上传-file和drap拖拽两种方式"><a href="#文件上传-file和drap拖拽两种方式" class="headerlink" title="文件上传-file和drap拖拽两种方式"></a>文件上传-file和drap拖拽两种方式</h3><p><a href="https://github.com/YeWills/file-upload" target="_blank" rel="noopener">详细参考demo</a></p><h4 id="type-text-input-获取file的三种方式："><a href="#type-text-input-获取file的三种方式：" class="headerlink" title="type=text input 获取file的三种方式："></a>type=text input 获取file的三种方式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//dom元素直接获取</span><br><span class="line"> document.getElementById(&quot;chooseFile&quot;).files[0];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//change事件</span><br><span class="line">  var file = document.querySelector(&apos;#file&apos;);</span><br><span class="line">  file.addEventListener(&apos;change&apos;, previewImage, false);</span><br><span class="line">  function previewImage(event) &#123;</span><br><span class="line">      event.target.files[0]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//formData 方式</span><br><span class="line">&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; name=&quot;fileinfo&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;fileName&quot; required /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">var form = document.forms.namedItem(&quot;fileinfo&quot;);</span><br><span class="line">var oData = new FormData(form);</span><br><span class="line">var file = oData.get(&apos;fileName&apos;)</span><br></pre></td></tr></table></figure><h4 id="drag-获取file方式："><a href="#drag-获取file方式：" class="headerlink" title="drag 获取file方式："></a>drag 获取file方式：</h4><p>参考：drap_file\dragInfo.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evt.dataTransfer.files</span><br></pre></td></tr></table></figure></p><h4 id="上传过程："><a href="#上传过程：" class="headerlink" title="上传过程："></a>上传过程：</h4><p>选择文件、预览、上传到服务器、服务器上传进度、服务器上传成功</p><h4 id="FormData与文件上传"><a href="#FormData与文件上传" class="headerlink" title="FormData与文件上传"></a>FormData与文件上传</h4><p>文件上传必须要使用FormData对文件流进行表单序列化，这样才可以被服务器端解析。<br>下面是三种服务器端上传图片的示例，每种示例都使用了formData进行文件流表格序列化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var formData = new FormData();</span><br><span class="line">formData.append(&apos;test-upload&apos;, file.files[0]);</span><br><span class="line">xhr.upload.onprogress = setProgress;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let file = document.getElementById(&quot;chooseFile&quot;).files[0];</span><br><span class="line">let formData = new FormData();</span><br><span class="line">formData.append(&quot;avatar&quot;, file);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &apos;POST&apos;,</span><br><span class="line">    url: &apos;/profile&apos;,</span><br><span class="line">    data: formData,</span><br><span class="line">    async: false,</span><br><span class="line">    cache: false,</span><br><span class="line">    contentType: false,</span><br><span class="line">    processData: false,</span><br><span class="line">    success: function (data) &#123;</span><br><span class="line">        $(&quot;.newImg&quot;).attr(&quot;src&quot;, data.filePath);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function (err) &#123;</span><br><span class="line">        console.log(err.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&apos;post&apos; action=&apos;/profile&apos; enctype=&apos;multipart/form-data&apos;&gt;</span><br><span class="line">   选择图片：&lt;input name=&quot;avatar&quot; id=&apos;upfile&apos; type=&apos;file&apos;/&gt;</span><br><span class="line">   &lt;input type=&apos;submit&apos; value=&apos;提交&apos;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h4 id="multer与文件上传"><a href="#multer与文件上传" class="headerlink" title="multer与文件上传"></a>multer与文件上传</h4><p>express，收到前台的上传请求后，因为上传文件的请求时一个多类型文件数据(multipart/form-data)请求，<br>必须通过require(‘multer’)才能正常处理这样的请求。<br>multer就是为了 处理多文件接口而生。</p><h4 id="上传技术说明"><a href="#上传技术说明" class="headerlink" title="上传技术说明"></a>上传技术说明</h4><p>FileReader 实现图片预览<br>通过FormData将file表格序列化，这样才能被post框架接收为参数，传给后台，并被后台识别；<br>上传的进度条和成功处理通过post框架的相关事件做：<br>以原生为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.onload = uploadSuccess; //成功处理</span><br><span class="line">xhr.upload.onprogress = setProgress;  //进度处理</span><br></pre></td></tr></table></figure></p><p>后台express，收到前台的上传请求后，通过中间件multer处理后，通过fs读取数据，并将上传的文件存到指定文件夹(/uploads)，整个上传过程结束。</p><h4 id="其他技术点"><a href="#其他技术点" class="headerlink" title="其他技术点"></a>其他技术点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dragenter</span><br><span class="line">dragover</span><br><span class="line">dragleave</span><br><span class="line">drop</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 笔记</title>
      <link href="/2021/01/03/react/"/>
      <url>/2021/01/03/react/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="warning-uncontrolled-to-be-controlled"><a href="#warning-uncontrolled-to-be-controlled" class="headerlink" title="warning:uncontrolled .. to be controlled"></a>warning:uncontrolled .. to be controlled</h3><p>主要还是给input的value在 有值与没有值-undefined 之间切换了，解决之道在于始终保持 value为值： value || ‘’ ；用‘’ 代替 undefined。<br><a href="https://stackoverflow.com/questions/47012169/a-component-is-changing-an-uncontrolled-input-of-type-text-to-be-controlled-erro" target="_blank" rel="noopener">解决方案参考</a></p><h3 id="之类的-React-元素本质就是对象（object）"><a href="#之类的-React-元素本质就是对象（object）" class="headerlink" title=" 之类的 React 元素本质就是对象（object）"></a><chat> 之类的 React 元素本质就是对象（object）</chat></h3><p><a href="https://react.docschina.org/docs/composition-vs-inheritance.html" target="_blank" rel="noopener">参考官网</a><br><code>&lt;Contacts /&gt; 和 &lt;Chat /&gt;</code>之类的 React 元素本质就是对象（object）<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SplitPane</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"SplitPane"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"SplitPane-left"</span>&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="SplitPane-right"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;props.right&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function App() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;SplitPane</span></span><br><span class="line"><span class="regexp">      left=&#123;</span></span><br><span class="line"><span class="regexp">        &lt;Contacts /</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right=&#123;</span><br><span class="line">        &lt;Chat /&gt;</span><br><span class="line">      &#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="什么是-React-元素"><a href="#什么是-React-元素" class="headerlink" title="什么是 React 元素"></a>什么是 React 元素</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>如上《<code>&lt;Chat /&gt;</code>之类的 React 元素本质就是对象（object）》<code>&lt;Chat\&gt;</code>这些就是React元素。<br>注意 Chat 是字符串，不是React元素， 带上小书括号的<code>&lt;Chat\&gt;</code>才是React元素。</p><h4 id="React元素就是object"><a href="#React元素就是object" class="headerlink" title="React元素就是object"></a>React元素就是object</h4><p>如上《<code>&lt;Chat /&gt;</code>之类的 React 元素本质就是对象（object）》</p><h3 id="Context-Provider的更新与consumer组件渲染问题"><a href="#Context-Provider的更新与consumer组件渲染问题" class="headerlink" title="Context.Provider的更新与consumer组件渲染问题"></a>Context.Provider的更新与consumer组件渲染问题</h3><p><a href="https://react.docschina.org/docs/context.html#contextprovider" target="_blank" rel="noopener">参考官网Context.Provider</a>。<br>当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。</p><h3 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h3><p>Context.Consumer是一种<strong>child function 模式</strong>，它类似一个context闭包，它会给它的child function 注入所有的context state；<br>并且会在底层 执行 child function。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContext.Consumer&gt;</span><br><span class="line">  &#123;value =&gt; <span class="comment">/* 基于 context 值进行渲染*/</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/MyContext.Consumer&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (</span><br><span class="line">        &lt;button          onClick=&#123;toggleTheme&#125;</span><br><span class="line">          style=&#123;&#123;<span class="attr">backgroundColor</span>: theme.background&#125;&#125;&gt;</span><br><span class="line"></span><br><span class="line">          Toggle Theme</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于：</span></span><br><span class="line">&lt;button          onClick=&#123;toggleTheme&#125;</span><br><span class="line">          style=&#123;&#123;<span class="attr">backgroundColor</span>: theme.background&#125;&#125;&gt;</span><br><span class="line"></span><br><span class="line">          Toggle Theme</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><h4 id="ref是实例还是dom元素？"><a href="#ref是实例还是dom元素？" class="headerlink" title="ref是实例还是dom元素？"></a>ref是实例还是dom元素？</h4><p>当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。<br>当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。<br><strong>你不能在函数组件上使用 ref 属性，因为他们没有实例。</strong></p><h4 id="不能在函数组件上使用-ref"><a href="#不能在函数组件上使用-ref" class="headerlink" title="不能在函数组件上使用 ref"></a>不能在函数组件上使用 ref</h4><p>参考《ref是什么》</p><h4 id="ref转发技术与React-forwardRef"><a href="#ref转发技术与React-forwardRef" class="headerlink" title="ref转发技术与React.forwardRef"></a>ref转发技术与React.forwardRef</h4><p>ref转发可用于获取子组件内部的ref，或者处理hoc ref无法获取的问题。<br>React.forwardRef理解与Context.Consumer类似，<br>通过React.forwardRef,可以让它的第一个参数是一个函数，并且这个函数有能力获得props和ref；当获得ref时，你就可以对ref的进一步的转发应用了。</p><p>详细参考官网<a href="https://react.docschina.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components" target="_blank" rel="noopener">在高阶组件中转发 refs</a>，这里有ref转发非常棒的应用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LogProps</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br></pre></td></tr></table></figure></p><h4 id="React-forwardRef"><a href="#React-forwardRef" class="headerlink" title="React.forwardRef"></a>React.forwardRef</h4><p>一般用于以下两个作用：</p><ul><li>转发 refs 到 DOM 组件</li><li>在高阶组件中转发 refs</li></ul><h4 id="两种获取子组件内部元素的ref"><a href="#两种获取子组件内部元素的ref" class="headerlink" title="两种获取子组件内部元素的ref"></a>两种获取子组件内部元素的ref</h4><p>有两种方式：</p><ul><li>方式一，参考《ref转发技术与React.forwardRef》</li><li>方式二，函数回调方式：<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;CustomTextInput</span><br><span class="line">        inputRef=&#123;el =&gt; <span class="keyword">this</span>.inputElement = el&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomTextInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="处理hoc-ref无法获取的问题"><a href="#处理hoc-ref无法获取的问题" class="headerlink" title="处理hoc ref无法获取的问题"></a>处理hoc ref无法获取的问题</h4><p>参考《ref转发技术与React.forwardRef》</p><h3 id="Portal-不一样的事件冒泡"><a href="#Portal-不一样的事件冒泡" class="headerlink" title="Portal 不一样的事件冒泡"></a>Portal 不一样的事件冒泡</h3><p>尽管 portal 可以被放置在 DOM 树中的任何地方，但在任何其他方面，其行为和普通的 React 子节点行为一致。由于 portal 仍存在于 React 树， 且与 DOM 树 中的位置无关，那么无论其子节点是否是 portal，像 context 这样的功能特性都是不变的。<br><a href="https://react.docschina.org/docs/portals.html#event-bubbling-through-portals" target="_blank" rel="noopener">参考</a></p><h3 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h3><h4 id="只用于function组件"><a href="#只用于function组件" class="headerlink" title="只用于function组件"></a>只用于function组件</h4><p>React.memo只适用于函数组件，而不适用 class 组件</p><h4 id="仅检查-props-变更"><a href="#仅检查-props-变更" class="headerlink" title="仅检查 props 变更"></a>仅检查 props 变更</h4><p>React.memo 仅检查 props 变更</p><h3 id="服务端渲染SSR的两个好处-相比客户端CSR"><a href="#服务端渲染SSR的两个好处-相比客户端CSR" class="headerlink" title="服务端渲染SSR的两个好处(相比客户端CSR)"></a>服务端渲染SSR的两个好处(相比客户端CSR)</h3><p>利于seo与首屏渲染。</p><h3 id="Fiber与Stack"><a href="#Fiber与Stack" class="headerlink" title="Fiber与Stack"></a>Fiber与Stack</h3><p><a href="https://www.imooc.com/video/21308" target="_blank" rel="noopener">参考</a></p><h4 id="动画1秒60帧"><a href="#动画1秒60帧" class="headerlink" title="动画1秒60帧"></a>动画1秒60帧</h4><p>人眼中，如果1秒内有60帧，那么动画看起来流畅，否则就卡顿。这样算起来，一帧就是12毫秒。</p><h4 id="Stack-16版本之前的渲染模式"><a href="#Stack-16版本之前的渲染模式" class="headerlink" title="Stack - 16版本之前的渲染模式"></a>Stack - 16版本之前的渲染模式</h4><p>主要特点，等等整个虚拟树完成了比较后，再统一渲染，如果渲染节点巨大，虚拟树比较的工作可能会超过12毫秒，此时会出现卡顿现象。</p><h4 id="Fiber-16版本的渲染模式"><a href="#Fiber-16版本的渲染模式" class="headerlink" title="Fiber - 16版本的渲染模式"></a>Fiber - 16版本的渲染模式</h4><p>主要特点，将整个虚拟数的比对拆分成很多个小任务，每个小任务的完成时间控制在一帧12毫秒内，每个小任务完成后都会完成一次渲染（小任务对应的局部渲染）。<br>因为每次渲染都控制在一帧以内，不用等所有任务或整个树比对完后才渲染，所有看起来流畅，不卡顿。</p><h3 id="react-与-react-native-关系"><a href="#react-与-react-native-关系" class="headerlink" title="react 与 react native 关系"></a>react 与 react native 关系</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>react框架设计时就考虑一个框架同时用于pc端和移动端。<br>其中将二者公共部分抽成 react 包内；<br>pc端 抽到 react-dom内，封装了浏览器的dom；<br>移动端 抽到 react-native内，封装了跟移动端有关的如打开相机 打开gps 原生能力；</p><p>因此 react+react-dom 结合用于pc开发；<br>react+react-native 结合用于移动端开发；<br><a href="https://www.imooc.com/video/21307" target="_blank" rel="noopener">更多参考</a></p><figure class="image-box">                <img src="/image/react/native.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="react-native-相当于pc的-react-dom"><a href="#react-native-相当于pc的-react-dom" class="headerlink" title="react native 相当于pc的 react-dom"></a>react native 相当于pc的 react-dom</h4><p>参考上面《概述》</p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><a href="https://segmentfault.com/a/1190000016539430" target="_blank" rel="noopener">参考</a><br><a href="https://www.cnblogs.com/forcheng/p/13246874.html" target="_blank" rel="noopener">参考</a><br><a href="https://www.bilibili.com/video/BV1B7411H7fL?from=search&amp;seid=16040033068650647202" target="_blank" rel="noopener">参考</a><br>主要进行以下三方面比较：</p><ul><li>tree diff 树比较   如果根节点 类型不一样，直接卸载，如果类型一样，则进行props比较；</li><li>component diff 组件比较  根据props不同，进行更新操作；</li><li>element diff 组件内节点比较 比如组件内列表节点比较，<ul><li>若无，就新建，</li><li>若删除，就卸载</li><li>若有，就比较顺序，这里就有个性能问题了，一般将原来最后的组件放在最前面，比较消耗性能。下面单独讲这块。</li></ul></li></ul><h4 id="不一样的-element-diff-比较规则"><a href="#不一样的-element-diff-比较规则" class="headerlink" title="不一样的 element diff 比较规则"></a>不一样的 element diff 比较规则</h4><p>详细<a href="https://www.bilibili.com/video/BV1B7411H7fL?from=search&amp;seid=16040033068650647202" target="_blank" rel="noopener">参考</a> 。<br><figure class="image-box">                <img src="/image/react/diff.jpg" alt="" title="" class="">                <p></p>            </figure><br>下面说明下为什么将最后面的组件放到最前面，最消耗性能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//原来顺序 A B C D</span><br><span class="line"></span><br><span class="line">//最新顺序 D A B C</span><br><span class="line">// 比较 D： lastindex 初始值为0， D原来的下标montindex是3，由于 lastindex &lt; mountindex, 因此D不移动，不过 lastindex将更新为mountindex， lastindex = 3.</span><br><span class="line">// 比较 A： 由上一步可知 D的lastindex为3，那么A的lastindex按照位置递增为4；而A原来的mountindex为0，lastindex &gt; mountindex ,A将向右移动，根据规则，lastindex不更新。</span><br><span class="line">// 比较 B： 根A一样，B 的lastindex 递增为 5，B将向右移动。</span><br><span class="line">// 比较 C： 跟上面一样， C的lastindex 递增为6，C将向右移动。</span><br><span class="line">// 比较完毕</span><br></pre></td></tr></table></figure></p><p>上面除了D没有移动位置，其他所有ABC元素都将移动位置，这将比较消耗性能。</p><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><h3 id="使用代理hoc就够了"><a href="#使用代理hoc就够了" class="headerlink" title="使用代理hoc就够了"></a>使用代理hoc就够了</h3><p>高阶组件有多种，但用得最多的是代理和继承hoc，由于代理hoc强大的便利性和作用，能用代理实现的不用继承hoc，因此实际项目中基本上用的是代理hoc，使用代理hoc，基本上就够你的开发需求了。</p><h3 id="hoc定义"><a href="#hoc定义" class="headerlink" title="hoc定义"></a>hoc定义</h3><h4 id="高阶函数定义"><a href="#高阶函数定义" class="headerlink" title="高阶函数定义"></a>高阶函数定义</h4><p>满足下面二者之一即为高阶组件(英文 Higher-Order Functions)。</p><ul><li>函数可以作为参数被传递；</li><li>函数可以作为返回值输出：<br><a href="https://blog.bitsrc.io/understanding-higher-order-functions-in-javascript-75461803bad" target="_blank" rel="noopener">参考 Higher-Order Functions</a><br><a href="https://www.imooc.com/video/18254/0" target="_blank" rel="noopener">慕课网</a></li></ul><h4 id="hoc定义-1"><a href="#hoc定义-1" class="headerlink" title="hoc定义"></a>hoc定义</h4><p>高阶组件就是接受一个组件作为参数并返回一个组件的函数。高阶组件具有以下特征：</p><ul><li>接受一个组件作为参数，并且返回一个新组件；</li><li>是一个函数，但不是一个组件；</li></ul><h3 id="代理hoc作用"><a href="#代理hoc作用" class="headerlink" title="代理hoc作用"></a>代理hoc作用</h3><p>因为项目中一般用的是代理hoc，这里先讲代理hoc作用。</p><h4 id="操纵prop"><a href="#操纵prop" class="headerlink" title="操纵prop"></a>操纵prop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@defaultValueHoc</span><br><span class="line">export default class Test extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                标题：&#123;this.props.defaultValue&#125;&lt;br/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const defaultValueHoc = (Comp) =&gt;&#123;</span><br><span class="line">    return class Wrap extends Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return &lt;Comp defaultValue=&quot;testVale&quot; /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问ref"><a href="#访问ref" class="headerlink" title="访问ref"></a>访问ref</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@defaultValueHoc</span><br><span class="line">export default class Login extends Component &#123;</span><br><span class="line">renderHear = ()=&gt;&#123;</span><br><span class="line">    return &lt;div&gt;it is header title&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            标题：good&lt;br/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const defaultValueHoc = (Comp) =&gt;&#123;</span><br><span class="line">  return class Wrap extends Component &#123;</span><br><span class="line">      state = &#123;</span><br><span class="line">        header:&apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      setRef=(CompInstance)=&gt;&#123;</span><br><span class="line">          const renderHear = CompInstance &amp;&amp; CompInstance.renderHear;</span><br><span class="line">          if(renderHear)&#123;</span><br><span class="line">            this.setState(&#123;header: renderHear()&#125;)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      render() &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;div style=&#123;&#123;background: &apos;red&apos;&#125;&#125;&gt;&#123;this.state.header&#125;&lt;/div&gt;</span><br><span class="line">              &lt;Comp defaultValue=&quot;testVale&quot; ref=&#123;this.setRef&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽取状态"><a href="#抽取状态" class="headerlink" title="抽取状态"></a>抽取状态</h4><p>抽取状态的好处是，由hoc统一写状态，将相同状态逻辑提取到hoc上，下次有相同逻辑时，直接将hoc装饰上即可，避免相同逻辑重复写，便于维护和代码精简。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 抽取状态之前</span><br><span class="line">class Login extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    value:&apos;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  onChange = (e)=&gt;&#123;</span><br><span class="line">    this.setState(&#123;value: e.target.value&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">      return (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">              &lt;input value=&#123;this.state.value&#125; onChange=&#123;this.onChange&#125; /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 抽取状态之后</span><br><span class="line">@defaultValueHoc</span><br><span class="line">export default class Login extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">      return (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">              &lt;input &#123;...this.props&#125; /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const defaultValueHoc = (Comp) =&gt;&#123;</span><br><span class="line">  return class Wrap extends Component &#123;</span><br><span class="line">      state = &#123;</span><br><span class="line">        value:&apos;统一设置提示语&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      onChange = (e)=&gt;&#123;</span><br><span class="line">        this.setState(&#123;value: e.target.value&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      render() &#123;</span><br><span class="line">        const moreProps = &#123;</span><br><span class="line">          value: this.state.value,</span><br><span class="line">          onChange: this.onChange</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(moreProps)</span><br><span class="line">          return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;Comp &#123;...this.props&#125; &#123;...moreProps&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="包裹组件"><a href="#包裹组件" class="headerlink" title="包裹组件"></a>包裹组件</h4><p>hoc包裹组件但作用显而易见，上面几个例子都是包裹了组件。</p><h3 id="继承hoc作用"><a href="#继承hoc作用" class="headerlink" title="继承hoc作用"></a>继承hoc作用</h3><ul><li>操作prop</li><li>操作生命周期</li></ul><p><a href="https://www.imooc.com/video/18258" target="_blank" rel="noopener">参考</a></p><h3 id="代理hoc与继承hoc比较"><a href="#代理hoc与继承hoc比较" class="headerlink" title="代理hoc与继承hoc比较"></a>代理hoc与继承hoc比较</h3><figure class="image-box">                <img src="/image/react/hoc2.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/react/hoc1.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="高阶组件显示名"><a href="#高阶组件显示名" class="headerlink" title="高阶组件显示名"></a>高阶组件显示名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const defaultValueHoc = (Comp) =&gt; &#123;</span><br><span class="line">  return class Wrap extends Component &#123;</span><br><span class="line">      static displayName = `NewComponent($&#123;Comp.displayName || Comp.name || &apos;Component&apos;&#125;)`;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        return &lt;Comp &#123;...this.props&#125; /&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="hoc-与-装饰器-配合时报错问题"><a href="#hoc-与-装饰器-配合时报错问题" class="headerlink" title="hoc 与 装饰器 配合时报错问题"></a>hoc 与 装饰器 配合时报错问题</h3><p>hoc与装饰器一起使用的时候，请一定要加上<code>export default</code>，不然会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@defaultValueHoc</span><br><span class="line">export default class Login extends Component &#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h2><h3 id="React-cloneElement是一把好刀"><a href="#React-cloneElement是一把好刀" class="headerlink" title="React.cloneElement是一把好刀"></a>React.cloneElement是一把好刀</h3><p>其最好的两个用法在于：<br>1.让你任意地方定义组件，然后让你按照意图，重新把组件渲染在指定位置；<br>2.重新组装props；<br>React.cloneElement是一个非常好用的API，给力你极大的自由，可以让你做很多意想不到的事情。</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>详细参考<a href="https://zh-hans.reactjs.org/docs/context.html" target="_blank" rel="noopener">使用 Context 之前的考虑</a>,<br>如下，Page是最外层父层 ，层级关系如下： Page-》PageLayout-》NavigationBar-》Link ，Link是最内层，最子层；如果Page要给Link传递参数，就必须给中间的每个组件设置相同的props，非常麻烦。还有一个麻烦是，如果后期Link还需要Page的更多参数，那么又要给每个组件加props，麻烦得狠。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Page user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line">&lt;PageLayout user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line">&lt;NavigationBar user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line">&lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">  &lt;Avatar user=&#123;user&#125; size=&#123;avatarSize&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure></p><p>为了解决上面的问题，因为Link的数据只与Page相关，那么在Page上将Link写成一个函数，在Page组件内将Link组装好，最后将Link自身传给最内层渲染即可，减少了传props的个数，也容易维护。使用类似 Render props的形式：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = props.user;</span><br><span class="line">  <span class="keyword">const</span> userLink = (</span><br><span class="line">    &lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">      &lt;Avatar user=&#123;user&#125; size=&#123;props.avatarSize&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">  return &lt;PageLayout userLink=&#123;userLink&#125; /</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，我们有这样的组件：</span></span><br><span class="line">&lt;Page user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt;</span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line">&lt;PageLayout userLink=&#123;...&#125; /&gt;</span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line">&lt;NavigationBar userLink=&#123;...&#125; /&gt;</span><br><span class="line"><span class="comment">// ... 渲染出 ...</span></span><br><span class="line">&#123;props.userLink&#125;</span><br></pre></td></tr></table></figure></p><h2 id="组合模式-与-Render-Props模式"><a href="#组合模式-与-Render-Props模式" class="headerlink" title="组合模式 与 Render Props模式"></a>组合模式 与 Render Props模式</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>这两种是React两种重要而常用的设计模式，Render Props模式是对 组合模式的扩展。</p><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>两种设计模式的理论基础在于React的props可以接收任何对象。所以就可以愉快地给props传递react元素和function了。<br>这在官网多次提到。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><p>什么是React的组合模式，通俗的说，就是将多个组件组合在一起:<br>下面FancyBorder就是一种组合模式，组件内通过props.children 渲染其他组件内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyBorder</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;<span class="string">'FancyBorder FancyBorder-'</span> + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function WelcomeDialog() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;FancyBorder color="blue"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1 className="Dialog-title"&gt;</span></span><br><span class="line"><span class="regexp">        Welcome</span></span><br><span class="line"><span class="regexp">      &lt;/</span>h1&gt;</span><br><span class="line">      &lt;p className=<span class="string">"Dialog-message"</span>&gt;</span><br><span class="line">        Thank you <span class="keyword">for</span> visiting our spacecraft!</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面也是一种组合模式<br>在PageLayout接收一个topBar，而这个topBar是一个渲染好的React元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = props.user;</span><br><span class="line">  <span class="keyword">const</span> content = <span class="xml"><span class="tag">&lt;<span class="name">Feed</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  const topBar = (</span></span><br><span class="line">    &lt;NavigationBar&gt;</span><br><span class="line">      &lt;Link href=&#123;user.permalink&#125;&gt;</span><br><span class="line">        &lt;Avatar user=&#123;user&#125; size=&#123;props.avatarSize&#125; /&gt;</span><br><span class="line">      &lt;/Link&gt;</span><br><span class="line">    &lt;/NavigationBar&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;PageLayout</span><br><span class="line">      topBar=&#123;topBar&#125;</span><br><span class="line">      content=&#123;content&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>由上面你应该可以看到，直白的说React组合模式就是 写好或组合好一个React元素，将此元素作为其他(子)组件的props，其他组件直接凭借props渲染的设计模式。</p><h4 id="特点：能拿到父组件所有数据"><a href="#特点：能拿到父组件所有数据" class="headerlink" title="特点：能拿到父组件所有数据"></a>特点：能拿到父组件所有数据</h4><p>参考如下分析《需求延伸：如何拿到子组件数据(父子组件交互)》</p><h4 id="需求延伸：如何拿到子组件数据-父子组件交互"><a href="#需求延伸：如何拿到子组件数据-父子组件交互" class="headerlink" title="需求延伸：如何拿到子组件数据(父子组件交互)"></a>需求延伸：如何拿到子组件数据(父子组件交互)</h4><p>在上面的《示例说明》中，<code>topBar</code>是组合好的react元素，它只能拿到父组件<code>Page</code>的所有state和props，但不能拿到<code>PageLayout</code>子组件的状态信息，如何可以获得呢，此时，我们可以把<code>topBar</code>设计成一个函数，比如下面的<code>mouseRender</code>，不仅可以拿到父组件的，还可以拿到子组件的state。<br><code>mouseRender</code>所代表的react设计模式就是 render props 模式。<br>下面的例子又可以看到，可以通过setStateName进行父子组件交互，这也是render props 模式另外一个好处。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    props.setStateName(<span class="string">'beautiful'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">height</span>: <span class="string">'100vh'</span> &#125;&#125; onMouseMove=&#123;<span class="keyword">this</span>.handleMouseMove&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.render(<span class="keyword">this</span>.state)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class MouseTracker extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123; x: 0, y: 0 , name:'you'&#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  setStateName(name) &#123;</span></span><br><span class="line"><span class="regexp">   this.setState(&#123;name&#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  mouseRender(mouse, ) &#123;</span></span><br><span class="line"><span class="regexp">   return &lt;Cat mouse=&#123;mouse&#125; setStateName=&#123;this.setStateName&#125; type=&#123;this.state&#125; /</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;Mouse render=&#123;mouseRender&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Render-Props模式"><a href="#Render-Props模式" class="headerlink" title="Render Props模式"></a>Render Props模式</h3><p>单独一章说明 《Render Props模式》</p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>Render Props模式是在组合模式延伸而来；<br>function内返回一个React对象，然后将此function作为props传递给子组件，这种设计模式就是Render Props模式，详细参考《需求延伸：如何拿到子组件数据(父子组件交互)》</p><h4 id="可以拿到父子两个组件的state"><a href="#可以拿到父子两个组件的state" class="headerlink" title="可以拿到父子两个组件的state"></a>可以拿到父子两个组件的state</h4><p>详细参考《需求延伸：如何拿到子组件数据(父子组件交互)》</p><h4 id="可以将父子组件进行交互"><a href="#可以将父子组件进行交互" class="headerlink" title="可以将父子组件进行交互"></a>可以将父子组件进行交互</h4><p>详细参考《需求延伸：如何拿到子组件数据(父子组件交互)》</p><h3 id="二者区别和联系"><a href="#二者区别和联系" class="headerlink" title="二者区别和联系"></a>二者区别和联系</h3><p>二者区别在于，组合模式只能拿到父组件信息，render props 能拿到两个组件的信息，并且可以做交互。<br>联系在于，render props 基于 组合模式发展而来。</p><h2 id="Render-Props模式-1"><a href="#Render-Props模式-1" class="headerlink" title="Render Props模式"></a>Render Props模式</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>Render Props模式是在组合模式延伸而来；<br>function内返回一个React对象，然后将此function作为props传递给子组件，这种设计模式就是Render Props模式，详细参考《需求延伸：如何拿到子组件数据(父子组件交互)》</p><h4 id="可以拿到父子两个组件的state-1"><a href="#可以拿到父子两个组件的state-1" class="headerlink" title="可以拿到父子两个组件的state"></a>可以拿到父子两个组件的state</h4><p>详细参考《需求延伸：如何拿到子组件数据(父子组件交互)》</p><h4 id="可以将父子组件进行交互-1"><a href="#可以将父子组件进行交互-1" class="headerlink" title="可以将父子组件进行交互"></a>可以将父子组件进行交互</h4><p>详细参考《需求延伸：如何拿到子组件数据(父子组件交互)》</p><h3 id="与组合模式的区别"><a href="#与组合模式的区别" class="headerlink" title="与组合模式的区别"></a>与组合模式的区别</h3><p>见 《组合模式 与 Render Props模式   –  二者区别和联系》</p><h3 id="与普通组件的区别"><a href="#与普通组件的区别" class="headerlink" title="与普通组件的区别"></a>与普通组件的区别</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>这点最容易迷惑，很多人认为 写成render props模式与直接写成组件有什么区别，<br>毕竟二者都是一个函数。<br>render是函数， 组件也是一个函数。但有区别。</p><h4 id="组件是国中国，render-Props还是一国"><a href="#组件是国中国，render-Props还是一国" class="headerlink" title="组件是国中国，render Props还是一国"></a>组件是国中国，render Props还是一国</h4><p>比如封装next 的form的时候，使用自定义组件，自定义组件的state与父组件是隔绝的<br>render props则与父组件一体，用的是父组件状态。</p><p>其实用组件也好还是render props好，大多情况不会碰到太多区别，除非，就是上次封装next form时，就是一个经典的区别。</p><h4 id="render-Props-比组件更灵活"><a href="#render-Props-比组件更灵活" class="headerlink" title="render Props 比组件更灵活"></a>render Props 比组件更灵活</h4><p>如下图，render props 获取父组件的state非常方便灵活，虽然自定义组件也可以获取，但要定义props等等，写法上要做出改变。<br><figure class="image-box">                <img src="/image/react/renderprops1.png" alt="" title="" class="">                <p></p>            </figure></p><p><a href="https://blog.csdn.net/qq_40962320/article/details/87043581" target="_blank" rel="noopener">参考</a></p><h4 id="render-props-可以实现高阶组件类似的代码复用"><a href="#render-props-可以实现高阶组件类似的代码复用" class="headerlink" title="render props 可以实现高阶组件类似的代码复用"></a>render props 可以实现高阶组件类似的代码复用</h4><p><a href="https://blog.csdn.net/qq_40962320/article/details/87043581" target="_blank" rel="noopener">参考</a></p><h4 id="render-props重大作用之一就是代码复用"><a href="#render-props重大作用之一就是代码复用" class="headerlink" title="render props重大作用之一就是代码复用"></a>render props重大作用之一就是代码复用</h4><p>参考上面的《render props 可以实现高阶组件类似的代码复用》</p><h3 id="与高阶组件的区别"><a href="#与高阶组件的区别" class="headerlink" title="与高阶组件的区别"></a>与高阶组件的区别</h3><p><a href="https://blog.csdn.net/qq_40962320/article/details/87043581" target="_blank" rel="noopener">参考</a></p><h3 id="与hooks的区别"><a href="#与hooks的区别" class="headerlink" title="与hooks的区别"></a>与hooks的区别</h3><p><a href="https://blog.csdn.net/qq_40962320/article/details/87043581" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React hooks 笔记</title>
      <link href="/2021/01/03/react_hooks/"/>
      <url>/2021/01/03/react_hooks/</url>
      
        <content type="html"><![CDATA[<p>以下内容很多是阅读react官网，做的读书笔记。</p><h2 id="遗憾的是hooks并没增加新的能力"><a href="#遗憾的是hooks并没增加新的能力" class="headerlink" title="遗憾的是hooks并没增加新的能力"></a>遗憾的是hooks并没增加新的能力</h2><p>hooks相比之前的react，并没有增加新的功能，只是针对以前的功能的重新封装和优化，它没有增加新的功能，比如没有增加redux功能，更不可能替代redux，因此在项目中建议class与hooks一起写，而不是一味用hooks，至少当前阶段是这样。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="先在不复杂的新组件使用"><a href="#先在不复杂的新组件使用" class="headerlink" title="先在不复杂的新组件使用"></a>先在不复杂的新组件使用</h3><p>不建议重写原有的组件，开始“用 Hook 的方式思考”前，需要做一些思维上的转变。按照我们的经验，最好先在新的不复杂的组件中尝试使用 Hook，并确保团队中的每一位成员都能适应。</p><h3 id="不用class就可用state-存在的意义"><a href="#不用class就可用state-存在的意义" class="headerlink" title="不用class就可用state -存在的意义"></a>不用class就可用state -存在的意义</h3><p>以前，如果组件有state就一定要使用class，hooks解决了这点，因此使用纯函数也可以拥有state变成了现实。这是hooks最大的变动。</p><h3 id="靠Hook调用顺序对应state"><a href="#靠Hook调用顺序对应state" class="headerlink" title="靠Hook调用顺序对应state"></a>靠Hook调用顺序对应state</h3><p>那么 React 怎么知道哪个 state 对应哪个 useState？答案是 React 靠的是 Hook 调用的顺序。<br>react不是神，它是通过hook的顺序将不同的变量名对应到当时定义它的state中。<br>详细<a href="https://zh-hans.reactjs.org/docs/hooks-rules.html#explanation" target="_blank" rel="noopener">参考官网</a></p><h3 id="hook的位置顺序至关重要"><a href="#hook的位置顺序至关重要" class="headerlink" title="hook的位置顺序至关重要"></a>hook的位置顺序至关重要</h3><p>参考上面的 《靠Hook调用顺序对应state》</p><h3 id="任何时候保持顶层使用hook"><a href="#任何时候保持顶层使用hook" class="headerlink" title="任何时候保持顶层使用hook"></a>任何时候保持顶层使用hook</h3><p>无论是在函数组件内还是<strong>自定义的hook函数</strong>内，请都保证在顶层使用hook，原因见《靠Hook调用顺序对应state》</p><h3 id="值相同，第二次后就不会再次render"><a href="#值相同，第二次后就不会再次render" class="headerlink" title="值相同，第二次后就不会再次render"></a>值相同，第二次后就不会再次render</h3><p>这是hooks自己做的优化，可在官网找到相关论述，无论是usestate还是useReducer都有这个现象，当state值相同时，渲染两次之后，不再渲染。<br>class组件无此现象。</p><h3 id="父组件render会导致子render，但setState不一定"><a href="#父组件render会导致子render，但setState不一定" class="headerlink" title="父组件render会导致子render，但setState不一定"></a>父组件render会导致子render，但setState不一定</h3><p>父亲render的时候，肯定导致函数式组件render；<br>但这个函数式样组件内使用useState更新时，如果state值相同，两次后就不会render；</p><h3 id="由useRef-createRef的区别-想到的"><a href="#由useRef-createRef的区别-想到的" class="headerlink" title="由useRef/createRef的区别 想到的"></a>由useRef/createRef的区别 想到的</h3><h4 id="一个用在function，一个用在class"><a href="#一个用在function，一个用在class" class="headerlink" title="一个用在function，一个用在class"></a>一个用在function，一个用在class</h4><p>详细参考<a href="https://juejin.im/post/5e5c5f6a6fb9a07cad3ba383" target="_blank" rel="noopener">useRef 与 createRef 的区别</a><br>useRef用在function组件内，后者用在class组件内，这是他们表现出来的主要区别。<br>useRef是hook它有这个能力，在function组件内，只在初始的时候运行一次；<br>而creatRef不是hook没有这个能力，是一个普通函数，在function组件内时，会每次都执行，因此不能用于function组件，<br>只用于class组件，并在class组件的constructor或didmount生命周期内定义。</p><h4 id="一个定义在function内部，一个定义在装卸载时"><a href="#一个定义在function内部，一个定义在装卸载时" class="headerlink" title="一个定义在function内部，一个定义在装卸载时"></a>一个定义在function内部，一个定义在装卸载时</h4><p>参考上面</p><h4 id="普通函数在hook组件内会被每次执行"><a href="#普通函数在hook组件内会被每次执行" class="headerlink" title="普通函数在hook组件内会被每次执行"></a>普通函数在hook组件内会被每次执行</h4><p>参考上面</p><h4 id="hook函数基本是只执行一次"><a href="#hook函数基本是只执行一次" class="headerlink" title="hook函数基本是只执行一次"></a>hook函数基本是只执行一次</h4><p>参考上面《由useRef/createRef的区别 想到的》，hook函数的最大特征之一，有别于普通函数，hook函数在函数组件内，不会被多次执行。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><h3 id="是三合一的API"><a href="#是三合一的API" class="headerlink" title="是三合一的API"></a>是三合一的API</h3><p>useEffect 给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。</p><h3 id="运行时机"><a href="#运行时机" class="headerlink" title="运行时机"></a>运行时机</h3><p>当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— 包括第一次渲染的时候。</p><h3 id="反模式的设计"><a href="#反模式的设计" class="headerlink" title="反模式的设计"></a>反模式的设计</h3><p>我们给useEffect每次传递的是一个崭新的函数，这样做的目的可能是这个崭新的函数每次可以获得组件内最新的上下文；官网对此做的解释如下，【每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。】<a href="https://zh-hans.reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener">详见官网</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">   document.title = `You clicked $&#123;count&#125; times`;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><h3 id="只会在组件的初始渲染中调用–使用函数设置初始值"><a href="#只会在组件的初始渲染中调用–使用函数设置初始值" class="headerlink" title="只会在组件的初始渲染中调用–使用函数设置初始值"></a>只会在组件的初始渲染中调用–使用函数设置初始值</h3><p>initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialState = someExpensiveComputation(props);</span><br><span class="line">  <span class="keyword">return</span> initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><h3 id="监听到变化后会渲染当前组建"><a href="#监听到变化后会渲染当前组建" class="headerlink" title="监听到变化后会渲染当前组建"></a>监听到变化后会渲染当前组建</h3><h3 id="需要配合hemeContext-Provider使用"><a href="#需要配合hemeContext-Provider使用" class="headerlink" title="需要配合hemeContext.Provider使用"></a>需要配合hemeContext.Provider使用</h3><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><h3 id="useReducer-与-redux-的关系"><a href="#useReducer-与-redux-的关系" class="headerlink" title="useReducer 与 redux 的关系"></a>useReducer 与 redux 的关系</h3><h4 id="经典demo"><a href="#经典demo" class="headerlink" title="经典demo"></a>经典demo</h4><p>如下demo，<br>这里的dispatch就是redux的dispatch API；<br>这里的todos就相当于redux的全局的store 的state；<br>这里的Provider与context结构 就是 redux 结合react的 react-connect的一套；<br>所以useReducer在思想上深度模仿了redux，很像一个迷你的redux。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodosDispatch = React.createContext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodosApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 提示：`dispatch` 不会在重新渲染之间变化</span></span><br><span class="line">  <span class="keyword">const</span> [todos, dispatch] = useReducer(todosReducer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;TodosDispatch.Provider value=&#123;dispatch&#125;&gt;</span><br><span class="line">      &lt;DeepTree todos=&#123;todos&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/TodosDispatch.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="原理上借鉴了redux"><a href="#原理上借鉴了redux" class="headerlink" title="原理上借鉴了redux"></a>原理上借鉴了redux</h4><p>参考上面《经典demo》</p><h4 id="就是一个迷你的redux"><a href="#就是一个迷你的redux" class="headerlink" title="就是一个迷你的redux"></a>就是一个迷你的redux</h4><p>参考上面《经典demo》</p><h3 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h3><p>运用场景：第一次计算state的逻辑复杂，以后不复杂，可以将第一次的计算逻辑剥离出来；<br>好处除了上面说的，还有就是逻辑剥离出来后，代码更加清晰，维护容易；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: initialCount&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> init(action.payload);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'reset'</span>, <span class="attr">payload</span>: initialCount&#125;)&#125;&gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: 'decrement'&#125;)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="场景-深层子层改变顶层state-reducer-context"><a href="#场景-深层子层改变顶层state-reducer-context" class="headerlink" title="场景 - 深层子层改变顶层state (reducer/context)"></a>场景 - 深层子层改变顶层state (reducer/context)</h3><p>以前我们是将顶层setState的函数传给子层，现在我们建议使用<strong>context与reducer</strong>的方式，<br>参看<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" target="_blank" rel="noopener">《如何避免向下传递回调》</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TodosDispatch = React.createContext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodosApp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 提示：`dispatch` 不会在重新渲染之间变化</span></span><br><span class="line">  <span class="keyword">const</span> [todos, dispatch] = useReducer(todosReducer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;TodosDispatch.Provider value=&#123;dispatch&#125;&gt;</span><br><span class="line">      &lt;DeepTree todos=&#123;todos&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/TodosDispatch.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function DeepChild(props) &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。</span></span><br><span class="line"><span class="regexp">  const dispatch = useContext(TodosDispatch);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  function handleClick() &#123;</span></span><br><span class="line"><span class="regexp">    dispatch(&#123; type: 'add', text: 'hello' &#125;);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;handleClick&#125;&gt;Add todo&lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="场景-如何避免向下传递回调"><a href="#场景-如何避免向下传递回调" class="headerlink" title="场景 - 如何避免向下传递回调"></a>场景 - 如何避免向下传递回调</h3><p>参考上面《场景 - 深层子层改变顶层state (reducer/context)》</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>useCallback的本质作用是将每次创建的函数都指向同一个引用对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resultCallback = useCallback(fn, deps); <span class="comment">//resultCallback 可以认为就是fn</span></span><br><span class="line"><span class="keyword">const</span> resultMemo = useMemo(fn, deps);<span class="comment">//resultMemo 就是 fn的执行后的结果</span></span><br></pre></td></tr></table></figure></p><p><a href="https://www.teaspect.com/detail/5756" target="_blank" rel="noopener">更多介绍</a></p><h3 id="可与React-memo或shouldComponentUpdate结合使用"><a href="#可与React-memo或shouldComponentUpdate结合使用" class="headerlink" title="可与React.memo或shouldComponentUpdate结合使用"></a>可与React.memo或shouldComponentUpdate结合使用</h3><p>useCallback并非一定要与以上一起使用，但与上面使用可体现它的威力，如果有其他场景，也可试试。</p><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>传统用法和详细介绍，<a href="https://blog.csdn.net/hjc256/article/details/102587037" target="_blank" rel="noopener">参考</a>；<br>除了传统用法，useRef另外一个好处在于用来保存值，修改它，不会造成重新渲染。</p><h3 id="给useRef设置一个值"><a href="#给useRef设置一个值" class="headerlink" title="给useRef设置一个值"></a>给useRef设置一个值</h3><p>刚开始不太理解设置一个值是什么意思，原来就是给current设置一个初始值。<br><a href="https://react.docschina.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily" target="_blank" rel="noopener">参考 如何惰性创建昂贵的对象？</a>；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = useRef(<span class="number">9999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ref)<span class="comment">//&#123;current: 9999&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="修改它不会造成组件重新渲染"><a href="#修改它不会造成组件重新渲染" class="headerlink" title="修改它不会造成组件重新渲染"></a>修改它不会造成组件重新渲染</h3><p><a href="https://blog.csdn.net/hjc256/article/details/102587037" target="_blank" rel="noopener">参考</a>；<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useMemo, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> doubleCount = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * count;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timerID = useRef();</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    timerID.current = setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>); </span><br><span class="line">  &#125;, []);</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(count &gt; <span class="number">10</span>)&#123;</span><br><span class="line">          clearInterval(timerID.current);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button ref=&#123;couterRef&#125; onClick=&#123;() =&gt; &#123;setCount(count + <span class="number">1</span>)&#125;&#125;&gt;Count: &#123;count&#125;, <span class="attr">double</span>: &#123;doubleCount&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h2><p>与useRef、 forwardRef 一起使用，自定义暴露给父组件使用时的ref，也是比较有用的API，我觉得它的作用之一是将子组件的内部方法，很容易的传给父组件。，详细<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">参考官网</a>。</p><h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p>用法同useEffect，只有在useEffect不满足情况下才使用，它的特点在于dom布局时同步触发，而不是渲染完成后触发，服务端不要使用此API。</p><h2 id="hooks出现的意义"><a href="#hooks出现的意义" class="headerlink" title="hooks出现的意义"></a>hooks出现的意义</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>hooks 实现了state状态的复用，以前state状态的复用，只能通过高阶组件，<br>现在可以通过hooks，但hooks比高阶组件复用状态时，写法简单，方便，可读性，易维护性更强。</p><p>以前必须使用高阶组件实现的state复用，现在只需要一段自定义hooks就可以马上实现非常简洁，清晰，易读易维护。<br><a href="https://blog.csdn.net/qq_40962320/article/details/87043581" target="_blank" rel="noopener">更多，参考这篇博客，讲的很好</a></p><h3 id="非常重要：可读性易维护性"><a href="#非常重要：可读性易维护性" class="headerlink" title="非常重要：可读性易维护性"></a>非常重要：可读性易维护性</h3><p>hooks的重要意义一方面是增加了方便性，比如可以替代原来高阶组件所实现的功能。<br>另外一个重要的核心就是，增加了可读性，易维护性，这点非常重要。</p><p>就好像es6没有出现前，一个变量可能被层层污染，不知道哪里被重新设置了，<br>es6的出现很好解决了这点。<br><figure class="image-box">                <img src="/image/react/hooks-read.png" alt="" title="" class="">                <p></p>            </figure><br><a href="https://blog.csdn.net/weixin_43606158/article/details/106715134" target="_blank" rel="noopener">参考</a></p><h3 id="功能是一方面，可读易维护也是重要方面"><a href="#功能是一方面，可读易维护也是重要方面" class="headerlink" title="功能是一方面，可读易维护也是重要方面"></a>功能是一方面，可读易维护也是重要方面</h3><p>参考上面《非常重要：可读性易维护性 》</p><h3 id="hooks与高阶组件区别"><a href="#hooks与高阶组件区别" class="headerlink" title="hooks与高阶组件区别"></a>hooks与高阶组件区别</h3><p>hooks与高阶组件都可以实现代码复用，比如state复用，二者本质上无区别，<br>但使用方式上却一个繁杂沉余，且要多一层组件包裹。<br>但hooks写法灵活，简单，且可读性极强。<br><a href="https://blog.csdn.net/qq_40962320/article/details/87043581" target="_blank" rel="noopener">更多，参考这篇博客，讲的很好</a></p><h2 id="FAQ之一"><a href="#FAQ之一" class="headerlink" title="FAQ之一"></a>FAQ之一</h2><h3 id="我应该使用单个还是多个-state-变量？"><a href="#我应该使用单个还是多个-state-变量？" class="headerlink" title="我应该使用单个还是多个 state 变量？"></a>我应该使用单个还是多个 state 变量？</h3><p>我们推荐把 state 切分成多个 state 变量，每个变量包含的不同值会在同时发生变化。<br>说的是，一个useState应该只改变 这个动作 改动的state；<br>比如一个是改变postion的，一个是改变宽高的，这两个应该写在不同state上，<br>当然，没有唯一的标准，靠自己平衡，分开与不分开，考虑的是后期维护性扩展和可读性，如果业务越来越复杂，应该碎片化state；<br>如果业务简单，是否分开可能作用不大，看个人的编程习惯。<br>详细<a href="https://react.docschina.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" target="_blank" rel="noopener">查看官网 我应该使用单个还是多个 state 变量？</a></p><h3 id="我可以只在更新时运行-effect-吗？-componentDidupdate"><a href="#我可以只在更新时运行-effect-吗？-componentDidupdate" class="headerlink" title="我可以只在更新时运行 effect 吗？(componentDidupdate)"></a>我可以只在更新时运行 effect 吗？(componentDidupdate)</h3><p>官网上的这个问题，讨论的就是如何使用useEffect 来模拟componentDidupdate，官网推荐方法是，使用Ref。</p><h3 id="如何获取上一轮的-props-或-state？"><a href="#如何获取上一轮的-props-或-state？" class="headerlink" title="如何获取上一轮的 props 或 state？"></a>如何获取上一轮的 props 或 state？</h3><p>目前，你可以 通过 ref 来手动实现.详细参看官网。<br>也许你说，可以通过useReducer</p><h3 id="ref-并非一定要跟子组件一起用，一定要嵌入子组件—ref大有可为，是新时代的实例对象和this不变指针。"><a href="#ref-并非一定要跟子组件一起用，一定要嵌入子组件—ref大有可为，是新时代的实例对象和this不变指针。" class="headerlink" title="ref 并非一定要跟子组件一起用，一定要嵌入子组件—ref大有可为，是新时代的实例对象和this不变指针。"></a>ref 并非一定要跟子组件一起用，一定要嵌入子组件—ref大有可为，是新时代的实例对象和this不变指针。</h3><p>比如 FAq <a href="https://react.docschina.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down" target="_blank" rel="noopener">为什么我会在我的函数中看到陈旧的 props 和 state ？ </a>也说到了ref的用处。</p><h3 id="我该如何实现-getDerivedStateFromProps"><a href="#我该如何实现-getDerivedStateFromProps" class="headerlink" title="我该如何实现 getDerivedStateFromProps?"></a>我该如何实现 getDerivedStateFromProps?</h3><p><a href="https://react.docschina.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops" target="_blank" rel="noopener">参考官网</a>，模拟getDerivedStateFromProps的关键在于获取上一次的props和state。官网的例子设置一个不用于渲染的state存储prestate。这里的<strong>特别之处在于：</strong>一般认为state用于渲染组件的，不渲染组件时不要用state。<br>这里官网都推荐了，所以，凡事无固定，平衡就好。</p><p>另外一种方式也可以通过 ref 来获取上一轮的props和state，也可以来模拟 getDerivedStateFromProps，参考上面的《如何获取上一轮的 props 或 state？》</p><h3 id="为什么我会在我的函数中看到陈旧的-props-和-state-？–内部函数作用域问题"><a href="#为什么我会在我的函数中看到陈旧的-props-和-state-？–内部函数作用域问题" class="headerlink" title="为什么我会在我的函数中看到陈旧的 props 和 state ？–内部函数作用域问题"></a>为什么我会在我的函数中看到陈旧的 props 和 state ？–内部函数作用域问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleAlertClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="string">'You clicked on: '</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleAlertClick&#125;&gt;</span><br><span class="line">        Show alert</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有类似-forceUpdate-的东西吗？"><a href="#有类似-forceUpdate-的东西吗？" class="headerlink" title="有类似 forceUpdate 的东西吗？"></a>有类似 forceUpdate 的东西吗？</h3><p>使用计时器结合 useState等来做，值得注意的是，<strong>必须要用计时器，因为useState相同的值，两次后，都不会更新，这是hooks于setState的根本区别</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const [ignored, forceUpdate] = useReducer(x =&gt; x + 1, 0);</span><br><span class="line"></span><br><span class="line">function handleClick() &#123;</span><br><span class="line">  forceUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="我该如何测量-DOM-节点？–-callback-ref-的使用"><a href="#我该如何测量-DOM-节点？–-callback-ref-的使用" class="headerlink" title="我该如何测量 DOM 节点？– callback ref 的使用"></a>我该如何测量 DOM 节点？– callback ref 的使用</h3><p>在这个案例中，我们没有选择使用 useRef，因为当 ref 是一个对象时它并不会把当前 ref 的值的 变化 通知到我们。使用 callback ref 可以确保 即便子组件延迟显示被测量的节点 。<br>值得注意的是，这里的callback ref其实就是老的class组件内使用的callback ref，没有区别。并不是hooks独创。<br>如果你可以定义一个实例唯一的函数，在下面代码中也可以不使用useCallback。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  function MeasureExample() &#123;</span><br><span class="line">  const [height, setHeight] = useState(0);</span><br><span class="line"></span><br><span class="line">  const measuredRef = useCallback(node =&gt; &#123;</span><br><span class="line">    if (node !== null) &#123;</span><br><span class="line">      setHeight(node.getBoundingClientRect().height);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1 ref=&#123;measuredRef&#125;&gt;Hello, world&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;The above header is &#123;Math.round(height)&#125;px tall&lt;/h2&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="形成闭包时，如何拿到最新的state"><a href="#形成闭包时，如何拿到最新的state" class="headerlink" title="形成闭包时，如何拿到最新的state"></a>形成闭包时，如何拿到最新的state</h3><p><a href="https://react.docschina.org/docs/hooks-faq.html" target="_blank" rel="noopener">详细参考官网 - 如果我的 effect 的依赖频繁变化，我该怎么办？</a><br>可通过函数式的useState：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// ✅ 在这不依赖于外部的 `count` 变量</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ 我们的 effect 不适用组件作用域中的任何变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="FAQ之二"><a href="#FAQ之二" class="headerlink" title="FAQ之二"></a>FAQ之二</h2><h3 id="获取pre-state和props的两种方式"><a href="#获取pre-state和props的两种方式" class="headerlink" title="获取pre state和props的两种方式"></a>获取pre state和props的两种方式</h3><h4 id="useState-1"><a href="#useState-1" class="headerlink" title="useState"></a>useState</h4><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><h3 id="hooks-与-setState的渲染的最大区别之一"><a href="#hooks-与-setState的渲染的最大区别之一" class="headerlink" title="hooks 与 setState的渲染的最大区别之一"></a>hooks 与 setState的渲染的最大区别之一</h3><p>相同的值，两次后，将不再渲染，<a href="https://react.docschina.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops" target="_blank" rel="noopener">查看官网–有类似 forceUpdate 的东西吗？</a></p><h3 id="如何给父组件暴露子组件的方法或自定义方法"><a href="#如何给父组件暴露子组件的方法或自定义方法" class="headerlink" title="如何给父组件暴露子组件的方法或自定义方法"></a>如何给父组件暴露子组件的方法或自定义方法</h3><p>通过  useImperativeHandle Hook 。</p><h3 id="callback-ref-与-useRef-的区别"><a href="#callback-ref-与-useRef-的区别" class="headerlink" title="callback ref 与 useRef 的区别"></a>callback ref 与 useRef 的区别</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>参考《我该如何测量 DOM 节点？》，要说的是：</p><ul><li>callback ref其实就是class组件以前使用的 函数 ref，并没有区别；</li><li>useRef 其实就是以前class组件内的，给ref传一个字符串；</li></ul><p>二者的区别在于 前者可实时获取ref组件最新内容，后者不行。<br>也可以这样描述，callback形式的ref要比字符串形式的ref更能感知dom的信息，保证每次 didmount或didupdate前获得最新的dom。<a href="https://react.docschina.org/docs/refs-and-the-dom.html#callback-refs" target="_blank" rel="noopener">参考官网 - 回调 Refs</a></p><h4 id="可以配合usecallback使用"><a href="#可以配合usecallback使用" class="headerlink" title="可以配合usecallback使用"></a>可以配合usecallback使用</h4><p>ref其实跟class版本的react使用一样，可以设定一个函数，在class组件中，这个函数通常是组件内部函数，通过this指向，属于实例范畴，因此升级到hooks，就是用usecallback来创建一个恒定不变的方法类似实例方法。<br>如果你有其他创建恒定函数的方式，也可以不用usecallback。</p><h3 id="ref-代替原来的-this"><a href="#ref-代替原来的-this" class="headerlink" title="ref 代替原来的 this"></a>ref 代替原来的 this</h3><p>在官方文档中，多次提到了，如果要使用原来class组件的this，就使用ref代替；</p><h3 id="函数式的的useState的妙用"><a href="#函数式的的useState的妙用" class="headerlink" title="函数式的的useState的妙用"></a>函数式的的useState的妙用</h3><h4 id="不依赖外层，通过参数就可拿到最新的state"><a href="#不依赖外层，通过参数就可拿到最新的state" class="headerlink" title="不依赖外层，通过参数就可拿到最新的state"></a>不依赖外层，通过参数就可拿到最新的state</h4><p>参考《形成闭包时，如何拿到最新的state》</p><h4 id="减少计算"><a href="#减少计算" class="headerlink" title="减少计算"></a>减少计算</h4><p><a href="https://react.docschina.org/docs/hooks-faq.html" target="_blank" rel="noopener">如何惰性创建昂贵的对象？</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Table</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ⚠️ createRows() 每次渲染都会被调用</span></span><br><span class="line">  <span class="keyword">const</span> [rows, setRows] = useState(createRows(props.count));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Table</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ✅ createRows() 只会被调用一次</span></span><br><span class="line">  <span class="keyword">const</span> [rows, setRows] = useState(<span class="function"><span class="params">()</span> =&gt;</span> createRows(props.count));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="render-prop-是一种关键技术"><a href="#render-prop-是一种关键技术" class="headerlink" title="render prop 是一种关键技术"></a>render prop 是一种关键技术</h2><p>render prop 的介绍看<a href="https://react.docschina.org/docs/render-props.html" target="_blank" rel="noopener">官网</a>，或者看另外一篇博客《React 笔记 - 其他技术 – Render Props 代替 HOC 》。<br>据官网介绍，hooks的出现与 render prop的运用有很大关系<a href="https://react.docschina.org/docs/hooks-faq.html#what-is-the-prior-art-for-hooks" target="_blank" rel="noopener">参考—Hook 使用了哪些现有技术？</a>.<br>因此在react开发中，无论是hooks还是class组件，要注重这种思想的运用。</p><p>更多参考，另外一篇笔记《React 笔记  –  组合模式 与 Render Props模式   –   Render Props模式》</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react hooks </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js设计模式下</title>
      <link href="/2021/01/03/js_design_main/"/>
      <url>/2021/01/03/js_design_main/</url>
      
        <content type="html"><![CDATA[<p>js设计模式分两篇来写，此为下篇，上篇为 《js设计模式上(面向对象、闭包、命名空间)》。<br>主要讲设计原则与设计模式两部分。</p><h1 id="js设计原则"><a href="#js设计原则" class="headerlink" title="js设计原则"></a>js设计原则</h1><p>js设计原则有四五个，但真正在js编程中的用得最多的差不多就两个：单一职责原则、开放封闭原则。<br>另外在本节的最后部分，附上《unix／linux 设计哲学》书中提到的几个linux的编码准则，列举其中对js编码有启发意义的几个。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>单一职责原则：一个对象（方法）只做一件事情。<br>单一职责原则要求我们在写复杂方法时，将方法进行抽象，分离颗粒化成多个方法，让每个方法只做一件事情。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：让一个方法只做一个事情，将复杂职责分解为多个职责，后期维护代码的时候，修改其中一个职责，也就不会影响其他职责，这样代码可读性、可维护性、可扩张、可移植性更好，也更符合开放封闭原则。<br>缺点：增加编写代码的复杂度（能写出单一职责设计原则代码的程序员，也是要求他有一定编程水平才能写出的），当我们按照职责把对象分解成更小粒度之后，实际上也增大了这些对象之间相互联系的难度。</p><p>单一职责原则是js编写代码最重要的两个准则之一，在它的优点面前，它的缺点不值得一提。</p><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>开放封闭原则：对扩展开放，对修改封闭。<br>开放封闭原则要求我们写出来的方法，当对程序方法进行扩展时，更加方便，不要修改原来的行为方法。</p><p>通过一段代码来体现 开放封闭原则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 这是原代码，此代码相比之下，每次扩展都需要修改makeSound方法，违反了开放封闭原则</span><br><span class="line">//每次扩展时，因为要修改公共方法makeSound，你还要担心有回归测试的一些问题，还要去测试Duck和Chicken</span><br><span class="line">var makeSound = function(animal)&#123;</span><br><span class="line">  if(animal instanceof Duck)&#123;</span><br><span class="line">    console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">  &#125;else if(animal instanceof Chicken)&#123;</span><br><span class="line">    console.log(&apos;咯咯咯&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var Duck = function()&#123;&#125;</span><br><span class="line">var Chicken = function()&#123;&#125;</span><br><span class="line">makeSound(new Duck);</span><br><span class="line">makeSound(new Chicken);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 这是改良后代码，此代码相比之下，每次扩展都不用修改makeSound方法，更加易于扩展，而且makeSound是一个公共的方法，</span><br><span class="line">//每次扩展时，因为不用修改公共方法makeSound，就不会担心有回归测试的一些问题，不用担心还要去测试Duck和Chicken</span><br><span class="line">var makeSound = function(animal)&#123;</span><br><span class="line">  animal.sound();</span><br><span class="line">&#125;</span><br><span class="line">var Duck = function()&#123;&#125;</span><br><span class="line">Duck.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var Chicken = function()&#123;&#125;</span><br><span class="line">Chicken.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;咯咯咯&apos;);</span><br><span class="line">&#125;</span><br><span class="line">makeSound(new Duck);</span><br><span class="line">makeSound(new Chicken);</span><br><span class="line"></span><br><span class="line">//增加新需求，添加一个Dog行为</span><br><span class="line">var Dog = function()&#123;&#125;</span><br><span class="line">Dog.prototype.sound = function()&#123;</span><br><span class="line">  console.log(&apos;汪汪汪&apos;);</span><br><span class="line">&#125;</span><br><span class="line">makeSound(new Dog);</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：从上面代码例子中看到，开放封闭原则的代码，后期可维护性更高，扩展性更强，当有扩展新功能时，风险更小，要做的回归测试问题更少，因此维护、扩展成本更低。<br>缺点：在项目刚开始时，因为业务不熟，或业务不稳定，因此你很难抽象出 方法中永远变化的部分和永远不变化的部分进行封装。</p><h3 id="接受第一次愚弄"><a href="#接受第一次愚弄" class="headerlink" title="接受第一次愚弄"></a>接受第一次愚弄</h3><p>为了解决上面说的缺点，一种现实的做法是，在项目刚开始时，我们假设方法的所有部分都是不变化的，不对方法进行开放封闭进行抽象封装处理，项目初期快速编码完成需求，不影响项目进度。<br>当后期变化发生时，再来回过头来封装这些变化地方，确保下一次不会掉进同一个坑里。<br>我们将这条编码经验称之为 ‘接受第一次愚弄’，但永远不会被同样的招数击倒第二次。</p><h2 id="其他准则"><a href="#其他准则" class="headerlink" title="其他准则"></a>其他准则</h2><p>下面是unix／linux 设计哲学 的 几条准则，对js编程依然有借鉴：<br>准则1:小即是美<br>准则2:让每个程序只做好一件事情<br>准则3:快速建立原型（快速更早将功能骨架做好，先让用户用起来，然后客户边用边反馈，开发根据这个实施开发客户反馈需求）<br>准则4:舍弃高效率而取可移植性（硬件升级或浏览器内核升级后，原来不高效的写法，因为计算机硬件提高，原来不高效写法不影响效率了）<br>准则5:充分地抽象封装程序，以此达到程序复用性</p><h1 id="js设计模式"><a href="#js设计模式" class="headerlink" title="js设计模式"></a>js设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>单例模式 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="标准单例模式示例"><a href="#标准单例模式示例" class="headerlink" title="标准单例模式示例"></a>标准单例模式示例</h3><p>标准的单例模式示例，如下代码符合单例模式的几点定义：</p><ul><li>Singletom是一个类；</li><li>new Singletom 是它点实例；</li><li>全局范围内，可通过Singletom访问这个类。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//标准的单例模式示例</span><br><span class="line">var Singletom = function(name)&#123;</span><br><span class="line">            console.log(name)</span><br><span class="line">          &#125;</span><br><span class="line">Singletom.getInstance = (function()&#123;</span><br><span class="line">var instance = null;</span><br><span class="line">return function(name)&#123;</span><br><span class="line">    if(!instance)&#123;</span><br><span class="line">    instance = new Singletom(name);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var a = Singletom.getInstance(&apos;sven1&apos;);</span><br><span class="line">var b = Singletom.getInstance(&apos;sven2&apos;);</span><br><span class="line">console.log(a === b)//true</span><br></pre></td></tr></table></figure><h3 id="将以上-标准单例模式示例-优化"><a href="#将以上-标准单例模式示例-优化" class="headerlink" title="将以上 标准单例模式示例 优化"></a>将以上 标准单例模式示例 优化</h3><p>上面的标准示例，将new 实例和 管理是否有无两个功能放在一个函数内，违背了 单一职责原则，在此改造下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//优化后的单例模式示例</span><br><span class="line">var CreateDiv = function(html)&#123;</span><br><span class="line">          this.html = html;</span><br><span class="line">          this.init()</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">CreateDiv.prototype.init = function()&#123;</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = this.html;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ProxySingletonCreateDiv = (function()&#123;</span><br><span class="line">    var instance;</span><br><span class="line">    return function(html)&#123;</span><br><span class="line">    if(! instance)&#123;</span><br><span class="line">        instance = new CreateDiv(html);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var a = new ProxySingletonCreateDiv(&apos;sven1&apos;);</span><br><span class="line">var b = new ProxySingletonCreateDiv(&apos;sven2&apos;);</span><br><span class="line">console.log(a === b)//true</span><br></pre></td></tr></table></figure></p><h3 id="通用的单例模式示例"><a href="#通用的单例模式示例" class="headerlink" title="通用的单例模式示例"></a>通用的单例模式示例</h3><p>上面我们解释了标准的单例模式，这样可以更加容易理解单例模式是什么，在实际应用中，我们更偏向使用基于以上标准单例模式改造而来的通用的单例模式。<br>我们不必拘泥于单例模式的定义，单例模式必须要求是一个类 和 实例，<br>其实类也是一个函数，实例其实就是对call或apply的应用，我们不必拘泥于new 实例，大可 将 函数的直接执行 来 代替实例。<br>单例模式的精神就是：</p><ul><li>有一个全局的函数（类）</li><li>此函数被执行或被实例一次<br>满足了以上两个条件，都可以称之为单例设计模式；<br>下面写了一个经典 单例模式示例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//优化后的单例模式示例</span><br><span class="line">var num = 0;</span><br><span class="line">var CreateDiv = function(...args)&#123;</span><br><span class="line">    num ++;</span><br><span class="line">    console.log(args[0],`一共执行了$&#123;num&#125;次`);</span><br><span class="line">    var div = document.createElement(&apos;div&apos;);</span><br><span class="line">    div.innerHTML = this.html;</span><br><span class="line">    document.body.appendChild(div);</span><br><span class="line">    return div;</span><br><span class="line">&#125;</span><br><span class="line">ProxySingletonCreateDiv 专门用来管理 函数是否执行</span><br><span class="line">var ProxySingletonCreateDiv = function(fn)&#123;</span><br><span class="line">    var instance;</span><br><span class="line">    return function()&#123;</span><br><span class="line">    if(! instance)&#123;</span><br><span class="line">        instance = fn.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = ProxySingletonCreateDiv(CreateDiv);</span><br><span class="line"></span><br><span class="line">a(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br><span class="line">a(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br><span class="line"></span><br><span class="line">//如果我们要扩展，增加一个CreateFrame，只需这样做,非常容易扩展</span><br><span class="line">var CreateFrame = function(...args)&#123;</span><br><span class="line">    console.log(args[0]);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">var f = ProxySingletonCreateDiv(CreateFrame);</span><br><span class="line">f(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br><span class="line">f(&apos;单例模式&apos;)//单例模式 一共执行了1次</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>购物车，登陆，redux 的 store都是单例模式的运用。</p><h3 id="如何写一个单例模式"><a href="#如何写一个单例模式" class="headerlink" title="如何写一个单例模式"></a>如何写一个单例模式</h3><p>由上面例子看到，写一个单例模式的功能，基本上要借助闭包来实现。<br>通过上面的例子看到，在单例模式中，请将管理单例 和 功能函数 分开编写。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式也称为发布订阅模式</p><h3 id="es6示例"><a href="#es6示例" class="headerlink" title="es6示例"></a>es6示例</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>对下面例子解说，<br>新闻公司通过 暴露出来一个接口attach，用来给订阅者(观察者)报名或参加订阅，<br>新闻公司内部，用以下几个属性用来记录情况：<br>this.foodState —- 将要推送的 食品消息<br>this.houseState —- 将要推送的 房产消息<br>this.foodObservers —- 食品消息订阅者个人信息<br>this.houseObservers —- 房产消息订阅者个人信息<br>this.deliveryType —- 将要推送的消息的类别<br>deliveryState —- 推送消息<br>notifyAllObservers  —- 给每个订阅者打电话将消息通知给订阅者<br>getState —- 暴露给订阅者的API,订阅者接到通知消息的电话后，可通过公司提供的渠道网站或短信来看新闻</p><p>订阅者：<br>订阅者用以下几个属性来记录情况<br>this.phoneNum —- 订阅新闻需要提供给新闻公司的 手机号码<br>this.subscribeType  —- 订阅新闻需要提供给新闻公司的 新闻类别<br>this.company  —- 用来保存公司资料，刚开始是根据公司提供的报名方式attach进行报名，后期新闻发送消息是，<br>                   可以通过公司提供的渠道(this.company.getState)查看消息，也可以针对新闻服务公司的服务态度，给公司反馈或投诉建议<br>this.company.attach 通过公司对外暴露的接口，登记报名订阅。</p><p>cellphone 订阅者对外暴露给新闻公司自己接收消息的方式，用来update。</p><h4 id="示例小结"><a href="#示例小结" class="headerlink" title="示例小结"></a>示例小结</h4><p>新闻公司必须 对订阅者暴露 订阅方式attach；<br>订阅者必须 对公司暴露 接收消息方式cellphone；<br>因为订阅者要 保存公司的资料，例如获取订阅方式等等，所以订阅者必须设计一个属性用来保存公司这个对象总类；<br>因为公司要 保存订阅者的资料，例如获取订阅者的接收方式等等，所以公司必须设计一个属性用来保存订阅者完整类；</p><p>因为公司要 发送消息deliveryState，就要用一个属性来保存将要发的消息foodState，然后要执行打电话通知notifyAllObservers，<br>通知完后，还要提供网站或app或短信等渠道getState，让订阅者查看新闻。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>此代码针对上面解说而写的，此示例代码的好处是可以很好地先理解好观察者到底是一个什么东西。<br>但此代码也有弊端，例如NewsCompany不易维护性，NewsCompany中维护了food，house，如果将来增加了money等等呢，需要改写NewsCompany内部。所以NewsCompany需要进一步优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// 主题，接收状态变化，触发每个观察者</span><br><span class="line"></span><br><span class="line">class NewsCompany &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.foodState = 0</span><br><span class="line">        this.houseState = 0</span><br><span class="line">        this.foodObservers = []</span><br><span class="line">        this.houseObservers = []</span><br><span class="line">        this.deliveryType = 0</span><br><span class="line">    &#125;</span><br><span class="line">    getState() &#123;</span><br><span class="line">        if(this.deliveryType === &apos;food&apos;)&#123;</span><br><span class="line">            return this.foodState</span><br><span class="line">        &#125;</span><br><span class="line">        return this.houseState</span><br><span class="line">    &#125;</span><br><span class="line">    deliveryState(state,deliveryType) &#123;</span><br><span class="line">        if(deliveryType === &apos;food&apos;)&#123;</span><br><span class="line">            this.foodState = state</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.houseState = state</span><br><span class="line">        &#125;</span><br><span class="line">        this.deliveryType = deliveryType;</span><br><span class="line">        this.notifyAllObservers(deliveryType)</span><br><span class="line">    &#125;</span><br><span class="line">    attach(observer) &#123;</span><br><span class="line">        if(observer.subscribeType === &apos;food&apos;)&#123;</span><br><span class="line">            this.foodObservers.push(observer)</span><br><span class="line">        &#125;</span><br><span class="line">        if(observer.subscribeType === &apos;house&apos;)&#123;</span><br><span class="line">            this.houseObservers.push(observer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAllObservers(type) &#123;</span><br><span class="line">        const observers = type === &apos;food&apos; ? this.foodObservers : this.houseObservers;</span><br><span class="line">        observers.forEach(observer =&gt; &#123;</span><br><span class="line">            //发布消息，给每个订阅者留的电话打电话，通知订阅者</span><br><span class="line">            observer.cellphone()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 观察者，等待被触发</span><br><span class="line">class Observer &#123;</span><br><span class="line">    constructor(phoneNum, subscribeType ,company) &#123;</span><br><span class="line">        this.phoneNum = phoneNum</span><br><span class="line">        //订阅的第一步，就必须获得订阅内容的资料或对象，我们把这个对象看成是新闻服务公司，这个新闻服务公司提供很多种类的新闻：房产新闻，食品新闻，体育新闻。。。。</span><br><span class="line">        this.company = company //必不可少，将公司资料保存下来，可以针对新闻服务公司的服务态度，给公司反馈或投诉建议</span><br><span class="line">        this.subscribeType = subscribeType</span><br><span class="line">        this.company.attach(this)//报名，参加订阅，这一步是不是可以理解为订阅.attach就是公司给订阅者的报名方式</span><br><span class="line">    &#125;</span><br><span class="line">    //cellphone 新闻服务公司，有消息时会打电话给每个订阅者，cellphone模拟的是订阅者手机接到电话的行为，很多示例中将cellphone写作update，不过为了方便理解，在此写成cellphone</span><br><span class="line">    cellphone() &#123;</span><br><span class="line">        console.log(`$&#123;this.phoneNum&#125; 收到, state新闻: $&#123;this.company.getState()&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 测试代码</span><br><span class="line">let newsCompany = new NewsCompany()</span><br><span class="line">//对于新闻服务公司来说，他只需要知道 订阅者 电话号码 和 订阅内容即可，一个人可以有很多特性，例如名字，性别，爱好等等，</span><br><span class="line">//但对于新闻服务公司而言，它只需要知道订阅者的 手机号码 和 新闻类别，所以一个订阅者的对象，只需要具备手机号码和订阅新闻类别两个属性即可。</span><br><span class="line">//所以我们上面设计的订阅者类Observer，只有phoneNum, subscribeType 两个属性。</span><br><span class="line">//从观察者的角度看，它还需要 一个属性来将公司资料保存下来，可以针对新闻服务公司的服务态度，给公司反馈或投诉建议</span><br><span class="line">//基于以上，一个订阅者，需要设置三个属性，而cellphone是公司打电话来时，模拟订阅者手机接到电话的行为</span><br><span class="line">let o1 = new Observer(&apos;15099281126&apos;, &apos;food&apos;, newsCompany)</span><br><span class="line">let o2 = new Observer(&apos;15099281127&apos;, &apos;food&apos;, newsCompany)</span><br><span class="line">let o3 = new Observer(&apos;15099281128&apos;, &apos;food&apos;, newsCompany)</span><br><span class="line">newsCompany.deliveryState(&apos;奶制食品新闻&apos;,&apos;food&apos;);//给每个订阅者发布消息</span><br><span class="line"></span><br><span class="line">let o7 = new Observer(&apos;13899761271&apos;, &apos;house&apos;, newsCompany)</span><br><span class="line">let o8 = new Observer(&apos;13899761272&apos;, &apos;house&apos;, newsCompany)</span><br><span class="line">let o9 = new Observer(&apos;13899761273&apos;, &apos;house&apos;, newsCompany)</span><br><span class="line">newsCompany.deliveryState(&apos;房产新闻&apos;,&apos;house&apos;);//给每个订阅者发布消息</span><br></pre></td></tr></table></figure></p><h4 id="优化及延伸方式一"><a href="#优化及延伸方式一" class="headerlink" title="优化及延伸方式一"></a>优化及延伸方式一</h4><p>对示例代码优化及延伸方式一：<br>上面代码不易扩展，将上面代码优化：NewsCompany中去掉constructor，并且改写food与house切换，将cellphone改为callback不再统一管理callback：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class NewsCompany &#123;</span><br><span class="line">    deliveryState(state,deliveryType) &#123;</span><br><span class="line">        this[`$&#123;deliveryType&#125;State`] = state;</span><br><span class="line">        this.deliveryType = deliveryType;</span><br><span class="line">        this.notifyAllObservers()</span><br><span class="line">    &#125;</span><br><span class="line">    attach(observer) &#123;</span><br><span class="line">        const &#123;subscribeType&#125; = observer;</span><br><span class="line">        if(!this[`$&#123;subscribeType&#125;Observers`])&#123;</span><br><span class="line">            this[`$&#123;subscribeType&#125;Observers`] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        this[`$&#123;subscribeType&#125;Observers`].push(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    notifyAllObservers() &#123;</span><br><span class="line">        const observers = this[`$&#123;this.deliveryType&#125;Observers`];</span><br><span class="line">        observers.forEach(observer =&gt; &#123;</span><br><span class="line">            observer.callback(this[`$&#123;this.deliveryType&#125;State`], this, observer)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 观察者，等待被触发</span><br><span class="line">class Observer &#123;</span><br><span class="line">    constructor(phoneNum, subscribeType ,company, callback) &#123;</span><br><span class="line">        this.phoneNum = phoneNum</span><br><span class="line">        this.subscribeType = subscribeType</span><br><span class="line">        this.callback = callback</span><br><span class="line">        company.attach(this)//报名，参加订阅，</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newsCompany = new NewsCompany()</span><br><span class="line">//state, newsCompany, observerMyself 将newsCompany和observerMyself都传给callback，以备不时之需</span><br><span class="line">let o1 = new Observer(&apos;15099281126&apos;, &apos;food&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`15099281126 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o2 = new Observer(&apos;15099281127&apos;, &apos;food&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`15099281127 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o3 = new Observer(&apos;15099281128&apos;, &apos;food&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`15099281128 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.deliveryState(&apos;奶制食品新闻&apos;,&apos;food&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let o7 = new Observer(&apos;13899761271&apos;, &apos;house&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`13899761271 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o8 = new Observer(&apos;13899761272&apos;, &apos;house&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`13899761272 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">let o9 = new Observer(&apos;13899761273&apos;, &apos;house&apos;, newsCompany, (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">    console.log(`13899761273 收到, state新闻: `,state)</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.deliveryState(&apos;房产新闻&apos;,&apos;house&apos;);</span><br></pre></td></tr></table></figure><h4 id="优化及延伸方式二"><a href="#优化及延伸方式二" class="headerlink" title="优化及延伸方式二"></a>优化及延伸方式二</h4><p>对示例代码优化及延伸方式二：<br>你会发现上面的phoneNum其实可有可无，NewsCompany保持跟上面不变，改造其他部分：<br>删除phoneNum,<br>将attach提取出来，<br>删除Observer类，直接用参数来代替，<br>参数因为可能会超过3个改成options对象方式容易扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let newsCompany = new NewsCompany()</span><br><span class="line">//state, newsCompany, observerMyself 将newsCompany和observerMyself都传给callback，以备不时之需</span><br><span class="line">newsCompany.attach(&#123;</span><br><span class="line">    subscribeType : &apos;food&apos;, </span><br><span class="line">    callback: (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">      console.log(`o1 订阅或观察者 收到, state新闻: `,state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.attach(&#123;</span><br><span class="line">    subscribeType : &apos;food&apos;, </span><br><span class="line">    callback: (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">      console.log(`o2 订阅或观察者 收到, state新闻: `,state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.attach(&#123;</span><br><span class="line">    subscribeType : &apos;food&apos;, </span><br><span class="line">    callback: (state, newsCompany, observerMyself)=&gt;&#123;</span><br><span class="line">      console.log(`o3 订阅或观察者 收到, state新闻: `,state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">newsCompany.deliveryState(&apos;奶制食品新闻&apos;,&apos;food&apos;);</span><br></pre></td></tr></table></figure><p>此时，你是否可以将attach想象成 addEventListener，deliveryState想象成fire或trigger。</p><h3 id="es5示例"><a href="#es5示例" class="headerlink" title="es5示例"></a>es5示例</h3><p>由于js天生可以很优雅地使用花括号来构造一个对象，而不用通过class实例化，因此我们可很容易通过es5来写一个观察者与订阅模式示例：</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">var Event = (function()&#123;</span><br><span class="line">    var ClientList = &#123;&#125;,</span><br><span class="line">    listen,</span><br><span class="line">    trigger,</span><br><span class="line">    remove;</span><br><span class="line">    listen = function(key, fn)&#123;</span><br><span class="line">        if(!ClientList[key])&#123;</span><br><span class="line">            ClientList[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        ClientList[key].push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    trigger = function()&#123;</span><br><span class="line">        var key = Array.prototype.shift.call(arguments),</span><br><span class="line">        fns = ClientList[key];</span><br><span class="line">        if(!fns || fns.listen === 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(var i = 0; i&lt;fns.length; i++)&#123;</span><br><span class="line">            fns[i].apply(this,arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    remove = function(key, fn)&#123;</span><br><span class="line">        var fns = ClientList[key];</span><br><span class="line">        if(!fns)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        var fns = ClientList[key];</span><br><span class="line">        if(!fn)&#123;</span><br><span class="line">            fns &amp;&amp; (fns.length = 0);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for (var l = fns.length -1;l&gt;0;l--)&#123;</span><br><span class="line">                var _fn = fns[l];</span><br><span class="line">                if(_fn === fn)&#123;</span><br><span class="line">                    fns.splice(l,1);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;listen,trigger,remove&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">Event.listen(&apos;squeremeter88&apos;, function(price)&#123;</span><br><span class="line">    console.log(&apos;价格= &apos;+price);</span><br><span class="line">&#125;)</span><br><span class="line">Event.listen(&apos;squeremeter88&apos;, function(price)&#123;</span><br><span class="line">    console.log(&apos;价格_111= &apos;+price);</span><br><span class="line">&#125;)</span><br><span class="line">Event.trigger(&apos;squeremeter88&apos;, 20000);</span><br></pre></td></tr></table></figure><p>当业务复杂后，可能出现命名污染的现象，这个时候，我们可以改写Event，通过Event.creat(namespace).listen(add),<br>Event.creat(namespace).trigger(add),详细可看 《js设计模式》书</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>一个按钮被点击时，出发一个div显示最新的count值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;count&quot;&gt;click&lt;/button&gt;</span><br><span class="line">&lt;div id=&quot;show&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var a = (function()&#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    var button = document.getElementById(&apos;count&apos;);</span><br><span class="line">    button.onclick = function()&#123;</span><br><span class="line">        //Event 就是上面的Event不变。</span><br><span class="line">        Event.trigger(&apos;add&apos;, count++)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">var b = (function()&#123;</span><br><span class="line">    var div = document.getElementById(&apos;show&apos;);</span><br><span class="line">    Event.listen(&apos;add&apos;, function(count)&#123;</span><br><span class="line">        div.innerHTML = count</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>网页事件绑定，promise的一系列then，还有react的生命周期函数其实都是定义callbase，是一种观察者模式</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。<br>它的特征是，</p><ul><li>发布和订阅</li><li>一对多（包含一对一）<br>设计的原则：<br>主题与观察者分离，不是主动触发而是被动监听，两者解耦。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面举例来es6和es5两种方式的观察者模式示例，es6和es5两种方式，各有各的优点，本质上也是一样的，为了便于直观理解观察者模式，可先行记忆es5示例的形式。</p><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>缺点 观察者模式容易隐藏 代码逻辑，过量使用观察者模式，后期后期维护时，可能不好找入口的风险带来一些麻烦。<br>优点 观察者模式可以用来很好地写异步编程，事件驱动编程。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h3><p>举例一个常规编程，但这个编程是一个不好的例子–反例，下节会基于此做优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var Light = function()&#123;</span><br><span class="line">    this.state = &apos;off&apos;</span><br><span class="line">    this.button = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Light.prototype.init = function()&#123;</span><br><span class="line">    var button = document.createElement(&apos;button&apos;),</span><br><span class="line">    self = this;</span><br><span class="line">    this.button = document.body.appendChild(button);</span><br><span class="line">    this.button.innerHTML = &apos;开关&apos;;</span><br><span class="line">    this.button.onclick = function()&#123;</span><br><span class="line">        self.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Light.prototype.buttonWasPressed = function(newState)&#123;</span><br><span class="line">   if(this.state === &apos;off&apos;)&#123;</span><br><span class="line">       console.log(&apos;弱光&apos;);//用console来象征 状态行为</span><br><span class="line">       this.state = &apos;weakLight&apos;;</span><br><span class="line">   &#125;else if(this.state === &apos;weakLight&apos;)&#123;</span><br><span class="line">       console.log(&apos;高光&apos;);</span><br><span class="line">       this.state = &apos;strongLight&apos;;</span><br><span class="line">   &#125;else if(this.state === &apos;strongLight&apos;)&#123;</span><br><span class="line">       console.log(&apos;关灯&apos;);</span><br><span class="line">       this.state = &apos;off&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var light = new Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure></p><p>需求来了，如果再增加一个超级强光，那么就要改写buttonWasPressed，违反了开放封闭原则，而且Light.prototype.buttonWasPressed会越来越臃肿，<br>代码中状态行为只有一句console.log(),但实际开发中，肯定不止这一句代码，基于以上两点理由，因为有必要 改写成下一节的示例代码</p><h3 id="标准状态模式示例"><a href="#标准状态模式示例" class="headerlink" title="标准状态模式示例"></a>标准状态模式示例</h3><p>将上节反例demo改造，优化，以下是标准状态模式demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//标准状态模式示例</span><br><span class="line">var LightState = function(nextState, stateCallback)&#123;</span><br><span class="line">    this.stateCallback = stateCallback;</span><br><span class="line">    this.nextState = nextState;</span><br><span class="line">&#125;</span><br><span class="line">LightState.prototype.buttonWasPressed = function()&#123;</span><br><span class="line">    this.stateCallback();//对应的行为</span><br><span class="line">    this.light.setState(this.nextState) //切换状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var OffLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">OffLightState.prototype = new LightState(&apos;weakLightState&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;弱光&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var WeakLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">WeakLightState.prototype = new LightState(&apos;strongLightState&apos; ,function()&#123;</span><br><span class="line">    console.log(&apos;强光&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var StrongLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">StrongLightState.prototype = new LightState(&apos;offLightState&apos; , function()&#123;</span><br><span class="line">    console.log(&apos;关灯&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var LightContext = function()&#123;</span><br><span class="line">    this.offLightState = new OffLightState(this)</span><br><span class="line">    this.weakLightState = new WeakLightState(this)</span><br><span class="line">    this.strongLightState = new StrongLightState(this)</span><br><span class="line">    this.button = null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LightContext.prototype.init = function()&#123;</span><br><span class="line">    var button = document.createElement(&apos;button&apos;),</span><br><span class="line">    self = this;</span><br><span class="line">    this.button = document.body.appendChild(button);</span><br><span class="line">    this.button.innerHTML = &apos;开关&apos;;</span><br><span class="line">    this.currState = this.offLightState; //设置开始状态</span><br><span class="line">    this.button.onclick = function()&#123;</span><br><span class="line">        self.currState.buttonWasPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LightContext.prototype.setState = function(newState)&#123;</span><br><span class="line">   this.currState = this[newState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var light = new LightContext();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure></p><p>当增加一个超级强光时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var SuperStrongLightState = function(light)&#123;</span><br><span class="line">    this.light = light;</span><br><span class="line">&#125;</span><br><span class="line">SuperStrongLightState.prototype = new LightState(&apos;offLightState&apos; , function()&#123;</span><br><span class="line">    console.log(&apos;关灯&apos;);//自定义对应的行为</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">StrongLightState.prototype = new LightState(&apos;superStrongLightState&apos; , function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var LightContext = function()&#123;</span><br><span class="line">...</span><br><span class="line">    this.superStrongLightState = new SuperStrongLightState(this)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态模式的优缺点"><a href="#状态模式的优缺点" class="headerlink" title="状态模式的优缺点"></a>状态模式的优缺点</h3><p>以上就是状态模式的魅力，符合开放封闭原则，可以不让buttonWasPressed臃肿，其实就是不让context无限臃肿。<br>缺点 会增加代码量，把逻辑分散到状态类中，无法在一个地方就可以将逻辑不能一目了然。</p><h3 id="设计原则与定义"><a href="#设计原则与定义" class="headerlink" title="设计原则与定义"></a>设计原则与定义</h3><p>状态模式，最重要的特征是定义状态类(如上的LightState)，并将逻辑分散到状态类中。<br>将状态(LightState)与主体(LightContext)分离，状态变化的逻辑单独到每个状态类中(例如OffLightState)处理。</p><p>状态模式的定义较晦涩：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。<br>这个定义基本看不懂，可以忽视掉。<br>状态模式的精髓在于 定义状态类，并状态对应的逻辑封装到状态类中。</p><h3 id="什么情况下使用"><a href="#什么情况下使用" class="headerlink" title="什么情况下使用"></a>什么情况下使用</h3><p>什么情况下使用状态模式，<br>如上面优缺点说的，<br>当你不希望Light.prototype.buttonWasPressed太臃肿时；<br>当每次有新需求你不希望每次都去修改Light.prototype.buttonWasPressed时；<br>当你做的功能业务有太多状态变化，且每个状态逻辑较多时；<br>那么就请使用状态模式吧</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="两者代理模式的概念"><a href="#两者代理模式的概念" class="headerlink" title="两者代理模式的概念"></a>两者代理模式的概念</h3><p>js中用得最多的虚拟代理和缓存代理；<br>虚拟代理指通过代理，将一个函数延迟或等到真正需要执行的时候再执行，说白了就是延时下，例如下面例子中，等图片完全加载好后再执行真正的加载。<br>缓存代理，如下例子中，指通过代理，不用每次都执行函数，开始执行完函数后，后期从缓存取，如果我计算或2+3，后面再2+3时，直接从缓存取。<br>代理模式很简单直接通过以下两个例子来领略下代理模式；</p><h3 id="虚拟代理示例"><a href="#虚拟代理示例" class="headerlink" title="虚拟代理示例"></a>虚拟代理示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var myImage = (function()&#123;</span><br><span class="line">    var imgNode = document.createElement(&apos;img&apos;);</span><br><span class="line">    document.body.appendChild(imgNode);</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc: function(src)&#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">var proxyImage = (function()&#123;</span><br><span class="line">    var img = new Image;</span><br><span class="line">    img.onload = function()&#123;</span><br><span class="line">        myImage.setSrc(this.src)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        setSrc:function(src)&#123;</span><br><span class="line">            myImage.setSrc(&apos;file:// /c:/user/abc.gif&apos;);</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">//myImage.setSrc(&apos;http://s9.knowsky.com/bizhi/l/20100615/2010112611%20(1).jpg&apos;)</span><br><span class="line">proxyImage.setSrc(&apos;http://s9.knowsky.com/bizhi/l/20100615/2010112611%20(1).jpg&apos;)</span><br></pre></td></tr></table></figure><p>注意一个现象，myImage有一个setSrc接口，proxyImage也有一个setSrc接口，并且代理函数体内用了myImage.setSrc；</p><h3 id="缓存代理示例"><a href="#缓存代理示例" class="headerlink" title="缓存代理示例"></a>缓存代理示例</h3><h4 id="简单版示例"><a href="#简单版示例" class="headerlink" title="简单版示例"></a>简单版示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var mult = function()&#123;</span><br><span class="line">    console.log(&apos;开始计算乘积&apos;);</span><br><span class="line">    var a = 1;</span><br><span class="line">    for (var i =0, l = arguments.length; i&lt;l; i++)&#123;</span><br><span class="line">        a = a*arguments[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var proxyMult = (function()&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = mult.apply(this, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">console.log(proxyMult(1,2,3,4))</span><br><span class="line">console.log(proxyMult(1,2,3,4))</span><br></pre></td></tr></table></figure><h4 id="延伸版示例"><a href="#延伸版示例" class="headerlink" title="延伸版示例"></a>延伸版示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var plus = function()&#123;</span><br><span class="line">    console.log(&apos;开始计算加和&apos;);</span><br><span class="line">    var a = 0;</span><br><span class="line">    for (var i =0, l = arguments.length; i&lt;l; i++)&#123;</span><br><span class="line">        a = a+arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var createProxyFactory = function(fn)&#123;</span><br><span class="line">    var cache = &#123;&#125;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">        if(args in cache)&#123;</span><br><span class="line">            return cache[args];</span><br><span class="line">        &#125;</span><br><span class="line">        return cache[args] = fn.apply(this, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var proxyMult = createProxyFactory(mult);</span><br><span class="line"></span><br><span class="line">console.log(proxyMult(11,2,3,4))</span><br><span class="line">console.log(proxyMult(11,2,3,4))</span><br></pre></td></tr></table></figure><p>注意一个现象，proxyMult代理函数体内用了fn.apply,且mult与proxyMult接收的参数是一致的，可以认为二者接口一致。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>从上面的示例我们可以看到，<br>设计一个代理模式，有一个小技巧：</p><ul><li>就是代理函数 要 提供跟被代理函数一摸一样的接口，或者有一摸一样的接收传参方式；</li><li>代理函数体内 引用 被代理函数。</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>策略模式的思想：<br>定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。<br>最代表性和关键的操作是将每种算法单独封装成类，或者函数。</p><h3 id="经典示例一"><a href="#经典示例一" class="headerlink" title="经典示例一"></a>经典示例一</h3><p>下面看一个策略模式最代表的例子：</p><h4 id="反例-1"><a href="#反例-1" class="headerlink" title="反例"></a>反例</h4><p>计算绩效奖金，最开始的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 这是反例</span><br><span class="line">var calculateBonus = function(performanceLevel, salary)&#123;</span><br><span class="line">    if(performanceLevel === &apos;S&apos;)&#123;</span><br><span class="line">        return salary*4;</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;A&apos;)&#123;</span><br><span class="line">        return salary*3;</span><br><span class="line">    &#125;</span><br><span class="line">    if(performanceLevel === &apos;B&apos;)&#123;</span><br><span class="line">        return salary*2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">calculateBonus(&apos;B&apos;, 20000);</span><br><span class="line">calculateBonus(&apos;S&apos;, 6000);</span><br></pre></td></tr></table></figure></p><p>上面写法致命缺点在于，将来如果有更多的绩效等级，例如C、D、E、F…时，都需要在calculateBonus中增加代码逻辑；<br>改进上面代码的关键，在于精简calculateBonus。</p><h4 id="标准示例"><a href="#标准示例" class="headerlink" title="标准示例"></a>标准示例</h4><p>改进如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//标准策略模式示例</span><br><span class="line">var S = function(salary)&#123;</span><br><span class="line">    return salary*4;</span><br><span class="line">&#125;</span><br><span class="line">var A = function(salary)&#123;</span><br><span class="line">    return salary*3;</span><br><span class="line">&#125;</span><br><span class="line">var B = function(salary)&#123;</span><br><span class="line">    return salary*2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var calculateBonus = function(func, salary)&#123;</span><br><span class="line">    return func(salary);</span><br><span class="line">&#125;</span><br><span class="line">calculateBonus(B, 20000);</span><br><span class="line">calculateBonus(S, 6000);</span><br></pre></td></tr></table></figure></p><p>改进后，将每个等级的逻辑封装成单独的类或函数，<br>无论未来增加多少绩效逻辑，都将单独定义绩效逻辑类，不会影响现有类，同时calculateBonus都不变。<br>改进用到的策略模式技巧：</p><ul><li>将算法类直接以算法名字命名</li></ul><h3 id="经典示例二"><a href="#经典示例二" class="headerlink" title="经典示例二"></a>经典示例二</h3><p>如果只需了解 策略模式，只需看以上内容即可，这部分内容只是再举例加深理解。</p><p>下面再看一个经典测试模式示例</p><h4 id="反例-2"><a href="#反例-2" class="headerlink" title="反例"></a>反例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//这是反例</span><br><span class="line">&lt;form action=&quot;#&quot; id=&quot;registerForm&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    请输入用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;</span><br><span class="line">    请输入密码：&lt;input type=&quot;text&quot; name=&quot;passWord&quot; /&gt;</span><br><span class="line">    请输入手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot; /&gt;</span><br><span class="line">    &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">var registerForm = document.getElementById(&apos;registerForm&apos;);</span><br><span class="line">registerForm.onsubmit = function()&#123;</span><br><span class="line">    if(registerForm.userName.value === &apos;&apos;)&#123;</span><br><span class="line">        alert(&apos;用户名不能为空&apos;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(registerForm.userName.length &lt; 6)&#123;</span><br><span class="line">        alert(&apos;用户名不能少于6位&apos;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(registerForm.password.length &lt; 6)&#123;</span><br><span class="line">        alert(&apos;密码不能少于6位&apos;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准示例-1"><a href="#标准示例-1" class="headerlink" title="标准示例"></a>标准示例</h4><p>对以上示例进行改进：</p><ul><li>将每种验证方法 封装成单独的类或函数，如strategies.isNonEmpty;</li><li>Validator可以看作是本节的第一个标准示例中的calculateBonus，<br>validataForm可以看作是calculateBonus(B, 20000);</li><li>将验证Validator分两步逻辑，一步是逐条添加规则，一步是一次性验证所有规则<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//将一系列 规则算法 封装成单独的函数</span><br><span class="line">var strategies = &#123;</span><br><span class="line">    isNonEmpty: function(value, errorMsg)&#123;</span><br><span class="line">        if(!value)&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    minLength: function(value, length, errorMsg)&#123;</span><br><span class="line">        if(value.length&lt;length)&#123;</span><br><span class="line">            return errorMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    isMobile: function(value, errorMsg)&#123;</span><br><span class="line">        if(!/13511112222/.test(value))&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var Validator = function()&#123;</span><br><span class="line">    this.cache = [];</span><br><span class="line">&#125;</span><br><span class="line">//设计 添加 和 验证 规则的逻辑</span><br><span class="line">Validator.prototype.add = function(dom, rules)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    for (var i = 0,rule; rule = rules[i++];)&#123;</span><br><span class="line">        (function(rule)&#123;</span><br><span class="line">            var strategyAry = rule.strategy.split(&apos;:&apos;);</span><br><span class="line">            var errorMsg = rule.errorMsg;</span><br><span class="line">            self.cache.push(function()&#123;</span><br><span class="line">                var strategy = strategyAry.shift();</span><br><span class="line">                strategyAry.unshift(dom.value);</span><br><span class="line">                strategyAry.push(errorMsg);</span><br><span class="line">                return strategies[strategy].apply(dom, strategyAry);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)(rule)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Validator.prototype.start = function()&#123;</span><br><span class="line">    for(var i= 0,validatorFunc; validatorFunc = this.cache[i++];)&#123;</span><br><span class="line">        var errorMsg = validatorFunc();</span><br><span class="line">        if(errorMsg)&#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为表单实际添加规则 和 验证</span><br><span class="line">var registerForm = document.getElementById(&apos;registerForm&apos;);</span><br><span class="line">var validataForm = function()&#123;</span><br><span class="line">    var validator = new Validator();</span><br><span class="line">    validator.add(registerForm.userName,[&#123;</span><br><span class="line">        strategy: &apos;isNonEmpty&apos;,</span><br><span class="line">        errorMsg: &apos;不能为空&apos;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        strategy: &apos;minLength:10&apos;,</span><br><span class="line">        errorMsg: &apos;长度不能小于10&apos;</span><br><span class="line">    &#125;])</span><br><span class="line">    validator.add(registerForm.passWord,[&#123;</span><br><span class="line">        strategy: &apos;isNonEmpty&apos;,</span><br><span class="line">        errorMsg: &apos;不能为空&apos;</span><br><span class="line">    &#125;])</span><br><span class="line"></span><br><span class="line">    var errorMsg = validator.start();</span><br><span class="line">    return errorMsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">registerForm.onsubmit = function()&#123;</span><br><span class="line">    var errorMsg = validataForm();</span><br><span class="line">    if(errorMsg)&#123;</span><br><span class="line">        alert(errorMsg);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>改进后，这种模式很好的适应了大型项目规则验证。</p><h3 id="编写策略模式技巧"><a href="#编写策略模式技巧" class="headerlink" title="编写策略模式技巧"></a>编写策略模式技巧</h3><ul><li>将策略算法 封装成单独函数或类；</li><li>直接以算法名称 命名 函数和类，如上面经典示例一</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>主要讲解es5装饰者模式的其中的两种实现方式：一个是定义类(构造函数)的方式，一个是修改超级函数Function原型的方式。<br>下面对这两种方式分别讲解：</p><h3 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var Plan = function()&#123;&#125;</span><br><span class="line">Plan.prototype.fire = function()&#123;</span><br><span class="line">    console.log(&apos;发射普通子弹&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var MissleDecorator = function(plan)&#123;</span><br><span class="line">    this.plan = plan;</span><br><span class="line">&#125;</span><br><span class="line">MissleDecorator.prototype.fire = function()&#123;</span><br><span class="line">    this.plan.fire();</span><br><span class="line">    console.log(&apos;发射导弹&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var AtomDecorator = function(plan)&#123;</span><br><span class="line">    this.plan = plan;</span><br><span class="line">&#125;</span><br><span class="line">AtomDecorator.prototype.fire = function()&#123;</span><br><span class="line">    this.plan.fire();</span><br><span class="line">    console.log(&apos;发射原子弹&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var plan = new Plan();</span><br><span class="line">plan = new MissleDecorator(plan);</span><br><span class="line">plan = new AtomDecorator(plan);</span><br><span class="line">plan.fire();</span><br></pre></td></tr></table></figure><h3 id="Function原型方式"><a href="#Function原型方式" class="headerlink" title="Function原型方式"></a>Function原型方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.before = function(beforefn)&#123;</span><br><span class="line">        var _self = this;//保存原函数的引用</span><br><span class="line">        return function()&#123;//返回包含类原函数和新函数的代理函数</span><br><span class="line">            beforefn.apply(this,arguments);//执行新函数，且保证this不被劫持，新函数接受的参数</span><br><span class="line">            return _self.apply(this, arguments);//执行原函数，并且返回原函数的执行结果，并且保持this不被劫持</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Function.prototype.after = function(afterfn)&#123;</span><br><span class="line">        var _self = this;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            var ret = _self.apply(this,arguments);</span><br><span class="line">            afterfn.apply(this,arguments);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var func = function(param)&#123;</span><br><span class="line">        console.log(param);</span><br><span class="line">    &#125;</span><br><span class="line">    func = func.before(function(param)&#123;</span><br><span class="line">        param.b = &apos;b&apos;;</span><br><span class="line">    &#125;)</span><br><span class="line">    func(&#123;a:&apos;a&apos;&#125;);//&#123;a:&apos;a&apos;, b:&apos;b&apos;&#125;</span><br></pre></td></tr></table></figure><h3 id="es6中的修饰器（Decorator）"><a href="#es6中的修饰器（Decorator）" class="headerlink" title="es6中的修饰器（Decorator）"></a>es6中的修饰器（Decorator）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line">class MyTestableClass &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">function testable(target) &#123;</span><br><span class="line">  target.isTestable = true;</span><br><span class="line">&#125;</span><br><span class="line">MyTestableClass.isTestable // true</span><br></pre></td></tr></table></figure><p>注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>装饰者，经常用到的小技巧，不改变原函数情况下，增加函数功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;</span><br><span class="line">        alert(1)</span><br><span class="line">    &#125;</span><br><span class="line">    var _a = a;</span><br><span class="line">    a = function()&#123;</span><br><span class="line">        _a();</span><br><span class="line">        alert(2);</span><br><span class="line">    &#125;</span><br><span class="line">    a();</span><br></pre></td></tr></table></figure></p><p>在开发中，我们常用这种方式，实现页面回退，加载等等事件时，增加功能。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> 观察者模式 </tag>
            
            <tag> 状态模式 </tag>
            
            <tag> 单一职责原则 </tag>
            
            <tag> 开放封闭原则 </tag>
            
            <tag> 舍弃高效率而取可移植性 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客持续集成的实现</title>
      <link href="/2021/01/03/blog_flow/"/>
      <url>/2021/01/03/blog_flow/</url>
      
        <content type="html"><![CDATA[<h2 id="持续集成的需求"><a href="#持续集成的需求" class="headerlink" title="持续集成的需求"></a>持续集成的需求</h2><p>基于github的博客持续集成，在博客分支下，以master作为发布分支；<br>blog_code作为开发分支；<br>当监听到blog_code提交commit时，将触发travis工具，执行 <code>hexo g</code>的编译，并将编译后的代码合并到master分支的过程。</p><h2 id="github-token"><a href="#github-token" class="headerlink" title="github token"></a>github token</h2><p>创建token，路径如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settings / Developer settings / Personal access tokens</span><br></pre></td></tr></table></figure></p><p>任意定义一个token 的名字，如果没有特殊要求，可先全部勾选所有权限：<br><figure class="image-box">                <img src="/image/blog_flow/token.jpg" alt="" title="" class="">                <p></p>            </figure><br>token类似一个秘钥，授权其他的应用来操作github的权限，比如创建、切换、提交分支的权限。</p><h2 id="travis-cli"><a href="#travis-cli" class="headerlink" title="travis-cli"></a>travis-cli</h2><h3 id="选择要操作的branch"><a href="#选择要操作的branch" class="headerlink" title="选择要操作的branch"></a>选择要操作的branch</h3><p>操作地址<a href="https://travis-ci.org/account/repositories，" target="_blank" rel="noopener">https://travis-ci.org/account/repositories，</a><br>选择要操作的branch，点击滑动开关<br><figure class="image-box">                <img src="/image/blog_flow/branch.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="填写github-token"><a href="#填写github-token" class="headerlink" title="填写github token"></a>填写github token</h3><p>点击旁边的setting，设置setting，将gitbuh token填写上就行，其他默认。<br><figure class="image-box">                <img src="/image/blog_flow/setting.jpg" alt="" title="" class="">                <p></p>            </figure><br>至此，travis-cli设置完毕，在首页将看到如下：<br><figure class="image-box">                <img src="/image/blog_flow/view.jpg" alt="" title="" class="">                <p></p>            </figure></p><h2 id="travis-sh"><a href="#travis-sh" class="headerlink" title="_travis.sh"></a>_travis.sh</h2><p>.sh文件是linux命令文件。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义时间</span></span><br><span class="line">time=`date +%Y-%m-%d\ %H:%M:%S`</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行成功</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">success</span></span>()&#123;</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"success"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行失败</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">failure</span></span>()&#123;</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"failure"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#默认执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">default</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  git <span class="built_in">clone</span> https://<span class="variable">$&#123;GH_REF&#125;</span> .deploy_git</span><br><span class="line">  <span class="built_in">cd</span> .deploy_git</span><br><span class="line"></span><br><span class="line">  git checkout master</span><br><span class="line">  <span class="built_in">cd</span> ../</span><br><span class="line"></span><br><span class="line">  mv .deploy_git/.git/ ./public/</span><br><span class="line">  <span class="built_in">cd</span> ./public</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF &gt;&gt; README.md</span><br><span class="line">部署状态 | 集成结果 | 参考值</span><br><span class="line">---|---|---</span><br><span class="line">完成时间 | <span class="variable">$time</span> | yyyy-mm-dd hh:mm:ss</span><br><span class="line">部署环境 | <span class="variable">$TRAVIS_OS_NAME</span> + <span class="variable">$TRAVIS_NODE_VERSION</span> | window \| linux + stable</span><br><span class="line">部署类型 | <span class="variable">$TRAVIS_EVENT_TYPE</span> | push \| pull_request \| api \| cron</span><br><span class="line">启用Sudo | <span class="variable">$TRAVIS_SUDO</span> | <span class="literal">false</span> \| <span class="literal">true</span></span><br><span class="line">仓库地址 | <span class="variable">$TRAVIS_REPO_SLUG</span> | owner_name/repo_name</span><br><span class="line">提交分支 | <span class="variable">$TRAVIS_COMMIT</span> | <span class="built_in">hash</span> 16位</span><br><span class="line">提交信息 | <span class="variable">$TRAVIS_COMMIT_MESSAGE</span> |</span><br><span class="line">Job ID   | <span class="variable">$TRAVIS_JOB_ID</span> |</span><br><span class="line">Job NUM  | <span class="variable">$TRAVIS_JOB_NUMBER</span> |</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">  git init</span><br><span class="line">  git config user.name <span class="string">"yeWills"</span></span><br><span class="line">  git config user.email <span class="string">"xxxx@qq.com"</span></span><br><span class="line">  git add .</span><br><span class="line">  git commit -m <span class="string">"Update Blog By TravisCI With Build <span class="variable">$TRAVIS_BUILD_NUMBER</span>"</span></span><br><span class="line">  <span class="comment"># Github Pages</span></span><br><span class="line">  git push --force --quiet <span class="string">"https://<span class="variable">$&#123;GH_TOKEN&#125;</span>@<span class="variable">$&#123;GH_REF&#125;</span>"</span> master:master</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create Tag</span></span><br><span class="line">  git tag v1.2.<span class="variable">$TRAVIS_BUILD_NUMBER</span> -a -m <span class="string">"Auto Taged By TravisCI With Build <span class="variable">$TRAVIS_BUILD_NUMBER</span>"</span></span><br><span class="line">  <span class="comment"># Github Pages</span></span><br><span class="line">  git push --quiet <span class="string">"https://<span class="variable">$&#123;GH_TOKEN&#125;</span>@<span class="variable">$&#123;GH_REF&#125;</span>"</span> master:master --tags</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">"success"</span>)</span><br><span class="line">     success</span><br><span class="line">       ;;</span><br><span class="line">    <span class="string">"failure"</span>)</span><br><span class="line">     failure</span><br><span class="line">     ;;</span><br><span class="line">         *)</span><br><span class="line">       default</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></p><h2 id="travis-yml"><a href="#travis-yml" class="headerlink" title=".travis.yml"></a>.travis.yml</h2><p>描述文件 yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="comment"># 虚拟环境下安装 11.12.0版本node</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"11.12.0"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cache</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"node_modules"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line">  <span class="comment"># 邮件发送部署结果通知</span></span><br><span class="line"><span class="attr">  email:</span></span><br><span class="line"><span class="attr">    recipients:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">xxxx@qq.com</span></span><br><span class="line"><span class="attr">    on_success:</span> <span class="string">change</span></span><br><span class="line"><span class="attr">    on_failure:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># S: Build Lifecycle</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">sudo</span> <span class="string">apt-get</span> <span class="string">install</span> <span class="string">libnotify-bin</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="comment">#  - gem install travis</span></span><br><span class="line"><span class="comment">#  - travis login --pro --github-token $&#123;GH_TOKEN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">export</span> <span class="string">TZ='Asia/Shanghai'</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="bullet">-g</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">_travis.sh</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="comment"># - hexo clean &amp;&amp; hexo g</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"> <span class="comment"># - LAST_BUILD_NUMBER=68</span></span><br><span class="line"> <span class="comment"># - for i in $(seq 1 $LAST_BUILD_NUMBER ); do  travis logs $i --delete --force ; done</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">./_travis.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># E: Build LifeCycle</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">blog_code</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr"> global:</span></span><br><span class="line"><span class="attr">   - GH_REF:</span> <span class="string">github.com/YeWills/YeWills.github.io.git</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> travis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css知识点汇</title>
      <link href="/2021/01/03/css_big/"/>
      <url>/2021/01/03/css_big/</url>
      
        <content type="html"><![CDATA[<p>本篇的css知识点，都在《css笔记》中有列举，由于知识点篇幅较大，单独将知识点放置于本篇详细描述。</p><h2 id="float浮动定位"><a href="#float浮动定位" class="headerlink" title="float浮动定位"></a>float浮动定位</h2><p>浮动定位有以下特点：</p><h3 id="收缩为最小宽度"><a href="#收缩为最小宽度" class="headerlink" title="收缩为最小宽度"></a>收缩为最小宽度</h3><p>除非已经定义了浮动元素的宽度，否则浮动元素收缩为适应元素内容的最小宽度。</p><h3 id="遇到块级元素将停止"><a href="#遇到块级元素将停止" class="headerlink" title="遇到块级元素将停止"></a>遇到块级元素将停止</h3><p>对于自身而言，浮动元素脱离文档流后，遇到块级元素将停止，</p><h3 id="脱离文档流，但不脱离文本流"><a href="#脱离文档流，但不脱离文本流" class="headerlink" title="脱离文档流，但不脱离文本流"></a>脱离文档流，但不脱离文本流</h3><p>当一个元素变为浮动元素时，对不同类型的相邻元素影响如下：</p><h4 id="与行内元素相邻"><a href="#与行内元素相邻" class="headerlink" title="与行内元素相邻"></a>与行内元素相邻</h4><p>会让行内元素紧贴浮动元素，典型的场景–图片文字环绕<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">&lt;img src=&quot;./aa.jpg&quot; alt=&quot;aa&quot;&gt;</span><br><span class="line">&lt;span&gt;行内元素文字行内元素文字&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><h4 id="与块级元素相邻"><a href="#与块级元素相邻" class="headerlink" title="与块级元素相邻"></a>与块级元素相邻</h4><p>浮动元素脱离文档流，此时效果类似position：absolute，相当于浮动元素不存在，与之相邻的块级元素将占领浮动元素位置；<br><strong>但是块级元素内的行内元素，将环绕浮动元素</strong>，这是因为float不脱离文本流<br>浮动之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    .float &#123;</span><br><span class="line">        height: 60px;</span><br><span class="line">        background: rebeccapurple;</span><br><span class="line">    &#125;</span><br><span class="line">    .test &#123;</span><br><span class="line">        border: 45px solid #00BCD4;</span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;float&quot;&gt;浮动之前&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;相邻块级元素&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/css/float-before.jpg" alt="" title="" class="">                <p></p>            </figure><p>浮动之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    .float &#123;</span><br><span class="line">      /* 其他代码省略 */</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;div class=&quot;float&quot;&gt;浮动之后&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;相邻块级元素相邻块级元素相邻块级元素...&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/css/float-after.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="与浮动元素相邻"><a href="#与浮动元素相邻" class="headerlink" title="与浮动元素相邻"></a>与浮动元素相邻</h4><p>浮动元素与浮动元素 将并列并排；<br>注意的是，如果浮动元素的高度不同，当浮动元素被挤到第二行时，将会卡住：<br><figure class="image-box">                <img src="/image/css/float-pading.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.triangle&#123;</span><br><span class="line">     float: left;</span><br><span class="line">     width: 150px;</span><br><span class="line">     height: 60px;</span><br><span class="line"> &#125;</span><br><span class="line"> .it1&#123;</span><br><span class="line">     height: 80px;</span><br><span class="line">     background:rebeccapurple;</span><br><span class="line"> &#125;</span><br><span class="line"> .it2&#123;</span><br><span class="line">     background:blue;</span><br><span class="line"> &#125;</span><br><span class="line"> .it3&#123;</span><br><span class="line">     background:#00BCD4;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;div class=&quot;triangle it1&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line"> &lt;div class=&quot;triangle it2&quot;&gt;浮动元素&lt;/div&gt;</span><br><span class="line"> &lt;div class=&quot;triangle it3&quot;&gt;浮动元素&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="消除与相邻元素的间隙"><a href="#消除与相邻元素的间隙" class="headerlink" title="消除与相邻元素的间隙"></a>消除与相邻元素的间隙</h3><p>当被定义为浮动元素时，它跟原来相邻元素可能由于系统中自带的缝隙，一旦变成浮动元素，此缝隙将没有了，参加《float清空格(间隙)的原因》；<br>消除间隙这个特性，在开发中经常被运用.</p><h3 id="与绝对定位区别"><a href="#与绝对定位区别" class="headerlink" title="与绝对定位区别"></a>与绝对定位区别</h3><p>浮动定位于绝对定位都会脱离文档流，但二者表现不一样；<br>绝对定位是完全脱离文档流，相当于文档中不存在此元素了，而浮动定位脱离文档流要区别行内元素，原因如上。</p><h3 id="float清空格-间隙-的原因"><a href="#float清空格-间隙-的原因" class="headerlink" title="float清空格(间隙)的原因"></a>float清空格(间隙)的原因</h3><p>根本原因是由于float会导致节点脱离文档流结构。它都不属于文档流结构了，那么它身边的什么换行、空格就都和它没关系的，它就尽量的往一边去靠拢，能靠多近就靠多近，这就是清空格的本质。</p><h3 id="几个相邻float元素卡住现象"><a href="#几个相邻float元素卡住现象" class="headerlink" title="几个相邻float元素卡住现象"></a>几个相邻float元素卡住现象</h3><p>参考《脱离文档流，但不脱离文本流  – 与浮动元素相邻》</p><h3 id="float对自身的影响"><a href="#float对自身的影响" class="headerlink" title="float对自身的影响"></a>float对自身的影响</h3><h4 id="形成“块”（BFC），从而可以设置height等等"><a href="#形成“块”（BFC），从而可以设置height等等" class="headerlink" title="形成“块”（BFC），从而可以设置height等等"></a>形成“块”（BFC），从而可以设置height等等</h4><p>float可以形成一个bfc，bfc相当于一个块级元素，可以设置大小，消除外边距折叠。</p><h3 id="float对父元素影响"><a href="#float对父元素影响" class="headerlink" title="float对父元素影响"></a>float对父元素影响</h3><h4 id="父元素的高度坍塌"><a href="#父元素的高度坍塌" class="headerlink" title="父元素的高度坍塌"></a>父元素的高度坍塌</h4><p>float元素脱离文档流，让父元素高度为0；</p><h3 id="消除浮动的方法"><a href="#消除浮动的方法" class="headerlink" title="消除浮动的方法"></a>消除浮动的方法</h3><h4 id="方法一-参考-《css笔记-–-BFC-–-消除浮动》"><a href="#方法一-参考-《css笔记-–-BFC-–-消除浮动》" class="headerlink" title="方法一 参考 《css笔记  – BFC  – 消除浮动》"></a>方法一 参考 《css笔记  – BFC  – 消除浮动》</h4><h4 id="方法二-参考-《css笔记-–-推荐使用伪类来消除浮动》"><a href="#方法二-参考-《css笔记-–-推荐使用伪类来消除浮动》" class="headerlink" title="方法二 参考 《css笔记  – 推荐使用伪类来消除浮动》"></a>方法二 参考 《css笔记  – 推荐使用伪类来消除浮动》</h4><h4 id="消除浮动方法优缺点-参考-《css笔记-–-推荐使用伪类来消除浮动》"><a href="#消除浮动方法优缺点-参考-《css笔记-–-推荐使用伪类来消除浮动》" class="headerlink" title="消除浮动方法优缺点  参考 《css笔记  – 推荐使用伪类来消除浮动》"></a>消除浮动方法优缺点  参考 《css笔记  – 推荐使用伪类来消除浮动》</h4><h2 id="transform与坐标变换"><a href="#transform与坐标变换" class="headerlink" title="transform与坐标变换"></a>transform与坐标变换</h2><h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><h4 id="参考外网-mdn与w3c"><a href="#参考外网-mdn与w3c" class="headerlink" title="参考外网 mdn与w3c"></a>参考外网 mdn与w3c</h4><p>基础知识请移步参考上面两个地址。记住是外文的，其他版本可能是阉割后的内容。</p><h3 id="两个相同写法引发的思考"><a href="#两个相同写法引发的思考" class="headerlink" title="两个相同写法引发的思考"></a>两个相同写法引发的思考</h3><h4 id="两种写法"><a href="#两种写法" class="headerlink" title="两种写法"></a>两种写法</h4><p>下面两种运行效果为什么一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//写法一</span><br><span class="line">transform-origin: -100% 50%;</span><br><span class="line">transform: rotate(45deg);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//写法二</span><br><span class="line">transform-origin: 0 0;</span><br><span class="line">transform: translate(-100%, 50%) rotate(45deg) translate(100%, -50%);</span><br></pre></td></tr></table></figure><h4 id="元素位移，自带坐标系跟着改变"><a href="#元素位移，自带坐标系跟着改变" class="headerlink" title="元素位移，自带坐标系跟着改变"></a>元素位移，自带坐标系跟着改变</h4><p>当元素发生位移或者旋转后，自带坐标系也随着改变，上面写法中的transform-origin后面跟的坐标就是元素自带的坐标系，一个元素发生平移前后，如果transform-origin都指向(0 0),其相对于世界坐标是不同位置：</p><h4 id="位移只按自身坐标系运动"><a href="#位移只按自身坐标系运动" class="headerlink" title="位移只按自身坐标系运动"></a>位移只按自身坐标系运动</h4><p>当自身坐标系改变时，比如发生旋转后，对元素进行水平或垂直偏移，都是沿着旋转后的自身坐标系而言的。</p><h4 id="二者transform-origin世界坐标位置相同"><a href="#二者transform-origin世界坐标位置相同" class="headerlink" title="二者transform-origin世界坐标位置相同"></a>二者transform-origin世界坐标位置相同</h4><p><strong>假如世界坐标的原点与元素自带坐标系位移前的右上角坐标重合</strong>：<br>先分析上面写法二：<br>元素位移前坐标 0 0，<br>位移-100% 50%后，<br>原来的0 0点将被移到世界坐标的 -100% 50%;<br>此时自带坐标系的0 0，与世界坐标 -100% 50%重合，为同一位置。</p><p>对于写法一，其transform-origin的世界坐标当然为 -100% 50%；<br>因此上面写法一和二，其ransform-origin位置是相同的。</p><h4 id="元素发生的旋转角度与transform-origin无关"><a href="#元素发生的旋转角度与transform-origin无关" class="headerlink" title="元素发生的旋转角度与transform-origin无关"></a>元素发生的旋转角度与transform-origin无关</h4><p>下面写法中，旋转的原点位置尽管不一样，元素旋转前与旋转后，发生的角度偏移大小是一样的。<br>也就是说，发生下面两种偏移后，虽然元素在水平和垂直方向的位移不同，但是其旋转的角度大小是一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//下面两种偏移后， 旋转角度还是一样</span><br><span class="line"></span><br><span class="line">//写法一</span><br><span class="line">transform-origin: -100px 50%;</span><br><span class="line">transform: rotate(45deg);</span><br><span class="line"></span><br><span class="line">//写法二</span><br><span class="line">transform-origin: -200px 50%;</span><br><span class="line">transform: rotate(45deg);</span><br></pre></td></tr></table></figure></p><h4 id="相同transform-origin发生偏移"><a href="#相同transform-origin发生偏移" class="headerlink" title="相同transform-origin发生偏移"></a>相同transform-origin发生偏移</h4><p>下面两种写法，其transform-origin在世界坐标上属于同一个坐标点，此时写法二相对于写法一发生的偏移为 -100% 50%，因此无论之后两种写法下，都发生同样都偏移，要让最后位置一样，只需在写法二中 抹平这个偏移差 -100% 50%即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//对于同一元素使用下面两种写法</span><br><span class="line"></span><br><span class="line">//写法一</span><br><span class="line">transform-origin: -100% 50%;</span><br><span class="line">transform: rotate(45deg);</span><br><span class="line"></span><br><span class="line">//写法二</span><br><span class="line">transform-origin: 0 0;</span><br><span class="line">transform: translate(-100%, 50%) ;</span><br><span class="line"></span><br><span class="line">//写法二 延伸（抹平偏移差）</span><br><span class="line">transform-origin: 0 0;</span><br><span class="line">transform: translate(-100%, 50%) rotate(45deg) translate(100%, -50%);</span><br></pre></td></tr></table></figure></p><p>如下也是相同效果（下面二者， transform-origin 相同）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//下面两种写法是一个意思</span><br><span class="line">//写法A</span><br><span class="line">transform-origin: 20px -50px;</span><br><span class="line">transform: translate(-120px, 100px) rotate(110deg) translate(120px, -100px);</span><br><span class="line"></span><br><span class="line">//写法B</span><br><span class="line">transform-origin: -100px 50px;</span><br><span class="line">transform: rotate(110deg);</span><br></pre></td></tr></table></figure></p><h4 id="相同transform-origin的结论"><a href="#相同transform-origin的结论" class="headerlink" title="相同transform-origin的结论"></a>相同transform-origin的结论</h4><p>同一个元素，当使用同一个世界位置的transform-origin时，形如如下时，要想写法A达到写法B的效果，写法A只需将transform定义的translate(-120px, 100px)等值反向以下，即可抹平偏移差，二者得到相同效果；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//写法A</span><br><span class="line">transform-origin: 20px -50px;</span><br><span class="line">transform: translate(-120px, 100px) rotate(110deg);</span><br><span class="line">//transform: translate(-120px, 100px) rotate(110deg) translate(120px, -100px);</span><br><span class="line"></span><br><span class="line">//写法B</span><br><span class="line">transform-origin: -100px 50px;</span><br><span class="line">transform: rotate(110deg);</span><br></pre></td></tr></table></figure></p><h4 id="不懂就看demo"><a href="#不懂就看demo" class="headerlink" title="不懂就看demo"></a>不懂就看demo</h4><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/transform-origin-rect.html" target="_blank" rel="noopener">长方形动画效果demo</a><br><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/transform-origin-point.html" target="_blank" rel="noopener">点动画效果demo</a></p><h3 id="元素位移，自带坐标系跟着改变-1"><a href="#元素位移，自带坐标系跟着改变-1" class="headerlink" title="元素位移，自带坐标系跟着改变"></a>元素位移，自带坐标系跟着改变</h3><p>参考《两个相同写法引发的思考  – 元素位移，自带坐标系跟着改变》</p><h3 id="位移只按自身坐标系运动-1"><a href="#位移只按自身坐标系运动-1" class="headerlink" title="位移只按自身坐标系运动"></a>位移只按自身坐标系运动</h3><p>参考《两个相同写法引发的思考  – 位移只按自身坐标系运动》</p><h2 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h2><h3 id="25帧"><a href="#25帧" class="headerlink" title="25帧"></a>25帧</h3><p>指的是一秒内有25张静止的图片，一般达到25帧，在视觉上可形成流畅的动画效果。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>更多参考《前端demo讲解 – 动画demo 及 css动画知识点》</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css之布局</title>
      <link href="/2021/01/03/css_layout/"/>
      <url>/2021/01/03/css_layout/</url>
      
        <content type="html"><![CDATA[<p>我们都知道，定位、浮动、flexbox，这些可以用来布局；<br>我们也知道什么固定布局，流式布局等等，这些也是布局；<br>那么定位、浮动这些是什么布局呢，是固定布局吗?<br>都不是，所以固定布局、弹性布局、流式布局，这些更代表了一种布局的设计思想，一种布局方案，<br>而定位、浮动、flexbox这些是一种布局的技术手段。<br>我们大可这样理解：<br>布局的设计方式有 固定设计方式、弹性设计方式、流式设计方式、响应式设计方式;<br>布局的技术方法(手段)有 定位、浮动、flexbox、百分比；</p><h2 id="布局的技术手段"><a href="#布局的技术手段" class="headerlink" title="布局的技术手段"></a>布局的技术手段</h2><h3 id="优先使用flexbox，减少使用定位和浮动布局"><a href="#优先使用flexbox，减少使用定位和浮动布局" class="headerlink" title="优先使用flexbox，减少使用定位和浮动布局"></a>优先使用flexbox，减少使用定位和浮动布局</h3><p>布局的技术手段有：定位(绝对定位、固定定位)、浮动、flexbox。<br>在这些技术手段中，绝对定位、浮动这些已经是比较老的技术手段了，而且flexbox能够轻松实现浮动或绝对定位。<br>因为遇到布局时推荐优先使用新的布局方法 flexbox。</p><h3 id="display：gird"><a href="#display：gird" class="headerlink" title="display：gird"></a>display：gird</h3><p>gird是最新的一种布局方式，可能在未来对目前的布局带来非常大的影响。</p><h2 id="布局设计方式"><a href="#布局设计方式" class="headerlink" title="布局设计方式"></a>布局设计方式</h2><h3 id="布局方式介绍"><a href="#布局方式介绍" class="headerlink" title="布局方式介绍"></a>布局方式介绍</h3><p>参考《精通css》P177<br><strong>固定布局</strong> 使用px布局；<br><strong>弹性布局</strong> 使用em作为布局元素的尺寸。(不是用em来作为font-size或margin、padding哦)<br><strong>流式布局</strong> 使用百分比布局，浏览器默认布局方式，也是主流布局方式。为什么说是主体布局方式了，因为响应式布局基本上基于流式布局。<br><strong>响应式布局</strong> 基于流式布局，利用媒体查询等手段进行响应自适应，本质上响应式布局也是流式布局。《精通css》P207中，直接将响应式布局描述为：可以适配不同视口大小的流式布局。</p><p>有人说只要使用了em或者rem的就是一种弹性布局，这可能不太准确，笔记使用em来定义font-size或margin、padding等等是常识，使用rem来定义font-size等等，这些都是常识，可以说就是应该这样做的。所以如果使用rem或em做以上事情，就不应该是弹性布局。<br>只有使用em作为元素的宽高尺寸了，那才说明用了弹性布局。</p><h3 id="响应式布局是当前最推荐方式"><a href="#响应式布局是当前最推荐方式" class="headerlink" title="响应式布局是当前最推荐方式"></a>响应式布局是当前最推荐方式</h3><p>上面几种布局中，当有最推荐和最重要的是响应式布局，(又称为 响应式web布局设计)。</p><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>响应式布局主体用的还是流式布局，在此基础上，主要使用媒体查询进行响应设计，另外也使用了flexbox进行响应设计。</p><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>自行网上查看。</p><h4 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h4><p>flexbox也是css中具有某种响应式特质的规范，无须使用媒体查询，flexbox本身就可以创建出能够有效利用空间的适配布局。<br>为什么说flexbox具备某种响应式特质呢，比如父级定义为flex，自己都会随着父级的变大而变大，缩小而缩小，这跟子级定义百分比，随父级增大而增大，缩小而缩小一样。说明了flexbox有浓烈的流式特性，流式特性是响应式布局的重要体现。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>媒体查询虽然是基于视口的创建响应式布局的主打方式，但它也有弊端，响应式布局同时要结合flexbox一起使用，才能做出更好的响应式布局。参考《精通css》P227。</p><p>另外，要做出一个好的响应式设计布局，其实是结合了固定、弹性、流式布局，以流式布局为主体，辅以弹性布局常用的em和rem来设计margin\font-size\padding等等，再辅以固定布局常用到的px来定义必要的元素。(这一段是个人见解，可能不太准确，笔记只有利用em来定义元素的宽高而非margin\font-size\padding才算弹性布局，只有利用px来定义布局元素的宽高才算固定范畴，因此这里所说的可能并非结合了固定和弹性布局，而是使用了固定、弹性布局常用的手段–px和em，即固定常用px，弹性常用em)</p><h2 id="flexbox-1"><a href="#flexbox-1" class="headerlink" title="flexbox"></a>flexbox</h2><p>参看《flex布局不是布局设计模式》《响应式布局是当前最推荐方式 —flexbox》《布局的技术手段》</p><h3 id="flex布局不是布局设计模式"><a href="#flex布局不是布局设计模式" class="headerlink" title="flex布局不是布局设计模式"></a>flex布局不是布局设计模式</h3><p>参考文首开头的分析，flex布局或flexbox并不是一种布局的设计模式，它不隶属任何一种布局设计方式，它只是一种布局技术手段而已。<br>它可以被运用于 固定、弹性、响应式布局当中。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布局的技术手段 </tag>
            
            <tag> 响应式布局(设计) </tag>
            
            <tag> 固定布局(设计) </tag>
            
            <tag> 弹性布局(设计) </tag>
            
            <tag> 流动布局(设计) </tag>
            
            <tag> 媒体查询 </tag>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>d3图形、demo讲解、使用经验</title>
      <link href="/2021/01/03/d3_layout/"/>
      <url>/2021/01/03/d3_layout/</url>
      
        <content type="html"><![CDATA[<h2 id="d3图形图解"><a href="#d3图形图解" class="headerlink" title="d3图形图解"></a>d3图形图解</h2><figure class="image-box">                <img src="/image/d3/all/images.jpg" alt="" title="" class="">                <p></p>            </figure><h2 id="树图"><a href="#树图" class="headerlink" title="树图"></a>树图</h2><h3 id="树图布局API"><a href="#树图布局API" class="headerlink" title="树图布局API"></a>树图布局API</h3><h4 id="d3-layout-tree-创建一个树图布局"><a href="#d3-layout-tree-创建一个树图布局" class="headerlink" title="d3.layout.tree() 创建一个树图布局"></a>d3.layout.tree() 创建一个树图布局</h4><h4 id="tree-size-设置相邻节点间隔"><a href="#tree-size-设置相邻节点间隔" class="headerlink" title="tree.size([]) 设置相邻节点间隔"></a>tree.size([]) 设置相邻节点间隔</h4><h4 id="tree-separation-separation-设置相邻节点间隔"><a href="#tree-separation-separation-设置相邻节点间隔" class="headerlink" title="tree.separation([separation]) 设置相邻节点间隔"></a>tree.separation([separation]) 设置相邻节点间隔</h4><h4 id="tree-nodes-root-根据root-计算获取节点数组"><a href="#tree-nodes-root-根据root-计算获取节点数组" class="headerlink" title="tree.nodes(root) 根据root 计算获取节点数组"></a>tree.nodes(root) 根据root 计算获取节点数组</h4><h4 id="tree-links-nodes-根据nodes-计算获取连线数组"><a href="#tree-links-nodes-根据nodes-计算获取连线数组" class="headerlink" title="tree.links(nodes) 根据nodes 计算获取连线数组"></a>tree.links(nodes) 根据nodes 计算获取连线数组</h4><h3 id="节点对象-nodes"><a href="#节点对象-nodes" class="headerlink" title="节点对象(nodes)"></a>节点对象(nodes)</h3><h4 id="parent-父节点"><a href="#parent-父节点" class="headerlink" title="parent 父节点"></a>parent 父节点</h4><h4 id="children-子节点"><a href="#children-子节点" class="headerlink" title="children 子节点"></a>children 子节点</h4><h4 id="depth-节点深度"><a href="#depth-节点深度" class="headerlink" title="depth 节点深度"></a>depth 节点深度</h4><h4 id="x-节点x坐标"><a href="#x-节点x坐标" class="headerlink" title="x 节点x坐标"></a>x 节点x坐标</h4><h4 id="y-节点y坐标"><a href="#y-节点y坐标" class="headerlink" title="y 节点y坐标"></a>y 节点y坐标</h4><h3 id="连线-links"><a href="#连线-links" class="headerlink" title="连线(links)"></a>连线(links)</h3><h4 id="source-前端节点"><a href="#source-前端节点" class="headerlink" title="source 前端节点"></a>source 前端节点</h4><h4 id="target-后端节点"><a href="#target-后端节点" class="headerlink" title="target 后端节点"></a>target 后端节点</h4><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="设置svg-宽高，添加g，设置位置"><a href="#设置svg-宽高，添加g，设置位置" class="headerlink" title="设置svg 宽高，添加g，设置位置"></a>设置svg 宽高，添加g，设置位置</h4><h4 id="生成树状布局，设置尺寸"><a href="#生成树状布局，设置尺寸" class="headerlink" title="生成树状布局，设置尺寸"></a>生成树状布局，设置尺寸</h4><h4 id="对角线生成器"><a href="#对角线生成器" class="headerlink" title="对角线生成器"></a>对角线生成器</h4><h4 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h4><ul><li>获取nodes节点数组和link连接线数组</li><li>生成连线</li><li>生成节点</li><li>给节点添加圆圈，设置半径</li><li>给节点添加文本、设置文本的样式 位置<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3>下面代码都基于以下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var svg = d3.select(&quot;body&quot;)</span><br><span class="line">                .append(&apos;svg&apos;)</span><br><span class="line">                .attr(&apos;width&apos;, 800)</span><br><span class="line">                .attr(&apos;height&apos;, 800);</span><br></pre></td></tr></table></figure></li></ul><p>以上是d3常用写法，下面示例皆以此为基础展开：</p><h3 id="树图demo"><a href="#树图demo" class="headerlink" title="树图demo"></a>树图demo</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>上面《树图》介绍的，在这个demo上都有体现。<br>效果：<br><figure class="image-box">                <img src="/image/d3/layout/tree1.jpg" alt="" title="" class="">                <p></p>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var nodes = tree.nodes(root),</span><br><span class="line">  links = tree.links(nodes);</span><br></pre></td></tr></table></figure><h4 id="转换坐标"><a href="#转换坐标" class="headerlink" title="转换坐标"></a>转换坐标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// diagonal 生成对角线</span><br><span class="line">       var diagonal = d3.svg.diagonal()</span><br><span class="line">               // 转换坐标轴方向</span><br><span class="line">               .projection(function (d) &#123;</span><br><span class="line">                       return [d.y, d.x];</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><h4 id="enter-时隐藏，-update时-显示："><a href="#enter-时隐藏，-update时-显示：" class="headerlink" title="enter 时隐藏， update时 显示："></a>enter 时隐藏， update时 显示：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// .attr(&apos;r&apos;, 0) 意为 隐藏，会在下面都 updateNodes.select(&quot;circle&quot;) 更新时，显示出来 .attr(&quot;r&quot;, 6)</span><br><span class="line">               enterNodes.append(&apos;circle&apos;)</span><br><span class="line">                       .attr(&apos;r&apos;, 0)</span><br><span class="line">                       .style(&apos;fill&apos;, (d) =&gt; d._children ? &apos;red&apos; : &apos;#fff&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">updateNodes.select(&quot;circle&quot;)</span><br><span class="line">                       .attr(&quot;r&quot;, 6)</span><br><span class="line">                       .style(&quot;fill&quot;, function (d) &#123;</span><br><span class="line">                               return d._children ? &quot;red&quot; : &quot;#fff&quot;;</span><br><span class="line">                       &#125;);</span><br></pre></td></tr></table></figure><h4 id="连点确定一线"><a href="#连点确定一线" class="headerlink" title="连点确定一线"></a>连点确定一线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//开始绘制点，亮点成一线，起始点-source 终点-target 二点相连，就是连线</span><br><span class="line">//如果起始点和终点在同一个位置，说明连线就是一个点</span><br><span class="line">.attr(&quot;d&quot;, function (d) &#123;</span><br><span class="line">        var o = &#123;</span><br><span class="line">                x: source.x0,</span><br><span class="line">                y: source.y0</span><br><span class="line">        &#125;;</span><br><span class="line">        return diagonal(&#123;</span><br><span class="line">                source: o,</span><br><span class="line">                target: o</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 使用对角线生成器</span><br><span class="line">//连线没有像上面一样指明起始点和终点，就意味着是一个正常的连线</span><br><span class="line">.attr(&quot;d&quot;, diagonal);</span><br></pre></td></tr></table></figure><h4 id="参考与demo地址"><a href="#参考与demo地址" class="headerlink" title="参考与demo地址"></a>参考与demo地址</h4><p><a href="https://github.com/YeWills/nodemon-server-template/tree/d3-demo" target="_blank" rel="noopener">demo地址, 找到其中的 circle d3 demo</a><br><a href="https://ke.qq.com/course/306436?taid=2254411154107652" target="_blank" rel="noopener">更多讲解看视频</a></p><h2 id="走势图"><a href="#走势图" class="headerlink" title="走势图"></a>走势图</h2><h3 id="demo介绍与d3使用经验"><a href="#demo介绍与d3使用经验" class="headerlink" title="demo介绍与d3使用经验"></a>demo介绍与d3使用经验</h3><h4 id="demo与效果"><a href="#demo与效果" class="headerlink" title="demo与效果"></a>demo与效果</h4><p><a href="https://yewills.github.io/d3-note-demo/pages/sar-chart/">走势图效果</a><br><a href="https://github.com/YeWills/d3-note-demo/blob/master/pages/sar-chart/" target="_blank" rel="noopener">demo地址</a></p><h4 id="记录d3使用经验"><a href="#记录d3使用经验" class="headerlink" title="记录d3使用经验"></a>记录d3使用经验</h4><p>本demo的笔记用于在于记录d3的使用经验，通过demo的编写，记下d3的使用经验，方便以后使用d3时借鉴。</p><h3 id="一切都是-update-enter-exit"><a href="#一切都是-update-enter-exit" class="headerlink" title="一切都是 update enter exit"></a>一切都是 update enter exit</h3><h4 id="更新后原来的svg图未消除"><a href="#更新后原来的svg图未消除" class="headerlink" title="更新后原来的svg图未消除"></a>更新后原来的svg图未消除</h4><p>使用d3重新绘制图形时，发现原来绘制的图形并没有消失，当时使用了js来remove dom，发现不能解决问题。<br>原来正确的解决之道在于d3的机制，除非你重新刷新整个页面，否则绘制的图形都需通过d3进行更新、新增、删除，对应update enter exit。</p><h4 id="如何重绘与更新"><a href="#如何重绘与更新" class="headerlink" title="如何重绘与更新"></a>如何重绘与更新</h4><p>如上讲解的，在d3中，必须通过update enter exit来进行重绘与更新，以及删除。</p><h4 id="update-enter-exit必须配合data才得到"><a href="#update-enter-exit必须配合data才得到" class="headerlink" title="update enter exit必须配合data才得到"></a>update enter exit必须配合data才得到</h4><p>参考 博客《d3的三种模式 及 append、data、selectAll  – data()  –  selectAll data enter exit 的联系》。</p><h4 id="一切从上面二者开始到结束"><a href="#一切从上面二者开始到结束" class="headerlink" title="一切从上面二者开始到结束"></a>一切从上面二者开始到结束</h4><p>基于以上的分析，在使用d3画图时，一切要从update enter exit开始，在刚开始画图时，就要建立这三者的模型，更多三者的使用，请查看 《update enter exit的使用》</p><h4 id="三者使用的经典demo"><a href="#三者使用的经典demo" class="headerlink" title="三者使用的经典demo"></a>三者使用的经典demo</h4><p><a href="https://github.com/YeWills/d3-note-demo/tree/d3-demo/pages/wangjingzhi/fifth.html" target="_blank" rel="noopener">散点图 demo</a><br><a href="https://github.com/YeWills/d3-note-demo/tree/d3-demo/pages/d3-jt-book/chapter4/4.8/4-8-2-update-data.html" target="_blank" rel="noopener">柱状图 demo</a></p><h3 id="update-enter-exit的使用"><a href="#update-enter-exit的使用" class="headerlink" title="update enter exit的使用"></a>update enter exit的使用</h3><h4 id="先建立模型"><a href="#先建立模型" class="headerlink" title="先建立模型"></a>先建立模型</h4><p>下面是经典的d3’建模’，一般画图一开始都是创建好下面代码，后面绘图都基于此：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> update = svg.selectAll(<span class="string">".MyCircle"</span>)</span><br><span class="line">.data(pointDatas);</span><br><span class="line"><span class="keyword">var</span> enter = update.enter();</span><br><span class="line"><span class="keyword">var</span> exit = update.exit();</span><br></pre></td></tr></table></figure></p><p>下面是基于上面代码的绘图：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enter.append(<span class="string">"circle"</span>)</span><br><span class="line">.attr(<span class="string">"class"</span>, <span class="string">"MyCircle"</span>)</span><br><span class="line">.attr(<span class="string">"r"</span>, <span class="number">4.5</span>)</span><br><span class="line">.attr(<span class="string">"transform"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">point</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"translate("</span> + focusX + <span class="string">","</span> + focusY + <span class="string">")"</span></span><br><span class="line">&#125;)</span><br><span class="line">.attr(<span class="string">"fill"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d,i</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> handleColor(&#123;<span class="attr">type</span>:d[<span class="number">3</span>]&#125;, colors);</span><br><span class="line">&#125;)</span><br><span class="line">       </span><br><span class="line">       update.attr(<span class="string">"transform"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">point</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"translate("</span> + focusX + <span class="string">","</span> + focusY + <span class="string">")"</span></span><br><span class="line">&#125;)</span><br><span class="line">.attr(<span class="string">"fill"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d,i</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> handleColor(&#123;<span class="attr">type</span>:d[<span class="number">3</span>]&#125;, colors);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">exit.remove();</span><br></pre></td></tr></table></figure></p><h4 id="enter负责增加图形"><a href="#enter负责增加图形" class="headerlink" title="enter负责增加图形"></a>enter负责增加图形</h4><p>参考上面代码。</p><h4 id="update是enter缩减版"><a href="#update是enter缩减版" class="headerlink" title="update是enter缩减版"></a>update是enter缩减版</h4><p>如上面的代码，update是在enter append的circle基础上，对这个circle的更新的。</p><h4 id="如果不更新，使用enter就够了"><a href="#如果不更新，使用enter就够了" class="headerlink" title="如果不更新，使用enter就够了"></a>如果不更新，使用enter就够了</h4><p>如果图形没有更新重绘，就不存在更新与删除，只使用enter就够了。</p><h4 id="记得使用exit-remove"><a href="#记得使用exit-remove" class="headerlink" title="记得使用exit.remove()"></a>记得使用exit.remove()</h4><p>这才是d3删除图形的正确姿态。</p><h3 id="d3的update-enter-exit-与react的生命周期函数"><a href="#d3的update-enter-exit-与react的生命周期函数" class="headerlink" title="d3的update enter exit 与react的生命周期函数"></a>d3的update enter exit 与react的生命周期函数</h3><p>d3的update enter exit很像react的生命周期函数，有didmount unmount，有willupdate didupdate render 等等。</p><h3 id="设置一个数组的技巧"><a href="#设置一个数组的技巧" class="headerlink" title="设置一个数组的技巧"></a>设置一个数组的技巧</h3><p>有时候可以设置一个数组，以便得到update enter exit，不过这种做法感觉有点乖乖的，姑且这样用着。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sar-chart/static/axis.js</span></span><br><span class="line"><span class="keyword">var</span> update = svg.selectAll(<span class="string">"g.xAxis"</span>)</span><br><span class="line">        <span class="comment">//data 后面的数组[1]只是任意写的，只要数组的长度为1就行，使用data，以便得到 enter、exit用来重绘。</span></span><br><span class="line">        .data([<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">var</span> enter = update.enter();</span><br><span class="line"><span class="keyword">var</span> exit = update.exit();</span><br></pre></td></tr></table></figure></p><h3 id="import-module-的经典使用"><a href="#import-module-的经典使用" class="headerlink" title="import module 的经典使用"></a>import module 的经典使用</h3><p>本demo也是浏览器端直接使用import的经典使用，具体有以下注意：</p><h4 id="html内使用import"><a href="#html内使用import" class="headerlink" title="html内使用import"></a>html内使用import</h4><p>html内使用import，需要 script type=”module”.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="javascript">   <span class="keyword">import</span> &#123;dataset, padding, width, height, colors, handleColor&#125; <span class="keyword">from</span> <span class="string">'./static/config.js'</span>; </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="js文件可直接使用import"><a href="#js文件可直接使用import" class="headerlink" title="js文件可直接使用import"></a>js文件可直接使用import</h4><p>如本demo中的config.js，直接使用了import：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//config.js</span><br><span class="line">import &#123;chartDatas&#125; from &apos;./data.js&apos;;</span><br></pre></td></tr></table></figure></p><h4 id="必须使用全路径，且包含文件后缀"><a href="#必须使用全路径，且包含文件后缀" class="headerlink" title="必须使用全路径，且包含文件后缀"></a>必须使用全路径，且包含文件后缀</h4><p>因为使用惯了webpack，通常不喜欢写文件后缀，岂知这些都是webpack替我们做了逻辑处理，而原生的js中，没有做任何处理，因此必须写明后缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//可以识别</span><br><span class="line">import &#123;chartDatas&#125; from &apos;./data.js&apos;;</span><br><span class="line"></span><br><span class="line">//不可以识别</span><br><span class="line">import &#123;chartDatas&#125; from &apos;./data&apos;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 图形化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> d3.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>医药</title>
      <link href="/2021/01/03/doctor/"/>
      <url>/2021/01/03/doctor/</url>
      
        <content type="html"><![CDATA[<h2 id="骨刺"><a href="#骨刺" class="headerlink" title="骨刺"></a>骨刺</h2><h3 id="物理外敷"><a href="#物理外敷" class="headerlink" title="物理外敷"></a>物理外敷</h3><ul><li>买个热敷吹风机(局部热敷一下)</li></ul><h3 id="药物外敷"><a href="#药物外敷" class="headerlink" title="药物外敷"></a>药物外敷</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>中药治疗以活血舒筋为主</p><h4 id="活络药物"><a href="#活络药物" class="headerlink" title="活络药物"></a>活络药物</h4><ul><li><p>介绍<br>使用一些治疗肌肉酸痛、关节疼痛的药膏也比较有疗效<br><a href="https://yp.120ask.com/detail/44258.html" target="_blank" rel="noopener">骨刺消痛液</a><br>骨刺平，骨刺贴膏<br>局部热敷一下<br>骨刺消痛液治疗<br>贴敷服比洛芬止膏药<br>奇正消痛贴</p></li><li><p>选择：<br>劲通双氯芬酸钠气雾剂<br>双氯芬酸钠贴</p></li></ul><h3 id="口服"><a href="#口服" class="headerlink" title="口服"></a>口服</h3><h4 id="镇痛-布诺分"><a href="#镇痛-布诺分" class="headerlink" title="镇痛 布诺分"></a>镇痛 布诺分</h4><p>非甾体抗炎药／非类固醇抗炎止痛剂 来达到缓解疼痛的目的 (布洛芬、双氯芬酸钠、阿司匹林、吲哚美辛、塞来昔布、芬必得、美洛昔康等，具有解热、镇痛、消炎作用)<br>塞来西布<br>如果疼痛严重口服双氯芬酸钠，<br>双氯芬酸钠缓释片<br>口服美洛昔康消炎止痛。</p><h4 id="治疗-骨刺平片"><a href="#治疗-骨刺平片" class="headerlink" title="治疗 骨刺平片"></a>治疗 骨刺平片</h4><p>骨刺平片，或者是壮骨关节丸治疗<br>抗骨质增生丸，骨刺片<br>骨刺平片等<br>口服仙灵骨葆胶囊<br>骨刺丸</p><h4 id="消炎-？"><a href="#消炎-？" class="headerlink" title="消炎 ？"></a>消炎 ？</h4><h4 id="选定"><a href="#选定" class="headerlink" title="选定"></a>选定</h4><p>骨刺平片和双氯芬酸钠缓释片</p><h3 id="营养"><a href="#营养" class="headerlink" title="营养"></a>营养</h3><ul><li>补钙</li><li>维生素b类的药物</li><li>口服氨基葡萄糖等软骨保护剂</li><li>氨基葡萄糖</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="布洛芬-与-双氯芬酸钠"><a href="#布洛芬-与-双氯芬酸钠" class="headerlink" title="布洛芬 与 双氯芬酸钠"></a>布洛芬 与 双氯芬酸钠</h4><p>布洛芬、双氯芬酸钠 同属于 非甾体抗炎药，二选一即可，不要一起吃，避免量叠加，过量使用。<br>双氯芬酸钠缓释剂型，具有缓慢、长时间释放活性成分的特点。该药具有服药次数少，血液药物浓度平稳，波动小，持续时间长等优点。适合类风湿性关节炎患者较长时间服用。<br><a href="http://tag.120ask.com/jibing/fashao/1325248.html" target="_blank" rel="noopener">参考</a></p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><figure class="image-box">                <img src="/image/doctor/test.png" alt="" title="" class="">                <p></p>            </figure>]]></content>
      
      
      <categories>
          
          <category> 医药 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医药 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>egg笔记</title>
      <link href="/2021/01/03/egg/"/>
      <url>/2021/01/03/egg/</url>
      
        <content type="html"><![CDATA[<h2 id="eggdemo"><a href="#eggdemo" class="headerlink" title="eggdemo"></a>eggdemo</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>创建项目，详细参考egg官网：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init egg --type=simple</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure></p><h3 id="编写mysql"><a href="#编写mysql" class="headerlink" title="编写mysql"></a>编写mysql</h3>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>canvas demo</title>
      <link href="/2021/01/03/canvas-demo/"/>
      <url>/2021/01/03/canvas-demo/</url>
      
        <content type="html"><![CDATA[<h2 id="写一个字"><a href="#写一个字" class="headerlink" title="写一个字"></a>写一个字</h2><h3 id="demo-地址"><a href="#demo-地址" class="headerlink" title="demo 地址"></a>demo 地址</h3><p><a href="">demo地址</a></p><h3 id="根据速度设置线条粗细"><a href="#根据速度设置线条粗细" class="headerlink" title="根据速度设置线条粗细"></a>根据速度设置线条粗细</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastLineWidth = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">var</span> maxLineWidth = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> minLineWidth = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> maxStrokeV = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> minStrokeV = <span class="number">0.1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calcLineWidth</span>(<span class="params"> time , distance </span>)</span>&#123;</span><br><span class="line">   <span class="comment">//v 速度 （注意，不是加速度）</span></span><br><span class="line">    <span class="keyword">var</span> v = distance / time;</span><br><span class="line">    <span class="keyword">var</span> resultLineWidth;</span><br><span class="line">    <span class="keyword">if</span>( v &lt;= minStrokeV )</span><br><span class="line">        resultLineWidth = maxLineWidth;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v &gt;= maxStrokeV )</span><br><span class="line">        resultLineWidth = minLineWidth;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        resultLineWidth = maxLineWidth -</span><br><span class="line">        (v-minStrokeV)/(maxStrokeV-minStrokeV)*(maxLineWidth-minLineWidth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lastLineWidth == -1 说明是刚开始画图，此时lastLineWidth不存在，直接取resultLineWidth</span></span><br><span class="line">    <span class="keyword">if</span>( lastLineWidth == <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> resultLineWidth;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有人说直接 return resultLineWidth，这样的缺点是，线条过渡不平滑；</span></span><br><span class="line"><span class="comment">//为了让线条平滑过渡，使用原来的宽度2/3，加上新的宽度1/3</span></span><br><span class="line">    <span class="keyword">return</span> resultLineWidth*<span class="number">1</span>/<span class="number">3</span> + lastLineWidth*<span class="number">2</span>/<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="刚开始画图宽度取值"><a href="#刚开始画图宽度取值" class="headerlink" title="刚开始画图宽度取值"></a>刚开始画图宽度取值</h4><p>参见上面代码的<code>lastLineWidth == -1</code>情况。</p><h4 id="2-3与1-3的平滑过渡技巧"><a href="#2-3与1-3的平滑过渡技巧" class="headerlink" title="2/3与1/3的平滑过渡技巧"></a>2/3与1/3的平滑过渡技巧</h4><p>参考上面代码，其实也不一定要设置成1/3 2/3，也可以是其他值，可以自己试验，只要壁画看起来平滑过渡即可。</p><h3 id="笔画的主体方法"><a href="#笔画的主体方法" class="headerlink" title="笔画的主体方法"></a>笔画的主体方法</h3><h4 id="从onmousedown开始"><a href="#从onmousedown开始" class="headerlink" title="从onmousedown开始"></a>从onmousedown开始</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginStroke</span>(<span class="params">point</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    isMouseDown = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//设置按下鼠标时的鼠标坐标 与 此时的时间戳</span></span><br><span class="line">    lastLoc = windowToCanvas(point.x, point.y)</span><br><span class="line">    lastTimestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只在isMouseDown-true时才画图"><a href="#只在isMouseDown-true时才画图" class="headerlink" title="只在isMouseDown true时才画图"></a>只在isMouseDown true时才画图</h4><p>onmousedown时设置isMouseDown为true，在鼠标松开(onmouseup)、鼠标离开dom时(onmouseout)设置isMouseDown为false，<br>onmousemove时不设置 值，此事件只负责画图。</p><h4 id="在onmousemove事件中画图"><a href="#在onmousemove事件中画图" class="headerlink" title="在onmousemove事件中画图"></a>在onmousemove事件中画图</h4><p>所以的绘制方法都在此事件中写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">canvas.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    <span class="keyword">if</span>( isMouseDown )&#123;</span><br><span class="line">        moveStroke(&#123;<span class="attr">x</span>: e.clientX , <span class="attr">y</span>: e.clientY&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveStroke</span>(<span class="params">point</span>)</span>&#123;</span><br><span class="line"><span class="comment">//获取当前坐标</span></span><br><span class="line">    <span class="keyword">var</span> curLoc = windowToCanvas( point.x , point.y );</span><br><span class="line">    <span class="keyword">var</span> curTimestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">var</span> s = calcDistance( curLoc , lastLoc )</span><br><span class="line">    <span class="keyword">var</span> t = curTimestamp - lastTimestamp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lineWidth = calcLineWidth( t , s );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw</span></span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.moveTo( lastLoc.x , lastLoc.y );</span><br><span class="line">    context.lineTo( curLoc.x , curLoc.y );</span><br><span class="line"></span><br><span class="line">    context.strokeStyle = strokeColor</span><br><span class="line">    context.lineWidth = lineWidth</span><br><span class="line">    <span class="comment">// lineCap lineJoin 让线条更加平滑</span></span><br><span class="line">    context.lineCap = <span class="string">"round"</span></span><br><span class="line">    context.lineJoin = <span class="string">"round"</span></span><br><span class="line">    context.stroke()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置上一次的状态</span></span><br><span class="line">    lastLoc = curLoc</span><br><span class="line">    lastTimestamp = curTimestamp</span><br><span class="line">    lastLineWidth = lineWidth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="onmousedown、onmousemove之间计算距离"><a href="#onmousedown、onmousemove之间计算距离" class="headerlink" title="onmousedown、onmousemove之间计算距离"></a>onmousedown、onmousemove之间计算距离</h4><p>如上面《画图方法》代码，笔画的移动就是通过计算二者之间的位置算出来的距离。</p><h4 id="onmousemove、onmousemove-之间计算距离"><a href="#onmousemove、onmousemove-之间计算距离" class="headerlink" title="onmousemove、onmousemove 之间计算距离"></a>onmousemove、onmousemove 之间计算距离</h4><p>如上面《画图方法》代码中的下面内容说明了这一点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重置上一次的状态</span></span><br><span class="line">    lastLoc = curLoc</span><br><span class="line">    lastTimestamp = curTimestamp</span><br><span class="line">    lastLineWidth = lineWidth</span><br></pre></td></tr></table></figure></p><h3 id="lineCap-lineJoin-让线条更加平滑"><a href="#lineCap-lineJoin-让线条更加平滑" class="headerlink" title="lineCap lineJoin 让线条更加平滑"></a>lineCap lineJoin 让线条更加平滑</h3><p>在没有加下面时，效果图如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.lineCap = <span class="string">"round"</span></span><br><span class="line">context.lineJoin = <span class="string">"round"</span></span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/canvas/canvas_demo/font.jpg" alt="" title="" class="">                <p></p>            </figure><p>为什么会这样？我们画的线其实是有很多段矩形拼接而成，如此啊，在拼接处就会有缝隙，此时可以使用线段的帽子lineCap，再加一个lineJoin，双保险，平滑过渡：<br><figure class="image-box">                <img src="/image/canvas/canvas_demo/line.jpg" alt="" title="" class="">                <p></p>            </figure></p><h2 id="图像处理-缩放图片"><a href="#图像处理-缩放图片" class="headerlink" title="图像处理-缩放图片"></a>图像处理-缩放图片</h2><h3 id="放大或缩小的显示"><a href="#放大或缩小的显示" class="headerlink" title="放大或缩小的显示"></a>放大或缩小的显示</h3><p>放大的时候，我们希望图像显示的中心点与原来图片中心点是重合的，为了保证中心点不动，就必须找准截取图片的坐标点，计算方法如下：<br><figure class="image-box">                <img src="/image/canvas/canvas_demo/scale.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="思路一-常规思路：误区"><a href="#思路一-常规思路：误区" class="headerlink" title="思路一(常规思路：误区)"></a>思路一(常规思路：误区)</h4><p>常规的思想是从原来图片选择一个点，然后截取一个区域，放到画布上，进行显示，如下，下面的计算方式无法达到自动缩放要求。<br>这种思路也可以达到缩放，但是需要大量的计算，非常麻烦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var imageWidth = 1152 * scale</span><br><span class="line">var imageHeight = 768 * scale</span><br><span class="line">var sx = imageWidth / 2 - canvas.width / 2</span><br><span class="line">var sy = imageHeight / 2 - canvas.height / 2</span><br><span class="line">context.drawImage( image , sx , sy , canvas.width , canvas.height </span><br><span class="line">    , 0 , 0 , canvas.width , canvas.height )</span><br></pre></td></tr></table></figure></p><h4 id="思路二-推荐"><a href="#思路二-推荐" class="headerlink" title="思路二(推荐)"></a>思路二(推荐)</h4><p>参考《经典的缩放处理方案》</p><h3 id="经典的缩放处理算法"><a href="#经典的缩放处理算法" class="headerlink" title="经典的缩放处理算法"></a>经典的缩放处理算法</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>缩放时必须保证 中心点不动。<br>放大的时候，x为负数，达到放大效果，缩小时，x为正值，达到缩小效果，完美兼容放大和缩小两种情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var imageWidth = 1152 * scale</span><br><span class="line">var imageHeight = 768 * scale</span><br><span class="line"></span><br><span class="line">x = canvas.width /2 - imageWidth / 2 </span><br><span class="line">y = canvas.height / 2 - imageHeight / 2</span><br><span class="line"></span><br><span class="line">context.clearRect( 0 , 0 , canvas.width , canvas.height )</span><br><span class="line">context.drawImage( image , x , y , imageWidth , imageHeight )</span><br></pre></td></tr></table></figure></p><h4 id="保证中心点不动"><a href="#保证中心点不动" class="headerlink" title="保证中心点不动"></a>保证中心点不动</h4><p>参考上面</p><h4 id="选取坐标点技巧"><a href="#选取坐标点技巧" class="headerlink" title="选取坐标点技巧"></a>选取坐标点技巧</h4><p>参考上面</p><h4 id="放大或缩放处理图片"><a href="#放大或缩放处理图片" class="headerlink" title="放大或缩放处理图片"></a>放大或缩放处理图片</h4><p>参考上面，为了缩放显示图片，在drawImage的最后两个参数时，都进行放大或缩放处理。</p><h3 id="onmousemove-代替-onchange"><a href="#onmousemove-代替-onchange" class="headerlink" title="onmousemove 代替 onchange"></a>onmousemove 代替 onchange</h3><p>为了达到鼠标移动时就触发绘图，需要使用onmousemove，因为onchange只有在停止滑动时才触发事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//  slider.onchange = function()&#123;</span><br><span class="line">//      scale = slider.value</span><br><span class="line">//      drawImage( image , scale )</span><br><span class="line">//  &#125;</span><br><span class="line"></span><br><span class="line">slider.onmousemove = function()&#123;</span><br><span class="line">    scale = slider.value</span><br><span class="line">    drawImageByScale( scale )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="离屏canvas技术"><a href="#离屏canvas技术" class="headerlink" title="离屏canvas技术"></a>离屏canvas技术</h2><h3 id="水印demo"><a href="#水印demo" class="headerlink" title="水印demo"></a>水印demo</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>定义一个水印的canvas，display 设置为不可见，让后将此canvas作为 drawImage 的第一个参数，绘制到画布当中。<br>因为水印的canvas本身不被显示，而只将其投影显示到画布当中，因此称之为离屏canvas。<br><figure class="image-box">                <img src="/image/canvas/canvas_demo/go_canvas.jpg" alt="" title="" class="">                <p></p>            </figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原来的canvas将会被cody到上一个图片画布中作为水印展示，不需要展示原来的canvas，因此隐藏原有的canvas --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"watermark-canvas"</span> <span class="attr">style</span>=<span class="string">"display:none;margin:0 auto;border:1px solid #aaa;"</span>&gt;</span></span><br><span class="line">        您的浏览器尚不支持canvas</span><br><span class="line">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setup watermark canvas</span></span><br><span class="line">   watermarkCanvas.width = <span class="number">600</span></span><br><span class="line">   watermarkCanvas.height = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">   watermarkContext.font = <span class="string">"bold 50px Arial"</span></span><br><span class="line">   watermarkContext.lineWidth = <span class="string">"1"</span></span><br><span class="line">   watermarkContext.fillStyle = <span class="string">"rgba( 255 , 255 , 255 , 0.5 )"</span></span><br><span class="line">   watermarkContext.textBaseline = <span class="string">"middle"</span>;</span><br><span class="line">   watermarkContext.fillText( <span class="string">"== liuyubobobo.com =="</span> , <span class="number">20</span> , <span class="number">50</span> )</span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">drawImage</span>(<span class="params"> image , scale </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">           imageWidth = <span class="number">1152</span> * scale</span><br><span class="line">           imageHeight = <span class="number">768</span> * scale</span><br><span class="line">           x = canvas.width /<span class="number">2</span> - imageWidth / <span class="number">2</span></span><br><span class="line">           y = canvas.height / <span class="number">2</span> - imageHeight / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">           context.clearRect( <span class="number">0</span> , <span class="number">0</span> , canvas.width , canvas.height )</span><br><span class="line">           context.drawImage( image , x , y , imageWidth , imageHeight )</span><br><span class="line">           context.drawImage( watermarkCanvas , canvas.width - watermarkCanvas.width ,</span><br><span class="line">                                                 canvas.height - watermarkCanvas.height )</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h4 id="将canvas作为drawImage参数"><a href="#将canvas作为drawImage参数" class="headerlink" title="将canvas作为drawImage参数"></a>将canvas作为drawImage参数</h4><p>利用了drawImage 可以将图片和canvas作为参数进行处理。</p><h3 id="放大镜"><a href="#放大镜" class="headerlink" title="放大镜"></a>放大镜</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>只使用一张高清图片。<br>离屏canvas绘制原尺寸图片，并且display none。<br>原屏canvas绘制缩放后图片，<br>计算离屏与缩放后图片的 倍率，以此作为缩放参数。<br>原屏绘制好后就不动它了，<br>每次放大镜时，都使用clip剪切区显示离屏投射。<br>可以参考上面代码。<br><figure class="image-box">                <img src="/image/canvas/canvas_demo/big.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="代码-和-demo地址"><a href="#代码-和-demo地址" class="headerlink" title="代码 和 demo地址"></a>代码 和 demo地址</h4><p><a href="http://127.0.0.1:3000/canvas-image/04-image-magnifier/index.html" target="_blank" rel="noopener">demo地址</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">style</span>=<span class="string">"display:block;margin:0 auto;border:1px solid #aaa;"</span>&gt;</span></span><br><span class="line">      您的浏览器尚不支持canvas</span><br><span class="line">  <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"offCanvas"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>)</span><br><span class="line">      <span class="keyword">var</span> context = canvas.getContext(<span class="string">"2d"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> offCanvas = <span class="built_in">document</span>.getElementById(<span class="string">"offCanvas"</span>)</span><br><span class="line">      <span class="keyword">var</span> offContext = offCanvas.getContext(<span class="string">"2d"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> image = <span class="keyword">new</span> Image()</span><br><span class="line">      <span class="keyword">var</span> isMouseDown = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">var</span> scale</span><br><span class="line"></span><br><span class="line">      <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">          canvas.width = <span class="number">1152</span></span><br><span class="line">          canvas.height = <span class="number">768</span></span><br><span class="line"></span><br><span class="line">          image.src = <span class="string">"img-lg.jpg"</span></span><br><span class="line">          image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">              offCanvas.width = image.width</span><br><span class="line">              offCanvas.height = image.height</span><br><span class="line">              scale = offCanvas.width / canvas.width</span><br><span class="line"></span><br><span class="line">              context.drawImage( image , <span class="number">0</span> , <span class="number">0</span> , canvas.width , canvas.height )</span><br><span class="line">              offContext.drawImage( image , <span class="number">0</span> , <span class="number">0</span> )</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">drawMagnifier</span>(<span class="params"> point </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//设置放大镜圆半径</span></span><br><span class="line">          <span class="keyword">var</span> mr = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> imageLG_cx = point.x * scale</span><br><span class="line">          <span class="keyword">var</span> imageLG_cy = point.y * scale</span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> sx = imageLG_cx - mr</span><br><span class="line">          <span class="keyword">var</span> sy = imageLG_cy - mr</span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> dx = point.x - mr</span><br><span class="line">          <span class="keyword">var</span> dy = point.y - mr</span><br><span class="line"></span><br><span class="line">          context.save()</span><br><span class="line"></span><br><span class="line">          context.lineWidth = <span class="number">10.0</span></span><br><span class="line">          context.strokeStyle = <span class="string">"#069"</span></span><br><span class="line">          <span class="comment">//使用剪切 clip 来做放大镜</span></span><br><span class="line">          context.beginPath()</span><br><span class="line">          context.arc( point.x , point.y , mr , <span class="number">0</span> , <span class="built_in">Math</span>.PI*<span class="number">2</span> , <span class="literal">true</span> )</span><br><span class="line">          context.stroke()</span><br><span class="line">          context.clip()</span><br><span class="line">          context.drawImage( offCanvas , sx , sy , <span class="number">2</span>*mr , <span class="number">2</span>*mr , dx , dy , <span class="number">2</span>*mr , <span class="number">2</span>*mr )</span><br><span class="line">          context.restore()</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="计算离屏信息"><a href="#计算离屏信息" class="headerlink" title="计算离屏信息"></a>计算离屏信息</h4><p>这里需要计算离屏canvas的这些信息（sx , sy , 2<em>mr , 2</em>mr），原理见下图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.drawImage( offCanvas , sx , sy , 2*mr , 2*mr , dx , dy , 2*mr , 2*mr )</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/canvas/canvas_demo/go_canvas1.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="计算原屏信息"><a href="#计算原屏信息" class="headerlink" title="计算原屏信息"></a>计算原屏信息</h4><p>这里需要计算离屏canvas的这些信息（dx , dy , 2<em>mr , 2</em>mr），原理见下图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.drawImage( offCanvas , sx , sy , 2*mr , 2*mr , dx , dy , 2*mr , 2*mr )</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/canvas/canvas_demo/go_canvas2.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="使用剪切-clip-来做放大镜"><a href="#使用剪切-clip-来做放大镜" class="headerlink" title="使用剪切 clip 来做放大镜"></a>使用剪切 clip 来做放大镜</h4><p>见上面代码。</p><h4 id="为什么clip不隐藏原屏图片"><a href="#为什么clip不隐藏原屏图片" class="headerlink" title="为什么clip不隐藏原屏图片"></a>为什么clip不隐藏原屏图片</h4><p>刚开始以为clip可能会隐藏原屏图片，结果没有，究其原因，估计是原屏图片是在clip之前就绘制好了，所以不受影响，后期绘制的离屏投射就受影响了</p>]]></content>
      
      
      <categories>
          
          <category> 图形化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css之移动开发</title>
      <link href="/2021/01/03/css_mobile/"/>
      <url>/2021/01/03/css_mobile/</url>
      
        <content type="html"><![CDATA[<h2 id="分辨率与像素"><a href="#分辨率与像素" class="headerlink" title="分辨率与像素"></a>分辨率与像素</h2><p>这是三星 GALAXY S5 手机<br><figure class="image-box">                <img src="/image/css_mobile/mobile1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="pixels单词含义"><a href="#pixels单词含义" class="headerlink" title="pixels单词含义"></a>pixels单词含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pixels //此单词含义为：像素</span><br></pre></td></tr></table></figure><p>所以px，指得就是像素。</p><h3 id="物理像素-与-分辨率"><a href="#物理像素-与-分辨率" class="headerlink" title="物理像素 与 分辨率"></a>物理像素 与 分辨率</h3><h4 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h4><p>上图中1920X1080像素，其实就是1920pxX1080px；如下图：<br><figure class="image-box">                <img src="/image/css_mobile/mobile2.jpg" alt="" title="" class="">                <p></p>            </figure><br>没错，这个像素就是(设备)物理像素(physical pixels)，它的单位也是px。(注意，这个px 非 css中使用的px，后面有讲解)。<br>上图表面，这个手机 横向的物理像素为 1080px; 竖向的物理像素为 1920px；<br>物理像素是一个虚拟的单位，与现实当中的厘米，毫米是两个东西，物理像素，能大能小，随不同设备变化。<br>(设备)物理像素，1px表示如下图的一个小方块：<br><figure class="image-box">                <img src="/image/css_mobile/img.jpg" alt="" title="" class="">                <p></p>            </figure><br>上图中Device pixels说的就是物理像素 (物理像素英文名肯定是physical pixels，这毫无疑问，但对是否是Device pixels还存一些考证，下面章节做了一些补充《别名 – Device pixels》)。</p><h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><p>屏幕分辨率为：1920*1080px；屏幕分辨率其实就是横向和竖向物理像素的组合表达的。因此：<br>(屏幕)分辨率是由横向和竖向的物理像素值表示的一种屏幕参考。</p><h4 id="分辨率不等同于物理像素"><a href="#分辨率不等同于物理像素" class="headerlink" title="分辨率不等同于物理像素"></a>分辨率不等同于物理像素</h4><p>由上分辨率的概念，屏幕分辨率不等同于物理像素。</p><h3 id="dpr-与-css像素"><a href="#dpr-与-css像素" class="headerlink" title="dpr 与 css像素"></a>dpr 与 css像素</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>dpr (devicePixelRatio)，设备像素比。<br>我们在实际开发中，会发现GALAXY S5的屏幕是 360pxX640px：<br><figure class="image-box">                <img src="/image/css_mobile/dpr.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>GALAXY S5 的横向物理像素是1080px,为什么在上图中就变成360px了呢？<br>原来，手机厂商在手机出厂时，为每个手机提供了一个参数，这个参数就是dpr，通过window.devicePixelRatio获取。<br>根据MDN的解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpr = 物理像素/css像素</span><br></pre></td></tr></table></figure></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio" target="_blank" rel="noopener">MDN的解释原文</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Window property devicePixelRatio returns the ratio of the resolution in physical pixels (物理像素) to the resolution in CSS pixels (css像素) for the current display device.</span><br></pre></td></tr></table></figure></p><p>因此，拿到一个手机的分辨率后，再通过window.devicePixelRatio 获取dpr后，就知道这个手机在前端开发时，它的css像素的 宽高。</p><h4 id="dpr是联系分辨率与css像素的桥梁"><a href="#dpr是联系分辨率与css像素的桥梁" class="headerlink" title="dpr是联系分辨率与css像素的桥梁"></a>dpr是联系分辨率与css像素的桥梁</h4><p>由上可知，如何让分辨率为前端技术所用，就是通过手机厂商定义的dpr，把分辨率变成我们前端可以理解的css像素。</p><h4 id="css像素"><a href="#css像素" class="headerlink" title="css像素"></a>css像素</h4><p>以上什么分辨率，物理像素，通通我们都不熟悉，都与前端开发无关，因为他们不是前端技术的度量范畴，此时说到css像素，是不是倍感亲切了，<br>它就是我们日常用的px，上面部分说的css像素就是这个东西。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这个100px就是css像素</span><br><span class="line">.wrap&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="dpr与css像素关系"><a href="#dpr与css像素关系" class="headerlink" title="dpr与css像素关系"></a>dpr与css像素关系</h4><p>在iPhone4之前，手机的dpr一般都是1，那时候手机的物理像素就是css像素。<br>随着iPhone4及以后高清屏的出现，dpr开始大于1，目前dpr场景值为 1、1.5、2、3。</p><h4 id="iPhone4是Retina屏"><a href="#iPhone4是Retina屏" class="headerlink" title="iPhone4是Retina屏"></a>iPhone4是Retina屏</h4><p>从iPhone4开始，及以后的iPhone都是Retina屏。<a href="https://baike.baidu.com/item/Retina/4616695?fr=aladdin" target="_blank" rel="noopener">参考</a></p><h3 id="放大2倍还是4倍？"><a href="#放大2倍还是4倍？" class="headerlink" title="放大2倍还是4倍？"></a>放大2倍还是4倍？</h3><p>下图 左侧是dpr=1，右侧dpr=2；<br>这里的放大几倍基于物理像素(英文可以是physical pixels 或 Device pixels )而言，<br>一个css像素为2X2px的元素。<br>dpr=1下，物理像素是 2X2px；<br>dpr=2下，物理像素是 4X4px；<br><figure class="image-box">                <img src="/image/css_mobile/img.jpg" alt="" title="" class="">                <p></p>            </figure><br>dpr=2下，原来的1小方块变成4个方块表示，好像是放大了四倍，其实不然，<br>1个方块可以写成：1X1px;<br>4个方块可以写成：2X2px；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//其实就是放大2倍</span><br><span class="line">(2*2px)/(1*1px) === 2</span><br><span class="line"></span><br><span class="line">//其实还是放大2倍</span><br><span class="line">(4*4px)/(2*2px) === 2</span><br></pre></td></tr></table></figure></p><p>所以dpr=2时相比dpr=1时，只是放大了两倍。<br>下面讲到的响应式设计时，用到媒体查询，需要UI根据dpr设计不同倍率的图片，需要多少倍的图片，由上面就知道了。</p><h3 id="多倍图响应式设计"><a href="#多倍图响应式设计" class="headerlink" title="多倍图响应式设计"></a>多倍图响应式设计</h3><p>当dpr大于1是，容易出现图片模糊的问题，以iPhone6为例:<br>iPnone6参数：<br><figure class="image-box">                <img src="/image/css_mobile/flex.jpg" alt="" title="" class="">                <p></p>            </figure><br>iPnone6 的 dpr为2，对应的屏幕的css像素尺寸为：375X667px；<br>由图片可知，i6的横向物理像素为750px，此时，如果在html页面定义展示一个img{width:375px}的图片，<br>i6在展示时因为会将此图片拉伸两倍，导致图片失真。解决的方法是，让UI设计一个750px的图片，避免失真，<br>这里解释失真可能有些牵强，姑且这样理解吧，也或者简单理解成，凡是dpr大于1的手机，<strong>只要提供与手机物理像素不一致的图片,显示时都会失真；</strong><br>不用太穷究为什么要失真，知道这样会失真就行。如果对失真有兴趣，去网上搜索，很多资源。</p><p>高清时，一般也就图片这种失真的情况，其他还好，为了解决这个图片失真，一般采用媒体查询方式。</p><h4 id="如何才图片不失真"><a href="#如何才图片不失真" class="headerlink" title="如何才图片不失真"></a>如何才图片不失真</h4><p>由上面推测可知，<strong>只有UI给的图片与手机的物理像素相等时才不失真</strong>，<br>比如，我在html上定义了一个100px css像素的图片；<br>手机的dpr为2；<br>此时这个100px css像素，对应的是 100*2=200px 的物理像素尺寸。<br>此时只有UI提供200px的图片放在上面的HTMl上才不失真。</p><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>解决方法如下，详细的可网上搜索：<br>主要思路，就是让UI提供几种不同尺寸的图片，通过媒体查询方式灵活使用。<a href="https://www.cnblogs.com/sese/p/5977486.html" target="_blank" rel="noopener">参考</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.css&#123;/* 普通显示屏(设备像素比例小于等于1.3)使用1倍的图 */ </span><br><span class="line">    background-image: url(img_1x.png);</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (-webkit-min-device-pixel-ratio:1.5),</span><br><span class="line">       (min-resolution: 1.5dppx)&#123;</span><br><span class="line">            .css&#123;/* 高清显示屏(设备像素比例大于等于1.5)使用2倍图  */</span><br><span class="line">                background-image: url(img_2x.png);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>媒体查询设备像素比主要查询 min-resolution,而webkit-min-device-pixel-ratio是一个意思，为了兼容safari。见《精通css》P233<br>当然，解决失真的方式还有js或svg矢量图的方式。</p><h3 id="ppi"><a href="#ppi" class="headerlink" title="ppi"></a>ppi</h3><p>ppi:屏幕像素密度,这个概念其实与前端开发无关，可以不用过多了解。<br>只是最上面的图片中提到了GALAXY S5 的像素密度，具体公式如下，<a href="https://www.jianshu.com/p/c3387bcc4f6e" target="_blank" rel="noopener">详细了解点击这里</a>：<br><figure class="image-box">                <img src="/image/css_mobile/ppi.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>下面列举了如 设备独立像素、什么其他像素…这些统统不要管，与前端开发无关，与前端开发有关的东西，上面已经单独列出讲解。<br>在这里写一些别名，只是为了在阅读别人的文文章时，他们写出这些名词你知道是什么，避免看不懂其他人的文章。</p><h4 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h4><p>有很多地方将 dpr = 物理像素 /设备独立像素;<br>显然这里 将设备独立像素看成是css像素了。我这里不说对不对，这里只是让大家知道<strong>设备独立像素 把它简单认为是 css像素就好，不必深究。</strong>关于dpr的定义还是以MDN网址定义为准，请看上文《dpr 与 css像素》<br><a href="https://www.jianshu.com/p/3d28f4959c5a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">参见</a></p><p>我们再看 它的定义：<br><a href="https://www.cnblogs.com/jiangzilong/p/6700023.html" target="_blank" rel="noopener">设备独立像素（Device Independent Pixel）：与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了CSS像素</a></p><h4 id="设备无关的像素"><a href="#设备无关的像素" class="headerlink" title="设备无关的像素"></a>设备无关的像素</h4><p>参考《设备独立像素》。<br>设备无关的像素 其实就是 设备独立像素 的说法，下面公式是相等的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS像素 =设备独立像素 = 设备无关的像素</span><br></pre></td></tr></table></figure></p><h4 id="逻辑像素"><a href="#逻辑像素" class="headerlink" title="逻辑像素"></a>逻辑像素</h4><p><a href="https://www.jianshu.com/p/3d28f4959c5a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">这篇文章提到:</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS像素 =设备独立像素 = 逻辑像素</span><br></pre></td></tr></table></figure></p><h4 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h4><p>设备像素也是物理像素，物理像素全称，设备物理像素，下面公式成立：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理像素===设备像素===设备物理像素===physical pixels====Device pixels</span><br></pre></td></tr></table></figure></p><h4 id="虚拟像素"><a href="#虚拟像素" class="headerlink" title="虚拟像素"></a>虚拟像素</h4><p>其实 物理像素、css像素、这些都是虚拟像素。(个人认为，未佐证)</p><h4 id="Device-pixels"><a href="#Device-pixels" class="headerlink" title="Device pixels"></a>Device pixels</h4><p>Device pixels应该就是物理像素的英文名称，<a href="https://www.w3schools.com/cssref/css_units.asp" target="_blank" rel="noopener">根据外文W3c – CSS Units 中关于 px的解释</a>，原文如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* Pixels (px) 【css像素】 are relative to the viewing device. For low-dpi devices, 1px is one device pixel (dot) of the display. For printers and high resolution screens 1px implies multiple device pixels【多倍的设备像素】.</span><br></pre></td></tr></table></figure></p><p>结合上面的分析，我们知道，屏幕中一般只有一种设备像素，那就是物理像素，因此物理像素的另外英文名称为 device pixels.</p><h3 id="物理像素的px与css像素px区别"><a href="#物理像素的px与css像素px区别" class="headerlink" title="物理像素的px与css像素px区别"></a>物理像素的px与css像素px区别</h3><p>虽然通过上面的分析，我们知道物理像素与css像素，有本质上的不同。<br>不过通过分析多倍dpr图片失真问题，解决失真，就要放与物理像素相同的px图片时才不失真。我们知否可大胆推测物理像素的px可能与css像素的px是一回事。<br>以上仅代表个人揣测。<br>然而物理像素确实又与css像素有本质区别。</p><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>视口部分，参考《精通css》这边书，若有问题，查询这边书的第八章。</p><h3 id="理想视口"><a href="#理想视口" class="headerlink" title="理想视口"></a>理想视口</h3><p>理想视口就是每个手机的屏幕css像素尺寸，例如GALAXY S5屏幕360pxX640px，它的理想视口就是360pxX640px 的css像素尺寸。 见《dpr 与 css像素》。</p><h3 id="默认视口"><a href="#默认视口" class="headerlink" title="默认视口"></a>默认视口</h3><p>手机设备都有一个默认视口，且不同类型的手机设备，其默认视口都是一样的尺寸，不同类型手机设备的默认视口，宽约为1000px css像素。<br>每想到吧，默认视口居然还有一个统一的宽度：约为1000px css像素，而且不同类型的手机宽度一样。</p><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><h4 id="理想视口显示"><a href="#理想视口显示" class="headerlink" title="理想视口显示"></a>理想视口显示</h4><p>使用 理想视口显示，设置meta如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="默认视口显示"><a href="#默认视口显示" class="headerlink" title="默认视口显示"></a>默认视口显示</h4><p>如果不设置meta，那么手机将采用默认视口显示，将html写的页面按照屏幕宽大约1000px排列布局好，然后把它缩小显示到手机中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;vs_test&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .wrap &#123;</span><br><span class="line">            background: rebeccapurple;</span><br><span class="line">            word-break: break-word;</span><br><span class="line">            font-size: 16px;</span><br><span class="line">        &#125;</span><br><span class="line">        .cell&#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            height: 50px;</span><br><span class="line">            width: 100px;</span><br><span class="line">            font-size: 40px;</span><br><span class="line">        &#125;</span><br><span class="line">        .cell:nth-child(even)&#123;</span><br><span class="line">            background: #FF9800</span><br><span class="line">        &#125;</span><br><span class="line">        .cell:nth-child(odd)&#123;</span><br><span class="line">            background: #00BCD4</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;7&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;8&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;9&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;0&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;cell&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p> GALAXY S5手机端显示如下：<br><figure class="image-box">                <img src="/image/css_mobile/view-port.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="默认视口-与-qq截图工具量元素尺寸"><a href="#默认视口-与-qq截图工具量元素尺寸" class="headerlink" title="默认视口 与 qq截图工具量元素尺寸"></a>默认视口 与 qq截图工具量元素尺寸</h4><p>如上图所示， 采用默认视口显示，会将原来在大约1000px显示好的页面，缩小到GALAXY S5手机宽360px的屏幕显示，<br>这样调试的时候，我们就无法使用qq或微信的截图工具里面显示的尺寸，来量元素的尺寸。<br>以此举一反三，只有移动端采用理想视口的情况时，才可以使用qq截图工具量元素尺寸。<br>不过，pc浏览器屏幕不存在此情况，pc浏览器任何情况下可以采用qq截图工具量尺寸。</p><h3 id="不要禁用缩放"><a href="#不要禁用缩放" class="headerlink" title="不要禁用缩放"></a>不要禁用缩放</h3><p>很多人喜欢用下面的方式来定义meta，下面配置了user-scalable=no，禁用了缩放，这样是不推荐的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//不推荐这种写法，因为禁用了缩放</span><br><span class="line">&lt;meta </span><br><span class="line">    name=&quot;viewport&quot; </span><br><span class="line">    content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span><br><span class="line"> /&gt;</span><br></pre></td></tr></table></figure></p><p>推荐写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//推荐写法：</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>上面写initial-scale=1完全是为了兼容，如果不考虑兼容，直接这样写就行，因为initial-scale=1表达的意思和width=device-width一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//推荐写法也可以这样写</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://www.ituring.com.cn/book/1910" target="_blank" rel="noopener">精通css 高级web标准解决方案</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio" target="_blank" rel="noopener">MDN –devicePixelRatio</a><br><a href="https://www.w3schools.com/cssref/css_units.asp" target="_blank" rel="noopener">外文W3c –CSS Units</a><br><a href="https://www.cnblogs.com/sese/p/5977486.html" target="_blank" rel="noopener">高清屏及适配不同设备的方案总结</a><br><a href="https://www.jianshu.com/p/c3387bcc4f6e" target="_blank" rel="noopener">（全解析）屏幕尺寸，分辨率，像素，PPI之间到底什么关系？</a><br><a href="https://www.jianshu.com/p/3d28f4959c5a?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">一篇文章搞懂CSS像素、物理像素、逻辑像素、设备像素比、PPI、Viewport</a><br><a href="https://www.cnblogs.com/jiangzilong/p/6700023.html" target="_blank" rel="noopener">CSS像素、设备独立像素、设备像素之间关系</a></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 屏幕分辨率 </tag>
            
            <tag> 物理像素 </tag>
            
            <tag> css像素 </tag>
            
            <tag> ppi </tag>
            
            <tag> dpr </tag>
            
            <tag> 多倍图的响应式设计 </tag>
            
            <tag> 视口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>d3的三种模式 及 append、data、selectAll</title>
      <link href="/2021/01/03/d3_basics/"/>
      <url>/2021/01/03/d3_basics/</url>
      
        <content type="html"><![CDATA[<p>这里讲解d3的 enter update exit三种模式，以及 append、data、selectAll。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>下面代码都基于以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var svg = d3.select(&quot;body&quot;)</span><br><span class="line">                .append(&apos;svg&apos;)</span><br><span class="line">                .attr(&apos;width&apos;, 800)</span><br><span class="line">                .attr(&apos;height&apos;, 800);</span><br></pre></td></tr></table></figure></p><p>以上是d3常用写法，下面示例皆以此为基础展开：</p><h2 id="append"><a href="#append" class="headerlink" title="append"></a>append</h2><h3 id="单个使用"><a href="#单个使用" class="headerlink" title="单个使用"></a>单个使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var new_circle = svg.append(&apos;circle&apos;)</span><br><span class="line">            .attr(&apos;cx&apos;, 250)</span><br><span class="line">            .attr(&apos;cy&apos;, 50)</span><br><span class="line">            .attr(&apos;r&apos;, 25)</span><br><span class="line">            .attr(&apos;fill&apos;, &apos;blue&apos;)</span><br></pre></td></tr></table></figure><p>效果：<br><figure class="image-box">                <img src="/image/d3/circle1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="多个使用"><a href="#多个使用" class="headerlink" title="多个使用"></a>多个使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">svg.append(&apos;circle&apos;)</span><br><span class="line">               .attr(&apos;cx&apos;, 250)</span><br><span class="line">               .attr(&apos;cy&apos;, 50)</span><br><span class="line">               .attr(&apos;r&apos;, 25)</span><br><span class="line">               .attr(&apos;fill&apos;, &apos;blue&apos;)</span><br><span class="line">   svg.append(&apos;circle&apos;)</span><br><span class="line">               .attr(&apos;cx&apos;, 250)</span><br><span class="line">               .attr(&apos;cy&apos;, 150)</span><br><span class="line">               .attr(&apos;r&apos;, 25)</span><br><span class="line">               .attr(&apos;fill&apos;, &apos;green&apos;)</span><br><span class="line">   svg.append(&apos;circle&apos;)</span><br><span class="line">               .attr(&apos;cx&apos;, 250)</span><br><span class="line">               .attr(&apos;cy&apos;, 250)</span><br><span class="line">               .attr(&apos;r&apos;, 25)</span><br><span class="line">               .attr(&apos;fill&apos;, &apos;orange&apos;)</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/d3/circle4.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>由上可知append其实就是用来添加实际效果的。</p><h2 id="selectAll"><a href="#selectAll" class="headerlink" title="selectAll"></a>selectAll</h2><h3 id="在上面《append》的代码上增加："><a href="#在上面《append》的代码上增加：" class="headerlink" title="在上面《append》的代码上增加："></a>在上面《append》的代码上增加：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var new_circle = svg.selectAll(&apos;circle&apos;)</span><br><span class="line">        .attr(&apos;cx&apos;, 250)</span><br><span class="line">        .attr(&apos;cy&apos;, 100)</span><br><span class="line">        .attr(&apos;fill&apos;, &apos;green&apos;)</span><br><span class="line">        .attr(&apos;r&apos;, 25)</span><br></pre></td></tr></table></figure><p>效果：<br><figure class="image-box">                <img src="/image/d3/circle2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><h4 id="在基本代码上增加如下代码"><a href="#在基本代码上增加如下代码" class="headerlink" title="在基本代码上增加如下代码"></a>在基本代码上增加如下代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">svg.append(&apos;circle&apos;)</span><br><span class="line">               .attr(&apos;cx&apos;, 250)</span><br><span class="line">               .attr(&apos;cy&apos;, 50)</span><br><span class="line">               .attr(&apos;r&apos;, 25)</span><br><span class="line">               .attr(&apos;fill&apos;, &apos;blue&apos;)</span><br><span class="line">   svg.append(&apos;circle&apos;)</span><br><span class="line">               .attr(&apos;cx&apos;, 250)</span><br><span class="line">               .attr(&apos;cy&apos;, 150)</span><br><span class="line">               .attr(&apos;r&apos;, 25)</span><br><span class="line">               .attr(&apos;fill&apos;, &apos;green&apos;)</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/d3/circle3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="增加selectAll后："><a href="#增加selectAll后：" class="headerlink" title="增加selectAll后："></a>增加selectAll后：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svg.selectAll(&apos;circle&apos;)</span><br><span class="line">             .attr(&apos;cx&apos;, 250)</span><br><span class="line">             .attr(&apos;cy&apos;, 350)</span><br><span class="line">             .attr(&apos;r&apos;, 25)</span><br><span class="line">             .attr(&apos;fill&apos;, &apos;yellowgreen&apos;)</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/d3/circle5.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>上面的例子都是单独使用selectAll，没有使用data()，此时selectAll选中所有的匹配，进行update，此时selectAll就是一个选择器，对selectAll进行链式操作，可将所有被命中的改写（可称之为update）</p><h2 id="data"><a href="#data" class="headerlink" title="data()"></a>data()</h2><h3 id="在基本代码上，增加如下代码："><a href="#在基本代码上，增加如下代码：" class="headerlink" title="在基本代码上，增加如下代码："></a>在基本代码上，增加如下代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">svg.append(&apos;circle&apos;)</span><br><span class="line">                .attr(&apos;cx&apos;, 250)</span><br><span class="line">                .attr(&apos;cy&apos;, 50)</span><br><span class="line">                .attr(&apos;r&apos;, 25)</span><br><span class="line">                .attr(&apos;fill&apos;, &apos;blue&apos;)</span><br><span class="line">    svg.append(&apos;circle&apos;)</span><br><span class="line">                .attr(&apos;cx&apos;, 250)</span><br><span class="line">                .attr(&apos;cy&apos;, 150)</span><br><span class="line">                .attr(&apos;r&apos;, 25)</span><br><span class="line">                .attr(&apos;fill&apos;, &apos;green&apos;)</span><br><span class="line"></span><br><span class="line">var data = [10, 20];</span><br><span class="line">svg.selectAll(&apos;circle&apos;)</span><br><span class="line">                .data(data)</span><br><span class="line">                .attr(&apos;cx&apos;, 250)</span><br><span class="line">                .attr(&apos;cy&apos;, 350)</span><br><span class="line">                .attr(&apos;r&apos;, 25)</span><br><span class="line">                .attr(&apos;fill&apos;, &apos;yellowgreen&apos;)</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/d3/circle5.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="修改data数组-length-1"><a href="#修改data数组-length-1" class="headerlink" title="修改data数组 length=1"></a>修改data数组 length=1</h3><p>修改以上代码中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var data = [10];</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><figure class="image-box">                <img src="/image/d3/circle8.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="修改data数组-length-0"><a href="#修改data数组-length-0" class="headerlink" title="修改data数组 length=0"></a>修改data数组 length=0</h3><p>修改以上代码中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var data = [];</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><figure class="image-box">                <img src="/image/d3/circle3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="selectAll-与-data-的关系"><a href="#selectAll-与-data-的关系" class="headerlink" title="selectAll 与 data 的关系"></a>selectAll 与 data 的关系</h3><p>由上可知，selectAll 是一次性命中了所有，如果要对这所有对命中进行过滤等操作，就使用data();<br>且经过data()操作后，就拥有了enter或exit操作方法，当然你可以不使用这些方法。<br>因此说白了，enter和exit无非是data()\selectAll()选择数据能力的延伸。</p><h3 id="selectAll-data-enter-exit-的联系"><a href="#selectAll-data-enter-exit-的联系" class="headerlink" title="selectAll data enter exit 的联系"></a>selectAll data enter exit 的联系</h3><p>参考《selectAll 与 data 的关系》，selectAll data enter exit都是数据的采集命中匹配。</p><h2 id="enter"><a href="#enter" class="headerlink" title="enter"></a>enter</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>enter 匹配 数据大于已存在时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> var svg = d3.select(&quot;body&quot;)</span><br><span class="line">                 .append(&apos;svg&apos;)</span><br><span class="line">                 .attr(&apos;width&apos;, 800)</span><br><span class="line">                 .attr(&apos;height&apos;, 800);</span><br><span class="line">      </span><br><span class="line">var data = [10];</span><br><span class="line">svg.selectAll(&apos;circle&apos;)</span><br><span class="line">                .data(data)</span><br><span class="line">                .enter()</span><br><span class="line">                .append(&apos;circle&apos;)</span><br><span class="line">                .attr(&apos;cx&apos;, 250)</span><br><span class="line">                .attr(&apos;cy&apos;, 350)</span><br><span class="line">                .attr(&apos;r&apos;, 25)</span><br><span class="line">                .attr(&apos;fill&apos;, &apos;yellowgreen&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="enter-要与append搭配使用"><a href="#enter-要与append搭配使用" class="headerlink" title="enter()要与append搭配使用"></a>enter()要与append搭配使用</h3><p>见上面《基本用法》</p><h3 id="enter-不会-改变已存在的"><a href="#enter-不会-改变已存在的" class="headerlink" title="enter 不会 改变已存在的"></a>enter 不会 改变已存在的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var new_circle = svg.append(&apos;circle&apos;)</span><br><span class="line">            .attr(&apos;cx&apos;, 250)</span><br><span class="line">            .attr(&apos;cy&apos;, 50)</span><br><span class="line">            .attr(&apos;r&apos;, 25)</span><br><span class="line">            .attr(&apos;fill&apos;, &apos;blue&apos;)</span><br><span class="line">var data = [10, 20];</span><br><span class="line">var new_circle = svg.selectAll(&apos;circle&apos;)</span><br><span class="line">        .data(data)</span><br><span class="line">        .enter()</span><br><span class="line">        .append(&apos;circle&apos;)</span><br><span class="line">        .attr(&apos;cx&apos;, 250)</span><br><span class="line">        .attr(&apos;cy&apos;, 100)</span><br><span class="line">        .attr(&apos;fill&apos;, &apos;green&apos;)</span><br><span class="line">        .attr(&apos;r&apos;, 25)</span><br></pre></td></tr></table></figure><p>效果：<br><figure class="image-box">                <img src="/image/d3/circle3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="比较好的exitdemo"><a href="#比较好的exitdemo" class="headerlink" title="比较好的exitdemo"></a>比较好的exitdemo</h3><ul><li><a href="https://github.com/YeWills/nodemon-server-template/blob/d3-demo/pages/wangjingzhi/fifth.html" target="_blank" rel="noopener">demo 1</a>，此demo是一个简单散点图，其中的去掉图中散点功能非常棒。</li></ul><h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><h3 id="不使用exit"><a href="#不使用exit" class="headerlink" title="不使用exit"></a>不使用exit</h3><p>在上面代码上增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">svg.append(&apos;circle&apos;)</span><br><span class="line">            .attr(&apos;cx&apos;, 250)</span><br><span class="line">            .attr(&apos;cy&apos;, 50)</span><br><span class="line">            .attr(&apos;r&apos;, 25)</span><br><span class="line">            .attr(&apos;fill&apos;, &apos;blue&apos;)</span><br><span class="line">svg.append(&apos;circle&apos;)</span><br><span class="line">            .attr(&apos;cx&apos;, 250)</span><br><span class="line">            .attr(&apos;cy&apos;, 150)</span><br><span class="line">            .attr(&apos;r&apos;, 25)</span><br><span class="line">            .attr(&apos;fill&apos;, &apos;green&apos;)</span><br><span class="line">svg.append(&apos;circle&apos;)</span><br><span class="line">            .attr(&apos;cx&apos;, 250)</span><br><span class="line">            .attr(&apos;cy&apos;, 250)</span><br><span class="line">            .attr(&apos;r&apos;, 25)</span><br><span class="line">            .attr(&apos;fill&apos;, &apos;orange&apos;)</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><figure class="image-box">                <img src="/image/d3/circle4.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="使用exit"><a href="#使用exit" class="headerlink" title="使用exit"></a>使用exit</h3><p>在上面代码上加入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var data = [10];</span><br><span class="line"> svg.selectAll(&apos;circle&apos;)</span><br><span class="line">             .data(data)</span><br><span class="line">             .exit()</span><br><span class="line">             //exit不与append一起使用,此处不能使用append</span><br><span class="line">             //.append(&apos;circle&apos;)</span><br><span class="line">             .attr(&apos;cx&apos;, 250)</span><br><span class="line">             .attr(&apos;cy&apos;, 350)</span><br><span class="line">             .attr(&apos;r&apos;, 25)</span><br><span class="line">             .attr(&apos;fill&apos;, &apos;yellowgreen&apos;)</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/d3/circle7.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="exit不与append一起使用"><a href="#exit不与append一起使用" class="headerlink" title="exit不与append一起使用"></a>exit不与append一起使用</h3><p>使用《使用exit》代码中，注释的部分解注，效果将是：<br><figure class="image-box">                <img src="/image/d3/circle4.jpg" alt="" title="" class="">                <p></p>            </figure><br>此时exit没有任何作用。</p><h3 id="exit将会改变已存在的"><a href="#exit将会改变已存在的" class="headerlink" title="exit将会改变已存在的"></a>exit将会改变已存在的</h3><p>参考《使用exit》</p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> var svg = d3.select(&quot;body&quot;)</span><br><span class="line">                 .append(&apos;svg&apos;)</span><br><span class="line">                 .attr(&apos;width&apos;, 800)</span><br><span class="line">                 .attr(&apos;height&apos;, 800);</span><br><span class="line">    svg.append(&apos;circle&apos;)</span><br><span class="line">               .attr(&apos;cx&apos;, 250)</span><br><span class="line">               .attr(&apos;cy&apos;, 50)</span><br><span class="line">               .attr(&apos;r&apos;, 25)</span><br><span class="line">               .attr(&apos;fill&apos;, &apos;green&apos;)</span><br><span class="line">   svg.append(&apos;circle&apos;)</span><br><span class="line">               .attr(&apos;cx&apos;, 250)</span><br><span class="line">               .attr(&apos;cy&apos;, 150)</span><br><span class="line">               .attr(&apos;r&apos;, 25)</span><br><span class="line">               .attr(&apos;fill&apos;, &apos;orange&apos;)</span><br><span class="line">   svg.append(&apos;circle&apos;)</span><br><span class="line">               .attr(&apos;cx&apos;, 250)</span><br><span class="line">               .attr(&apos;cy&apos;, 250)</span><br><span class="line">               .attr(&apos;r&apos;, 25)</span><br><span class="line">               .attr(&apos;fill&apos;, &apos;black&apos;)</span><br><span class="line">      </span><br><span class="line">var data = [10];</span><br><span class="line">svg.selectAll(&apos;circle&apos;)</span><br><span class="line">                .data(data)</span><br><span class="line">                .attr(&apos;fill&apos;, &apos;blue&apos;)</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/d3/circle9.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="示例二-1"><a href="#示例二-1" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;default&lt;/p&gt;</span><br><span class="line">&lt;p&gt;default&lt;/p&gt;</span><br><span class="line">&lt;p&gt;default&lt;/p&gt;</span><br><span class="line">&lt;p&gt;default&lt;/p&gt;</span><br><span class="line">&lt;p&gt;default&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var data = [10, 20, 30];</span><br><span class="line">d3.selectAll(&apos;p&apos;)</span><br><span class="line">  .data(data)</span><br><span class="line">  .text(t=&gt;t)</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/d3/update.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="update-p-data-arr"><a href="#update-p-data-arr" class="headerlink" title="update = p.data(arr)"></a>update = p.data(arr)</h3><p>比如示例二可写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var data = [10, 20, 30];</span><br><span class="line">var update = d3.selectAll(&apos;p&apos;);</span><br><span class="line"></span><br><span class="line">update.data(data)</span><br><span class="line">  .text(t=&gt;t)</span><br></pre></td></tr></table></figure></p><p>因此可认为  update 等于 data()方法的修改。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>通过上面例子，update实际上是元素与数据绑定时，元素与数据 的交集部分的更新。<br>这种情况少。</p><h2 id="大话各者之间关系"><a href="#大话各者之间关系" class="headerlink" title="大话各者之间关系"></a>大话各者之间关系</h2><h3 id="选择集-select-selectAll"><a href="#选择集-select-selectAll" class="headerlink" title="选择集 - select selectAll"></a>选择集 - select selectAll</h3><h3 id="数据绑定-selection-data"><a href="#数据绑定-selection-data" class="headerlink" title="数据绑定 - selection.data()"></a>数据绑定 - selection.data()</h3><h3 id="数据绑定的选择集-enter-exit"><a href="#数据绑定的选择集-enter-exit" class="headerlink" title="数据绑定的选择集 - enter exit"></a>数据绑定的选择集 - enter exit</h3><h3 id="DOM操作-attr-append-insert"><a href="#DOM操作-attr-append-insert" class="headerlink" title="DOM操作 - attr append insert"></a>DOM操作 - attr append insert</h3><h3 id="远程加载数据-d3-josn"><a href="#远程加载数据-d3-josn" class="headerlink" title="远程加载数据 d3.josn()"></a>远程加载数据 d3.josn()</h3><h2 id="应用demo"><a href="#应用demo" class="headerlink" title="应用demo"></a>应用demo</h2><h3 id="柱状图demo"><a href="#柱状图demo" class="headerlink" title="柱状图demo"></a><a href="https://github.com/YeWills/nodemon-server-template/blob/d3-demo/pages/d3-jt-book/chapter4/4.8/4-8-2-update-data.html" target="_blank" rel="noopener">柱状图demo</a></h3><p>此demo非常简短，对enter update exit理解非常有帮助。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://v.youku.com/v_show/id_XNDE3MTEwNDE4OA==.html?refer=seo_operation.liuxiao.liux_00003303_3000_Qzu6ve_19042900" target="_blank" rel="noopener">彻底弄懂 D3js enter update exit 是咋回事</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> d3.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>dva与umi笔记</title>
      <link href="/2021/01/03/dva_umi/"/>
      <url>/2021/01/03/dva_umi/</url>
      
        <content type="html"><![CDATA[<p>暂时没有想好如何整理笔记，暂且以每个项目为章节记笔记。</p><h2 id="user-dashboard项目细节"><a href="#user-dashboard项目细节" class="headerlink" title="user-dashboard项目细节"></a>user-dashboard项目细节</h2><h3 id="umi-目录"><a href="#umi-目录" class="headerlink" title=".umi/ 目录"></a>.umi/ 目录</h3><p> 此目录为验证目录，npm start生成，没有作用，也不推荐在此修改代码，为方便验证而生。</p><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3> <figure class="image-box">                <img src="/image/dva_umi/user-dashboard.png" alt="" title="" class="">                <p></p>            </figure><h3 id="入口页面"><a href="#入口页面" class="headerlink" title="入口页面"></a>入口页面</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src\pages\.umi\umi.js  ---ReactDOM.render</span><br></pre></td></tr></table></figure><p>此页面集成了一个项目的两大要素： dva (状态) 和 路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src\pages\.umi\DvaContainer.js  ---dva (状态)</span><br><span class="line">src\pages\.umi\router.js ---路由</span><br></pre></td></tr></table></figure></p><h3 id="dva-布局"><a href="#dva-布局" class="headerlink" title="dva 布局"></a>dva 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src\pages\.umi\DvaContainer.js</span><br><span class="line">src\pages\users\models\users.js (reducers effects)</span><br><span class="line">src\pages\users\components\Users\Users.js (connect mapStateToProps dispatch) 【dispatch 由connect集成】</span><br></pre></td></tr></table></figure><h3 id="User-js页面分析"><a href="#User-js页面分析" class="headerlink" title="User.js页面分析"></a>User.js页面分析</h3><h4 id="subscriptions-setup"><a href="#subscriptions-setup" class="headerlink" title="subscriptions setup"></a>subscriptions setup</h4><p>进入User页面后，首先触发 src\pages\users\models\users.js 下的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">subscriptions: &#123;</span><br><span class="line">    setup(&#123; dispatch, history &#125;) &#123;</span><br><span class="line">      return history.listen((&#123; pathname, query &#125;) =&gt; &#123;</span><br><span class="line">        if (pathname === &apos;/users&apos;) &#123;</span><br><span class="line">          dispatch(&#123; type: &apos;fetch&apos;, payload: query &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>在setup 中触发 改js下的 effects fetch.<br><a href="https://dvajs.com/knowledgemap/#%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96" target="_blank" rel="noopener">原因参考dva文档—异步数据初始化</a></p><h4 id="effects-fetch"><a href="#effects-fetch" class="headerlink" title="effects fetch"></a>effects fetch</h4><p>在fetch中首先 usersService.fetch 向后台请求数据；<br>然后将返回的数据，put触发 reducers save;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*fetch(&#123; payload: &#123; page = 1 &#125; &#125;, &#123; call, put &#125;) &#123;</span><br><span class="line">     const &#123; data, headers &#125; = yield call(usersService.fetch, &#123; page &#125;);</span><br><span class="line">     yield put(&#123;</span><br><span class="line">       type: &apos;save&apos;,</span><br><span class="line">       payload: &#123;</span><br><span class="line">         data,</span><br><span class="line">         total: parseInt(headers[&apos;x-total-count&apos;], 10),</span><br><span class="line">         page: parseInt(page, 10),</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="reducers-save"><a href="#reducers-save" class="headerlink" title="reducers save"></a>reducers save</h4><p>通过save reducer忘redux上造数据list，total。。。以后User页面使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reducers: &#123;</span><br><span class="line">   save(state, &#123; payload: &#123; data: list, total, page &#125; &#125;) &#123;</span><br><span class="line">     return &#123; ...state, list, total, page &#125;;</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="细节关注点"><a href="#细节关注点" class="headerlink" title="细节关注点"></a>细节关注点</h3><h4 id="fetch-与-yield-的-generateor写法"><a href="#fetch-与-yield-的-generateor写法" class="headerlink" title="*fetch 与 yield 的 generateor写法"></a>*fetch 与 yield 的 generateor写法</h4><p>这里的*和yield是 generateor的写法，可到mdn网查询了解。</p><h4 id="fetch的loading是怎么来的"><a href="#fetch的loading是怎么来的" class="headerlink" title="fetch的loading是怎么来的"></a>fetch的loading是怎么来的</h4><p>发fetch请求时，通过dva-loading 配合dva中间件，会自动给redux 的store 改变store.loading的state，<br>在fetch开始和完成时将store.loading置为true或false：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//src\pages\.umi\DvaContainer.js</span><br><span class="line">import createLoading from &apos;dva-loading&apos;;</span><br><span class="line">app.use(createLoading());</span><br></pre></td></tr></table></figure><p>在页面中，通过mapStateToProps拿到这个redux的state.loading值，根据这个值，自行开启或关闭loading组件或效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//src\pages\users\components\Users\Users.js</span><br><span class="line">&lt;Table</span><br><span class="line">    columns=&#123;columns&#125;</span><br><span class="line">    dataSource=&#123;dataSource&#125;</span><br><span class="line">    loading=&#123;loading&#125;</span><br><span class="line">    rowKey=&#123;record =&gt; record.id&#125;</span><br><span class="line">    pagination=&#123;false&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">function mapStateToProps(state) &#123;</span><br><span class="line">  const &#123; list, total, page &#125; = state.users;</span><br><span class="line">  return &#123;</span><br><span class="line">    loading: state.loading.models.users,</span><br><span class="line">    list,</span><br><span class="line">    total,</span><br><span class="line">    page,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps)(Users);</span><br></pre></td></tr></table></figure></p><h4 id="import-styles-from-‘-index-css’-的运用："><a href="#import-styles-from-‘-index-css’-的运用：" class="headerlink" title="import styles from ‘./index.css’ 的运用："></a>import styles from ‘./index.css’ 的运用：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import styles from &apos;./index.css&apos;;</span><br><span class="line">console.log(styles)//&#123;normal: &quot;index__normal___3v60A&quot;, content: &quot;index__content___14HDd&quot;, main: &quot;index__main___nz_0B&quot;&#125;</span><br><span class="line"> &lt;div className=&#123;styles.main&#125;&gt;&#123;children&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="dva与umijs在项目中起的作用统筹分析"><a href="#dva与umijs在项目中起的作用统筹分析" class="headerlink" title="dva与umijs在项目中起的作用统筹分析"></a>dva与umijs在项目中起的作用统筹分析</h3><p>本节分析参考pages/.umi/下的文件进行。</p><h4 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h4><p>项目中，通过dva，你不用写store与Provider的集成代码，dva帮你把这块实现,dva又将路由这块的逻辑剥离出来，提供类似接口(this.props.children)方式，方便接入项目路由js；(因此，dva只专注做redux相关的状态部分，并剥离路由且提供路由接口，方便接入路由)</p><p>而你只需专注于：</p><p>1、写reducer；(按dva规定，将reducer写在model下，以便dva能解析)</p><p>2、哪个组件需要redux了，给组件包一层connect，写好mapStateToProps，</p><h4 id="umijs"><a href="#umijs" class="headerlink" title="umijs"></a>umijs</h4><p>至于路由，则由umijs处理，umijs可以将pages下的文件自动解析为路由router.js(.umi下的router.js);</p><p>至此，一个项目的 redux与路由两大块全部写好。<br>剩下一个工作就是 如何将redux与路由两大块有机结合起来呢，<br>这个工作就是umijs做的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function render() &#123;</span><br><span class="line">  const DvaContainer = require(&apos;./DvaContainer&apos;).default; //dva处理的redux逻辑部分</span><br><span class="line">ReactDOM.render(React.createElement(</span><br><span class="line">  DvaContainer,</span><br><span class="line">  null,</span><br><span class="line">  React.createElement(require(&apos;./router&apos;).default)  //umijs处理的路由部分逻辑部分</span><br><span class="line">), document.getElementById(&apos;root&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>因此在以上过程umijs做了以下事情：</p><p>1、封装路由，按约定会将pages下的文件编译为路由文件；</p><p>2、将上面的路由文件与 dva封装好的redux的reducer状态文件有机组合；</p><p>3、有机结合路由和redux后，ReactDOM.render生成启动入口js；</p><p>由上可知，umijs至始至终没有处理过redux部分，都是dva处理好后，umijs拿过来组合下而已。</p><p>整个项目过程，dva只做了一件事情：</p><p>封装reducer，处理redux，dva按约定会将model目录下的文件封装成reducer；</p><p>另外在整个过程中，umijs顺手还做了 webpack配置，比如module.hot 热更新。</p><h3 id="user-dashboard-与-with-dva"><a href="#user-dashboard-与-with-dva" class="headerlink" title="user-dashboard 与 with-dva"></a>user-dashboard 与 with-dva</h3><p>分析这两个项目，有利于理解dva与umi两个人干的事情，这两个项目将他们二人的配置有机串起来，<br>在刷一遍dva与umi文档的基础上，看这两个项目，看完项目后，再去看dva与umi的文档，发现更能看懂在文档中所表达的意思。<br>以上过程入手和研究其他框架的常用手段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">网上大量刷一些有关框架的作用比较和题外话，加深框架的整体影响；</span><br><span class="line">刷一遍文档(快速)；</span><br><span class="line">启动下官方推荐的例子；</span><br><span class="line">再次刷文档；</span><br></pre></td></tr></table></figure></p><h2 id="with-dva项目细节"><a href="#with-dva项目细节" class="headerlink" title="with-dva项目细节"></a>with-dva项目细节</h2><h3 id="layout-js-与-嵌套路由"><a href="#layout-js-与-嵌套路由" class="headerlink" title="_layout.js 与 嵌套路由"></a>_layout.js 与 嵌套路由</h3><p><a href="https://umijs.org/zh/guide/router.html#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">umi 里约定目录下有 _layout.js 时会生成嵌套路由，以 _layout.js 为该目录的 layout 。</a></p><p>本例的src\pages\list_layout.js 是嵌套路由。</p><h3 id="全局-layout"><a href="#全局-layout" class="headerlink" title="全局 layout"></a>全局 layout</h3><p>与上相应的是，全局路由，<a href="https://umijs.org/zh/guide/router.html#%E5%85%A8%E5%B1%80-layout" target="_blank" rel="noopener">参考官网</a>。<br>本例的src\layouts\index.js 是 全局路由。</p><h3 id="model-js-与-models-目录"><a href="#model-js-与-models-目录" class="headerlink" title="model.js 与 models/ 目录"></a>model.js 与 models/ 目录</h3><p><a href="https://dvajs.com/guide/getting-started.html#%E5%AE%9A%E4%B9%89-model" target="_blank" rel="noopener">参考官网–快速上手-定义model</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本例的 src\pages\list\search\model.js</span><br><span class="line">本例的 src\pages\list\models\</span><br></pre></td></tr></table></figure></p><p>以上两种情况都会被dva用来解析成reducer，组装store.getState().[nameSpace],也就是组装全局state的key值；<br>任何组件都可以通过store.getState()获取</p><p>这里想说的是，项目中，在不同位置定义的model，看起来没有什么区别或特殊，任意一个地方定义了model后，任何组件都可以凭model的nameSpace获取该状态。</p><h3 id="src-pages-index路由说明"><a href="#src-pages-index路由说明" class="headerlink" title="src\pages\index路由说明"></a>src\pages\index路由说明</h3><p>在目录的 src\pages\index下有以下文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ pages/</span><br><span class="line">  + index/</span><br><span class="line">    - components/</span><br><span class="line">      - Count.js</span><br><span class="line">    - model.js</span><br><span class="line">    - index.js</span><br></pre></td></tr></table></figure></p><p>按照umijs约定，输入以下路由到浏览器url上，应该是可以显示Count页面的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8000/#/index/components/Count</span><br></pre></td></tr></table></figure></p><p>但是却不行，原因是src\pages\index是主目录路由，src\pages\index\目录下定义的文件都将不被解析为路由，此目录下的index.js为默认主域名下的页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8000/#/</span><br></pre></td></tr></table></figure></p><h3 id="本例具有hot-loader功能"><a href="#本例具有hot-loader功能" class="headerlink" title="本例具有hot-loader功能"></a>本例具有hot-loader功能</h3><p>本例具有热更新功能，有兴趣可以研究底层配置实现。</p><h3 id="effects"><a href="#effects" class="headerlink" title="effects"></a>effects</h3><p>Effect 被称为副作用，在我们的应用中，最常见的就是异步操作。<br>项目的异步请求，以及异步请求后根据接口数据，发起action，都是写在effects中。<br>effects定义了一些关键字(put\call\select..)用来处理比如发送action：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield put(&#123; type: &apos;reload&apos; &#125;);</span><br></pre></td></tr></table></figure></p><p><a href="https://dvajs.com/guide/concepts.html#effect" target="_blank" rel="noopener">参考dva–指南-dva概念-models-Effect</a><br><a href="https://dvajs.com/knowledgemap/#effects" target="_blank" rel="noopener">参考dva–知识地图-Effect-effects</a></p><h3 id="effects与reducers"><a href="#effects与reducers" class="headerlink" title="effects与reducers"></a>effects与reducers</h3><p>effects跟reducers定义相似，二者都是用来定义action的reducer操作，不同的是，effects用来定义异步action，当action要发起post请求时，一般用effects；<br>相对的，reducer用来定义同步：<a href="https://github.com/YeWills/dva-example/tree/user-dashboard" target="_blank" rel="noopener">参考示例user-dashboard—src\pages\users\models\users.js</a></p><h2 id="umi"><a href="#umi" class="headerlink" title="umi"></a>umi</h2><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="权限路由-与-Routes"><a href="#权限路由-与-Routes" class="headerlink" title="权限路由 与 Routes"></a>权限路由 与 Routes</h4><p>umi 的权限路由是通过配置路由的 Routes 属性来实现。<br><a href="https://github.com/YeWills/umi-example/tree/routes-via-config" target="_blank" rel="noopener">参考demo</a><br>以下是权限路由的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &apos;/list&apos;, component: &apos;./pages/list.js&apos;, Routes: [&apos;./routes/PrivateRoute.js&apos;] &#125;,</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//PrivateRoute.js</span><br><span class="line">export default (props) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;PrivateRoute (routes/PrivateRoute.js)&lt;/div&gt;</span><br><span class="line">      &#123; props.children &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Routes定义的权限组件PrivateRoute而言，PrivateRoute可以通过props.children能访问上面component定义的组件，然后跳转到/list路由url时，实际显示的是Routes的组件。Routes组件拥有最高权限，通过props.child决定是否显示component定义的组件。</p><p>权限路由有些类似全局路由。<br>更多说明，<a href="https://umijs.org/zh/guide/router.html#%E6%9D%83%E9%99%90%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">参考 umi–指南-路由-权限路由</a></p><h3 id="umi-command-not-found"><a href="#umi-command-not-found" class="headerlink" title="umi:command not found"></a>umi:command not found</h3><h4 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global install umi</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//查看yarn目录</span><br><span class="line">yarn global bin</span><br><span class="line">/Users/js/.yarn/bin</span><br></pre></td></tr></table></figure><p>设置环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi ~/.bash_profile</span><br><span class="line">//然后输入用户密码</span><br><span class="line">//添加这一句话到.bash_profile文件</span><br><span class="line">export PATH=&quot;$PATH:`yarn global bin`&quot;</span><br></pre></td></tr></table></figure></p><p>重启命令窗口<br>再次输入umi就可以了。</p><h4 id="关于mac环境变量配置有关"><a href="#关于mac环境变量配置有关" class="headerlink" title="关于mac环境变量配置有关"></a>关于mac环境变量配置有关</h4><h4 id="PATH的字符串写法"><a href="#PATH的字符串写法" class="headerlink" title="$PATH的字符串写法"></a>$PATH的字符串写法</h4><p>接着上面mac对umi的环境变量配置，上面设置环境变量的步骤设置成如下也是的一样的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/Users/js/.yarn/bin</span><br></pre></td></tr></table></figure></p><h4 id="PATH的变量写法"><a href="#PATH的变量写法" class="headerlink" title="$PATH的变量写法"></a>$PATH的变量写法</h4><p>我们观察到，export PATH=”$PATH:<code>yarn global bin</code>“ 是一种变量的写法，将yarn global bin 这个整体当成一个变量。<br>类似于 yarn global bin 等价于 /Users/js/.yarn/bin；<br>因为bash中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//查看yarn目录</span><br><span class="line">yarn global bin</span><br><span class="line">/Users/js/.yarn/bin</span><br></pre></td></tr></table></figure></p><h4 id="多个环境变量以：打印echo输出"><a href="#多个环境变量以：打印echo输出" class="headerlink" title="多个环境变量以：打印echo输出"></a>多个环境变量以：打印echo输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi ~/.bash_profile</span><br><span class="line">//进入vim模式后，文件内容如下：</span><br><span class="line">export PATH=$PATH:/usr/local/mongodb/bin</span><br><span class="line">export PATH=$PATH:/Users/js/.yarn/bin</span><br><span class="line">$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/mongodb/bin:/Users/js/.yarn/bin</span><br><span class="line">我们看到了 mongodb的环境变量并没有被后面的yarn路径覆盖，他们全部被平行保存，通过冒号:隔开表示。</span><br></pre></td></tr></table></figure><h4 id="bash-profile中的环境变量不会覆盖"><a href="#bash-profile中的环境变量不会覆盖" class="headerlink" title=".bash_profile中的环境变量不会覆盖"></a>.bash_profile中的环境变量不会覆盖</h4><p>如上分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/mongodb/bin</span><br><span class="line">export PATH=$PATH:/Users/js/.yarn/bin</span><br></pre></td></tr></table></figure></p><p>虽然使用PATH=先后定义了mongodb和yarn，但是yarn并没有覆盖mongodb，通过echo打印可以查证。具体参考上面分析。</p><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>windows解决方式一样，唯一不同的是，是将 yarn global bin 打印的地址添加到环境变量中。</p><h3 id="umi的使用"><a href="#umi的使用" class="headerlink" title="umi的使用"></a>umi的使用</h3><p>官网中通过 <code>快速上手</code> 和 <code>通过脚手架创建项目</code> 两部分详细介绍了如何使用umi，通过这种方式来创建项目工程，很有借鉴学习之用，亲试可行，在此单独从官网从拎出来说明，以示重视。</p><h4 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h4><p><a href="https://umijs.org/zh/guide/getting-started.html" target="_blank" rel="noopener">参考umi–指南-快速上手</a></p><h4 id="通过脚手架创建项目"><a href="#通过脚手架创建项目" class="headerlink" title="通过脚手架创建项目"></a>通过脚手架创建项目</h4><p><a href="https://umijs.org/zh/guide/create-umi-app.html" target="_blank" rel="noopener">参考umi–指南-通过脚手架创建项目</a></p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="with-dva"><a href="#with-dva" class="headerlink" title="with-dva"></a>with-dva</h3><p><a href="https://github.com/YeWills/umi-example/tree/with-dva" target="_blank" rel="noopener">demo地址</a><br>一个很好的 umi 配合 dva的例子，讲了各种路由配置,已经dva的运用，是 umi约定式路由范例。<br>参考《with-dva项目细节》<br> <figure class="image-box">                <img src="/image/dva_umi/with-dva.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h3><p><a href="https://github.com/YeWills/umi-example/tree/routes" target="_blank" rel="noopener">demo地址</a><br>本例展示在umijs中如何按约定生成 各种类型的路由，如 基础、动态、可选动态、嵌套、全局、404路由。<br>相关讲解，<a href="https://umijs.org/zh/guide/router.html#%E5%9F%BA%E7%A1%80%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">参考umi–指南-路由-约定式路由</a><br>本项目也可用于react项目常用到的一些路由知识学习<br> <figure class="image-box">                <img src="/image/dva_umi/routes.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="routes-via-config"><a href="#routes-via-config" class="headerlink" title="routes-via-config"></a>routes-via-config</h3><p>此demo相对简单，在umijs下，如何自行配置路由。是 umi配置式路由范例。<br>通过本例知道，主要是通过.umirc.js 来进行配置路由。 本例运用了权限路由。<br><a href="https://umijs.org/zh/guide/router.html#%E9%85%8D%E7%BD%AE%E5%BC%8F%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">参考umi–指南-路由-配置式路由</a><br> <figure class="image-box">                <img src="/image/dva_umi/routes-via-config.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="umi-dva-user-dashboard"><a href="#umi-dva-user-dashboard" class="headerlink" title="umi-dva-user-dashboard"></a>umi-dva-user-dashboard</h3><p>一个简单的示例，可作为umi与dva结合的示例。是了解umi与dva的入门demo，其解说参见《user-dashboard项目细节》，<br>是下面的user-dashboard示例的优化版。<br><a href="https://github.com/YeWills/umi-example/tree/umi-dva-user-dashboard" target="_blank" rel="noopener">demo地址</a><br> <figure class="image-box">                <img src="/image/dva_umi/umi-dva-user-dashboard.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="user-dashboard"><a href="#user-dashboard" class="headerlink" title="user-dashboard"></a>user-dashboard</h3><p>参考《user-dashboard项目细节》<br>这个示例没有 上面的 umi-dva-user-dashboard精细，但也可一看。<br> <figure class="image-box">                <img src="/image/dva_umi/user-dashboard-view.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="with-nav-and-sidebar"><a href="#with-nav-and-sidebar" class="headerlink" title="with-nav-and-sidebar"></a>with-nav-and-sidebar</h3><p><a href="https://github.com/YeWills/umi-example/tree/with-nav-and-sidebar" target="_blank" rel="noopener">demo地址</a><br>要做侧边栏(sidebar)和导航栏时，可参考本示例，非常简洁的，只有侧边栏和导航栏的示例<br><img src="https://gw.alipayobjects.com/zos/rmsportal/DReQIejdcJPeaXWEDKDe.png"></p><h3 id="ant-design-pro"><a href="#ant-design-pro" class="headerlink" title="ant-design-pro"></a>ant-design-pro</h3><p>深入了解umi与dva的综合示例</p><h2 id="学习资料与小结"><a href="#学习资料与小结" class="headerlink" title="学习资料与小结"></a>学习资料与小结</h2><h3 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a>github仓库</h3><p>github中以下仓库为学习期间的全部demo：<br><a href="https://github.com/YeWills/umi-example" target="_blank" rel="noopener">umi-example</a><br><a href="https://github.com/YeWills/dva-example" target="_blank" rel="noopener">dva-example</a><br><a href="https://github.com/YeWills/ant-design-pro" target="_blank" rel="noopener">ant-design-pro</a><br>以上demo都基于官网开源demo，感谢。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><h4 id="dva与umi学习"><a href="#dva与umi学习" class="headerlink" title="dva与umi学习"></a>dva与umi学习</h4><p>学习dva与umi，建议先从dva了解开始，然后是umi，然后再是ant-design-pro；<br>dva与umi的学习，快速过官网文档，然后运行文档中给出的demo，对照demo，再针对性看文档，多看文档。<br>以上熟悉后，再看ant-design-pro。</p><h4 id="dva与umi认识"><a href="#dva与umi认识" class="headerlink" title="dva与umi认识"></a>dva与umi认识</h4><p>dva与umi创建项目的方式新颖，通过包管理方式创建脚手架，是很多公司大厂的常规做法，umi更像一个大厂内部的标准工程脚手架。<br>如果你处于一个公司的架构师位置，想要出一个全公司统一的前端开发脚手架，你所在公司安全级别高，对项目依赖包有安全要求，对项目有管控需求以便达到安全级别，umi无疑是你的标杆。<br>如果你们公司不是一个五六百人的公司，而且没有对公司内所有前端项目所用依赖包的版本有管制需求，并且没有统一前端脚手架的需求，建议还是自行配置一套脚手架，有利于 版本升级，问题追踪，风险可控性好。<br>总而言之，umi这种react标准化工程项目的做法非常妙，无论你想直接用它或者从中借鉴理念或方案都非常值得你一看。</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><h3 id="dva-1"><a href="#dva-1" class="headerlink" title="dva"></a>dva</h3><p><a href="https://dvajs.com/guide/getting-started.html#%E5%AE%9A%E4%B9%89-model" target="_blank" rel="noopener">参考dva–指南-快速上手-定义model</a><br><a href="https://dvajs.com/guide/concepts.html#effect" target="_blank" rel="noopener">参考dva–指南-dva概念-models-Effect</a><br><a href="https://dvajs.com/knowledgemap/#effects" target="_blank" rel="noopener">参考dva–知识地图-Effect-effects</a></p><h3 id="umi-1"><a href="#umi-1" class="headerlink" title="umi"></a>umi</h3><p><a href="https://umijs.org/zh/guide/router.html#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">参考umi–指南-路由-约定式路由</a></p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dva </tag>
            
            <tag> umi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>后端笔记</title>
      <link href="/2021/01/03/end_base/"/>
      <url>/2021/01/03/end_base/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="express是一个nodejs框架"><a href="#express是一个nodejs框架" class="headerlink" title="express是一个nodejs框架"></a>express是一个nodejs框架</h3><p>如下图，express其实封装了原生写法的http等等nodejs的模块，<br>只是原生的http模块用来写req、res有很多要处理的功能，<br>express封装了很多功能到req、res中，用起来更加方便。<br>因此express与nodejs的关系 就好比 jquery 与 js 的关系。<br>因此可以认为express就是一个nodejs框架。<br><figure class="image-box">                <img src="/image/end_base/express.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="express是对http等的封装"><a href="#express是对http等的封装" class="headerlink" title="express是对http等的封装"></a>express是对http等的封装</h3><p>参考上面《express是一个nodejs框架》</p><h3 id="一个url被web渲染经历了什么"><a href="#一个url被web渲染经历了什么" class="headerlink" title="一个url被web渲染经历了什么"></a>一个url被web渲染经历了什么</h3><p>url 通过dns域名解析，<br>找到目标服务器（进入目标服务器）；<br>服务器通过服务器路由对这个url请求做出相应；</p><p>服务器路由是处理请求接口如何响应的规则。</p><h3 id="uri"><a href="#uri" class="headerlink" title="uri"></a>uri</h3><p>通俗的讲，一个完整的url中，除了域名和端口的部分，剩下的就是uri，可以用uri唯一标识资源。如下：<br><code>https://blog.csdn.net/qq_32595453/article/details/79516787</code>;<br>上面的uri就是 <code>/qq_32595453/article/details/79516787</code>;</p><h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><h3 id="all-API的用法"><a href="#all-API的用法" class="headerlink" title="all API的用法"></a>all API的用法</h3><h4 id="匹配所有的请求类型"><a href="#匹配所有的请求类型" class="headerlink" title="匹配所有的请求类型"></a>匹配所有的请求类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">'/demo'</span>,(req, res)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="匹配所有的uri"><a href="#匹配所有的uri" class="headerlink" title="匹配所有的uri"></a>匹配所有的uri</h4><p>使用*来匹配所有的uri，常用的场景有打印请求日志 等等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">'*'</span>,(req, res)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="app-use-中间件的使用"><a href="#app-use-中间件的使用" class="headerlink" title="app.use 中间件的使用"></a>app.use 中间件的使用</h3><h4 id="匹配所有的请求类型-1"><a href="#匹配所有的请求类型-1" class="headerlink" title="匹配所有的请求类型"></a>匹配所有的请求类型</h4><p>use一般用于中间件的集成，不过也可以用来做路由的定义，可以轻松实现上面的功能：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/demo'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'test get use'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//与下面等效：</span></span><br><span class="line">app.all(<span class="string">'/demo'</span>,(req, res)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="匹配所有的uri-1"><a href="#匹配所有的uri-1" class="headerlink" title="匹配所有的uri"></a>匹配所有的uri</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'test all use'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//与下面等效：</span></span><br><span class="line">app.all(<span class="string">'*'</span>,(req, res)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="注意：一般不做请求的响应"><a href="#注意：一般不做请求的响应" class="headerlink" title="注意：一般不做请求的响应"></a>注意：一般不做请求的响应</h4><p>app.use一般不做上面的《匹配所有的请求类型》《匹配所有的uri》接口编写。<br>一般用于中间件的使用，也可以用来做路由的拆分。</p><h4 id="路由拆分-express-Router"><a href="#路由拆分-express-Router" class="headerlink" title="路由拆分(express.Router)"></a>路由拆分(express.Router)</h4><p>由于内容较多，拆成独立一节，参考《路由拆分(express.Router)》</p><h3 id="路由拆分-express-Router-1"><a href="#路由拆分-express-Router-1" class="headerlink" title="路由拆分(express.Router)"></a>路由拆分(express.Router)</h3><p><a href="https://www.imooc.com/video/20689" target="_blank" rel="noopener">参考慕课视频</a></p><h4 id="基本用法-单个"><a href="#基本用法-单个" class="headerlink" title="基本用法(单个)"></a>基本用法(单个)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.router.js</span></span><br><span class="line"><span class="keyword">const</span>  express = <span class="built_in">require</span>(<span class="string">'express'</span>) ;</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/list'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'test router'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  express = <span class="built_in">require</span>(<span class="string">'express'</span>) ;</span><br><span class="line"><span class="keyword">const</span>  appRouter = <span class="built_in">require</span>(<span class="string">'./app.router'</span>) ; <span class="comment">//app.router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(appRouter)</span><br><span class="line">app.listen(<span class="number">3000</span>, ()=&gt;<span class="built_in">console</span>.log(<span class="string">'please open 3000 port'</span>))</span><br></pre></td></tr></table></figure><h4 id="多个路由"><a href="#多个路由" class="headerlink" title="多个路由"></a>多个路由</h4><p>在上面单个路由的基础上，增加一个路由，写法与第一个路由一摸一样,此时会遇到一个问题，当发<code>http://127.0.0.1:3000/list</code>请求时，<br>只能被第一个appRouter截取，moreRouter无法获得。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.moreRouter.js</span></span><br><span class="line"><span class="keyword">const</span>  express = <span class="built_in">require</span>(<span class="string">'express'</span>) ;</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/list'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'test router'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  express = <span class="built_in">require</span>(<span class="string">'express'</span>) ;</span><br><span class="line"><span class="keyword">const</span>  appRouter = <span class="built_in">require</span>(<span class="string">'./app.router'</span>) ; <span class="comment">//app.router.js</span></span><br><span class="line"><span class="keyword">const</span>  moreRouter = <span class="built_in">require</span>(<span class="string">'./app.moreRouter'</span>) ; <span class="comment">//app.moreRouter.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(appRouter)</span><br><span class="line">app.use(moreRouter)</span><br><span class="line">app.listen(<span class="number">3000</span>, ()=&gt;<span class="built_in">console</span>.log(<span class="string">'please open 3000 port'</span>))</span><br></pre></td></tr></table></figure><p>为了解决上面的问题，在app.use上定义路由，其他不变：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  express = <span class="built_in">require</span>(<span class="string">'express'</span>) ;</span><br><span class="line"><span class="keyword">const</span>  appRouter = <span class="built_in">require</span>(<span class="string">'./app.router'</span>) ; <span class="comment">//app.router.js</span></span><br><span class="line"><span class="keyword">const</span>  moreRouter = <span class="built_in">require</span>(<span class="string">'./app.moreRouter'</span>) ; <span class="comment">//app.moreRouter.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(<span class="string">'/main'</span>,appRouter) <span class="comment">//http://127.0.0.1:3000/main/list</span></span><br><span class="line">app.use(<span class="string">'/more'</span>,moreRouter) <span class="comment">//http://127.0.0.1:3000/more/list</span></span><br><span class="line">app.listen(<span class="number">3000</span>, ()=&gt;<span class="built_in">console</span>.log(<span class="string">'please open 3000 port'</span>))</span><br></pre></td></tr></table></figure></p><h4 id="路由文件内再拆分-router-use"><a href="#路由文件内再拆分-router-use" class="headerlink" title="路由文件内再拆分(router.use)"></a>路由文件内再拆分(router.use)</h4><p>如上面的<code>app.moreRouter.js</code>内，可以使用<code>router.use</code>再进行嵌套拆分，不过一般不推荐这种多层嵌套的做法。<br>就像数据追求扁平化一样，路由设计也不要追求深层嵌套。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.moreRouter.js</span></span><br><span class="line"><span class="keyword">const</span>  express = <span class="built_in">require</span>(<span class="string">'express'</span>) ;</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/list'</span>,(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'test router'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//可以再进行路由拆分</span></span><br><span class="line">router.use(......)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure></p><h3 id="会不会同时被多个路由响应"><a href="#会不会同时被多个路由响应" class="headerlink" title="会不会同时被多个路由响应"></a>会不会同时被多个路由响应</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>如下，如果写一个url：<code>http://127.0.0.1:3000/test</code>;<br>会被下面两个路由同时捕获吗？<br>实际上只会被第一个 all 捕获，第二个路由不会被捕获，究其原因是在第一个路由上使用了res.json.<br>如果没有res，且使用next就会被第二个路由捕获。<br>由此可看出，res.json和next都相当于return，如果使用res.json 那么后面代码就不执行。next以此类推。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://127.0.0.1:3000/test 被匹配 </span></span><br><span class="line">app.all(<span class="string">'*'</span>, (req,res, next)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'test all '</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为上面已经 res.json 因此这里 http://127.0.0.1:3000/test 不被匹配 </span></span><br><span class="line">app.get(<span class="string">'/test'</span>, (req,res, next)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'test 11 '</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="配合next可被多个路由匹配"><a href="#配合next可被多个路由匹配" class="headerlink" title="配合next可被多个路由匹配"></a>配合next可被多个路由匹配</h4><p>下面路由中，第一个用于打印日志，第二个用于真正接口的响应。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://127.0.0.1:3000/test 被匹配 </span></span><br><span class="line">app.all(<span class="string">'*'</span>, (req,res, next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'打印日志'</span>, req.originalUrl)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为上面使用next 这里 http://127.0.0.1:3000/test 被匹配 </span></span><br><span class="line">app.get(<span class="string">'/test'</span>, (req,res, next)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'test 11 '</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="只会被一个路由响应"><a href="#只会被一个路由响应" class="headerlink" title="只会被一个路由响应"></a>只会被一个路由响应</h4><p>通过《概述》的例子看出，当任意一个路由使用了res.json来响应后，接口处理程序将终止，不会被第二个路由匹配到。<br>因此只会被一个路由响应。</p><h4 id="res-json、next相当于return"><a href="#res-json、next相当于return" class="headerlink" title="res.json、next相当于return"></a>res.json、next相当于return</h4><p>参考上面《概述》</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h4><p>valid_name_middleware 就是一个中间件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> valid_name_middleware = <span class="function">(<span class="params">req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name&#125; = req.query;</span><br><span class="line">    <span class="keyword">if</span>(!name ||!name.length)&#123;</span><br><span class="line">        res.json(&#123;<span class="attr">msg</span>:<span class="string">'缺少name参数'</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'*'</span>, valid_name_middleware)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/test'</span>, (req,res, next)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'test '</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="使用场景或级别"><a href="#使用场景或级别" class="headerlink" title="使用场景或级别"></a>使用场景或级别</h4><ul><li>app级别</li><li>router级别</li><li>异常处理（其实也可能是app或router级别）</li></ul><h4 id="app级别"><a href="#app级别" class="headerlink" title="app级别"></a>app级别</h4><p>注册的时候，一定是最顶级，在express实例时就进行。<br>使用方式是，使用app.use来集成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> log_mid = <span class="function">(<span class="params">req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求来了'</span>)</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">app.use(log_mid)</span><br></pre></td></tr></table></figure></p><p>express内置了很多app级别的中间件，比如 static：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="comment">//指定index.html放在static目录下：express-router/static/index.html</span></span><br><span class="line">app.use(express.static(<span class="string">'static'</span>,&#123;</span><br><span class="line">    extensions:[<span class="string">'html'</span>, <span class="string">'htm'</span>]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p><h4 id="router级别"><a href="#router级别" class="headerlink" title="router级别"></a>router级别</h4><p>第一种情况与 app级别用法一样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> log_mid = <span class="function">(<span class="params">req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求来了'</span>)</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">router.use(log_mid)</span><br></pre></td></tr></table></figure></p><p>这里要讲 <strong>路由内部中间件</strong>的使用。<br>下面是给登陆接口写两个校验参数的中间件：<br>访问<code>http://127.0.0.1:3000/main/login?password=2&amp;id=2</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">app.use(<span class="string">'/main'</span>,appRouter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//router.js</span></span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> valid_pwd = <span class="function">(<span class="params">req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;password&#125; = req.query;</span><br><span class="line">    <span class="keyword">if</span>(!password ||!password.length)&#123;</span><br><span class="line">        res.json(&#123;<span class="attr">msg</span>:<span class="string">'缺少密码参数'</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> valid_id = <span class="function">(<span class="params">req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;id&#125; = req.query;</span><br><span class="line">    <span class="keyword">if</span>(!id ||!id.length)&#123;</span><br><span class="line">        res.json(&#123;<span class="attr">msg</span>:<span class="string">'缺少user id参数'</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主要利用路由级别内的路由函数，第二个参数可以是定义一系列中间件的</span></span><br><span class="line">router.get(<span class="string">'/login'</span>,[valid_pwd, valid_id],(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'登陆成功'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="中间件传递数据给路由"><a href="#中间件传递数据给路由" class="headerlink" title="中间件传递数据给路由"></a>中间件传递数据给路由</h4><p>给req任意定义一个属性来保存数据，到下一步路由时，凭借此属性拿取数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> valid_id = <span class="function">(<span class="params">req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;id, password&#125; = req.query;</span><br><span class="line">    <span class="keyword">if</span>(!id ||!id.length)&#123;</span><br><span class="line">        res.json(&#123;<span class="attr">msg</span>:<span class="string">'缺少user id参数'</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//给req任意定义一个属性来保存数据</span></span><br><span class="line">        req.midCustom = &#123;id, password&#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/login'</span>,[valid_pwd, valid_id],(req,res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        user:req.midCustom,<span class="comment">//凭借midCustom属性拿取数据</span></span><br><span class="line">        msg:<span class="string">'登陆成功'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="根据回调的传参个数判定操作类别"><a href="#根据回调的传参个数判定操作类别" class="headerlink" title="根据回调的传参个数判定操作类别"></a>根据回调的传参个数判定操作类别</h4><p>四个传参的回调函数被自动识别为异常处理函数。<br>express框架层面应该做了识别处理，<br>如果你给app.use传递一个有四个传参 的回调函数，那么express认为此回调函数是错误处理函数，那么回调函数传参依次为 ：<code>err,req, res, next</code>;<br>如果你给app.use传递一个有三个传参的回调函数，那么express认为此回调函数是错误处理函数，那么回调函数传参依次为 ：<br><code>req, res, next</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> errorHandle = <span class="function">(<span class="params">err,req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;message&#125;= err;</span><br><span class="line">        res.status(<span class="number">500</span>)</span><br><span class="line">        .json(&#123;</span><br><span class="line">            message:<span class="string">`<span class="subst">$&#123;message || <span class="string">'请求异常'</span>&#125;</span>`</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> matchAll = <span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'test all use'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.use(matchAll)</span><br><span class="line">app.use(errorHandle)</span><br></pre></td></tr></table></figure></p><h4 id="异常处理放置最后"><a href="#异常处理放置最后" class="headerlink" title="异常处理放置最后"></a>异常处理放置最后</h4><p>异常处理一般放在所有路由或中间件的最后取定义。</p><h4 id="404-not-found处理"><a href="#404-not-found处理" class="headerlink" title="404 not found处理"></a>404 not found处理</h4><p>在路由的最后位置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> errorHandle = <span class="function">(<span class="params">err,req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;message&#125;= err;</span><br><span class="line">        res.status(<span class="number">500</span>)</span><br><span class="line">        .json(&#123;</span><br><span class="line">            message:<span class="string">`<span class="subst">$&#123;message || <span class="string">'请求异常'</span>&#125;</span>`</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> notfound = <span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'请求的接口不存在'</span><span class="comment">//404</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.use(notfound)</span><br><span class="line">app.use(errorHandle)</span><br></pre></td></tr></table></figure></p><h3 id="接口返回一个静态文件"><a href="#接口返回一个静态文件" class="headerlink" title="接口返回一个静态文件"></a>接口返回一个静态文件</h3><h4 id="不指定路由"><a href="#不指定路由" class="headerlink" title="不指定路由"></a>不指定路由</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(path.resolve(__dirname, <span class="string">'public'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问 http://127.0.0.1:3000/test.js</span></span><br></pre></td></tr></table></figure><h4 id="指定路由"><a href="#指定路由" class="headerlink" title="指定路由"></a>指定路由</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/pub'</span>,express.static(path.resolve(__dirname, <span class="string">'public'</span>)))</span><br><span class="line"><span class="comment">//访问 http://127.0.0.1:3000/pub/test.js</span></span><br></pre></td></tr></table></figure><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p><a href="https://github.com/YeWills/learns/tree/master/sequelize-demo" target="_blank" rel="noopener">异常处理、模型表数据修改 demo</a><br>也可参考 《sequelize集成使用》 章节的demo和参考</p><h2 id="sequlize集成使用"><a href="#sequlize集成使用" class="headerlink" title="sequlize集成使用"></a>sequlize集成使用</h2><h3 id="sequelize-cli初始化工程"><a href="#sequelize-cli初始化工程" class="headerlink" title="sequelize-cli初始化工程"></a>sequelize-cli初始化工程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize-cli init</span><br></pre></td></tr></table></figure><p>修改 文件如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//config.json</span><br><span class="line"> "development": &#123;</span><br><span class="line">    "username": "root",</span><br><span class="line">    "password": "root1111",</span><br><span class="line">    "database": "sqe_db",</span><br><span class="line">    "host": "127.0.0.1",</span><br><span class="line">    "dialect": "mysql"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h3><figure class="image-box">                <img src="/image/end_base/right.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/end_base/db.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="sequelize-cli创建模型"><a href="#sequelize-cli创建模型" class="headerlink" title="sequelize-cli创建模型"></a>sequelize-cli创建模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize-cli model:generate --name User --attributes name:string</span><br></pre></td></tr></table></figure><p>命令会做以下事情：</p><ul><li>生成 migrate文件 ： 在 models 文件夹中创建了一个 user 模型文件;</li><li>生成 model文件 ：在 migrations 文件夹中创建了一个名字像 XXXXXXXXXXXXXX-create-user.js 的迁移文件.<h3 id="将刚才的模型添加到数据库中-生成表"><a href="#将刚才的模型添加到数据库中-生成表" class="headerlink" title="将刚才的模型添加到数据库中(生成表)"></a>将刚才的模型添加到数据库中(生成表)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize-cli db:migrate</span><br></pre></td></tr></table></figure></li></ul><p>一般命令后要设置env，如果不设置则默认使用development。与下面命令等效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx sequelize-cli db:migrate --env=development</span><br></pre></td></tr></table></figure></p><p>这里的development就是<code>sequelize-demo/config/config.json</code>的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"development"</span>: &#123;</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"root1111"</span>,</span><br><span class="line">    <span class="attr">"database"</span>: <span class="string">"sqe_db"</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"dialect"</span>: <span class="string">"mysql"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"test"</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  "production": &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将模型添加到数据库后，你就会在数据库中看到模型中添加的表(模型生产的)<br><figure class="image-box">                <img src="/image/end_base/db.jpg" alt="" title="" class="">                <p></p>            </figure><br>至此，桥接数据库，通过sequelize在数据库中建表的工作完成，下一步就是使用express操作数据库。</p><h3 id="使用express操作数据库"><a href="#使用express操作数据库" class="headerlink" title="使用express操作数据库"></a>使用express操作数据库</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  express = <span class="built_in">require</span>(<span class="string">'express'</span>) ;</span><br><span class="line"><span class="keyword">const</span> models = <span class="built_in">require</span>(<span class="string">'../models'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">'/create'</span>, <span class="keyword">async</span> (req,res, next)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name&#125; = req.query;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> models.User.create(&#123;</span><br><span class="line">        name</span><br><span class="line">    &#125;)</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        msg:<span class="string">'create success!'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="mysql2"><a href="#mysql2" class="headerlink" title="mysql2"></a>mysql2</h3><p>如下，node应用通过orm来操作 mysql数据库，必须借助node环境下的mysql驱动，而这个驱动就是mysql2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node-application -- ORM(sequelize) --&gt; 驱动(node-mysql 其实就是mysql2) --&gt; mysql db</span><br></pre></td></tr></table></figure></p><h2 id="demo与参考"><a href="#demo与参考" class="headerlink" title="demo与参考"></a>demo与参考</h2><p><a href="https://github.com/YeWills/learns/tree/sequelize-demo/sequelize-demo" target="_blank" rel="noopener">demo</a><br>也可参考本文其他章节的相关demo。<br><a href="https://www.imooc.com/video/20693" target="_blank" rel="noopener">本节视频参考</a><br><a href="https://github.com/demopark/sequelize-docs-Zh-CN/blob/master/other-topics/migrations.md" target="_blank" rel="noopener">sequelize migrations</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
            <tag> node </tag>
            
            <tag> koa </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vertical-align、行盒子、baseline</title>
      <link href="/2021/01/03/css_vertical_align/"/>
      <url>/2021/01/03/css_vertical_align/</url>
      
        <content type="html"><![CDATA[<p>本文讲解vertical-align, baseline, 行盒子, x-height, line-height, 半铅空,以及这些概念如何运用于行内元素居中、和使用line-height让元素居中，其中花了大量示例和说明介绍了如何确定父元素和行内元素的baseline。</p><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><h3 id="为什么会这样"><a href="#为什么会这样" class="headerlink" title="为什么会这样"></a>为什么会这样</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>如图两个定义为inline-block的div一模一样，就是一个多了555：<br>没有555时，两个div还是一起的：<br><figure class="image-box">                <img src="/image/css/question1.png" alt="" title="" class="">                <p></p>            </figure><br>加了555，两个div不一起了：<br><figure class="image-box">                <img src="/image/css/question2.png" alt="" title="" class="">                <p></p>            </figure><br>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        .qq&#123;</span><br><span class="line">            height: 80px;</span><br><span class="line">            width: 80px;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            display: inline-block;</span><br><span class="line">        &#125;</span><br><span class="line">        .a1&#123;</span><br><span class="line">            background-color: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">        .a2&#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;a1 qq&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;a2 qq&quot;&gt;555&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><h5 id="为什么之前是对齐的"><a href="#为什么之前是对齐的" class="headerlink" title="为什么之前是对齐的"></a>为什么之前是对齐的</h5><p>在a2中没有加555之前，a2这个inline-block，它的基线(baseline)，就是它的下边距。因为<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">没有基线的元素，使用外边距的下边缘替代</a>；<br>a2所在的父元素，它的基线由父元素内的inline-block元素确定，那么父元素的基线，也是a1和a2的下边距，<br>此时 a1、a2默认的垂直对齐方式都是 vertical-align:baseline；<br>所以a1和a2是对齐的；</p><h5 id="为什么之后不对齐"><a href="#为什么之后不对齐" class="headerlink" title="为什么之后不对齐"></a>为什么之后不对齐</h5><p>在a2中加555之后，它的基线(baseline)就是a2行内块中的555这串文字决定的，它的基线就是下图黄色矩形框的下黄色边框；<br><figure class="image-box">                <img src="/image/css/vertical-align/vertical1.png" alt="" title="" class="">                <p></p>            </figure><br>，因为a1、a2默认的垂直对齐方式都是 vertical-align:baseline，而父基线由a1决定，就是a1的下边框；所以a2需要下降，让它的的基线与父基线位置一致。</p><h3 id="如何对齐"><a href="#如何对齐" class="headerlink" title="如何对齐"></a>如何对齐</h3><p>将同时设置两个inline-block 为<br>vertical-align: middle;<br>或者<br>    vertical-align: top;都可以<br>当然，还可以设置inline-block为浮动元素，脱离文档流，也可以对齐；<br>解释下同时设置两个inline-block 为 vertical-align: middle时为何能对齐；<br>上面的例子，a1是空的inline-block，a2是非空inline-block，父基线以 空的a1为准，当a1设置vertical-align: middle，<br>a1将父基线的位置由a1的下边距，提升至a1的中部+x-height/2,可以近似看成就是a1的中部。<br>a2也将自己的中部与父基线对齐，所以就对齐了。<br>如果不清楚，可以看下面章节《如何确定父元素的baseline》或《另外一个例子》</p><h3 id="对上面例子延伸"><a href="#对上面例子延伸" class="headerlink" title="对上面例子延伸"></a>对上面例子延伸</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 其他都一样 --&gt;</span><br><span class="line">  &lt;div class=&quot;a1 qq&quot;&gt;555&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;a2 qq&quot;&gt;555&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这时候，他们又对齐了：<br><figure class="image-box">                <img src="/image/css/vertical-align/vertical2.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>这是因为他们的父baseline就是下图所示黄色矩形框的下边框，父级baseline其实就是a1和a2的baseline；<br><figure class="image-box">                <img src="/image/css/vertical-align/vertical3.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>在本例的修改基础上，现在我们又将a1定义为vertical-align:middle,其他保持不变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 其他保持不变 --&gt;</span><br><span class="line">.a1&#123;</span><br><span class="line">   vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果变成如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/vertical4.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>vertical-align: middle 意思是：使元素的中部与父元素的基线加上父元素x-height的一半对齐。</p><p>本例中，x-height的值差不多5px，x-height 的值计算，参考下面章节《x-height》,<br>父元素的基线就是a2的基线，a2的基线如图所示，所以变成这样的效果。</p><h3 id="确定父基线最简单的方法"><a href="#确定父基线最简单的方法" class="headerlink" title="确定父基线最简单的方法"></a>确定父基线最简单的方法</h3><p>可能你疑惑，上面例子中，父基线真的是上面所说的吗，怎么验证呢，一个简单的方法，就是在父元素内，增加一段匿名行内元素，简单点说就是在父元素内，增加一段字符，那么这个字符的位置就说明了父元素的基线位置，因为，父元素的基线 总是与其内的匿名行内元素的基线一致：<br>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line">.qq&#123;</span><br><span class="line">    height: 80px;</span><br><span class="line">    width: 80px;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">.a1&#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.a2&#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">     我这几个字就是所谓的匿名行内元素哦</span><br><span class="line">    &lt;div class=&quot;a1 qq&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;a2 qq&quot;&gt;555&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/vae1.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>继续修改，其他不变，在a1中加555字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 其他都一样 --&gt;</span><br><span class="line">  &lt;div class=&quot;a1 qq&quot;&gt;555&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/ver2.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>继续修改，其他不变，修改如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 其他保持不变 --&gt;</span><br><span class="line">.a1&#123;</span><br><span class="line">   vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/ver3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="另外一个例子"><a href="#另外一个例子" class="headerlink" title="另外一个例子"></a>另外一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">      background: blue;</span><br><span class="line">  &#125;</span><br><span class="line">  .item&#123;</span><br><span class="line">      height: 80px;</span><br><span class="line">      width: 80px;</span><br><span class="line">      border: 1px solid black;</span><br><span class="line">      display: inline-block;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">             6666</span><br><span class="line">              &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">          &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/image/css/vertical-align/more1.jpg" alt="" title="" class="">                <p></p>            </figure><p>现在修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//其他不变</span><br><span class="line">.item&#123;</span><br><span class="line">     vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/more2.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>为什么呢，原因是，item改为vertical-align: middle时，直接将父baseline改到自身的中部位置了，<br>这个例子说明，<strong>父级内的空的inline-block元素，可以通过vertical-align: middle将父baseline改到自身的中部位置。</strong></p><h3 id="为什么会有间隙"><a href="#为什么会有间隙" class="headerlink" title="为什么会有间隙"></a>为什么会有间隙</h3><p>上面的例子中，看到因为 img 的存在，导致了父层底部与图片底部有间隙。 这是因为，img 的排版默认是按照行盒子排列的，也就是按照baseline对齐，而baseline与行盒子的底线是有一定距离的，这个距离就是间隙。<br>当img 的父层 字体越大时，间隙越大。<br><strong>这种现象一般出现于图片，在项目中遇到图片排列时，要注意会产生这种间隙。</strong><br>再举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">       background: blue;</span><br><span class="line">       font-size: 50px;</span><br><span class="line">   &#125;</span><br><span class="line">   img&#123;</span><br><span class="line">       height: 150px;</span><br><span class="line">       width: 200px;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">       &lt;img src=&quot;./git3.png&quot; /&gt;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/css/vertical-align/verialign-1.jpg" alt="" title="" class="">                <p></p>            </figure><p>消除间隙的方法是，给img 一个vertical-align：middle或者其他值都可以。</p><h3 id="如何确定父元素的baseline"><a href="#如何确定父元素的baseline" class="headerlink" title="如何确定父元素的baseline"></a>如何确定父元素的baseline</h3><p>父元素的baseline依据其内部行内元素类型不同，baseline不同。<br>通过以上例子，我们可以看到</p><h4 id="全部是行内元素"><a href="#全部是行内元素" class="headerlink" title="全部是行内元素"></a>全部是行内元素</h4><p>当父元素内，全部是行内元素(非inline-block)时，类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">   abc文字符</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>父元素内的baseline 由’abc文字符’这几个字确定，此时父baseline就是文字的下划线的位置上</p><h4 id="有inline-block"><a href="#有inline-block" class="headerlink" title="有inline-block"></a>有inline-block</h4><p>如果父元素内有inline-block，且inline-block内没有文字时，父baseline就是inline-block的下边距线；<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;inline-block&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>如果父元素内有多个inline-block，且有些inline-block内有文字时,此时父元素内的baseline以没有文字的inline-block为准；<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;inline-block&quot;&gt;来电文字&lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;inline-block&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>详细，参见上面例子。</p><h4 id="有img图片"><a href="#有img图片" class="headerlink" title="有img图片"></a>有img图片</h4><p>父元素含有img图片其实就是空的inline-block，规则参见《有inline-block》</p><h4 id="可使用vertical-align修改父基线"><a href="#可使用vertical-align修改父基线" class="headerlink" title="可使用vertical-align修改父基线"></a>可使用vertical-align修改父基线</h4><p>父级内的空的inline-block元素，可以通过设置不同的vertical-align值达到修改父baseline。<br>见《另外一个例子》</p><h3 id="如何确定自己的baseline"><a href="#如何确定自己的baseline" class="headerlink" title="如何确定自己的baseline"></a>如何确定自己的baseline</h3><p>这里的自己，就是上面例子中的a1、a2、字符串等等的行内元素，依据不同类型行内元素的自己，baseline取值不同</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>这个最简单，基线几乎等于紧贴字符串的下划线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc字符串</span><br></pre></td></tr></table></figure></p><h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><p>当自己是inline-block时，<br>分两种情况：</p><ul><li><p>当自己是空的inline-block时，自己的基线就是自己的下边框,如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;inline-block&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>当自己是非空的inline-block时，自己的基线就是自己元素内部的字符串的下边框，也就是紧贴字符串的下划线,更多请参考《为什么之后不对齐》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;inline-block&quot;&gt;abc456&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="img"><a href="#img" class="headerlink" title="img"></a>img</h4><p>这种最好分别，参考同《inline-block》的空inline-block情况，它的基线就是图片下边框。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>要解答文首抛出的疑问，我们要了解 父元素的baseline 如何确定；<br>inline-block内有无文字时，其baseline如何确定；<br>中间涉及到行内盒子的x-height概念。<br>而vertical-align并没有什么神秘，其实就是制定对齐规则而已。<br>本例只专门讨论<br>vertical-align:baseline<br>vertical-align:middle<br>这两种情况，用得最多，其他情况根据这两种情况类推就行。</p><p>还要特别注意的，在mdn上说了，<strong>vertical-align只作用于 行内元素，inline-block，img 这些元素。</strong></p><h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><h4 id="为什么有间隙"><a href="#为什么有间隙" class="headerlink" title="为什么有间隙"></a>为什么有间隙</h4><p>在文首的提问中，为什么这里有缝隙呢，<a href="https://www.cnblogs.com/starof/p/4512284.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">原来这个默认vertical-align:baseline，而baseline的下方会给字母的一部分留出空间，因此会产生一个空隙，要产生理想的效果</a>,链接上文章上说它与vertical-align有关（顺便说下，此链接上的文章有些例子有问题，注意了），至于为什么或者到底是否与vertical-align有关就不要穷究了，可能是vertical-align造成就行。<br><figure class="image-box">                <img src="/image/css/question1.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="利用伪类垂直居中"><a href="#利用伪类垂直居中" class="headerlink" title="利用伪类垂直居中"></a>利用伪类垂直居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  .wrap &#123;</span><br><span class="line">        background: #00bcd4ba;</span><br><span class="line">        height: 150px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .item &#123;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .item1 &#123;</span><br><span class="line">        height: 50px;</span><br><span class="line">        width: 50px;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .item2 &#123;</span><br><span class="line">        height: 80px;</span><br><span class="line">        width: 80px;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        background: blue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">    80版经典上海滩</span><br><span class="line">    &lt;div class=&quot;item1 item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item2 item&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果：<br><figure class="image-box">                <img src="/image/css/vertical-align/after1.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>你看到就算你把item1和item2都做了vertical-align: middle;<br>都无法让元素相对于整个wrap元素垂直居中，<br>增加下面代码就可以了,给父层增加一个伪类，设置这个伪类为inline-block,从而能设置宽高；<br>这个伪类的高度撑满整个wrap，然后设置vertical-align: middle;<br>因为这个伪类的高度相对其他元素最高，所以，它设置vertical-align: middle会将父元素的baseline拉到伪类的中部去，<br>而伪类又与父元素同高，这样就可以达到相对父元素垂直居中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.wrap::after &#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    height: 100%;</span><br><span class="line">    &lt;!-- 注意的是上面代码不起作用时，可以定义width: 1px; 一般是不必定义width: 1px--&gt;</span><br><span class="line">    &lt;!-- width: 1px; --&gt;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实这样的after伪类有些人也称为幽灵元素。<br>效果：<br><figure class="image-box">                <img src="/image/css/vertical-align/after2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="关于vertical-align你要知道的"><a href="#关于vertical-align你要知道的" class="headerlink" title="关于vertical-align你要知道的"></a>关于vertical-align你要知道的</h3><p>vertical-align 就是用来让行内元素对齐的；vertical-align这个属性就是为了行内元素而生，如果没有行内元素，vertical-align就没有任何存在的意义；<br>同样的，如何要做行内元素的对齐，你可以不使用vertical-align，但如果不懂vertical-align，那么你能把行内元素做得对齐，也是碰运气，瞎搞搞。<br>要全面的理解vertical-align，不仅要知道vertical-align的定义，还要知道行内元素的特性，如行内元素的基线；<br>还要知道父元素的基线(这是最难的)，还要知道行盒子的概念，例如x-height,行盒子的baseline；<br>很多奇型八怪的问题都是 父元素 与 行内元素的vertical-align 搞出来的。</p><h2 id="行盒子"><a href="#行盒子" class="headerlink" title="行盒子"></a>行盒子</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>每行文本都会生成一个行盒子。(语出《精通css 高级web标准解决方案》)<br>行盒子主要涉及以下概念：<br>x-height；<br>行盒子的baseline；<br>注意font-size 与 行盒子的关系；<br>半铅空(《精通css 高级web标准解决方案》有讲到)，以下也有讲解；<br>直接上图理解吧，以下三张都是行盒子介绍图：<br><figure class="image-box">                <img src="/image/css/vertical-align/column.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/vertical-align/x-height.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/vertical-align/inline-box.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="行盒子-与-行内盒子"><a href="#行盒子-与-行内盒子" class="headerlink" title="行盒子 与 行内盒子"></a>行盒子 与 行内盒子</h3><p>span、strong等等这些是行内元素，他们内容以<strong>行内盒子</strong>形式展示，直白的说span 元素就是一个行内盒子；<br>由一行文本形成的水平盒子叫行盒子，行盒子的高度由它所包含的行内盒子决定；<br>以上均语出《css精通》 P43 P44。<br>由上可知，行盒子可以包含很多个行内盒子。当行盒子只有一个行内盒子时，行内盒子就是行盒子。</p><h3 id="x-height"><a href="#x-height" class="headerlink" title="x-height"></a>x-height</h3><p>x-height,也就是上面图片中的x高度，说白点，就是小写字母X的高度；<br>另外一个注意的是，<strong>相同的font-size，相同的字符，在不同的字体font-family中x-height是不同的</strong>，这也就解释了有些字体下，明明文本看起来是居中的，换其他字体可能就看起来不太居中了。<br>上面的例子中，font-size,默认是浏览器的16px，那么x-height值差不多是font-size的三分之一，就是5px左右。</p><h3 id="line-height居中原理"><a href="#line-height居中原理" class="headerlink" title="line-height居中原理"></a>line-height居中原理</h3><p>我们经常会利用将height于line-height设置成一致进行居中，如下，然而，这个原理是什么呢？ 其实它的居中利用的是行盒子上下两个半铅空永远相等得到的,下面会慢慢讲解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height: 100%;</span><br><span class="line">line-height: 100%;</span><br></pre></td></tr></table></figure></p><p>我们先看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">    background: #00bcd4b5;</span><br><span class="line">    height: 75px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">   经典good morning, koa2!</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>此时wrap内的文字不居中，这个不居中与 “经典good morning, koa2!”这段文本生成的行盒子有莫大关系，<br>根据line-height默认值是1.2，我们可以画出行盒子的line-height,下面是这串代码的效果图和文本行生成的行盒子：<br><figure class="image-box">                <img src="/image/css/vertical-align/line-height.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>其他不变，我们把line-height设置为75px:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">    line-height: 75px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>居中了，效果如下：<br><figure class="image-box">                <img src="/image/css/vertical-align/line-height2.jpg" alt="" title="" class="">                <p></p>            </figure><br>由图中可以看出，使用height与line-height相同值达到居中的，其实是利用了行盒子半铅空相等的特性,因为在行盒子内，文本相对于行盒子，永远是居中的，行盒子的高度取决于line-height，如何将line-height的值设成与height一致，就达到了，height高度下的文字居中了。</p><h2 id="父元素与对齐相关的概念"><a href="#父元素与对齐相关的概念" class="headerlink" title="父元素与对齐相关的概念"></a>父元素与对齐相关的概念</h2><p>这里说的父元素，就是上面通篇都在讲的父元素,这个父元素一般就是一个div，div内有文字，有inline-block元素，有img；（img也是一种inline-block），<br>那么这个父元素与行内元素垂直对齐相关的有哪些概念或属性呢，直接上图说明：<br><figure class="image-box">                <img src="/image/css/vertical-align/father.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>为什么这些属性与行内元素垂直对齐相关呢，这都是因为vertical-align,我们说过，vertical-align就是为了行内元素对齐而生而创造的，<br>vertical-align有以下对齐方式，可参考mdn：<br>baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length><br>这些对齐方式就是基于父元素的相关属性。<br>具体信息参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">mdn</a></length></percentage></p><h2 id="行内元素与对齐相关的概念"><a href="#行内元素与对齐相关的概念" class="headerlink" title="行内元素与对齐相关的概念"></a>行内元素与对齐相关的概念</h2><p>这里的行内元素，包含了inline-block、img元素；<br>行内元素与对齐相关的 是 元素中部、顶部、底部、基线；<br>前三者好理解，只有基线这个不好理解，请参考《如何确定自己的baseline》</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于如何划定父元素的baseline，目前就算官方也没有一个很清晰的定义，上文中关于baseline的划定，在参考了很多资料后，很多都基于试验而来,读者请分别好。<br>另外就参考资料而言，mdn里面讲得很好，解释了vertical-align特性，还讲了元素的基线确定。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">MDN</a><br><a href="https://www.w3schools.com/cssref/pr_pos_vertical-align.asp" target="_blank" rel="noopener">外网w3c</a><br><a href="http://www.ituring.com.cn/book/1910" target="_blank" rel="noopener">精通css 高级web标准解决方案</a></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> vertical-align </tag>
            
            <tag> baseline </tag>
            
            <tag> 行盒子 </tag>
            
            <tag> x-height </tag>
            
            <tag> line-height </tag>
            
            <tag> 半铅空 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>canvas笔记</title>
      <link href="/2021/01/03/canvas/"/>
      <url>/2021/01/03/canvas/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="html5、canvas、svg、WebGL历史"><a href="#html5、canvas、svg、WebGL历史" class="headerlink" title="html5、canvas、svg、WebGL历史"></a>html5、canvas、svg、WebGL历史</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>html5的草案大概是2008年开始制定，用来取代1999制定的html 4.1，经历了html5草案制定，到2014年最终标准发布。<br>canvas <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Drawing_graphics" target="_blank" rel="noopener">由苹果公司在 2004 年前后发明运用于Safari，后来其他的浏览器开始跟进</a>，后来canvas被收入到html5草案中，之后大家对canvas关注越来越多(canvas被大家越来越多的关注，我推测应该在2008左右)，一直到2014年随着html5，作为标准发布。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG" target="_blank" rel="noopener">SVG 是由万维网联盟（W3C）自 1999 年开始开发的开放标准</a>，与canvas使用js绘图不同，svg使用xml来画图。</p><h4 id="canvas是html5"><a href="#canvas是html5" class="headerlink" title="canvas是html5"></a>canvas是html5</h4><p>canvas是html5.0的标准，在此前的标准(W3C标准,html4.1)中从未有过canvas，在html5.0标准于2014年被公布以前，canvas一直存在于html5.0的草案当中。</p><h4 id="svg不是html5新创的标签"><a href="#svg不是html5新创的标签" class="headerlink" title="svg不是html5新创的标签"></a>svg不是html5新创的标签</h4><p>svg不是html5才出现的新标签，它在1999年就被开始制定，彼时还没有所谓的html5，但这不妨碍svg与html5的联系，因为在html5.0中，svg被丰富了更多的功能。<br>所以在html5之前与之后的svg，其功能还是有区别的。</p><h4 id="canvas与svg的发展和区别"><a href="#canvas与svg的发展和区别" class="headerlink" title="canvas与svg的发展和区别"></a>canvas与svg的发展和区别</h4><p>svg不是什么新的技术了，于1999年被创造后，一直到现在，svg并没有太多的突破发展。<br>相比而言，canvas是比较新的技术，于2008年(年份基于上面的推测)被大家关注以来，到现在，先后被用于2D，3D的位图绘制。</p><h5 id="从发展速度而言："><a href="#从发展速度而言：" class="headerlink" title="从发展速度而言："></a>从发展速度而言：</h5><p>从这一点来看，canvas要比svg发展更快。</p><h5 id="从运用的角度来讲："><a href="#从运用的角度来讲：" class="headerlink" title="从运用的角度来讲："></a>从运用的角度来讲：</h5><p>svg用于矢量图绘制，canvas用于位图绘制，所以二者不是纯粹的替代竞争关系；</p><ul><li>只要你对矢量图有需求，svg永远不会被消失；</li><li>只要你对位图有需求，canvas永远不会被消失；</li><li>只要你对图有需求，svg和canvas都是你的选择；<h5 id="就兼容性而言："><a href="#就兼容性而言：" class="headerlink" title="就兼容性而言："></a>就兼容性而言：</h5>svg、canvas 所有的浏览器都兼容，不同的是，svg因为很早就出现了，就算是低版本的浏览器也都兼容；<br>而canvas相对而言比较新，一些低版本的浏览器不支持，好消息是，都9102了，市面上的浏览器的版本基本都支持canvas，不用太担心兼容问题。<h4 id="WebGL与canvas的关系"><a href="#WebGL与canvas的关系" class="headerlink" title="WebGL与canvas的关系"></a>WebGL与canvas的关系</h4>WebGL是基于canvas元素绘制3D图的js API。</li></ul><h3 id="canvas基于状态绘图的特性"><a href="#canvas基于状态绘图的特性" class="headerlink" title="canvas基于状态绘图的特性"></a>canvas基于状态绘图的特性</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>先设置好路径作为绘图状态，再使用绘制的api绘图，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//设置状态</span><br><span class="line">context.moveTo(100,100)</span><br><span class="line">context.lineTo(700,700)</span><br><span class="line">context.lineWidth = 10</span><br><span class="line">context.strokeStyle = “#058”</span><br><span class="line"></span><br><span class="line">//绘图</span><br><span class="line">context.stroke()</span><br></pre></td></tr></table></figure></p><h4 id="使用beginPath来分别设置状态"><a href="#使用beginPath来分别设置状态" class="headerlink" title="使用beginPath来分别设置状态"></a>使用beginPath来分别设置状态</h4><p>如上面代码，canvas不针对某一个形状进行状态设置，因此设置的状态都是针对全局的，假如我们要对画布内几个图形分别设置状态如颜色，<br>此时需配合beginPath使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath()</span><br><span class="line">context.moveTo(100,100)</span><br><span class="line">context.lineTo(700,700)</span><br><span class="line">context.lineWidth = 10</span><br><span class="line">context.strokeStyle = “#058”</span><br><span class="line"></span><br><span class="line">context.beginPath()</span><br><span class="line">context.moveTo(1100,1100)</span><br><span class="line">context.lineTo(1700,1700)</span><br><span class="line">context.lineWidth = 15</span><br><span class="line">context.strokeStyle = “red”</span><br><span class="line"></span><br><span class="line">//绘图</span><br><span class="line">context.stroke()</span><br></pre></td></tr></table></figure></p><h3 id="moveTo-与-lineTo"><a href="#moveTo-与-lineTo" class="headerlink" title="moveTo 与 lineTo"></a>moveTo 与 lineTo</h3><h4 id="beginPath与lineTo一起，lineTo相当于-moveTo"><a href="#beginPath与lineTo一起，lineTo相当于-moveTo" class="headerlink" title="beginPath与lineTo一起，lineTo相当于 moveTo"></a>beginPath与lineTo一起，lineTo相当于 moveTo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath()</span><br><span class="line">context.moveTo(100,100)</span><br><span class="line">context.lineTo(700,700)</span><br></pre></td></tr></table></figure><p>等同于，因为beginPath相当于从新开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath()</span><br><span class="line">context.lineTo(100,100)</span><br><span class="line">context.lineTo(700,700)</span><br></pre></td></tr></table></figure></p><h3 id="先填充后描边：先fill后stroke"><a href="#先填充后描边：先fill后stroke" class="headerlink" title="先填充后描边：先fill后stroke"></a>先填充后描边：先fill后stroke</h3><p>如果你要对一个矩形填充，并且绘制样式多样的边线，那么请先fill，后stroke，反之 填充的效果就覆盖了线条的效果。</p><h3 id="接口汇集"><a href="#接口汇集" class="headerlink" title="接口汇集"></a>接口汇集</h3><h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rect( x , y , width , height )</span><br><span class="line">fillRect( x , y , width , height )</span><br><span class="line">strokeRect( x , y , width , height )</span><br></pre></td></tr></table></figure><h4 id="填充与绘制"><a href="#填充与绘制" class="headerlink" title="填充与绘制"></a>填充与绘制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stroke()</span><br><span class="line">fill()</span><br></pre></td></tr></table></figure><h3 id="beginPath、-closePath"><a href="#beginPath、-closePath" class="headerlink" title="beginPath、 closePath"></a>beginPath、 closePath</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>画一个形状时，需要cxt.beginPath()，但closePath不是必须，可以不使用，下次再使用cxt.beginPath()时，会默认自动closePath上一个路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cxt.beginPath();</span><br><span class="line">cxt.arc( x+j*2*(RADIUS+1)+(RADIUS+1) , y+i*2*(RADIUS+1)+(RADIUS+1) , RADIUS , 0 , 2*Math.PI )</span><br><span class="line">cxt.closePath()</span><br><span class="line">cxt.fill()</span><br></pre></td></tr></table></figure></p><h4 id="closePath不是必须"><a href="#closePath不是必须" class="headerlink" title="closePath不是必须"></a>closePath不是必须</h4><p>参考上面分析</p><h4 id="第一个beginPath可以省略"><a href="#第一个beginPath可以省略" class="headerlink" title="第一个beginPath可以省略"></a>第一个beginPath可以省略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath()//可省略</span><br><span class="line">context.moveTo(100,100)</span><br><span class="line">context.lineTo(700,700)</span><br><span class="line"></span><br><span class="line">context.beginPath()</span><br><span class="line">context.moveTo(1100,1100)</span><br><span class="line">context.lineTo(1700,1700)</span><br></pre></td></tr></table></figure><h4 id="封闭图形推荐使用closePath"><a href="#封闭图形推荐使用closePath" class="headerlink" title="封闭图形推荐使用closePath"></a>封闭图形推荐使用closePath</h4><p>封闭图形使用closePath的好处在于，自动封闭严密，一些封闭不齐，有凹角等等问题，都会被自动解决。</p><h4 id="使用beginPath来分别设置状态-1"><a href="#使用beginPath来分别设置状态-1" class="headerlink" title="使用beginPath来分别设置状态"></a>使用beginPath来分别设置状态</h4><p>参考《canvas基于状态绘图的特性 – 使用beginPath来分别设置状态》</p><h3 id="生成-2d-画布上下文的要素"><a href="#生成-2d-画布上下文的要素" class="headerlink" title="生成(2d)画布上下文的要素"></a>生成(2d)画布上下文的要素</h3><p>注意的是canvas.width，不要使用css的方式嵌入，具体原因待写，最好直接以style属性或js直接写入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var context = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">canvas.width = WINDOW_WIDTH;</span><br><span class="line">canvas.height = WINDOW_HEIGHT;</span><br></pre></td></tr></table></figure></p><h3 id="线条属性"><a href="#线条属性" class="headerlink" title="线条属性"></a>线条属性</h3><h4 id="lineCap-线条的帽子"><a href="#lineCap-线条的帽子" class="headerlink" title="lineCap 线条的帽子"></a>lineCap 线条的帽子</h4><p>线条两端的倒角设置。</p><h4 id="lineJoin-折线的帽子"><a href="#lineJoin-折线的帽子" class="headerlink" title="lineJoin 折线的帽子"></a>lineJoin 折线的帽子</h4><p>设置折线两条线相交处的倒角。</p><h4 id="miterLimit-折线交点距离"><a href="#miterLimit-折线交点距离" class="headerlink" title="miterLimit 折线交点距离"></a>miterLimit 折线交点距离</h4><p>miterLimit 是折线中心线交点与折线外边线交点距离<br>此属于通常与lineJoin一起使用，用来设置折线的尖角的尖锐度,下面是原理图：<br><figure class="image-box">                <img src="/image/canvas/miter.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="画五角星"><a href="#画五角星" class="headerlink" title="画五角星"></a>画五角星</h3><figure class="image-box">                <img src="/image/canvas/five_star.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line">          canvas.width = <span class="number">800</span>;</span><br><span class="line">          canvas.height = <span class="number">800</span>;</span><br><span class="line">          <span class="keyword">var</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">          context.lineWidth = <span class="number">10</span>;</span><br><span class="line">          drawStar(context, <span class="number">150</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">400</span>)</span><br><span class="line">          <span class="comment">//rotate旋转角度</span></span><br><span class="line">          <span class="comment">//r,R,x,y 小圆，大圆，x方向偏移量，y方向偏移量</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">drawStar</span>(<span class="params">cxt,r,R,x,y,rotate=<span class="number">0</span></span>)</span>&#123;</span><br><span class="line">          cxt.beginPath();</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">              cxt.lineTo(<span class="built_in">Math</span>.cos((<span class="number">18</span> + i*<span class="number">72</span> - rotate)/<span class="number">180</span> * <span class="built_in">Math</span>.PI) * R + x,</span><br><span class="line">              -<span class="built_in">Math</span>.sin((<span class="number">18</span> + i*<span class="number">72</span> - rotate)/<span class="number">180</span> * <span class="built_in">Math</span>.PI) * R + y);</span><br><span class="line">              cxt.lineTo(<span class="built_in">Math</span>.cos((<span class="number">54</span> + i*<span class="number">72</span> - rotate)/<span class="number">180</span> * <span class="built_in">Math</span>.PI) * r + x,</span><br><span class="line">              -<span class="built_in">Math</span>.sin((<span class="number">54</span> + i*<span class="number">72</span> - rotate)/<span class="number">180</span> * <span class="built_in">Math</span>.PI) * r + y);</span><br><span class="line">          &#125;</span><br><span class="line">          context.closePath();</span><br><span class="line">          context.stroke();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="阴影的理解"><a href="#阴影的理解" class="headerlink" title="阴影的理解"></a>阴影的理解</h3><p>阴影是围绕图形的一层阴影图形，这个阴影图形是固定的，当你对这个阴影图形进行向右偏移时，<strong>阴影图形大小不变，图形将整体平移</strong>，这样阴影图形的左侧就会被原图形给<strong>遮挡</strong>，导致看起来只看到图形只有右侧才有阴影。</p><h4 id="shadowOffsetX"><a href="#shadowOffsetX" class="headerlink" title="shadowOffsetX"></a>shadowOffsetX</h4><p>下面两张图片分别展示了 阴影图形平移原理，具体是 阴影图形不变，整体偏移被遮挡。<br><figure class="image-box">                <img src="/image/canvas/shadow1.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/canvas/shadow2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="shadowBlur-模糊程度"><a href="#shadowBlur-模糊程度" class="headerlink" title="shadowBlur 模糊程度"></a>shadowBlur 模糊程度</h4><p>一般的人说这个是模糊程度，我觉得这个说法不太准确，shadowBlur是扩散并模糊才对，因为shadowBlur会导致阴影扩散的长度，比如定义为10的时候，阴影将扩散长度10px，然后针对这10px进行模糊，会导致阴影的。<br>此时，如果定义 shadowBlur 为30，然后偏移量 shadowOffsetX为10，会出现图形四周都有阴影，但左侧阴影长度为20，右侧为40，上下为30.<br><figure class="image-box">                <img src="/image/canvas/shadowblur.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="globalAlpha-透明度"><a href="#globalAlpha-透明度" class="headerlink" title="globalAlpha 透明度"></a>globalAlpha 透明度</h3><p>设置canvas的透明度</p><h3 id="图形叠加的遮盖设置"><a href="#图形叠加的遮盖设置" class="headerlink" title="图形叠加的遮盖设置"></a>图形叠加的遮盖设置</h3><p>可以通过globleCompositeOperation 设置图形叠加时，如何遮盖的问题：<br><figure class="image-box">                <img src="/image/canvas/shadowblur.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="剪辑区域-clip"><a href="#剪辑区域-clip" class="headerlink" title="剪辑区域 clip"></a>剪辑区域 clip</h3><p>与路径规划函数(如arc)等等共同使用，clip先使用，使canvas绘制区域只显示在clip的路径内，其他区域只显示整个context.fillStyle。<br><figure class="image-box">                <img src="/image/canvas/clip.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> context.beginPath();</span><br><span class="line">context.fillStyle=&apos;yellow&apos;</span><br><span class="line">context.fillRect(0,0,w,h);</span><br><span class="line">context.beginPath(); </span><br><span class="line">//指定clip路径    </span><br><span class="line">context.arc(ball.x,ball.y,ball.r,0,2*Math.PI);</span><br><span class="line">context.fillStyle=&apos;blue&apos;;</span><br><span class="line">context.fill();</span><br><span class="line">context.clip();</span><br><span class="line">context.beginPath();</span><br><span class="line">context.font=&apos;bold 120px Arial&apos;;</span><br><span class="line">context.textAlign=&apos;center&apos;;</span><br><span class="line">context.fillStyle=&apos;#ff55cc&apos;;</span><br><span class="line">context.fillText(&apos;天若有情&apos;,w/2,h/1.6);</span><br></pre></td></tr></table></figure></p><h4 id="探照灯动画-demo"><a href="#探照灯动画-demo" class="headerlink" title="探照灯动画 demo"></a>探照灯动画 demo</h4><p>代码如下，新颖的思想是：</p><ul><li>每一次轮询，创建一个方法 update 来更新路径，然后创建一个方法使用新的路径进行绘制。</li><li>先绘制，紧接着更新路径，然后轮询这个动作。</li><li>这个例子再一次印证了canvas的 规划路径 和 绘制是分开的。<br><a href="/Users/js/Desktop/work/git/canvas-demo/pages/canvas-master/绘图/探照灯.html">demo地址</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = $(<span class="string">'#canvas'</span>)[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">var</span> context=c.getContext(<span class="string">'2d'</span>);<span class="comment">//用context进行绘制</span></span><br><span class="line">   <span class="keyword">var</span> w =canvas.width;</span><br><span class="line">   <span class="keyword">var</span> h =canvas.height</span><br><span class="line">   <span class="keyword">var</span> ball=&#123;</span><br><span class="line">     x:w/<span class="number">2</span>,</span><br><span class="line">     y:h/<span class="number">2</span>,</span><br><span class="line">     r:<span class="number">100</span>,</span><br><span class="line">     vx:<span class="number">20</span>,</span><br><span class="line">     vy:<span class="number">15</span></span><br><span class="line">   &#125;</span><br><span class="line">   setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     draw();</span><br><span class="line">     update();</span><br><span class="line">   &#125;,<span class="number">50</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     context.clearRect(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line">     context.save(); <span class="comment">//////////</span></span><br><span class="line">     context.beginPath();</span><br><span class="line">     context.fillStyle=<span class="string">'black'</span></span><br><span class="line">     context.fillRect(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line">     context.beginPath();     </span><br><span class="line">     context.arc(ball.x,ball.y,ball.r,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">      context.fillStyle=<span class="string">'white'</span>;</span><br><span class="line">      context.fill();</span><br><span class="line">      context.clip();</span><br><span class="line">      context.beginPath();</span><br><span class="line">      context.font=<span class="string">'bold 120px Arial'</span>;</span><br><span class="line">      context.textAlign=<span class="string">'center'</span>;</span><br><span class="line">      context.fillStyle=<span class="string">'#ff55cc'</span>;</span><br><span class="line">      context.fillText(<span class="string">'天若有情'</span>,w/<span class="number">2</span>,h/<span class="number">3</span>);</span><br><span class="line">      context.fillText(<span class="string">'沧海桑田'</span>,w/<span class="number">2</span>,h/<span class="number">4</span>*<span class="number">3</span>);</span><br><span class="line">      context.restore();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     ball.x+=ball.vx;</span><br><span class="line">     ball.y+=ball.vy;</span><br><span class="line">     <span class="keyword">if</span>(ball.x&lt;=ball.r)&#123;</span><br><span class="line">       ball.x=ball.r;</span><br><span class="line">       ball.vx=-ball.vx;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(ball.x&gt;=w-ball.r)&#123;</span><br><span class="line">       ball.x=w-ball.r;</span><br><span class="line">        ball.vx=-ball.vx;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(ball.y&lt;=ball.r)&#123;</span><br><span class="line">       ball.y=ball.r;</span><br><span class="line">        ball.vy=-ball.vy;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(ball.y&gt;=h-ball.r)&#123;</span><br><span class="line">       ball.y=h-ball.r;</span><br><span class="line">        ball.vy=-ball.vy;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="clearRect"><a href="#clearRect" class="headerlink" title="clearRect"></a>clearRect</h3><p>常用于动画，当重新绘制图形时，使用此API清空画布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.clearRect(x,y width, height);</span><br></pre></td></tr></table></figure></p><h3 id="isPointInPath"><a href="#isPointInPath" class="headerlink" title="isPointInPath"></a>isPointInPath</h3><p>是否处于图形之内，<a href="/Users/js/Desktop/work/git/canvas-demo/pages/canvas-master/绘图/交互.html">查看demo</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.isPointInPath( x , y )</span><br></pre></td></tr></table></figure></p><h3 id="获取canvas坐标"><a href="#获取canvas坐标" class="headerlink" title="获取canvas坐标"></a>获取canvas坐标</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line">  canvas.mousemove(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//canvas画布内的x坐标 = 相对于整个视口x轴的值-画布离视口左侧的距离</span></span><br><span class="line">      <span class="keyword">var</span> x1= e.clientX-canvas.getBoundingClientRect().left;</span><br><span class="line">      <span class="keyword">var</span> y1= e.clientY-canvas.getBoundingClientRect().top;     </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="阴影-shadowColor相关"><a href="#阴影-shadowColor相关" class="headerlink" title="阴影 shadowColor相关"></a>阴影 shadowColor相关</h3><p>参考《对阴影的影响》</p><h2 id="黑知识"><a href="#黑知识" class="headerlink" title="黑知识"></a>黑知识</h2><h3 id="非零环绕原则"><a href="#非零环绕原则" class="headerlink" title="非零环绕原则"></a>非零环绕原则</h3><p>非零环绕原则 用来确认某一区域处于图形外面或里面；<br>如下图，A C处于图形里面，B处于图形外面，判断原则为：<br>区域内向外画一条线，这条线穿过N条线，指定一种方向为-1，相反方向为1，N条线加起来的值，<br>若为0，说明该区域处于图形外部；<br>若为非0，说明处于内部。<br><figure class="image-box">                <img src="/image/canvas/zero.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="圆圈内外圆顺-逆时针影响到的"><a href="#圆圈内外圆顺-逆时针影响到的" class="headerlink" title="圆圈内外圆顺\逆时针影响到的"></a>圆圈内外圆顺\逆时针影响到的</h3><h4 id="内外两个圆不指定方向"><a href="#内外两个圆不指定方向" class="headerlink" title="内外两个圆不指定方向"></a>内外两个圆不指定方向</h4><p>如下，不指定方向的时候，画出来的图是一个大的实心圆，并非希望的镂空圆圈。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var c = $(&apos;#canvas&apos;)[0];</span><br><span class="line"> var context=c.getContext(&apos;2d&apos;);</span><br><span class="line"> context.arc(400,250,100,0,2*Math.PI);//不指定方向</span><br><span class="line"> context.arc(400,250,50,0,2*Math.PI);//不指定方向</span><br><span class="line"> context.fillStyle=&apos;blue&apos;;</span><br><span class="line"> context.fill();</span><br></pre></td></tr></table></figure></p><h4 id="内外圆指定不同方向"><a href="#内外圆指定不同方向" class="headerlink" title="内外圆指定不同方向"></a>内外圆指定不同方向</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var c = $(&apos;#canvas&apos;)[0];</span><br><span class="line">   var context=c.getContext(&apos;2d&apos;);</span><br><span class="line">   context.arc(400,250,100,0,2*Math.PI, false);//顺时针</span><br><span class="line">   context.arc(400,250,50,0,2*Math.PI, true);//逆时针</span><br><span class="line">   context.fillStyle=&apos;blue&apos;;</span><br><span class="line">   context.fill();</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/canvas/ring.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="非零环绕原则-1"><a href="#非零环绕原则-1" class="headerlink" title="非零环绕原则"></a>非零环绕原则</h4><p>当指定不同方向时，利用非零环绕原则，内圆的区域相对于整个图形而言处于图形之外，此时fill方法不会填充此区域，产生镂空效果。</p><h4 id="对阴影的影响"><a href="#对阴影的影响" class="headerlink" title="对阴影的影响"></a>对阴影的影响</h4><p>代码和效果如下，正常的情况，阴影默认都应该位于图形外侧，如B的位置，<br>因此如果给内圆定义阴影的画，阴影应该位于A的位置，但实际情况却位于图中所示但C位置。<br>初一看觉得不合理，但是我们用非零环绕原则时，发现内圆的确处于图形外侧，因此阴影处于C的位置是对的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = $(<span class="string">'#canvas'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> context=c.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.arc(<span class="number">400</span>,<span class="number">250</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">  context.arc(<span class="number">400</span>,<span class="number">250</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  context.fillStyle=<span class="string">'rebeccapurple'</span>;</span><br><span class="line">  context.shadowColor = <span class="string">'blue'</span>;</span><br><span class="line">  context.shadowOffsetX = <span class="number">10</span>;</span><br><span class="line">  context.shadowOffsetY = <span class="number">10</span>;</span><br><span class="line">  context.shadowBlur = <span class="number">10</span>;</span><br><span class="line">  context.fill();</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/image/canvas/ring2.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="CanvasRenderingContext2D"><a href="#CanvasRenderingContext2D" class="headerlink" title="CanvasRenderingContext2D"></a>CanvasRenderingContext2D</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>对canvas扩展使用 CanvasRenderingContext2D 进行扩展。可以扩展新API，可扩展现在API(谨慎),可扩展一个对象，存放数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = $(<span class="string">'#canvas'</span>)[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">var</span> context=c.getContext(<span class="string">'2d'</span>);<span class="comment">//用context进行绘制</span></span><br><span class="line">   <span class="comment">//扩展对象</span></span><br><span class="line">   CanvasRenderingContext2D.prototype.lastMoveToLoc = &#123;&#125;;</span><br><span class="line">   <span class="comment">//扩展现有方法</span></span><br><span class="line">   <span class="keyword">var</span> originMoveto = CanvasRenderingContext2D.prototype.moveTo;</span><br><span class="line">   CanvasRenderingContext2D.prototype.moveTo = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">     originMoveto.apply(context, [x, y]);</span><br><span class="line">     <span class="keyword">this</span>.lastMoveToLoc.x = x;</span><br><span class="line">     <span class="keyword">this</span>.lastMoveToLoc.y = y;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//扩展新方法</span></span><br><span class="line">   CanvasRenderingContext2D.prototype.drawStar = <span class="function"><span class="keyword">function</span>(<span class="params">r,R,rot</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.beginPath();</span><br><span class="line">     <span class="keyword">var</span> x = <span class="keyword">this</span>.lastMoveToLoc.x;</span><br><span class="line">     <span class="keyword">var</span> y = <span class="keyword">this</span>.lastMoveToLoc.y;</span><br><span class="line">     <span class="keyword">var</span> rot1 = rot || <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">this</span>.lineTo(<span class="built_in">Math</span>.cos((<span class="number">18</span>+i*<span class="number">72</span>-rot1)/<span class="number">180</span>*<span class="built_in">Math</span>.PI)*R+x,</span><br><span class="line">       -<span class="built_in">Math</span>.sin((<span class="number">18</span>+i*<span class="number">72</span>-rot1)/<span class="number">180</span>*<span class="built_in">Math</span>.PI)*R+y)</span><br><span class="line">       <span class="keyword">this</span>.lineTo(<span class="built_in">Math</span>.cos((<span class="number">54</span>+i*<span class="number">72</span>-rot1)/<span class="number">180</span>*<span class="built_in">Math</span>.PI)*r+x,</span><br><span class="line">       -<span class="built_in">Math</span>.sin((<span class="number">54</span>+i*<span class="number">72</span>-rot1)/<span class="number">180</span>*<span class="built_in">Math</span>.PI)*r+y)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">this</span>.closePath();</span><br><span class="line">     <span class="keyword">this</span>.fill();</span><br><span class="line">   &#125;</span><br><span class="line">   context.fillStyle = <span class="string">'blue'</span>;</span><br><span class="line">   context.moveTo(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">   context.drawStar(<span class="number">150</span>,<span class="number">300</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure></p><h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p>参考上面</p><h4 id="扩展对象"><a href="#扩展对象" class="headerlink" title="扩展对象"></a>扩展对象</h4><p>参考上面</p><h2 id="图形变换"><a href="#图形变换" class="headerlink" title="图形变换"></a>图形变换</h2><h3 id="图形变换的API"><a href="#图形变换的API" class="headerlink" title="图形变换的API"></a>图形变换的API</h3><ul><li>位移 translate( x , y )</li><li>旋转 rotate( deg )</li><li>缩放 scale( sx , sy )</li></ul><h3 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h3><figure class="image-box">                <img src="/image/canvas/transform_matrix.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="transform-与-变换重置"><a href="#transform-与-变换重置" class="headerlink" title="transform 与 变换重置"></a>transform 与 变换重置</h3><p>当对context多次transform后，想丢弃、重置之前所有的transform的影响，可使用setTransform。<br>transform( a , b , c , d , e , f )<br>setTransform( a , b , c , d , e , f ) </p><h3 id="状态的保存和恢复-save-restore"><a href="#状态的保存和恢复-save-restore" class="headerlink" title="状态的保存和恢复(save\restore)"></a>状态的保存和恢复(save\restore)</h3><p>画两个矩形，第一个矩形向左偏移100，第二个矩形向左偏移200，<br>由于偏移都是对整个上下文执行的，为了免除第一次偏移的影响，在第一次偏移之前，执行save，保存当时的状态；<br>在给第二个矩形偏移之前，执行restore，将状态恢复到save时的状态。</p><h3 id="scale的副作用"><a href="#scale的副作用" class="headerlink" title="scale的副作用"></a>scale的副作用</h3><p>scale会对坐标点的 xy值、图形宽度、线条宽度都产生放大缩小效果。这是scale的特点，但也是副作用，用的时候需注意。</p><h3 id="fillStyle"><a href="#fillStyle" class="headerlink" title="fillStyle"></a>fillStyle</h3><h4 id="color"><a href="#color" class="headerlink" title="color"></a>color</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.fillStyle=&apos;red&apos;;</span><br></pre></td></tr></table></figure><h4 id="线性渐变color"><a href="#线性渐变color" class="headerlink" title="线性渐变color"></a>线性渐变color</h4><p>线性渐变颜色创建context.createLinearGradient。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//起始点坐标100 100， 终点 100 300；</span><br><span class="line">   var linear = context.createLinearGradient(100,100,100,300);</span><br><span class="line">   //addColorStop 第一参数是浮点数，取值范围为0-1，0表示起点，1表示终点</span><br><span class="line">   linear.addColorStop(0.0,&apos;green&apos;);</span><br><span class="line">   linear.addColorStop(0.5,&apos;yellow&apos;);</span><br><span class="line">   linear.addColorStop(1.0,&apos;blue&apos;);</span><br><span class="line">   context.fillStyle=linear;</span><br><span class="line">   context.fillRect(100,100,300,200);</span><br></pre></td></tr></table></figure></p><h4 id="径向渐变color"><a href="#径向渐变color" class="headerlink" title="径向渐变color"></a>径向渐变color</h4><p>用法与线性渐变一致，可网上查阅，这里不列出。</p><h4 id="图片填充"><a href="#图片填充" class="headerlink" title="图片填充"></a>图片填充</h4><p>使用API createPattern 创建填充图片<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bi=<span class="keyword">new</span> Image();</span><br><span class="line">bi.src=<span class="string">'autumn.jpg'</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = context.createPattern(bi,<span class="string">'repeat'</span>);</span><br><span class="line">context.beginPath();</span><br><span class="line">context.fillStyle=pattern;</span><br><span class="line">context.fillRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">300</span>);</span><br></pre></td></tr></table></figure></p><h3 id="createLinearGradient-线性渐变填充色"><a href="#createLinearGradient-线性渐变填充色" class="headerlink" title="createLinearGradient 线性渐变填充色"></a>createLinearGradient 线性渐变填充色</h3><p>此api用于创建线性渐变颜色，详细参考《线性渐变color》</p><h3 id="createPattern-图片填充"><a href="#createPattern-图片填充" class="headerlink" title="createPattern 图片填充"></a>createPattern 图片填充</h3><p>此API创建填充图片<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受图片</span></span><br><span class="line">  context.createPattern(img,<span class="string">'repeat'</span>)</span><br><span class="line"><span class="comment">//接受canvas画布</span></span><br><span class="line">  context.createPattern(canvas,<span class="string">'repeat'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="文字渲染API"><a href="#文字渲染API" class="headerlink" title="文字渲染API"></a>文字渲染API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.font = &quot;bold 40px Arial&quot;</span><br><span class="line">context.fillText( string , x , y , [maxlen] );</span><br><span class="line">context.strokeText( string , x , y  , [maxlen] );</span><br></pre></td></tr></table></figure><h3 id="一些几何思路"><a href="#一些几何思路" class="headerlink" title="一些几何思路"></a>一些几何思路</h3><h4 id="带倒角的矩形"><a href="#带倒角的矩形" class="headerlink" title="带倒角的矩形"></a>带倒角的矩形</h4><figure class="image-box">                <img src="/image/canvas/rect.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="圆的pi概念"><a href="#圆的pi概念" class="headerlink" title="圆的pi概念"></a>圆的pi概念</h4><figure class="image-box">                <img src="/image/canvas/arc.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="月亮"><a href="#月亮" class="headerlink" title="月亮"></a>月亮</h4><figure class="image-box">                <img src="/image/canvas/moon.jpg" alt="" title="" class="">                <p></p>            </figure><p>你也可以使用两段闭合的圆弧线来构建一个圆，<a href="">参考demo</a></p><h2 id="图像处理API"><a href="#图像处理API" class="headerlink" title="图像处理API"></a>图像处理API</h2><h3 id="drawImage-图像处理"><a href="#drawImage-图像处理" class="headerlink" title="drawImage 图像处理"></a>drawImage 图像处理</h3><h4 id="image-onload时加载"><a href="#image-onload时加载" class="headerlink" title="image.onload时加载"></a>image.onload时加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.src = &quot;img.jpg&quot;</span><br><span class="line">image.onload = function()&#123;</span><br><span class="line">    context.drawImage( image , 0, 0)</span><br><span class="line">&#125;</span><br><span class="line">context.drawImage( image , 300 , 100, 800, 300, 300, 300 ,200,200 )</span><br></pre></td></tr></table></figure><p>另外 drawImage有三种赋值模式：</p><h4 id="drawImage-image-0-0-–此模式不会缩放图片"><a href="#drawImage-image-0-0-–此模式不会缩放图片" class="headerlink" title="drawImage(image,0,0) –此模式不会缩放图片"></a>drawImage(image,0,0) –此模式不会缩放图片</h4><p>在画布的坐标 0，0的位置上开始画图片，图片以原像素和比例展示。</p><h4 id="drawImage-image-0-0-100-100"><a href="#drawImage-image-0-0-100-100" class="headerlink" title="drawImage(image,0,0,100,100)"></a>drawImage(image,0,0,100,100)</h4><p>在画布的坐标0，0上开始画图片，并且将整个图片放置于宽高都为100的区域内，图片会根据区域大小缩放。</p><h4 id="drawImage-image-0-0-100-100-0-0-200-200"><a href="#drawImage-image-0-0-100-100-0-0-200-200" class="headerlink" title="drawImage(image,0,0,100,100,0,0,200,200)"></a>drawImage(image,0,0,100,100,0,0,200,200)</h4><p>参数含义依次为：图片，原图片信息(0,0,100,100)，目的图片信息(0,0,200,200);<br>基本含义为：截取原图片坐标点为0，0起点宽高各100的区域，绘制到画布的坐标点0，0为起点，宽高各200的区域上。<br>截图的图片会按照目的区域大小缩放<br><figure class="image-box">                <img src="/image/canvas/drawImage.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="getImageData-获取图片信息"><a href="#getImageData-获取图片信息" class="headerlink" title="getImageData 获取图片信息"></a>getImageData 获取图片信息</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>getImageData 接受四个参数，这四个参数构造了一个矩形区域，分别是坐标点，宽高。表示获取该区域内所以图片的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const imageData = getImageData( x , y , width , height )</span><br><span class="line">imageData对象：</span><br><span class="line">width</span><br><span class="line">height</span><br><span class="line">data(图片像素等信息,以多维数组的方式展示)</span><br></pre></td></tr></table></figure></p><p>下面是imageData.data的信息，更多信息参考《putImageData 插入图像》：<br><figure class="image-box">                <img src="/image/canvas/put_data.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><p>图片存储在本地时，是默认没有域名的，如果不启动服务直接打开html，用getImageData方法时，浏览器会判定为跨域而报错！解决方法是启动本地服务打开html。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Uncaught DOMException: Failed to execute &apos;getImageData&apos; on &apos;CanvasRenderingContext2D&apos;: The canvas has been tainted by cross-origin data.</span><br><span class="line">at HTMLImageElement.document.getElementById.onload&quot;</span><br></pre></td></tr></table></figure></p><h3 id="putImageData-插入图像"><a href="#putImageData-插入图像" class="headerlink" title="putImageData 插入图像"></a>putImageData 插入图像</h3><p>其7个参数意思依次为：getImageData获取的图片imageData对象，坐标点x(也是相对于canvas的相对位移，故写成dx)，坐标点y，脏位移x(脏是因为通过putImageData获取的图片信息，不是纯正的原图片信息，是“被污染了的”数据)，脏位移y，脏图片宽度，脏图片高度。<br><figure class="image-box">                <img src="/image/canvas/put.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>要与 getImageData 一起使用，<a href="http://127.0.0.1:3000/canvas-image/05-image-copy/index.html" target="_blank" rel="noopener">demo 地址</a>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvasa = <span class="built_in">document</span>.getElementById(<span class="string">"canvasa"</span>)</span><br><span class="line">       <span class="keyword">var</span> contexta = canvasa.getContext(<span class="string">"2d"</span>)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> canvasb = <span class="built_in">document</span>.getElementById(<span class="string">"canvasb"</span>)</span><br><span class="line">       <span class="keyword">var</span> contextb = canvasb.getContext(<span class="string">"2d"</span>)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> image = <span class="keyword">new</span> Image()</span><br><span class="line"></span><br><span class="line">       <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">           image.src = <span class="string">"autumn.jpg"</span></span><br><span class="line">           image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">               contexta.drawImage( image , <span class="number">0</span> , <span class="number">0</span> , canvasa.width , canvasa.height )</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">copyImage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">var</span> imageData = contexta.getImageData( <span class="number">0</span> , <span class="number">0</span> , canvasa.width , canvasa.height )</span><br><span class="line">           <span class="keyword">var</span> pixelData = imageData.data</span><br><span class="line">           <span class="comment">//改变图片像素，让新copy出来的图片置灰</span></span><br><span class="line">           <span class="comment">// for( var i = 0 ; i &lt; canvasb.width * canvasb.height ; i ++ )&#123;</span></span><br><span class="line">           <span class="comment">//     var r = pixelData[i*4+0]</span></span><br><span class="line">           <span class="comment">//     var g = pixelData[i*4+1]</span></span><br><span class="line">           <span class="comment">//     var b = pixelData[i*4+2]</span></span><br><span class="line">           <span class="comment">//     var grey = r*0.3+g*0.59+b*0.11</span></span><br><span class="line">           <span class="comment">//     pixelData[i*4+0] = grey</span></span><br><span class="line">           <span class="comment">//     pixelData[i*4+1] = grey</span></span><br><span class="line">           <span class="comment">//     pixelData[i*4+2] = grey</span></span><br><span class="line">           <span class="comment">// &#125;</span></span><br><span class="line">           contextb.putImageData( imageData , <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , <span class="number">0</span> , canvasb.width , canvasb.height )</span><br><span class="line">           context.putImageData()</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h2 id="曲线绘制"><a href="#曲线绘制" class="headerlink" title="曲线绘制"></a>曲线绘制</h2><h3 id="arc-绘制圆弧"><a href="#arc-绘制圆弧" class="headerlink" title="arc 绘制圆弧"></a>arc 绘制圆弧</h3><p>注意，arc绘制的是一条弧线，并非闭合的不规则圆。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context.arc(</span><br><span class="line">centerx, centery, radius,</span><br><span class="line">startingAngle, endingAngle,</span><br><span class="line">anticlockwise = false</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="arcTo-需与-moveTo-的一起使用"><a href="#arcTo-需与-moveTo-的一起使用" class="headerlink" title="arcTo(需与 moveTo 的一起使用)"></a>arcTo(需与 moveTo 的一起使用)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context.moveTo( x0 , y0 )   开始点；</span><br><span class="line">context.arcTo( </span><br><span class="line">x1 , y1 ,               控制点；</span><br><span class="line">x2 , y2 ,               控制点；</span><br><span class="line">radius );               结束点；</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/image/canvas/arcTo.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="贝塞尔曲线-Bezier"><a href="#贝塞尔曲线-Bezier" class="headerlink" title="贝塞尔曲线 Bezier"></a>贝塞尔曲线 Bezier</h3><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>贝塞尔曲线类似于ps画图软件中的钢笔工具画出的线，无论下面介绍的二次还是三次曲线，它们都需要结合moveTo绘制开始点。</p><h4 id="需要moveTo配合绘制开始点"><a href="#需要moveTo配合绘制开始点" class="headerlink" title="需要moveTo配合绘制开始点"></a>需要moveTo配合绘制开始点</h4><p>参考上面</p><h4 id="二次贝塞尔曲线"><a href="#二次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线"></a>二次贝塞尔曲线</h4><p>二次贝塞尔曲线API是quadraticCurveTo，二次贝塞尔曲线与三次贝塞尔曲线的区别在于，二次不能画波浪线，三次可以：<br><figure class="image-box">                <img src="/image/canvas/bezeirinfo.jpg" alt="" title="" class="">                <p></p>            </figure><br>如下图所示，演示了开始点、控制点、结束点。<br><figure class="image-box">                <img src="/image/canvas/bezeir.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="三次贝塞尔曲线"><a href="#三次贝塞尔曲线" class="headerlink" title="三次贝塞尔曲线"></a>三次贝塞尔曲线</h4><p>三次贝塞尔曲线API是 bezierCurveTo 更多信息参考《二次贝塞尔曲线 Bezier》：<br><figure class="image-box">                <img src="/image/canvas/bezeircurve.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="画线条只能用stroke"><a href="#画线条只能用stroke" class="headerlink" title="画线条只能用stroke"></a>画线条只能用stroke</h3><p>如题，线条使用fill将无法绘制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath();</span><br><span class="line">context.moveTo(2,2)</span><br><span class="line">context.lineTo(300,400)</span><br><span class="line">context.lineWidth=5;</span><br><span class="line">context.fillStyle=&apos;yellow&apos;;</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure></p><h2 id="炫丽的倒计时效果demo"><a href="#炫丽的倒计时效果demo" class="headerlink" title="炫丽的倒计时效果demo"></a>炫丽的倒计时效果demo</h2><h3 id="数据建模–多维数组矩阵创建数字模型"><a href="#数据建模–多维数组矩阵创建数字模型" class="headerlink" title="数据建模–多维数组矩阵创建数字模型"></a>数据建模–多维数组矩阵创建数字模型</h3><p>用一个只有0和1的数组，1表示有路径，0表示填充为空。<br><figure class="image-box">                <img src="/image/canvas/digit.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/canvas/cell.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="计算数字矩阵模型内的元素坐标"><a href="#计算数字矩阵模型内的元素坐标" class="headerlink" title="计算数字矩阵模型内的元素坐标"></a>计算数字矩阵模型内的元素坐标</h3><p>如上图所示，只要我们能知道矩阵左上角的坐标值xy，就可以计算出矩阵内所有的元素坐标值；<br>值得注意的是，上面的i和j分别是二维数组的i和j，它们对应的初始值都是0，具体公式，参考上图。</p><h3 id="模拟抛物线路径"><a href="#模拟抛物线路径" class="headerlink" title="模拟抛物线路径"></a>模拟抛物线路径</h3><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aBall = &#123;</span><br><span class="line">       x:x+j*<span class="number">2</span>*(RADIUS+<span class="number">1</span>)+(RADIUS+<span class="number">1</span>),</span><br><span class="line">       y:y+i*<span class="number">2</span>*(RADIUS+<span class="number">1</span>)+(RADIUS+<span class="number">1</span>),</span><br><span class="line">       <span class="comment">//g是重力加速度，只影响在垂直方向的速度，Math.random() 创造每个不同小球不同的重力加速度，产生不同的速度，让每个小球运动更加自然</span></span><br><span class="line">       g:<span class="number">1.5</span>+<span class="built_in">Math</span>.random(),</span><br><span class="line">       <span class="comment">//vx小球在x 水平方向的速度，Math.pow( -1 , Math.ceil( Math.random()*1000 ) ) * 4 其实就是随机生成-4和4</span></span><br><span class="line">       vx:<span class="built_in">Math</span>.pow( <span class="number">-1</span> , <span class="built_in">Math</span>.ceil( <span class="built_in">Math</span>.random()*<span class="number">1000</span> ) ) * <span class="number">4</span>,</span><br><span class="line">       <span class="comment">//vx小球在y 垂直方向的速度，让小球有一个向上抛的动作。</span></span><br><span class="line">       vy:<span class="number">-5</span>,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; balls.length ; i ++ )&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//模拟抛物线路径</span></span><br><span class="line">       balls[i].x += balls[i].vx;</span><br><span class="line">       balls[i].y += balls[i].vy;</span><br><span class="line">       balls[i].vy += balls[i].g;</span><br><span class="line">   <span class="comment">//0.75是空气阻力，当球面落到地面时，小球应该反弹原来高度的0.75</span></span><br><span class="line">       <span class="keyword">if</span>( balls[i].y &gt;= WINDOW_HEIGHT-RADIUS )&#123;</span><br><span class="line">           balls[i].y = WINDOW_HEIGHT-RADIUS;</span><br><span class="line">           balls[i].vy = - balls[i].vy*<span class="number">0.75</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="x、y坐标值"><a href="#x、y坐标值" class="headerlink" title="x、y坐标值"></a>x、y坐标值</h4><p>参考上面代码</p><h4 id="g-重力加速度"><a href="#g-重力加速度" class="headerlink" title="g 重力加速度"></a>g 重力加速度</h4><p>参考上面代码</p><h4 id="vx-水平方向速度"><a href="#vx-水平方向速度" class="headerlink" title="vx 水平方向速度"></a>vx 水平方向速度</h4><p>参考上面代码</p><h4 id="vy-垂直方向速度"><a href="#vy-垂直方向速度" class="headerlink" title="vy 垂直方向速度"></a>vy 垂直方向速度</h4><p>参考上面代码</p><h4 id="空气阻力"><a href="#空气阻力" class="headerlink" title="空气阻力"></a>空气阻力</h4><p>参考上面代码</p><h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//只取屏幕内的元素</span><br><span class="line">    var cnt = 0</span><br><span class="line">    for( var i = 0 ; i &lt; balls.length ; i ++ )&#123;</span><br><span class="line">        //碰撞检测--满足下面情况说明在屏幕上</span><br><span class="line">        if( balls[i].x + RADIUS &gt; 0 &amp;&amp; balls[i].x -RADIUS &lt; WINDOW_WIDTH )&#123;</span><br><span class="line">            balls[cnt++] = balls[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//balls数组前面的元素，都是最先生成的，因此，也应该最先被删除</span><br><span class="line">    while( balls.length &gt; cnt )&#123;</span><br><span class="line">        balls.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="溢出删除的优化处理"><a href="#溢出删除的优化处理" class="headerlink" title="溢出删除的优化处理"></a>溢出删除的优化处理</h3><p>参考《碰撞检测》</p><h3 id="用50毫秒轮询模拟1秒的动作"><a href="#用50毫秒轮询模拟1秒的动作" class="headerlink" title="用50毫秒轮询模拟1秒的动作"></a>用50毫秒轮询模拟1秒的动作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setInterval(</span><br><span class="line">       <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="comment">//渲染时间的显示</span></span><br><span class="line">           renderTimes( context );</span><br><span class="line">           <span class="comment">//渲染小球的显示</span></span><br><span class="line">           renderBall( context );</span><br><span class="line">           <span class="comment">//更新时间 和 小球数据，以备下次时间和小球渲染使用</span></span><br><span class="line">           updateBallDatas();</span><br><span class="line">       &#125; , <span class="number">50</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p>当时在想，既然做一个定时器，那么就写一个1秒的轮询，这样才有道理，其实不然，如果写一个1秒的轮询就会有延迟的现象；<br>如果你用一个50毫秒的轮询，如果秒钟没有到达下一秒，画面其实也不会跳转，因为50毫秒内拿到什么画面，就显示什么画面，在一秒内，有20个50毫秒，<br>这20个50毫秒内拿到的时间肯定都是一个值，那么渲染出来的值肯定也是一个值，就不会有跳转，也不会出现延时，就算出现延时也只是50毫秒内，可以接受。<br>所以，要想做一个响应快速的，应该将轮询值改得更小，而不是放大。</p><h4 id="误区一：以为1秒的定时器就应该使用1秒的轮询"><a href="#误区一：以为1秒的定时器就应该使用1秒的轮询" class="headerlink" title="误区一：以为1秒的定时器就应该使用1秒的轮询"></a>误区一：以为1秒的定时器就应该使用1秒的轮询</h4><p>参考上面讲解</p><h4 id="误区一：以为50秒的轮询会让定时器加速跳转"><a href="#误区一：以为50秒的轮询会让定时器加速跳转" class="headerlink" title="误区一：以为50秒的轮询会让定时器加速跳转"></a>误区一：以为50秒的轮询会让定时器加速跳转</h4><p>参考上面讲解</p><h4 id="一秒的定时器，必须使用小于一秒的轮询"><a href="#一秒的定时器，必须使用小于一秒的轮询" class="headerlink" title="一秒的定时器，必须使用小于一秒的轮询"></a>一秒的定时器，必须使用小于一秒的轮询</h4><p>参考上面讲解</p><h4 id="轮询时间越小，延时更小，响应更快"><a href="#轮询时间越小，延时更小，响应更快" class="headerlink" title="轮询时间越小，延时更小，响应更快"></a>轮询时间越小，延时更小，响应更快</h4><p>参考上面讲解</p><h4 id="轮询时间需要平衡js代码执行时间和性能"><a href="#轮询时间需要平衡js代码执行时间和性能" class="headerlink" title="轮询时间需要平衡js代码执行时间和性能"></a>轮询时间需要平衡js代码执行时间和性能</h4><p>代码轮询时，执行了很多js，这些js如果非常大量，也是需要时间才能执行完，所以轮询时间要考虑是否大量执行js会延迟轮询时间，也要考虑性能。</p><h3 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a>demo地址</h3><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/index.html" target="_blank" rel="noopener">点击查看demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>d3笔记</title>
      <link href="/2021/01/03/d3/"/>
      <url>/2021/01/03/d3/</url>
      
        <content type="html"><![CDATA[<h2 id="d3知识"><a href="#d3知识" class="headerlink" title="d3知识"></a>d3知识</h2><h3 id="d3文档介绍"><a href="#d3文档介绍" class="headerlink" title="d3文档介绍"></a>d3文档介绍</h3><h4 id="d3各版本变化"><a href="#d3各版本变化" class="headerlink" title="d3各版本变化"></a>d3各版本变化</h4><p><a href="https://github.com/d3/d3/blob/master/CHANGES.md" target="_blank" rel="noopener">官网英文</a></p><h3 id="d3小知识点或技巧"><a href="#d3小知识点或技巧" class="headerlink" title="d3小知识点或技巧"></a>d3小知识点或技巧</h3><h4 id="gx-call-xAxis-与xAxis-gx-相等"><a href="#gx-call-xAxis-与xAxis-gx-相等" class="headerlink" title="gx.call(xAxis)与xAxis(gx)相等"></a>gx.call(xAxis)与xAxis(gx)相等</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//生成底部轴线</span><br><span class="line">const xAxis = d3.axisBottom(xScale);</span><br><span class="line">//设置轴线偏移位置</span><br><span class="line">const gx = svg.append(&apos;g&apos;).attr(&apos;transform&apos;, `translate($&#123;padding.left&#125;,$&#123;height - padding.bottom&#125;)`);</span><br><span class="line">//也可以写成xAxis(gx)</span><br><span class="line">gx.call(xAxis);</span><br></pre></td></tr></table></figure><h4 id="d3的图形与布局"><a href="#d3的图形与布局" class="headerlink" title="d3的图形与布局"></a>d3的图形与布局</h4><p>柱状图、折线图、散点图 是d3常见的图形。<br>除以上三种图形外，还有很多图形他们位置不固定（还有其他说法），比如饼图，饼图可以在任意位置，这个时候，就需要一种其他的画图方式，这种方式就是d3的布局。<br>d3的布局用法为 d3.layout.pie,d3的布局有12种，饼图是其中最简单一个。</p><h4 id="d3的坐标轴方向"><a href="#d3的坐标轴方向" class="headerlink" title="d3的坐标轴方向"></a>d3的坐标轴方向</h4><p>如图，d3的坐标轴，默认原点在左上角，y的正值是向下的。<br><figure class="image-box">                <img src="/image/d3/all/axio.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="transition-动画"><a href="#transition-动画" class="headerlink" title="transition 动画"></a>transition 动画</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>transition用来定义动画，<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/mars/lesson09/test01.html" target="_blank" rel="noopener">点击看完整demo</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">circle1.transition()</span><br><span class="line">        .duration(3000)</span><br><span class="line">        .attr(&quot;cx&quot;,200)</span><br><span class="line">        .delay(2000)</span><br><span class="line">        .transition()</span><br><span class="line">        .duration(3000)</span><br><span class="line">        .attr(&quot;cx&quot;,400)</span><br><span class="line">        .each(&quot;start&quot;,function () &#123; d3.select(this).attr(&quot;fill&quot;,&quot;blue&quot;);&#125;  )</span><br><span class="line">        .transition()</span><br><span class="line">        .duration(3000)</span><br><span class="line">        .attr(&quot;cy&quot;,400)</span><br><span class="line">        .each(&quot;start&quot;,function () &#123; d3.select(this).attr(&quot;fill&quot;,&quot;red&quot;);&#125;  )</span><br></pre></td></tr></table></figure></p><h4 id="duration"><a href="#duration" class="headerlink" title="duration"></a>duration</h4><p>duration定义延迟</p><h4 id="each"><a href="#each" class="headerlink" title="each"></a>each</h4><p>each可以定义start、end等行为</p><h3 id="生成坐标轴"><a href="#生成坐标轴" class="headerlink" title="生成坐标轴"></a>生成坐标轴</h3><h4 id="概述和代码"><a href="#概述和代码" class="headerlink" title="概述和代码"></a>概述和代码</h4><p>坐标轴一般用比例尺来做，用到比例尺就要用到两个概念 domain 与 range。<br>domain为实际数据范围，range为坐标轴的刻度范围，这个刻度范围是用来表示数据范围的。<br>所以数据范围与刻度范围形成一定比例。</p><p>以下都基于以下两个demo：<br><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/my-d3-practice/BarChart-full.html" target="_blank" rel="noopener">参考demo一</a><br><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/my-d3-practice/LineChart.html" target="_blank" rel="noopener">参考demo二</a></p><p>生成坐标轴的完整代码如下：<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const dataset = [50, 43, 120, 87, 99, 167, 142];</span><br><span class="line">//scaleBand生成序数分段比例尺，x轴通常使用scaleBand</span><br><span class="line">const xScale = d3.scaleBand().domain(dataset.map((d, i) =&gt; i)).range([0, xAxisWidth]).padding(0.1);</span><br><span class="line">//scaleLinear生成线性比例尺，y轴通常使用这个</span><br><span class="line">const yScale = d3.scaleLinear().domain([d3.max(dataset, d =&gt; d), 0]).range([0, yAxisWidth]);</span><br><span class="line"></span><br><span class="line">//生成底部轴线</span><br><span class="line">const xAxis = d3.axisBottom(xScale);</span><br><span class="line">//生成左侧轴线</span><br><span class="line">const yAxis = d3.axisLeft(yScale);</span><br><span class="line"></span><br><span class="line">//设置轴线偏移位置</span><br><span class="line">const gx = svg.append(&apos;g&apos;).attr(&apos;transform&apos;, `translate($&#123;padding.left&#125;,$&#123;height - padding.bottom&#125;)`);</span><br><span class="line">const gy = svg.append(&apos;g&apos;).attr(&apos;transform&apos;, `translate($&#123;padding.left&#125;,$&#123;height - padding.bottom - yAxisWidth&#125;)`);</span><br><span class="line">gx.call(xAxis);</span><br><span class="line">gy.call(yAxis);</span><br></pre></td></tr></table></figure></p><h4 id="生成比例尺的方法-scaleLinear-scaleBand"><a href="#生成比例尺的方法-scaleLinear-scaleBand" class="headerlink" title="生成比例尺的方法 scaleLinear\scaleBand"></a>生成比例尺的方法 scaleLinear\scaleBand</h4><p>这两个方法都是生成比例尺的方法，见《概述和代码》 </p><h4 id="domain-range"><a href="#domain-range" class="headerlink" title="domain range"></a>domain range</h4><p>见《概述和代码》；<br>除代码中外，还可以这样用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const xScale = d3.scaleBand().domain([1,2,3,4]).range([11,23,25,67]);</span><br><span class="line">xScale(2)//23  一一对应关系</span><br></pre></td></tr></table></figure></p><h4 id="ticks-不是一个确数"><a href="#ticks-不是一个确数" class="headerlink" title="ticks 不是一个确数"></a>ticks 不是一个确数</h4><p>ticks设置坐标轴的刻度数量，但不是你设置几个，最终显示几个，d3会自动设置在设置数的上下。<br>参考《groud 与 g》的demo</p><h4 id="domain-range-的单位"><a href="#domain-range-的单位" class="headerlink" title="domain range 的单位"></a>domain range 的单位</h4><p>如下， domain是值域，没有单位，纯粹代表数值大小；range是地域范围，单位是px，用来限定坐标轴占地面积大小。<br>demo 参考《groud 与 g》的demo。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var scalewidth = d3.scale.linear()</span><br><span class="line">                        .domain([0,80])</span><br><span class="line">                        .range([0,500])</span><br></pre></td></tr></table></figure></p><h3 id="生成对角线-直线-–d3-svg-diagonal"><a href="#生成对角线-直线-–d3-svg-diagonal" class="headerlink" title="生成对角线(直线)–d3.svg.diagonal"></a>生成对角线(直线)–d3.svg.diagonal</h3><h4 id="使用d3-svg-diagonal实现"><a href="#使用d3-svg-diagonal实现" class="headerlink" title="使用d3.svg.diagonal实现"></a>使用d3.svg.diagonal实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var canvas = d3.select(&quot;body&quot;)</span><br><span class="line">                 .append(&quot;svg&quot;)</span><br><span class="line">                 .attr(&quot;width&quot;,500)</span><br><span class="line">                 .attr(&quot;height&quot;,500);</span><br><span class="line"></span><br><span class="line">   var diagonal = d3.svg.diagonal()</span><br><span class="line">                       .source(&#123; x: 10 , y:10&#125;)</span><br><span class="line">                       .target(&#123; x: 300 , y: 300&#125;)</span><br><span class="line">  canvas.append(&quot;path&quot;)</span><br><span class="line">          .attr(&quot;fill&quot;,&quot;none&quot;)</span><br><span class="line">          .attr(&quot;stroke&quot;,&quot;black&quot;)</span><br><span class="line">          .attr(&quot;d&quot;,diagonal);</span><br></pre></td></tr></table></figure><h4 id="使用source和target定义起始和终点位置"><a href="#使用source和target定义起始和终点位置" class="headerlink" title="使用source和target定义起始和终点位置"></a>使用source和target定义起始和终点位置</h4><p>参考上面代码。</p><h3 id="生成折线图"><a href="#生成折线图" class="headerlink" title="生成折线图"></a>生成折线图</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>如图，坐标轴生成代码同《生成坐标轴》。下面的代码主要介绍生成折线图的折线。<br><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/my-d3-practice/LineChart.html" target="_blank" rel="noopener">demo地址</a><br><a href="https://www.bilibili.com/video/av13729975/?spm_id_from=333.788.videocard.1" target="_blank" rel="noopener">视频讲解</a><br><figure class="image-box">                <img src="/image/d3/all/liner.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//使用d3的方法来生成折线的path</span><br><span class="line"> const linePath = d3.line().x((d, i) =&gt; xScale(i) + padding.left + xScale.bandwidth() / 2)</span><br><span class="line">            .y(d =&gt; height - padding.bottom - (yScale(0) - yScale(d)));</span><br><span class="line">//将数据传给上面写好的 d3生成线的path方法，避免手动写繁杂的path(而这正是d3的本职工作)</span><br><span class="line">const line = svg.append(&apos;path&apos;).attr(&apos;d&apos;, linePath(dataset)).attr(&apos;stroke&apos;, &apos;#000&apos;)</span><br><span class="line">        .attr(&apos;stroke-width&apos;, &apos;3px&apos;).attr(&apos;fill&apos;, &apos;none&apos;);</span><br></pre></td></tr></table></figure></p><h4 id="手工写生成折线的path"><a href="#手工写生成折线的path" class="headerlink" title="手工写生成折线的path"></a>手工写生成折线的path</h4><p>svg的path手动写非常繁杂，手工写不现实，而这正是d3存在的原因之一，d3提供了丰富的方法用于生成path,也就是下面介绍到的d3.line()。</p><h4 id="d3-line-生成折线"><a href="#d3-line-生成折线" class="headerlink" title="d3.line()生成折线"></a>d3.line()生成折线</h4><p>参考本节的《概述》</p><h3 id="生成直方图"><a href="#生成直方图" class="headerlink" title="生成直方图"></a>生成直方图</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>如图，坐标轴生成代码同《生成坐标轴》。<br>直方图主要是绘制矩形柱状图 和 text的显示，具体下来就是如何确定柱状图的 x、y坐标，宽高度。<br><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/my-d3-practice/BarChart-full.html" target="_blank" rel="noopener">demo地址</a><br><a href="https://www.bilibili.com/video/av13492121/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">视频讲解</a></p><figure class="image-box">                <img src="/image/d3/all/barchart.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> //标尺</span><br><span class="line">const xScale = d3.scaleBand().domain(dataset.map((o, i) =&gt; i))</span><br><span class="line">.range([0, xAxisWidth]).padding(0.1);</span><br><span class="line">const yScale = d3.scaleLinear().domain([0, d3.max(dataset)]).rangeRound([yAxisWidth, 0]);</span><br><span class="line">//绘制矩形柱状图 的方法，</span><br><span class="line">const updateRect = svg.selectAll(&quot;rect&quot;).data(dataset)      </span><br><span class="line">        .attr(&quot;fill&quot;, (d, i) =&gt; color(i))</span><br><span class="line">        .attr(&quot;x&quot;, (d, i) =&gt; padding.left + xScale(i))</span><br><span class="line">        .attr(&quot;y&quot;, (d, i) =&gt; height - padding.bottom)</span><br><span class="line">        .attr(&quot;width&quot;, xScale.bandwidth())</span><br><span class="line">        .attr(&quot;height&quot;, 0)</span><br><span class="line">        .transition().duration(1000)  //重新赋值y，height 过渡效果</span><br><span class="line">        .attr(&quot;y&quot;, (d, i) =&gt; height - padding.bottom - (yScale(0) - yScale(d)))</span><br><span class="line">        .attr(&quot;height&quot;, d =&gt; yScale(0) - yScale(d));</span><br></pre></td></tr></table></figure><h4 id="设置x，y坐标、宽高度"><a href="#设置x，y坐标、宽高度" class="headerlink" title="设置x，y坐标、宽高度"></a>设置x，y坐标、宽高度</h4><p>见上面代码</p><h4 id="svg的rect与text的运用"><a href="#svg的rect与text的运用" class="headerlink" title="svg的rect与text的运用"></a>svg的rect与text的运用</h4><p>见上面代码</p><h4 id="比例尺与柱状图的绘制密切联系"><a href="#比例尺与柱状图的绘制密切联系" class="headerlink" title="比例尺与柱状图的绘制密切联系"></a>比例尺与柱状图的绘制密切联系</h4><p>本示例中，柱状图的x、y坐标的确定与标尺xScale等相关联，这也是坐标轴图的套路，上面的《生成折线图》也有映射。</p><h4 id="x、y值使用比例尺表示"><a href="#x、y值使用比例尺表示" class="headerlink" title="x、y值使用比例尺表示"></a>x、y值使用比例尺表示</h4><p>见上面代码</p><h4 id="update、enter、exit的经典运用"><a href="#update、enter、exit的经典运用" class="headerlink" title="update、enter、exit的经典运用"></a>update、enter、exit的经典运用</h4><p>详见上面提到的demo地址，这个简洁demo介绍了这三种状态的渲染。</p><h3 id="生成饼状图"><a href="#生成饼状图" class="headerlink" title="生成饼状图"></a>生成饼状图</h3><h4 id="饼状图的一些概念"><a href="#饼状图的一些概念" class="headerlink" title="饼状图的一些概念"></a>饼状图的一些概念</h4><ul><li>outerRadius 外半径</li><li>innerRadius 内半径</li><li>startAngle 起始角度</li><li>endAngle 结束角度<figure class="image-box">                <img src="/image/d3/all/pie1.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="单段饼图"><a href="#单段饼图" class="headerlink" title="单段饼图"></a>单段饼图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> const svg = d3.select(&quot;#svg&quot;).append(&quot;svg&quot;).attr(&quot;width&quot;, &quot;300&quot;).attr(&quot;height&quot;, &quot;300&quot;);</span><br><span class="line">const dataset = &#123;startAngle:0, endAngle: Math.PI*0.75&#125;;</span><br><span class="line">const arcPath = d3.arc()  //弧生成器</span><br><span class="line">        .innerRadius(50)   //设置内半径</span><br><span class="line">        .outerRadius(100);  //设置外半径</span><br><span class="line">svg.append(&quot;path&quot;)</span><br><span class="line">        .attr(&quot;d&quot;, arcPath(dataset)) // 用弧生成器生成弧线数据，赋值给SVG的d属性</span><br><span class="line">        .attr(&quot;transform&quot;, &apos;translate(200, 200)&apos;) // 填充颜色</span><br><span class="line">        .attr(&quot;stroke&quot;, &apos;#000&apos;).attr(&apos;stroke-width&apos;, &apos;3px&apos;) // 填充颜色</span><br><span class="line">        .attr(&quot;fill&quot;, &apos;blue&apos;) // 填充颜色</span><br></pre></td></tr></table></figure></li></ul><p>效果如图：<br><figure class="image-box">                <img src="/image/d3/all/pie2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="多个饼图拼成一个完整饼图"><a href="#多个饼图拼成一个完整饼图" class="headerlink" title="多个饼图拼成一个完整饼图"></a>多个饼图拼成一个完整饼图</h4><p>一个饼图其实是由上面说到的一个个分段的饼图拼接而成：<br><figure class="highlight plain"><figcaption><span>svg </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const pie = d3.pie();</span><br><span class="line">const dataset = [30, 10, 43, 55, 13];</span><br><span class="line">const piedata = pie(dataset);</span><br><span class="line">const outerRadius = 150; //外半径</span><br><span class="line">const innerRadius = 0; //内半径，为0则中间没有空白</span><br><span class="line">const arc = d3.arc()  //弧生成器</span><br><span class="line">    .innerRadius(innerRadius)   //设置内半径</span><br><span class="line">    .outerRadius(outerRadius);  //设置外半径</span><br><span class="line">const arcs = svg.selectAll(&quot;g&quot;) // 存放弧的容器</span><br><span class="line">    .data(piedata) //绑定pie数据</span><br><span class="line">    .enter() // 数据进入</span><br><span class="line">    .append(&quot;g&quot;) // 生成g</span><br><span class="line">    .attr(&quot;transform&quot;, &quot;translate(&quot; + (300 / 2) + &quot;,&quot; + (300 / 2) + &quot;)&quot;); // 偏移</span><br><span class="line">const color = d3.scaleOrdinal(d3.schemeCategory10);</span><br><span class="line">arcs.append(&quot;path&quot;)</span><br><span class="line">    .attr(&quot;fill&quot;, (d, i) =&gt; color(i)) // 填充颜色</span><br><span class="line">    .attr(&quot;d&quot;, d =&gt; &#123;</span><br><span class="line">        return arc(d)</span><br><span class="line">    &#125;); // 用弧生成器生成弧线数据，赋值给SVG的d属性</span><br><span class="line">arcs.append(&quot;text&quot;)</span><br><span class="line">    .attr(&quot;transform&quot;, d =&gt; &quot;translate(&quot; + arc.centroid(d) + &quot;)&quot;) // 设置文本至扇区中心</span><br><span class="line">    .attr(&quot;text-anchor&quot;, &quot;middle&quot;) //设置文本锚点</span><br><span class="line">    .attr(&quot;fill&quot;, &quot;#fff&quot;) //设置文字颜色</span><br><span class="line">    .text(d =&gt; d.data);</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/d3/all/pie3.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="获取圆弧中心点"><a href="#获取圆弧中心点" class="headerlink" title="获取圆弧中心点"></a>获取圆弧中心点</h4><p><a href="https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#arc" target="_blank" rel="noopener">主要运用arc的centroid API</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arcFn = d3.svg.arc()</span><br><span class="line">.innerRadius(innerRadius)</span><br><span class="line">.outerRadius(outerRadius);</span><br><span class="line"></span><br><span class="line">arcs.append(&quot;text&quot;)</span><br><span class="line">.attr(&quot;class&quot;,&quot;MyText&quot;)</span><br><span class="line">.attr(&quot;transform&quot;, function(d)&#123;</span><br><span class="line">var center = arcFn.centroid(d);</span><br><span class="line">return &quot;translate(&quot; + </span><br><span class="line">center[0] * 1.4 + &quot;,&quot; + </span><br><span class="line">center[1] * 1.4 + &quot;)&quot;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/wangjingzhi/sixth.html" target="_blank" rel="noopener">参考demo — 功能更丰富的的完整饼图</a></p><h4 id="熟练运用arc-centroid圆弧中心"><a href="#熟练运用arc-centroid圆弧中心" class="headerlink" title="熟练运用arc.centroid圆弧中心"></a>熟练运用arc.centroid圆弧中心</h4><p>饼图的文字或者标注线，都需要依赖圆弧中心点的运用，所以涉及到饼图时，需要重度使用圆弧中心点，以及如何凭借这个圆弧中间点，延伸画出一条中心线的技巧， <a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter10/10.1/10-1-pie.html" target="_blank" rel="noopener">详细参考demo</a></p><h4 id="demo地址与参考"><a href="#demo地址与参考" class="headerlink" title="demo地址与参考"></a>demo地址与参考</h4><p><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/my-d3-practice/PieChart.html" target="_blank" rel="noopener">单段饼图 demo地址</a><br><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/my-d3-practice/PieCharts.html" target="_blank" rel="noopener">完整饼图 demo地址</a><br><a href="https://www.bilibili.com/video/av13872208/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">视频讲解</a></p><h4 id="arc-与-pie-关系"><a href="#arc-与-pie-关系" class="headerlink" title="arc 与 pie 关系"></a>arc 与 pie 关系</h4><p>arc是用来画弧的，arc用来画饼图(pie)时，要设置起始角度startAngle、endAngle，为了省去这些麻烦，配合使用pie可以完美画饼图。</p><p><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/wangjingzhi/sixth.html" target="_blank" rel="noopener">功能更丰富的的完整饼图</a></p><h3 id="生成线段"><a href="#生成线段" class="headerlink" title="生成线段"></a>生成线段</h3><p>完整代码如下，主要运用d3.svg.line，另外interpolate是生成不同类型连接线类型的，<a href="https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#_line" target="_blank" rel="noopener">参考文档</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//v3.x</span><br><span class="line">var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;)</span><br><span class="line">.attr(&quot;width&quot;, 400)</span><br><span class="line">.attr(&quot;height&quot;, 400);</span><br><span class="line">var data = [</span><br><span class="line">&#123;&quot;x&quot;: 10, &quot;y&quot;: 200&#125;,</span><br><span class="line">&#123;&quot;x&quot;: 50, &quot;y&quot;: 260&#125;,</span><br><span class="line">&#123;&quot;x&quot;: 90, &quot;y&quot;: 120&#125;</span><br><span class="line">]</span><br><span class="line">var line = d3.svg.line()</span><br><span class="line">.x( function(d)&#123; return d.x; &#125; )</span><br><span class="line">.y( function(d)&#123; return d.y; &#125; )</span><br><span class="line">.interpolate(&quot;line&quot;);</span><br><span class="line">svg.append(&quot;path&quot;)</span><br><span class="line">.attr(&quot;class&quot;,&quot;MyPath&quot;)</span><br><span class="line">.attr(&quot;d&quot;, line(data) )</span><br></pre></td></tr></table></figure></p><h3 id="生成线段-与-fill-none"><a href="#生成线段-与-fill-none" class="headerlink" title="生成线段 与 fill none"></a>生成线段 与 fill none</h3><p>如下，没有使用fill none时，效果如下：<br><figure class="image-box">                <img src="/image/d3/all/line_fill.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var canvas = d3.select(&quot;body&quot;)</span><br><span class="line">                 .append(&quot;svg&quot;)</span><br><span class="line">                 .attr(&quot;width&quot;,500)</span><br><span class="line">                 .attr(&quot;height&quot;,500);</span><br><span class="line"></span><br><span class="line">   var data2 = [</span><br><span class="line">           &#123;x : 10 , y : 20&#125;,</span><br><span class="line">           &#123;x : 10 , y : 260&#125;,</span><br><span class="line">           &#123;x : 250 , y : 260&#125;</span><br><span class="line">   ];</span><br><span class="line"></span><br><span class="line">   var group = canvas.append(&quot;g&quot;)</span><br><span class="line">                    .attr(&quot;transform&quot;, &quot;translate(100,200)&quot;);</span><br><span class="line"></span><br><span class="line">   var line = d3.svg.line()</span><br><span class="line">                  .x(function(d) &#123; return d.x;&#125;)</span><br><span class="line">                  .y(function(d) &#123; return d.y;&#125;);</span><br><span class="line"></span><br><span class="line">   group.selectAll(&quot;path&quot;)</span><br><span class="line">             .data([data2])</span><br><span class="line">             .enter()</span><br><span class="line">              .append(&quot;path&quot;)</span><br><span class="line">              .attr(&quot;d&quot;,line)</span><br><span class="line">              //.attr(&quot;fill&quot;,&quot;none&quot;)</span><br><span class="line">              .attr(&quot;stroke&quot; , &quot;#000&quot;)</span><br><span class="line">              .attr(&quot;stroke-width&quot;, 10 );</span><br></pre></td></tr></table></figure></p><p>将上面代码的<code>//.attr(&quot;fill&quot;,&quot;none&quot;)</code>解注后，效果如下：<br><figure class="image-box">                <img src="/image/d3/all/line_fill1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="生成散点图"><a href="#生成散点图" class="headerlink" title="生成散点图"></a>生成散点图</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>散点图比较简单，主要代码如下，<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/wangjingzhi/fifth.html" target="_blank" rel="noopener">demo地址点击这里</a>。</p><p>这里要注意的是比例尺与圆心cx cy的结合使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//v3.x</span><br><span class="line"></span><br><span class="line">var xScale = d3.scale.linear()</span><br><span class="line">.domain([0, 100])</span><br><span class="line">.range([0,300]);</span><br><span class="line"></span><br><span class="line">var points = svg.selectAll(&quot;.MyCircle&quot;)</span><br><span class="line">.data(dataset)</span><br><span class="line">.enter()</span><br><span class="line">.append(&quot;circle&quot;)</span><br><span class="line">.attr(&quot;class&quot;,&quot;MyCircle&quot;)</span><br><span class="line">.attr(&quot;transform&quot;,&quot;translate(30,50)&quot;)</span><br><span class="line">.attr(&quot;r&quot;, 10)</span><br><span class="line">.attr(&quot;cx&quot;, function(d)&#123; return xScale(d.x); &#125;)</span><br><span class="line">.attr(&quot;cy&quot;, function(d)&#123; return yScale(d.y); &#125;);</span><br></pre></td></tr></table></figure></p><h4 id="比例尺与圆心cx-cy的结合使用"><a href="#比例尺与圆心cx-cy的结合使用" class="headerlink" title="比例尺与圆心cx cy的结合使用"></a>比例尺与圆心cx cy的结合使用</h4><p>参考上面。</p><h3 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h3><h4 id="一个简单的比例尺"><a href="#一个简单的比例尺" class="headerlink" title="一个简单的比例尺"></a>一个简单的比例尺</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var linear = d3.scale.linear()</span><br><span class="line">.domain([0,20]) //定义域</span><br><span class="line">.range([0,100]); //值域</span><br></pre></td></tr></table></figure><h4 id="比例尺使用情况"><a href="#比例尺使用情况" class="headerlink" title="比例尺使用情况"></a>比例尺使用情况</h4><p>序数比例尺与线性比例尺用的最多；<br>序数比例尺用来做x轴；线性做y轴；<br>另外一个用的多的是量子比例尺：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var quantize= d3.scale.quantize().domain([0, 10]).range([&apos;red&apos;,&apos;green&apos;,&apos;blue&apos;,&apos;yellow&apos;])</span><br><span class="line">quantize(1)//&apos;red&apos;</span><br></pre></td></tr></table></figure></p><h4 id="scale比例尺的作用"><a href="#scale比例尺的作用" class="headerlink" title="scale比例尺的作用"></a>scale比例尺的作用</h4><p>参考《scale比例尺的作用》</p><h3 id="d3-event-d3-mouse-this-d3-touches-this"><a href="#d3-event-d3-mouse-this-d3-touches-this" class="headerlink" title="d3.event d3.mouse(this) d3.touches(this)"></a>d3.event d3.mouse(this) d3.touches(this)</h3><p>一般的监听和事件绑定中都可以通过d3.event获取想要的值，<br>具体的事件或监听中，可通过d3.mouse(this) d3.touches(this)获取值；<br>demo参考 《精通d3.js》的第八章。</p><h3 id="scale比例尺的作用-1"><a href="#scale比例尺的作用-1" class="headerlink" title="scale比例尺的作用"></a>scale比例尺的作用</h3><h4 id="没有比例尺"><a href="#没有比例尺" class="headerlink" title="没有比例尺"></a>没有比例尺</h4><p>如下，没有比例尺时，下面两个柱形图太长了，而svg只是一个500*500的容器，大于500的，无法显示，为了自适应，引入比例尺。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var canvas = d3.select(&quot;body&quot;)</span><br><span class="line">                .append(&quot;svg&quot;)</span><br><span class="line">                .attr(&quot;width&quot;,500)</span><br><span class="line">                .attr(&quot;height&quot;,500);</span><br><span class="line">var bar1= canvas.selectAll(&quot;rect&quot;)</span><br><span class="line">            .data([20,40,60,80,150])</span><br><span class="line">            .enter()</span><br><span class="line">                .append(&quot;rect&quot;)</span><br><span class="line">                .attr(&quot;width&quot;,function(d) &#123; return d*8&#125;)</span><br><span class="line">                .attr(&quot;height&quot;,30)</span><br><span class="line">                .attr(&quot;y&quot;,function(d, i) &#123; return (i+1)*65; &#125;)</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/d3/all/scale.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="使用比例尺"><a href="#使用比例尺" class="headerlink" title="使用比例尺"></a>使用比例尺</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//d3.scale.linear比例尺</span><br><span class="line"> var scalewidth = d3.scale.linear()</span><br><span class="line">        .domain([0,140])</span><br><span class="line">        .range([0,500])</span><br><span class="line">var bar1= canvas.selectAll(&quot;rect&quot;)</span><br><span class="line">            .data([20,40,60,80,150])</span><br><span class="line">            .enter()</span><br><span class="line">                .append(&quot;rect&quot;)</span><br><span class="line">                //使用比例尺来生成width</span><br><span class="line">                .attr(&quot;width&quot;,function(d) &#123; return scalewidth(d)&#125;)</span><br><span class="line">                .attr(&quot;height&quot;,30)</span><br><span class="line">                .attr(&quot;y&quot;,function(d, i) &#123; return (i+1)*65; &#125;)</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/image/d3/all/scale2.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="groud-与-g"><a href="#groud-与-g" class="headerlink" title="groud 与 g"></a>groud 与 g</h3><h4 id="分组-与-div"><a href="#分组-与-div" class="headerlink" title="分组 与 div"></a>分组 与 div</h4><p>groud就是分组，缩写就是 g，这也是d3上常用到的g标签。<br>如下面代码，加g后，可以统一设置g分组内的所有rect，所有g相当于html中的div<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var scalewidth = d3.scale.linear()</span><br><span class="line">                       .domain([0,80])</span><br><span class="line">                       .range([0,500])</span><br><span class="line"></span><br><span class="line">   var axis = d3.svg.axis()</span><br><span class="line">                 .ticks(10)</span><br><span class="line">                 .scale(scalewidth)</span><br><span class="line"></span><br><span class="line">   var canvas = d3.select(&quot;body&quot;)</span><br><span class="line">                 .append(&quot;svg&quot;)</span><br><span class="line">                 .attr(&quot;width&quot;,500)</span><br><span class="line">                 .attr(&quot;height&quot;,500)</span><br><span class="line">                 // 这里是否加g进行分组，效果是一样的，但是加g后，可以在g上统一对下面的rect设置样式：</span><br><span class="line">                 .append(&quot;g&quot;)</span><br><span class="line"></span><br><span class="line">   var color = d3.scale.linear()</span><br><span class="line">                   .domain([0,140])</span><br><span class="line">                   .range([&quot;red&quot;,&quot;blue&quot;])</span><br><span class="line"></span><br><span class="line">   var bar1= canvas.selectAll(&quot;rect&quot;)</span><br><span class="line">               .data([20,40,60,80,])</span><br><span class="line">               .enter()</span><br><span class="line">                   .append(&quot;rect&quot;)</span><br><span class="line">                   .attr(&quot;width&quot;,function(d) &#123; return scalewidth(d)&#125;)</span><br><span class="line">                   .attr(&quot;height&quot;,40)</span><br><span class="line">                   .attr(&quot;fill&quot;,function(d) &#123; return color(d)&#125;)</span><br><span class="line">                   .attr(&quot;y&quot;,function(d) &#123; return d * 3&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="例子二-–-坐标轴是否分组"><a href="#例子二-–-坐标轴是否分组" class="headerlink" title="例子二 – 坐标轴是否分组"></a>例子二 – 坐标轴是否分组</h4><p>对上面的代码进行延伸，加一个坐标轴，坐标轴分组和不分组，区别很大，分组后，更容易设置样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var canvas = d3.select(&quot;body&quot;)</span><br><span class="line">                  .append(&quot;svg&quot;)</span><br><span class="line">                  .attr(&quot;width&quot;,500)</span><br><span class="line">                  .attr(&quot;height&quot;,500)</span><br><span class="line">                  .append(&quot;g&quot;)</span><br><span class="line">                  // 不推荐写法---未将坐标轴分组，不容易设置样式：</span><br><span class="line">                  //   .call(axis)</span><br><span class="line">                  ;</span><br><span class="line">            // 推荐写法---将坐标轴分组，更容易设置样式：</span><br><span class="line">            // canvas.append(&quot;g&quot;)</span><br><span class="line">            //         .attr(&quot;transform&quot;,&quot;translate(0,300)&quot;)</span><br><span class="line">            //         .call(axis)</span><br></pre></td></tr></table></figure></p><h4 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a>demo地址</h4><p><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/mars/lesson6/test01.html" target="_blank" rel="noopener">demo地址</a></p><h3 id="d3-json-d3-csv-d3-xml-d3-html-d3-text"><a href="#d3-json-d3-csv-d3-xml-d3-html-d3-text" class="headerlink" title="d3.json d3.csv d3.xml d3.html d3.text"></a>d3.json d3.csv d3.xml d3.html d3.text</h3><p>上面几种是d3请求外部文件的方式。<br><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter9/9.1/9-1-1-readjson.html" target="_blank" rel="noopener">demo 参考</a></p><h3 id="svg导出为png-svg"><a href="#svg导出为png-svg" class="headerlink" title="svg导出为png/svg"></a>svg导出为png/svg</h3><p>主要运用 d3-downloadable，<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter9/9.2/9-2-1-d3-downloadable.html" target="_blank" rel="noopener">demo 参考</a>，此demo也提供了一种方案，如何自定义右键菜单，并且另存为(下载)图片。</p><h2 id="d3黑知识"><a href="#d3黑知识" class="headerlink" title="d3黑知识"></a>d3黑知识</h2><h3 id="d3-event-dx-鼠标偏移量"><a href="#d3-event-dx-鼠标偏移量" class="headerlink" title="d3.event.dx 鼠标偏移量"></a>d3.event.dx 鼠标偏移量</h3><p>鼠标每次偏移量，通过试验发现，偏移量基本上是三个值：-1 0 1;<br>这个用处非常多，通过叠加偏移量的方式，可以画一种时刻跟随鼠标的动作，比如拖动图片时，图片跟随鼠标显示。等等，<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter12/12.3/12-3-1-pie-drag.html" target="_blank" rel="noopener">拖拽饼状图 demo</a></p><h3 id="d-自定义属性的传递使用"><a href="#d-自定义属性的传递使用" class="headerlink" title="d 自定义属性的传递使用"></a>d 自定义属性的传递使用</h3><p>如下，在选择集中定义的customDx123属性，在arcs.append(“path”)和d3.behavior.drag()都能使用，这二者有一个共性，那就是都使用了arcs对象。<br>完整demo参考：<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter12/12.3/12-3-1-pie-drag.html" target="_blank" rel="noopener">拖拽饼状图 demo</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加对应数目的弧组，即&lt;g&gt;元素</span></span><br><span class="line"><span class="keyword">var</span> arcs = svg.selectAll(<span class="string">"g"</span>)</span><br><span class="line">                .data(piedata)<span class="comment">//绑定转换后的数据piedata</span></span><br><span class="line">                .enter()</span><br><span class="line">                .append(<span class="string">"g"</span>)</span><br><span class="line">                .each(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">                    <span class="comment">//customDx123 这个属性是自己加和命名的</span></span><br><span class="line">                d.customDx123 = width/<span class="number">2</span>;</span><br><span class="line">                d.customDy123 = height/<span class="number">2</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .attr(<span class="string">"transform"</span>,<span class="string">"translate("</span>+( width/<span class="number">2</span> )+<span class="string">","</span>+ ( height/<span class="number">2</span> ) +<span class="string">")"</span>);</span><br><span class="line"><span class="comment">//绘制弧</span></span><br><span class="line">arcs.append(<span class="string">"path"</span>)</span><br><span class="line">.attr(<span class="string">"fill"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d,i</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> color(i);<span class="comment">//设定弧的颜色</span></span><br><span class="line">&#125;)</span><br><span class="line">.attr(<span class="string">"d"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(d.customDx123);</span><br><span class="line"><span class="keyword">return</span> arc(d);<span class="comment">//使用弧生成器</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 交互式</span></span><br><span class="line"><span class="keyword">var</span> drag = d3.behavior.drag()</span><br><span class="line">    .origin(<span class="literal">null</span>)</span><br><span class="line">.on(<span class="string">"drag"</span>, dragmove);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dragmove</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//customDx123 这个属性是自己加和命名的</span></span><br><span class="line">d.customDx123 += d3.event.dx;</span><br><span class="line">d.customDy123 += d3.event.dy;</span><br><span class="line">d3.select(<span class="keyword">this</span>)</span><br><span class="line">.attr(<span class="string">"transform"</span>,<span class="string">"translate("</span>+d.customDx123+<span class="string">","</span>+d.customDy123+<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">       arcs.call(drag);</span><br></pre></td></tr></table></figure></p><h3 id="d3-svg-brush-区域选中"><a href="#d3-svg-brush-区域选中" class="headerlink" title="d3.svg.brush 区域选中"></a>d3.svg.brush 区域选中</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>效果如下，完整<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter12/12.4/12-4-2-selectArea-scatter.html" target="_blank" rel="noopener">demo</a>:<br><figure class="image-box">                <img src="/image/d3/all/brush.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xScale = d3.scale.linear()</span><br><span class="line">                .domain([<span class="number">0</span>,width])</span><br><span class="line">                .range([<span class="number">0</span>, width]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yScale = d3.scale.linear()</span><br><span class="line">                .domain([<span class="number">0</span>, height])</span><br><span class="line">                .range([<span class="number">0</span>, height]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> brush = d3.svg.brush()</span><br><span class="line">              .x(xScale)</span><br><span class="line">              .y(yScale)</span><br><span class="line">              .extent([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">100</span>, <span class="number">100</span>]])</span><br><span class="line">              .on(<span class="string">"brush"</span>,brushed);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">brushed</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> extent = brush.extent();</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"x方向的下限:  "</span> + extent[<span class="number">0</span>][<span class="number">0</span>] );</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"x方向的上限:  "</span> + extent[<span class="number">1</span>][<span class="number">0</span>] );</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"y方向的下限:  "</span> + extent[<span class="number">0</span>][<span class="number">1</span>] );</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"y方向的上限:  "</span> + extent[<span class="number">1</span>][<span class="number">1</span>] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">svg.append(<span class="string">"g"</span>)</span><br><span class="line">    .call(brush)</span><br><span class="line">    .selectAll(<span class="string">"rect"</span>)</span><br><span class="line">    .style(<span class="string">"fill-opacity"</span>,<span class="number">0.3</span>);</span><br></pre></td></tr></table></figure><h4 id="必须配合比例尺使用"><a href="#必须配合比例尺使用" class="headerlink" title="必须配合比例尺使用"></a>必须配合比例尺使用</h4><p>参考上面一节代码。</p><h4 id="监听三种事件类型"><a href="#监听三种事件类型" class="headerlink" title="监听三种事件类型"></a>监听三种事件类型</h4><ul><li>brushstart 鼠标键按下时</li><li>brush 鼠标键按下拖拽时</li><li>brushend 鼠标键放开时<h4 id="brush-extent-获取选中区域的x-y上下限"><a href="#brush-extent-获取选中区域的x-y上下限" class="headerlink" title="brush.extent 获取选中区域的x y上下限"></a>brush.extent 获取选中区域的x y上下限</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extent = brush.extent();</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"x方向的下限:  "</span> + extent[<span class="number">0</span>][<span class="number">0</span>] );</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"x方向的上限:  "</span> + extent[<span class="number">1</span>][<span class="number">0</span>] );</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"y方向的下限:  "</span> + extent[<span class="number">0</span>][<span class="number">1</span>] );</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"y方向的上限:  "</span> + extent[<span class="number">1</span>][<span class="number">1</span>] );</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建-线性渐变颜色"><a href="#创建-线性渐变颜色" class="headerlink" title="创建 线性渐变颜色"></a>创建 线性渐变颜色</h3><p>如下，线性渐变的颜色，需要借助 url来使用。详细参考 《值域与线性渐变  –  创建 线性渐变颜色》<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规的颜色填充</span></span><br><span class="line">svgNode</span><br><span class="line">.style(<span class="string">"fill"</span>,<span class="string">"red"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性渐变颜色填充 （线性渐变的颜色 使用 url）</span></span><br><span class="line">svgNode</span><br><span class="line">.style(<span class="string">"fill"</span>,<span class="string">"url(#"</span> + linearGradient.attr(<span class="string">"id"</span>) + <span class="string">")"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="利用投影函数转换经纬度成坐标"><a href="#利用投影函数转换经纬度成坐标" class="headerlink" title="利用投影函数转换经纬度成坐标"></a>利用投影函数转换经纬度成坐标</h3><p>其实GeoJSON文件的地理信息也是经纬度，也是通过投影函数得到地图路径坐标的。所以可以通过投影函数获得经纬度对应的地图像素坐标。<br>demo参考：<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter13/13.2/13-2-1-mark-place.html" target="_blank" rel="noopener">地图上标注地点 demo</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> projection = d3.geo.mercator()</span><br><span class="line">.center([<span class="number">107</span>, <span class="number">31</span>])</span><br><span class="line">.scale(<span class="number">600</span>)</span><br><span class="line">    .translate([width/<span class="number">2</span>, height/<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = d3.geo.path()</span><br><span class="line">.projection(projection);</span><br><span class="line"></span><br><span class="line"><span class="comment">//d.log， d.lat ：经纬度 计算标注点的位置</span></span><br><span class="line"> <span class="keyword">var</span> coor = projection([d.log, d.lat]);</span><br></pre></td></tr></table></figure></p><h2 id="d3生成器"><a href="#d3生成器" class="headerlink" title="d3生成器"></a>d3生成器</h2><p>生成器就是生成svg的path路径，svg通过生成器生成的path绘制不同图形，d3提供了直线、四边形(区域)、弦、符号、折线、对角线等生成器。</p><h3 id="svg-area-区域生成器"><a href="#svg-area-区域生成器" class="headerlink" title="svg.area 区域生成器"></a>svg.area 区域生成器</h3><p>svg.area的原理是通过两条线 确定一个四边形；好比 两个点确定一条线的道理。<br>所以svg.area 都是画一条线，需要画两条线，即可确定一个四边形。<br><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter6/6.3/6-3-1-areaGenerator.html" target="_blank" rel="noopener">详细demo</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//创建一个区域生成器</span><br><span class="line">//svg.area的原理是通过两条线 确定一个四边形；好比 两个点确定一条线的道理。</span><br><span class="line">//svg.area一次性设置两个点 x0 y0； x1 y1； 通过 x 一次性设置 x0 和 y0；</span><br><span class="line">var areaPath = d3.svg.area()</span><br><span class="line">.x(function(d,i)&#123; return 50 + i * 80; &#125;)</span><br><span class="line">.y0(function(d,i)&#123; return height/2; &#125;)</span><br><span class="line">.y1(function(d,i)&#123; return height/2 - d; &#125;)</span><br><span class="line">// .interpolate(&quot;step&quot;);</span><br><span class="line"></span><br><span class="line">//添加路径</span><br><span class="line">svg.append(&quot;path&quot;)</span><br><span class="line">.attr(&quot;d&quot;,areaPath(dataset))</span><br><span class="line">.attr(&quot;stroke&quot;,&quot;black&quot;)</span><br><span class="line">.attr(&quot;stroke-width&quot;,&quot;3px&quot;)</span><br><span class="line">.attr(&quot;fill&quot;,&quot;yellow&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="d3交互"><a href="#d3交互" class="headerlink" title="d3交互"></a>d3交互</h2><h3 id="折线图的焦点"><a href="#折线图的焦点" class="headerlink" title="折线图的焦点"></a>折线图的焦点</h3><p><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter11/11.2/11.2.1/11-2-1-GeoJSON-chinamap.html" target="_blank" rel="noopener">完整demo</a>，效果如下：<br><figure class="image-box">                <img src="/image/d3/all/style.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="设置透明度为0的矩形"><a href="#设置透明度为0的矩形" class="headerlink" title="设置透明度为0的矩形"></a>设置透明度为0的矩形</h4><p>设置透明度为0的矩形，覆盖整个图，获取鼠标的焦点位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//获取鼠标相对于透明矩形左上角的坐标，左上角坐标为(0,0)</span><br><span class="line">var mouseX = d3.mouse(this)[0] - padding.left;</span><br><span class="line">var mouseY = d3.mouse(this)[1] - padding.top;</span><br></pre></td></tr></table></figure></p><h4 id="焦点位置-反射出-对应坐标值"><a href="#焦点位置-反射出-对应坐标值" class="headerlink" title="焦点位置 反射出 对应坐标值"></a>焦点位置 反射出 对应坐标值</h4><p>使用函数 xScale.invert：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x0 = xScale.invert( mouseX );</span><br></pre></td></tr></table></figure></p><h4 id="根据坐标值-找出-实际值域内的值"><a href="#根据坐标值-找出-实际值域内的值" class="headerlink" title="根据坐标值 找出 实际值域内的值"></a>根据坐标值 找出 实际值域内的值</h4><p>实际的坐标值可能没有对应的值，那么此时应该通过逻辑找到临近的 值域内的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//对x0四舍五入，如果x0是2005.6，则返回2006；如果是2005.2，则返回2005</span><br><span class="line">x0 = Math.round(x0);</span><br><span class="line"></span><br><span class="line">//查找在原数组中x0的值，并返回索引号</span><br><span class="line">var bisect = d3.bisector( function(d) &#123; return d[0]; &#125;).left;</span><br><span class="line">var index = bisect(data, x0) ;</span><br><span class="line">// 找到对应的实际定义的值</span><br><span class="line">dataset[k].gdp[index]</span><br></pre></td></tr></table></figure></p><h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>有了坐标值，就知道所有的信息，就可以绘图了。</p><h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><h3 id="地图数据下载地址-GeoJSON"><a href="#地图数据下载地址-GeoJSON" class="headerlink" title="地图数据下载地址(GeoJSON)"></a>地图数据下载地址(GeoJSON)</h3><p><a href="http://www.naturalearthdata.com/" target="_blank" rel="noopener">地图数据下载地址</a>,这个网址下载的数据是一个zip包，里面有一个.shp文件，地图数据在这个文件中，需要解压这个数据。</p><h3 id="从-shp提取数据"><a href="#从-shp提取数据" class="headerlink" title="从.shp提取数据"></a>从.shp提取数据</h3><p>需要通过<a href="http://ogr2gui.ca/" target="_blank" rel="noopener">此网址</a>从.shp文件中提取json数据的获取。提取出来的数据通常很大，需要简化使用，更加高效。</p><h3 id="简化数据"><a href="#简化数据" class="headerlink" title="简化数据"></a>简化数据</h3><p><a href="https://mapshaper.org/" target="_blank" rel="noopener">点击查看简化数据网址</a></p><h3 id="TopoJSON"><a href="#TopoJSON" class="headerlink" title="TopoJSON"></a>TopoJSON</h3><p>TopoJSON 是d3作者制定，表达同样的地图信息，TopoJSON文件的体积要比GeoJSON小百分之八十，当GeoJSON文件达到20M以上时，节省下来的体积更加明显，网络请求更加快速。<br>因此在服务器端可放置TopoJSON文件，因为文件小，请求快速，请求回来后，在前端转换为 GeoJSON 文件，然后使用GeoJSON画图。因为画图还是使用GeoJSON的。</p><h3 id="地理路径生成器"><a href="#地理路径生成器" class="headerlink" title="地理路径生成器"></a>地理路径生成器</h3><h4 id="d3-geo-path"><a href="#d3-geo-path" class="headerlink" title="d3.geo.path()"></a>d3.geo.path()</h4><p>这是绘制地图的核心，地图基本路径都是这个；<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter11/11.2/11.2.1/11-2-1-GeoJSON-chinamap.html" target="_blank" rel="noopener">参考demo</a></p><h4 id="d3-geo-graticule"><a href="#d3-geo-graticule" class="headerlink" title="d3.geo.graticule()"></a>d3.geo.graticule()</h4><p>用于绘制经线和纬线；<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter11/11.3/11.3.2/11-3-2-1-grid-world.html" target="_blank" rel="noopener">参考demo</a></p><h4 id="d3-geo-circle"><a href="#d3-geo-circle" class="headerlink" title="d3.geo.circle()"></a>d3.geo.circle()</h4><p>用于以某一地点为中心绘制圆形圆格，一般用得少。<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter11/11.3/11.3.2/11-3-2-3-circle-grid.html" target="_blank" rel="noopener">参考demo</a></p><h4 id="d3-geo-projection"><a href="#d3-geo-projection" class="headerlink" title="d3.geo.projection"></a>d3.geo.projection</h4><p>用于创建投影。一般用默认的投影即可，用得少。<a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter11/11.3/11.3.2/11-3-2-1-grid-world.html" target="_blank" rel="noopener">参考demo</a></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><h4 id="GeoJSON-demo"><a href="#GeoJSON-demo" class="headerlink" title="GeoJSON demo"></a>GeoJSON demo</h4><p><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter11/11.2/11.2.1/11-2-1-GeoJSON-chinamap.html" target="_blank" rel="noopener">一个简单的GeoJSON demo</a></p><h4 id="TopoJSON-demo"><a href="#TopoJSON-demo" class="headerlink" title="TopoJSON demo"></a>TopoJSON demo</h4><p><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter11/11.2/11.2.2/11.2.2.1/11-2-2-1-TopoJSON-chinamap.html" target="_blank" rel="noopener">一个简单的TopoJSON demo</a></p><h2 id="地图demo讲解"><a href="#地图demo讲解" class="headerlink" title="地图demo讲解"></a>地图demo讲解</h2><h3 id="值域与线性渐变"><a href="#值域与线性渐变" class="headerlink" title="值域与线性渐变"></a>值域与线性渐变</h3><p>参考《值域与线性渐变》</p><h3 id="夜光图"><a href="#夜光图" class="headerlink" title="夜光图"></a>夜光图</h3><h4 id="完整demo与效果"><a href="#完整demo与效果" class="headerlink" title="完整demo与效果"></a>完整demo与效果</h4><p><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter13/13.2/13-2-2-night-light.html" target="_blank" rel="noopener">完整 demo</a><br><figure class="image-box">                <img src="/image/d3/all/night.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="在svg中添加滤镜"><a href="#在svg中添加滤镜" class="headerlink" title="在svg中添加滤镜"></a>在svg中添加滤镜</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defs = svg.append(<span class="string">"defs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gaussian = defs.append(<span class="string">"filter"</span>)</span><br><span class="line">.attr(<span class="string">"id"</span>,<span class="string">"gaussian"</span>);</span><br><span class="line"></span><br><span class="line">gaussian.append(<span class="string">"feGaussianBlur"</span>)</span><br><span class="line">.attr(<span class="string">"in"</span>,<span class="string">"SourceGraphic"</span>)</span><br><span class="line">.attr(<span class="string">"stdDeviation"</span>,<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> points = svg.selectAll(<span class="string">"circle"</span>)</span><br><span class="line">                    .data(cities)<span class="comment">//绑定数组</span></span><br><span class="line">                    .enter()</span><br><span class="line">                    .append(<span class="string">"circle"</span>)</span><br><span class="line">                    .attr(<span class="string">"class"</span>,<span class="string">"point"</span>)</span><br><span class="line">                    <span class="comment">//设定过滤器</span></span><br><span class="line">                    .style(<span class="string">"filter"</span>,<span class="string">"url(#"</span>+ gaussian.attr(<span class="string">"id"</span>) +<span class="string">")"</span>);</span><br></pre></td></tr></table></figure><h3 id="标线"><a href="#标线" class="headerlink" title="标线"></a>标线</h3><h4 id="完整demo与效果-1"><a href="#完整demo与效果-1" class="headerlink" title="完整demo与效果"></a>完整demo与效果</h4><p>本例主要考察 如何创建一个标线，主要利用了 line 标签， marker-end，mark-start 属性。<br><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter13/13.3/13-3-1-arrow-line.html" target="_blank" rel="noopener">完整 demo</a><br><figure class="image-box">                <img src="/image/d3/all/map_line.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="线段的起始位置添加标记图标"><a href="#线段的起始位置添加标记图标" class="headerlink" title="线段的起始位置添加标记图标"></a>线段的起始位置添加标记图标</h4><p>本例中，线段起始位置分别添加圆点与箭头标记。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">svg.append(<span class="string">"line"</span>)</span><br><span class="line">.attr(<span class="string">"class"</span>,<span class="string">"route"</span>)</span><br><span class="line">.attr(<span class="string">"x1"</span>,guilin[<span class="number">0</span>])</span><br><span class="line">.attr(<span class="string">"y1"</span>,guilin[<span class="number">1</span>])</span><br><span class="line">.attr(<span class="string">"x2"</span>,peking[<span class="number">0</span>])</span><br><span class="line">.attr(<span class="string">"y2"</span>,peking[<span class="number">1</span>])</span><br><span class="line">.attr(<span class="string">"marker-end"</span>,<span class="string">"url(#arrow)"</span>)</span><br><span class="line">.attr(<span class="string">"marker-start"</span>,<span class="string">"url(#startPoint)"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="line的-mark-start-确定起始位置"><a href="#line的-mark-start-确定起始位置" class="headerlink" title="line的 mark-start 确定起始位置"></a>line的 mark-start 确定起始位置</h4><p>参考上面代码</p><h4 id="line的-marker-end-确定终点位置"><a href="#line的-marker-end-确定终点位置" class="headerlink" title="line的 marker-end 确定终点位置"></a>line的 marker-end 确定终点位置</h4><p>参考上面代码</p><h4 id="d3标记图标的使用"><a href="#d3标记图标的使用" class="headerlink" title="d3标记图标的使用"></a>d3标记图标的使用</h4><p>如下，就是本例效果图中的箭头图标使用方法,在defs上创建，添加marker标签：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defs = svg.append(<span class="string">"defs"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arrowMarker = defs.append(<span class="string">"marker"</span>)</span><br><span class="line">.attr(<span class="string">"id"</span>,<span class="string">"arrow"</span>)</span><br><span class="line">.attr(<span class="string">"markerUnits"</span>,<span class="string">"strokeWidth"</span>)</span><br><span class="line">    .attr(<span class="string">"markerWidth"</span>,<span class="string">"12"</span>)</span><br><span class="line">                        .attr(<span class="string">"markerHeight"</span>,<span class="string">"12"</span>)</span><br><span class="line">                        .attr(<span class="string">"viewBox"</span>,<span class="string">"0 0 12 12"</span>) </span><br><span class="line">                        .attr(<span class="string">"refX"</span>,<span class="string">"6"</span>)</span><br><span class="line">                        .attr(<span class="string">"refY"</span>,<span class="string">"6"</span>)</span><br><span class="line">                        .attr(<span class="string">"orient"</span>,<span class="string">"auto"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arrow_path = <span class="string">"M2,2 L10,6 L2,10 L6,6 L2,2"</span>;</span><br><span class="line"></span><br><span class="line">arrowMarker.append(<span class="string">"path"</span>)</span><br><span class="line">.attr(<span class="string">"d"</span>,arrow_path)</span><br><span class="line">.attr(<span class="string">"fill"</span>,<span class="string">"#000"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="缩放与平移"><a href="#缩放与平移" class="headerlink" title="缩放与平移"></a>缩放与平移</h3><h4 id="完整demo与效果-2"><a href="#完整demo与效果-2" class="headerlink" title="完整demo与效果"></a>完整demo与效果</h4><p>本例主要考察 如何创建一个标线，主要利用了 line 标签， marker-end，mark-start 属性。<br><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter13/13.4/13-4-1-plane-drag-scale.html" target="_blank" rel="noopener">完整 demo</a><br><figure class="image-box">                <img src="/image/d3/all/map_zoom.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="定义透明矩形，设置zoom行为"><a href="#定义透明矩形，设置zoom行为" class="headerlink" title="定义透明矩形，设置zoom行为"></a>定义透明矩形，设置zoom行为</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zoom = d3.behavior.zoom()</span><br><span class="line">.scaleExtent([<span class="number">1</span>, <span class="number">10</span>])</span><br><span class="line">.on(<span class="string">"zoom"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line"><span class="comment">//更新投影函数的平移量</span></span><br><span class="line">projection.translate([ initTran[<span class="number">0</span>] + d3.event.translate[<span class="number">0</span>],</span><br><span class="line">   initTran[<span class="number">1</span>] + d3.event.translate[<span class="number">1</span>] ]);</span><br><span class="line"><span class="comment">//更新投影函数的缩放量</span></span><br><span class="line">projection.scale( initScale * d3.event.scale );</span><br><span class="line"></span><br><span class="line"><span class="comment">//重绘地图</span></span><br><span class="line">countries.attr(<span class="string">"d"</span>,path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重绘经纬度网格</span></span><br><span class="line">gridPath.attr(<span class="string">"d"</span>,path);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">svg.append(<span class="string">"rect"</span>)</span><br><span class="line">.attr(<span class="string">"class"</span>,<span class="string">"overlay"</span>)</span><br><span class="line">.attr(<span class="string">"x"</span>, <span class="number">0</span>)</span><br><span class="line">.attr(<span class="string">"y"</span>, <span class="number">0</span>)</span><br><span class="line">.attr(<span class="string">"width"</span>,width)</span><br><span class="line">.attr(<span class="string">"height"</span>,height)</span><br><span class="line">.call(zoom);</span><br></pre></td></tr></table></figure><h4 id="利用投影函数的translate和scale"><a href="#利用投影函数的translate和scale" class="headerlink" title="利用投影函数的translate和scale"></a>利用投影函数的translate和scale</h4><p>如上面代码</p><h2 id="值域与线性渐变-1"><a href="#值域与线性渐变-1" class="headerlink" title="值域与线性渐变"></a>值域与线性渐变</h2><h3 id="完整demo与效果-3"><a href="#完整demo与效果-3" class="headerlink" title="完整demo与效果"></a>完整demo与效果</h3><p><a href="https://github.com/YeWills/d3-note-demo/blob/d3-demo/pages/d3-jt-book/chapter13/13.1/13-1-colorRange.html" target="_blank" rel="noopener">完整 demo</a><br><figure class="image-box">                <img src="/image/d3/all/colors.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="通过值域创建颜色"><a href="#通过值域创建颜色" class="headerlink" title="通过值域创建颜色"></a>通过值域创建颜色</h3><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个线性比例尺，将最小值和最大值之间的值映射到[0, 1]</span></span><br><span class="line"><span class="keyword">var</span> linear = d3.scale.linear()</span><br><span class="line">.domain([minvalue, maxvalue])</span><br><span class="line">.range([<span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义最小值和最大值对应的颜色</span></span><br><span class="line"><span class="keyword">var</span> a = d3.rgb(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>);<span class="comment">//浅蓝色</span></span><br><span class="line"><span class="keyword">var</span> b = d3.rgb(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>);<span class="comment">//蓝色</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//颜色插值函数</span></span><br><span class="line"><span class="keyword">var</span> computeColor = d3.interpolate(a,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设定各省份的填充色</span></span><br><span class="line">provinces.style(<span class="string">"fill"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d,i</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> t = linear( values[d.properties.name] );</span><br><span class="line"><span class="keyword">var</span> color = computeColor(t);</span><br><span class="line"><span class="keyword">return</span> color.toString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="d3-scale-linear创建-0-1-范围的比例尺"><a href="#d3-scale-linear创建-0-1-范围的比例尺" class="headerlink" title="d3.scale.linear创建[0,1]范围的比例尺"></a>d3.scale.linear创建[0,1]范围的比例尺</h4><p>参考上面代码</p><h4 id="d3-interpolate-a-b-接受两个极限颜色"><a href="#d3-interpolate-a-b-接受两个极限颜色" class="headerlink" title="d3.interpolate(a,b)接受两个极限颜色"></a>d3.interpolate(a,b)接受两个极限颜色</h4><p>参考上面代码</p><h3 id="创建-线性渐变颜色-1"><a href="#创建-线性渐变颜色-1" class="headerlink" title="创建 线性渐变颜色"></a>创建 线性渐变颜色</h3><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义最小值和最大值对应的颜色</span></span><br><span class="line"><span class="keyword">var</span> a = d3.rgb(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>);<span class="comment">//浅蓝色</span></span><br><span class="line"><span class="keyword">var</span> b = d3.rgb(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>);<span class="comment">//蓝色</span></span><br><span class="line"><span class="comment">//定义一个线性渐变</span></span><br><span class="line">    <span class="keyword">var</span> defs = svg.append(<span class="string">"defs"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> linearGradient = defs.append(<span class="string">"linearGradient"</span>)</span><br><span class="line">                            .attr(<span class="string">"id"</span>,<span class="string">"linearColor"</span>)</span><br><span class="line">                            .attr(<span class="string">"x1"</span>,<span class="string">"0%"</span>)</span><br><span class="line">                            .attr(<span class="string">"y1"</span>,<span class="string">"0%"</span>)</span><br><span class="line">                            .attr(<span class="string">"x2"</span>,<span class="string">"100%"</span>)</span><br><span class="line">                            .attr(<span class="string">"y2"</span>,<span class="string">"0%"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stop1 = linearGradient.append(<span class="string">"stop"</span>)</span><br><span class="line">                    .attr(<span class="string">"offset"</span>,<span class="string">"0%"</span>)</span><br><span class="line">                    .style(<span class="string">"stop-color"</span>,a.toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> stop2 = linearGradient.append(<span class="string">"stop"</span>)</span><br><span class="line">                    .attr(<span class="string">"offset"</span>,<span class="string">"100%"</span>)</span><br><span class="line">                    .style(<span class="string">"stop-color"</span>,b.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个矩形，并应用线性渐变</span></span><br><span class="line">    <span class="keyword">var</span> colorRect = svg.append(<span class="string">"rect"</span>)</span><br><span class="line">                .attr(<span class="string">"x"</span>, <span class="number">20</span>)</span><br><span class="line">                .attr(<span class="string">"y"</span>, <span class="number">490</span>)</span><br><span class="line">                .attr(<span class="string">"width"</span>, <span class="number">140</span>)</span><br><span class="line">                .attr(<span class="string">"height"</span>, <span class="number">30</span>)</span><br><span class="line">                .style(<span class="string">"fill"</span>,<span class="string">"url(#"</span> + linearGradient.attr(<span class="string">"id"</span>) + <span class="string">")"</span>);</span><br></pre></td></tr></table></figure><h4 id="线性渐变定义在-defs-标签中"><a href="#线性渐变定义在-defs-标签中" class="headerlink" title="线性渐变定义在 defs 标签中"></a>线性渐变定义在 defs 标签中</h4><p>线性渐变就是上图 下面的那个渐变矩形框。<br>线性渐变定义在 defs 标签中。参考上面代码。</p><h4 id="定义一个带id的linearGradient"><a href="#定义一个带id的linearGradient" class="headerlink" title="定义一个带id的linearGradient"></a>定义一个带id的linearGradient</h4><p>如上，通过id来引用这个渐变颜色</p><h4 id="渐变颜色使用url-fill"><a href="#渐变颜色使用url-fill" class="headerlink" title="渐变颜色使用url fill"></a>渐变颜色使用url fill</h4><p>参考上面代码</p><h4 id="通过stop添加极限颜色"><a href="#通过stop添加极限颜色" class="headerlink" title="通过stop添加极限颜色"></a>通过stop添加极限颜色</h4><p>参考上面代码</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/av13492121/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">视频教程有7个，在这个网站上是能找到这七个视频的</a><br><a href="https://github.com/tianxuzhang/d3.v4-API-Translation" target="_blank" rel="noopener">D3.js 4.x API中文手册</a><br><a href="https://github.com/d3/d3-3.x-api-reference/blob/master/API-Reference.md" target="_blank" rel="noopener">D3.js 3.x API英文文档</a><br><a href="https://github.com/d3/d3-3.x-api-reference/blob/master/API-Reference.md" target="_blank" rel="noopener">D3.js 中文文档(包含最新版本中文文档，同时放出中英文各版本地址)</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> d3.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css笔记</title>
      <link href="/2021/01/03/css/"/>
      <url>/2021/01/03/css/</url>
      
        <content type="html"><![CDATA[<p>最近对从业以来的css知识从新梳理，整理成四篇博客，除本篇博客外，还有：<br><a href="http://127.0.0.1:4000/2019/04/06/css_vertical_align/" target="_blank" rel="noopener">《vertical-align、行盒子、baseline》</a><br><a href="http://127.0.0.1:4000/2019/04/13/css_mobile/" target="_blank" rel="noopener">《css之移动开发》</a><br><a href="http://127.0.0.1:4000/2019/04/14/css_layout/" target="_blank" rel="noopener">《css之布局》</a></p><h2 id="css需求方案"><a href="#css需求方案" class="headerlink" title="css需求方案"></a>css需求方案</h2><h3 id="三角"><a href="#三角" class="headerlink" title="三角"></a>三角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.triangle&#123;</span><br><span class="line">  height: 0;</span><br><span class="line">  width: 0;</span><br><span class="line">  border: 40px solid;</span><br><span class="line">  border-color: red #00ff37 #1b00ff #673AB7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下,边框的四边并非我们想象的四个矩形，而是四个三角形：<br><figure class="image-box">                <img src="/image/css/block.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>border-color可以接受透明色：transparent</p><p>将上面代码的border-color改成如下，即可得到一个三角：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-color: transparent transparent #1b00ff transparent;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/css/triangle.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="阴影box-shadow"><a href="#阴影box-shadow" class="headerlink" title="阴影box-shadow"></a>阴影box-shadow</h3><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><p>box-shadow: none|h-offset v-offset blur spread color |inset|initial|inherit;<br>            是否需要阴影|竖直偏移 水平偏移 模糊度 扩展度 颜色|方向|基本不用|基本不用<br>模糊度 其实就是对阴影的边缘进行模糊处理，让阴影与外界颜色过渡自然；<br>扩展度 在阴影的基础上，对阴影进行等长度加长，如图。<br><figure class="image-box">                <img src="/image/css/shadow6.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>方向 阴影默认向外扩散，可以设置向内；<br>下面通过一组图片展示每项参数意义：<br><figure class="image-box">                <img src="/image/css/shadow1.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/shadow2.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/shadow3.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/shadow4.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/css/shadow5.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="竖直、水平偏移都设置为0"><a href="#竖直、水平偏移都设置为0" class="headerlink" title="竖直、水平偏移都设置为0"></a>竖直、水平偏移都设置为0</h4><p>二者都设置为0，可以达到outline的效果，并且还有模糊度<br><figure class="image-box">                <img src="/image/css/shadow7.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="多个阴影"><a href="#多个阴影" class="headerlink" title="多个阴影"></a>多个阴影</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">height: 80px;</span><br><span class="line">width: 180px;</span><br><span class="line">background: gainsboro;</span><br><span class="line">box-shadow: 5px 5px blue, 10px 10px red, 15px 15px green;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/image/css/shadow8.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="box-shadow脱离文档流"><a href="#box-shadow脱离文档流" class="headerlink" title="box-shadow脱离文档流"></a>box-shadow脱离文档流</h4><p>box-shadow 是脱离文档流的，给元素设置box-shadow，无论数值多少，都不会让元素移动，这点很好</p><h4 id="box-shadow-与-filter"><a href="#box-shadow-与-filter" class="headerlink" title="box-shadow 与 filter"></a>box-shadow 与 filter</h4><p>filter也可以用来写一个阴影效果。filter还有其他很多功能。<br>以下两个写法，都可以达到元素阴影的效果，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filter: drop-shadow(0px 0px 10px gray);</span><br><span class="line">box-shadow:0px 0px 10px gray;</span><br></pre></td></tr></table></figure></p><h3 id="outline-轮廊线"><a href="#outline-轮廊线" class="headerlink" title="outline 轮廊线"></a>outline 轮廊线</h3><h4 id="outline能做到的效果："><a href="#outline能做到的效果：" class="headerlink" title="outline能做到的效果："></a>outline能做到的效果：</h4><figure class="image-box">                <img src="/image/css/outline.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="outline-相关属性："><a href="#outline-相关属性：" class="headerlink" title="outline 相关属性："></a>outline 相关属性：</h4><p>outline-width/outline-style/outline-color/outline-offse;</p><h4 id="outline-style的相反值："><a href="#outline-style的相反值：" class="headerlink" title="outline-style的相反值："></a>outline-style的相反值：</h4><ul><li><p>ridge groove</p></li><li><p>inset outset</p></li></ul><h4 id="outline-写法"><a href="#outline-写法" class="headerlink" title="outline 写法"></a>outline 写法</h4><p>outline 是 outline-width outline-style outline-color 的简写，如：<br>outline: 15px solid grey;<br>也可简写：outline: solid;</p><h4 id="outline-offse"><a href="#outline-offse" class="headerlink" title="outline-offse"></a>outline-offse</h4><p>outline-offse 是 outline相关的另外一个样式，但不包含在outline的简写当中。</p><h4 id="outline与box-shadow区别"><a href="#outline与box-shadow区别" class="headerlink" title="outline与box-shadow区别"></a>outline与box-shadow区别</h4><p>outline 与 box-shadow有时候可以达到相同效果，不同的是，当元素有border-redius，outline会有缝隙，box-shadow不会。</p><h3 id="充满父级或屏幕"><a href="#充满父级或屏幕" class="headerlink" title="充满父级或屏幕"></a>充满父级或屏幕</h3><h4 id="充满父级："><a href="#充满父级：" class="headerlink" title="充满父级："></a>充满父级：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="充满屏幕："><a href="#充满屏幕：" class="headerlink" title="充满屏幕："></a>充满屏幕：</h4><p>在css中position: fixed是由position: absolute发展而来，相对于屏幕定位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">position: fixed;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="0-5px的下边框"><a href="#0-5px的下边框" class="headerlink" title="0.5px的下边框"></a>0.5px的下边框</h3><h4 id="0-5px的元素"><a href="#0-5px的元素" class="headerlink" title="0.5px的元素"></a>0.5px的元素</h4><p>定义高度为1px，然后缩小高度一半，得到0.5px;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> .small&#123;</span><br><span class="line">     width: 200px;</span><br><span class="line">     background: blue;</span><br><span class="line">     height: 1px;</span><br><span class="line">     transform: scaleY(0.5);</span><br><span class="line"> &#125;</span><br><span class="line">&lt;div class=&quot;small&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="0-5px的下边框-1"><a href="#0-5px的下边框-1" class="headerlink" title="0.5px的下边框"></a>0.5px的下边框</h4><p>给要定义下边框的元素定义一个伪类，这样的好处是不用另外写html；<br>伪类相当于一个元素，在伪类中，写一个0.5px的元素;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.item::after &#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    background: blue;</span><br><span class="line">    height: 1px;</span><br><span class="line">    transform: scaleY(0.5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>关于渐变的东西太多，这里只写点东西，留个印象。</p><h4 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h4><p>线性渐变由linear-gradient定义，linear-gradient是一个css函数,</p><h5 id="同位置定义两个颜色"><a href="#同位置定义两个颜色" class="headerlink" title="同位置定义两个颜色"></a>同位置定义两个颜色</h5><p>同位置定义两个颜色会形成一个分割线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: linear-gradient(blue, green 30%, red 50%);</span><br></pre></td></tr></table></figure><p>从上到下，蓝色开始，到30%的位置时是绿色开始，到50%是红色开始，以后都是红色，效果：<br><figure class="image-box">                <img src="/image/css/linear1.jpg" alt="" title="" class="">                <p></p>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: linear-gradient(blue, green 50%, red 50%);</span><br></pre></td></tr></table></figure><p>同位置定义了绿色和红色 50%；发现绿色和红色重合了，这个也是一个小技巧，效果：<br><figure class="image-box">                <img src="/image/css/linear2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h5 id="其他值"><a href="#其他值" class="headerlink" title="其他值"></a>其他值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 渐变轴为45度，从蓝色渐变到红色 */</span><br><span class="line">linear-gradient(45deg, blue, red);</span><br><span class="line">/* 从右下到左上、从蓝色渐变到红色 */</span><br><span class="line">linear-gradient(to left top, blue, red);</span><br></pre></td></tr></table></figure><h4 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: radial-gradient(circle, red, yellow, green);</span><br></pre></td></tr></table></figure><h4 id="渐变的应用场景"><a href="#渐变的应用场景" class="headerlink" title="渐变的应用场景"></a>渐变的应用场景</h4><p>渐变的应用场景非常广泛，很多css技巧，很多图形，如四边形，菱形，梯形，多边形，格子背景，背景图案 等等，都可以有渐变完成；<br>在《css 揭秘》这边书中，有很多技巧都基于渐变完成</p><h3 id="伪元素做边框"><a href="#伪元素做边框" class="headerlink" title="伪元素做边框"></a>伪元素做边框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">        height: 100px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .text::after&#123;</span><br><span class="line">        content: &apos;&apos;;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        border: 1px solid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;text&quot;&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这其实利用了经常使用的遮罩方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//以此达到百分之百撑满body，这比width：100%要少很多想不到的问题</span><br><span class="line">.mask&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    background: grey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="cursor-光标图标"><a href="#cursor-光标图标" class="headerlink" title="cursor 光标图标"></a>cursor 光标图标</h3><p>设置光标图形，几乎你页面上看到的所有光标图样，都可以设置，参考MDN，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor: wait;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/css/cursor.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="跟随神器"><a href="#跟随神器" class="headerlink" title="跟随神器"></a>跟随神器</h3><p>js 函数，自适应方向上下左右浮动</p><h3 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h3><p>E:\css-mastery-16-master\chapter-04\04-33-experimenting-with-shadows.html</p><h3 id="平移和动画"><a href="#平移和动画" class="headerlink" title="平移和动画"></a>平移和动画</h3><p>可查看<a href="https://github.com/YeWills/css_demo" target="_blank" rel="noopener">GitHub上的demo</a><br>或查看<a href="https://github.com/YeWills/css_demo/tree/master/chapter-10" target="_blank" rel="noopener">GitHub上的demo</a></p><h3 id="四种居中方式"><a href="#四种居中方式" class="headerlink" title="四种居中方式"></a>四种居中方式</h3><h4 id="flex居中"><a href="#flex居中" class="headerlink" title="flex居中"></a>flex居中</h4><p> flex为水平和垂直居中而生，是当代居中最佳方案，这里是展示相对屏幕居中，如果是元素居中更加简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    position: fixed;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">   &#125;</span><br><span class="line">.wrap &#123;</span><br><span class="line">width: 18em;</span><br><span class="line">height: 18em;</span><br><span class="line">box-sizing: border-box;</span><br><span class="line">background: #00BCD4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt; &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><h4 id="translate居中"><a href="#translate居中" class="headerlink" title="translate居中"></a>translate居中</h4><p> flex没有出来之前，该方法最好，因为不需要知道元素宽度；<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//除flex外，最好的居中最好方法</span><br><span class="line"> .wrap &#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          top: 50%;</span><br><span class="line">          left: 50%;</span><br><span class="line">          transform: translate(-50%, -50%)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h4 id="margin负数"><a href="#margin负数" class="headerlink" title="margin负数"></a>margin负数</h4><p> 该方法有点，兼容性最强，弊端，需要知道元素宽度；<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//居中最好方法</span><br><span class="line"> .wrap &#123;</span><br><span class="line">          position: absolute;</span><br><span class="line">          top: 50%;</span><br><span class="line">          left: 50%;</span><br><span class="line">          margin-top: -3em;</span><br><span class="line">          margin-left: -9em;</span><br><span class="line">          width:18em;</span><br><span class="line">          height:6eml</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h4 id="视口vh方法"><a href="#视口vh方法" class="headerlink" title="视口vh方法"></a>视口vh方法</h4><p> 该方法局限性很大，只能相对于视口，也就是相对于屏幕居中，无法相对元素居中；<a href="http://dabblet.com/gist/bf12b39d8f5da2b6e5b6" target="_blank" rel="noopener">demo</a><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">width: 18em;</span><br><span class="line">height: 18em;</span><br><span class="line">margin: 50vh auto 0;</span><br><span class="line">transform: translateY(-50%);</span><br><span class="line">box-sizing: border-box;</span><br><span class="line">background: #00BCD4;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="自定义CheckBox"><a href="#自定义CheckBox" class="headerlink" title="自定义CheckBox"></a>自定义CheckBox</h3><p>主要是定义好这几个状态的样式： focus hover  同时focus和hover；<br>主要通过以下步骤：</p><h4 id="定义-label-for-和id"><a href="#定义-label-for-和id" class="headerlink" title="定义 label[for]和id"></a>定义 label[for]和id</h4><h4 id="隐藏元素input"><a href="#隐藏元素input" class="headerlink" title="隐藏元素input"></a>隐藏元素input</h4><h4 id="利用选择器-input-type-”checkbox”-label"><a href="#利用选择器-input-type-”checkbox”-label" class="headerlink" title="利用选择器 input[type=”checkbox”] + label"></a>利用选择器 input[type=”checkbox”] + label</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;input type=&quot;checkbox&quot; name=&quot;lang-as&quot; id=&quot;lang-as&quot;&gt;</span><br><span class="line">  &lt;label for=&quot;lang-as&quot;&gt;ActionScript&lt;/label&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input[type=&quot;checkbox&quot;] &#123;</span><br><span class="line">      position: absolute;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      width: 1px;</span><br><span class="line">      height: 1px;</span><br><span class="line">      clip: rect(0 0 0 0);</span><br><span class="line">    &#125;</span><br><span class="line">input[type=&quot;checkbox&quot;] + label &#123;</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">  color: #333;</span><br><span class="line">  padding-left: 1.5em;</span><br><span class="line">  background-position: .125em 36%;</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-size: 18px 18px;</span><br><span class="line">&#125;</span><br><span class="line">input[type=&quot;checkbox&quot;] + label &#123;</span><br><span class="line">  background-image: url(images/checkbox-unchecked.png);</span><br><span class="line">&#125;</span><br><span class="line">input[type=&quot;checkbox&quot;]:checked + label &#123;</span><br><span class="line">  background-image: url(images/checkbox-checked.png);</span><br><span class="line">&#125;</span><br><span class="line">input[type=&quot;checkbox&quot;]:focus + label &#123;</span><br><span class="line">  background-image: url(images/checkbox-unchecked-focus.png);</span><br><span class="line">&#125;</span><br><span class="line">input[type=&quot;checkbox&quot;]:focus:checked + label &#123;</span><br><span class="line">  background-image: url(images/checkbox-checked-focus.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/YeWills/css_demo/blob/master/chapter-09/09-checkbox.html" target="_blank" rel="noopener">demo</a></p><h3 id="如何适配移动端页面"><a href="#如何适配移动端页面" class="headerlink" title="如何适配移动端页面"></a>如何适配移动端页面</h3><h4 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h4><p>设置viewport让页面宽度与屏幕宽度适配，否则在移动端上显示时字体将变小</p><h4 id="rem／viewport／media-query"><a href="#rem／viewport／media-query" class="headerlink" title="rem／viewport／media query"></a>rem／viewport／media query</h4><p>通过rem、viewport、媒体查询等进行响应式设计</p><h4 id="设计上：隐藏-折行-自适应"><a href="#设计上：隐藏-折行-自适应" class="headerlink" title="设计上：隐藏 折行 自适应"></a>设计上：隐藏 折行 自适应</h4><p>功能设计上，pc端有的功能，移动端可以去掉隐藏；<br>pc端一行显示的，移动端多行显示；<br>给一些元素留下自适应的空间，让一些元素可大可小。</p><h3 id="扑克牌式展开图片-transform-origin"><a href="#扑克牌式展开图片-transform-origin" class="headerlink" title="扑克牌式展开图片(transform-origin)"></a>扑克牌式展开图片(transform-origin)</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cardfan</span> &gt; <span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">transform-origin</span>: center <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cardfan</span> <span class="selector-tag">img</span><span class="selector-pseudo">:first-child</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">rotate</span>(5deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cardfan</span> <span class="selector-tag">img</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">rotate</span>(-5deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h4><p>transform-origin 默认值为 center，如果直接旋转会达不到此效果，需要设置圆心，此时可达到扑克牌式样展开效果，此时设置位置如下，更多用法参考mdn，<br><figure class="image-box">                <img src="/image/css/transform-origin.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>另外也可以设置transform-origin: center -400px;显示相反效果。</p><h3 id="折角与翻页动画"><a href="#折角与翻页动画" class="headerlink" title="折角与翻页动画"></a>折角与翻页动画</h3><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><figure class="image-box">                <img src="/image/css/page.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="折角方案-两边border值为0"><a href="#折角方案-两边border值为0" class="headerlink" title="折角方案-两边border值为0"></a>折角方案-两边border值为0</h4><p>如下，border两面为0两面有值，形状如下，在上图图片的div上设置一个before伪元素，<br>伪元素content为0，只有两个border有width，半边白色，半边是带透明度的颜色(达到不完全遮住图片效果)：<br><figure class="image-box">                <img src="/image/css/page0.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div class=&quot;image-layer&quot; id=&quot;image-layer&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">.image-layer:before &#123;</span><br><span class="line">  content: &apos;&apos;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-width: 0;</span><br><span class="line">  border-color: rgba(0,0,0,0.2) #fff;</span><br><span class="line">  border-radius: 0 0 0 4px;</span><br><span class="line">  transition:all 0.4s ease-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.image-layer:hover:before&#123;</span><br><span class="line">  border-right-width:80px;</span><br><span class="line">  border-bottom-width:80px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="翻页动画方案-设置border-width为较大值"><a href="#翻页动画方案-设置border-width为较大值" class="headerlink" title="翻页动画方案-设置border-width为较大值"></a>翻页动画方案-设置border-width为较大值</h4><p>翻页是一个页面呈三角形状直至三角为0的过程，也可以使用上面的方案，只有两个border有width，半边白色，半边是带透明度的颜色，<br>当border-width足够大时，白色区域足够大，形成翻页效果。</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/3-3/border-width.html" target="_blank" rel="noopener">demo1</a><br><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/3-3/border-width-more.html" target="_blank" rel="noopener">demo2</a></p><h3 id="绕-椭-圆行驶动画-transform-origin"><a href="#绕-椭-圆行驶动画-transform-origin" class="headerlink" title="绕(椭)圆行驶动画 (transform-origin)"></a>绕(椭)圆行驶动画 (transform-origin)</h3><h4 id="绕圆行驶动画"><a href="#绕圆行驶动画" class="headerlink" title="绕圆行驶动画"></a>绕圆行驶动画</h4><p>这个最简单，绕自身旋转就是,原地打转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform:rotate(1turn)</span><br></pre></td></tr></table></figure></p><p>设置如下就可以绕圆行驶了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform-origin:center 150%;</span><br></pre></td></tr></table></figure></p><h4 id="绕椭圆行驶-translate"><a href="#绕椭圆行驶-translate" class="headerlink" title="绕椭圆行驶(translate)"></a>绕椭圆行驶(translate)</h4><p>椭圆的路径就要结合偏移了transform:translateY(200px);如下图，<br>每次行驶到上下两个顶点时候，让父节点跟着偏移：<br><figure class="image-box">                <img src="/image/css/circle-ani.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">  &lt;div class=&quot;butterfly&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;http://p7.qhimg.com/t01a4c54ef5309e561c.png&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/figure&gt;</span><br><span class="line"></span><br><span class="line">  .butterfly&#123;</span><br><span class="line">  width:150px;</span><br><span class="line">  height:142px;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  transform-origin:center 150%;</span><br><span class="line">  animation:circle 2s infinite linear;</span><br><span class="line">&#125;</span><br><span class="line">.butterfly img&#123;</span><br><span class="line">  width:100%;</span><br><span class="line">  height:auto;</span><br><span class="line">&#125;</span><br><span class="line">figure&#123;</span><br><span class="line">  margin-left: 200px;</span><br><span class="line">  animation:updown 1s infinite ease-in-out alternate;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes updown&#123;</span><br><span class="line">    to&#123;</span><br><span class="line">      transform:translateY(200px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes circle&#123;</span><br><span class="line">  to&#123;</span><br><span class="line">    transform:rotate(-1turn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h4><p><a href="https://github.com/YeWills/canvas-demo/tree/master/pages/multy/css-animation/3-4" target="_blank" rel="noopener">demo</a></p><h2 id="css知识"><a href="#css知识" class="headerlink" title="css知识"></a>css知识</h2><h3 id="行内盒子-匿名盒子"><a href="#行内盒子-匿名盒子" class="headerlink" title="行内盒子 匿名盒子"></a>行内盒子 匿名盒子</h3><p>具体参考 另外一篇博客《vertical-align、行盒子、baseline》<br>匿名盒子说的是没有任何标签的文本，如下， prity girl 这两个文本就是一个匿名盒子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">     prity girl</span><br><span class="line">     &lt;p&gt;can you liu one qq&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="float浮动定位"><a href="#float浮动定位" class="headerlink" title="float浮动定位"></a>float浮动定位</h3><p>参考 《css知识点汇 – float浮动定位》</p><h3 id="有关em"><a href="#有关em" class="headerlink" title="有关em"></a>有关em</h3><h4 id="font-size的em叠加"><a href="#font-size的em叠加" class="headerlink" title="font-size的em叠加"></a>font-size的em叠加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.it1&#123;</span><br><span class="line">  font-size:1.314em;</span><br><span class="line">&#125;</span><br><span class="line">.it2&#123;</span><br><span class="line">  font-size:1.314em;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;it1&quot;&gt;</span><br><span class="line">  &lt;!-- 元素1  font-size 将为16px*1.314 =21px --&gt;</span><br><span class="line">  元素1</span><br><span class="line">  &lt;!-- 元素2  font-size 将为16px*1.314*1.314 =28px --&gt;</span><br><span class="line">  &lt;div class=&quot;it2&quot;&gt;元素2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="font-size-1-314em-与-height-1-314em-区别"><a href="#font-size-1-314em-与-height-1-314em-区别" class="headerlink" title="font-size:1.314em 与 height: 1.314em 区别"></a>font-size:1.314em 与 height: 1.314em 区别</h4><p>由下面代码可知，font-size 与 height\margin\padding这些属性不一样；<br>font-size的em的基准是父font-size;<br>height\margin\padding等的em基准是自身的font-size；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.it1&#123;</span><br><span class="line">  font-size:1.314em;</span><br><span class="line">&#125;</span><br><span class="line">.it2&#123;</span><br><span class="line">  font-size:1.314em;</span><br><span class="line">  height: 1.314em;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;it1&quot;&gt;</span><br><span class="line">  &lt;!-- 元素1  font-size 将为16px*1.314 =21px --&gt;</span><br><span class="line">  元素1</span><br><span class="line">  &lt;!-- 元素2  font-size 将为16px*1.314*1.314 =28px --&gt;</span><br><span class="line">  &lt;!-- 元素2  height  将为自己的font-size*1.314 =36px --&gt;</span><br><span class="line">  &lt;div class=&quot;it2&quot;&gt;元素2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="em的使用场景"><a href="#em的使用场景" class="headerlink" title="em的使用场景"></a>em的使用场景</h4><p>font-size<br>padding<br>border-radius (不包含border-with)<br>margin</p><h4 id="为什么要使用em"><a href="#为什么要使用em" class="headerlink" title="为什么要使用em"></a>为什么要使用em</h4><p>当你想要当前元素的 padding\padding\border-radius\box-shadow\text-shadow\margin\line-height 等值，与当前字体大小成比例的时候，使用 em 单位。</p><h3 id="rem的使用场景"><a href="#rem的使用场景" class="headerlink" title="rem的使用场景"></a>rem的使用场景</h3><p>rem 主要用于移动端适配，pc端用得少.</p><h3 id="display-none与visibility-hidden"><a href="#display-none与visibility-hidden" class="headerlink" title="display:none与visibility:hidden"></a>display:none与visibility:hidden</h3><p>display:none 不为被隐藏的对象保留其物理空间<br>visibility：hidden 为被隐藏的对象保留其物理空间</p><h3 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::before  //伪元素</span><br><span class="line">:focus  //伪类</span><br></pre></td></tr></table></figure><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><p>伪元素是真的有元素，伪类只是元素的状态。</p><h4 id="content-attr-url-counter"><a href="#content-attr-url-counter" class="headerlink" title="content - attr\url\counter"></a>content - attr\url\counter</h4><h5 id="配合attr使用"><a href="#配合attr使用" class="headerlink" title="配合attr使用"></a>配合attr使用</h5><p>attr是css3的一个属性。<br>attr是用来content与元素进行通信的一个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.text[show-tip]:hover::before&#123;</span><br><span class="line">    content: attr(show-tip);</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: -150%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translateX(-50%);</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;span class=&quot;text&quot; show-tip=&quot;6666&quot;&gt; prity girl&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><h5 id="配合url使用"><a href="#配合url使用" class="headerlink" title="配合url使用"></a>配合url使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1:after &#123;content:url(/i/w3school_logo_white.gif)&#125;</span><br></pre></td></tr></table></figure><h5 id="配合counter使用"><a href="#配合counter使用" class="headerlink" title="配合counter使用"></a>配合counter使用</h5><p>用得较少，用来计数，更多请-&gt;Google<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.conter p:before&#123;</span><br><span class="line">                   content: counter(count,decimal) &quot;.&quot; /*调用计数器 并在数字后添加.*/</span><br><span class="line">                   counter-increment: count;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure></p><h4 id="伪元素相当于父级内的内联span元素"><a href="#伪元素相当于父级内的内联span元素" class="headerlink" title="伪元素相当于父级内的内联span元素"></a>伪元素相当于父级内的内联span元素</h4><p>伪类其实相当于定义在父级元素内的内联span元素或匿名行内元素，可以通过display改变其属性。<br>把伪类当成父级元素内的元素看即可，没有什么不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   .father::after&#123;</span><br><span class="line">            content: &apos;after伪类 content&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        .father::before&#123;</span><br><span class="line">            content: &apos;before伪类 content&apos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;father&quot;&gt;父元素的text&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;span&gt;before伪类 content&lt;/span&gt;</span><br><span class="line">    父元素的text</span><br><span class="line">    &lt;span&gt;after伪类 content&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>由上得出：</p><ul><li>before 相当于 紧跟父元素之前的行内块；</li><li>after 相当于 紧跟父元素之后的行内块</li></ul><h4 id="hover-before"><a href="#hover-before" class="headerlink" title=":hover::before"></a>:hover::before</h4><p>伪类结合伪元素一起使用<br>参考《content几种用法》<br>参考《自定义CheckBox》</p><h4 id="hover-active-focus-onblur-经典应用"><a href="#hover-active-focus-onblur-经典应用" class="headerlink" title="hover active focus onblur 经典应用"></a>hover active focus onblur 经典应用</h4><p>一个按钮的hover active focus onblur这三个状态触发时候先后顺序的<br>hover  鼠标悬浮按钮上；<br>active  左键按住按钮；<br>focus  左键松开后，激活按钮状态为focus；<br>onblur 左键点击任意位置，变为非focus状态</p><p>理解上面四个状态非常关键，很多基本的样式都是基于上面开发的，一个前端不早弄懂上面四个状态，哭都没地方去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.btn:hover&#123;</span><br><span class="line">    background: blueviolet;</span><br><span class="line">&#125;</span><br><span class="line">.btn:active:focus&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">.btn:focus&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    outline: 2px solid yellow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> &lt;button class=&quot;btn&quot;&gt;9999999&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><h4 id="focus-与-tabindex"><a href="#focus-与-tabindex" class="headerlink" title="focus 与 tabindex"></a>focus 与 tabindex</h4><p>tabindex 是html5属性 ，非常好用， 指示其元素是否可以聚焦<br>在html4中，不是每个标签都拥有focus属性，在html5中，通过tabindex，每个标签都可以定义focus属性。<br>参考《博客—html笔记—tabindex》</p><h4 id="伪元素做边框-1"><a href="#伪元素做边框-1" class="headerlink" title="伪元素做边框"></a>伪元素做边框</h4><p>参考《伪元素做边框》</p><h3 id="大汇集"><a href="#大汇集" class="headerlink" title="大汇集"></a>大汇集</h3><p>font-weight 默认为normal，normal对应数值为400，可以使用关键字 normal、bold等等，也可以使用数数值，都是100的整数：100、200、300、400等等<br>text-transform 可以使英文单词首字母大写或者所有字母大写，或者所有字符小写的功能；<br>word-spacing: 0.1em; 英文单词间距<br>letter-spacing: 0.1em; 英文字母间距<br>text-shadow ： 字体阴影效果<br>text-overflow: ellipsis或clip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clip : 不显示省略标记（...），而是简单的裁切</span><br><span class="line">ellipsis : 当对象内文本溢出时显示省略标记（...）</span><br></pre></td></tr></table></figure></p><p>columns 可用来文本分多栏显示；<br>pointer-events 可用来打开的禁止元素的事件响应，设置为none的时候，不会触发该元素的hover和click事件；</p><h3 id="font-face写法"><a href="#font-face写法" class="headerlink" title="@font-face写法"></a>@font-face写法</h3><p>format 给浏览器提示，src内的文件类型是什么，方便浏览器阅读；<br>font-face用的是后备机制写法，如下src写了很多，就是给不同设备的浏览器解析，增加兼容性；<br>font-weight和font-style作为可选配置，如果配置了，那么在使用此字体时，必须设置与<strong>这里一样的font-weight和font-style值时才起作用,这点很容易让人忽视</strong><br>见P84《精通css 高级web标准解决方案》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  @font-face &#123;</span><br><span class="line">font-family: &apos;YourWebFontName&apos;;</span><br><span class="line">   font-weight: &apos;400&apos;;</span><br><span class="line">src: url(&apos;YourWebFontName.eot&apos;); /* IE9 Compat Modes */</span><br><span class="line">src: url(&apos;YourWebFontName.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */</span><br><span class="line">            url(&apos;YourWebFontName.woff&apos;) format(&apos;woff&apos;), /* Modern Browsers */</span><br><span class="line">            url(&apos;YourWebFontName.ttf&apos;)  format(&apos;truetype&apos;), /* Safari, Android, iOS */</span><br><span class="line">            url(&apos;YourWebFontName.svg#YourWebFontName&apos;) format(&apos;svg&apos;); /* Legacy iOS */</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="position定位相关"><a href="#position定位相关" class="headerlink" title="position定位相关"></a>position定位相关</h3><p>position:relactive:<br>相对定位：相对于自身原位置偏移；<br>仍处于标准文档流中；<br>随即拥有偏移属性和z-index属性；</p><p>position:absolute:<br>绝对定位：<br>完全脱离了标准文档流；<br>随即拥有偏移属性和z-index属性；<br>元素具有了包裹性，与float类似；</p><h3 id="颜色值函数-rgb-rgba-hsla"><a href="#颜色值函数-rgb-rgba-hsla" class="headerlink" title="颜色值函数-rgb/rgba/hsla"></a>颜色值函数-rgb/rgba/hsla</h3><p>rgba是rgb的进化版，带有透明度；</p><p>#ffffff 六位数是没有透明度的；</p><p>#00000000 八位数的是有透明度的；<br>hsla是hsl的进化版，带有透明度；<br>hsla其实没什么特别的，也就跟rgba一样是个颜色单位，貌似它与rgba区别的是，hsla写法更加简洁。</p><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><h4 id="关于background本身"><a href="#关于background本身" class="headerlink" title="关于background本身"></a>关于background本身</h4><p>background是个简写属性，会重置以前定义的很多background属性，因此定义的时候，把它放在最上面，然后使用background-color等等属性叠加定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//不推荐，background会重置background-repeat属性，达不到no-repeat效果</span><br><span class="line">background-repeat: no-repeat;</span><br><span class="line">background: url(../image/css/vertical-align/column.png);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//推荐这种写法</span><br><span class="line">  background: url(../image/css/vertical-align/column.png);</span><br><span class="line">  background-repeat: no-repeat;</span><br></pre></td></tr></table></figure><h4 id="background多重背景"><a href="#background多重背景" class="headerlink" title="background多重背景"></a>background多重背景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background: url(./column.png), url(./column1.png), url(./column2.png), url(./column3.png);</span><br><span class="line">background-position: left top, right top, left bottom, right bottom;</span><br><span class="line">background-repeat: no-repeat, no-repeat, no-repeat, no-repeat;</span><br><span class="line">background-color: pink;</span><br></pre></td></tr></table></figure><h4 id="带颜色-图片-定位的背景"><a href="#带颜色-图片-定位的背景" class="headerlink" title="带颜色\图片\定位的背景"></a>带颜色\图片\定位的背景</h4><p>蓝色背景、背景图片、背景图片距离父级右边19px底部向上10px.<a href="http://dabblet.com/gist/0f226e63595d1bef88cb" target="_blank" rel="noopener">demo</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">           background: url(../image/css/outLine.jpg)  no-repeat  blue;</span><br><span class="line">         background-position: right 19px bottom 10px;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h4 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h4><p>如果要让背景图片充满整个元素，则基本上要用到这个属性<br>background-size: 100% 100%  背景图片的宽度为元素宽度100%，高度为元素高度100% （此种写法会让图片充满元素，但会失真）<br>background-size: 100% auto  背景图片的宽度为元素宽度100%，高度由浏览器自动计算一个值，保持不失真(推荐)<br>其他可取值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">background-size:auto;</span><br><span class="line">background-size:cover;</span><br><span class="line">background-size:contain;</span><br><span class="line">background-size:auto;</span><br><span class="line">background-size:50px;</span><br><span class="line">background-size:50%;</span><br></pre></td></tr></table></figure></p><h4 id="background相关属性"><a href="#background相关属性" class="headerlink" title="background相关属性"></a>background相关属性</h4><p><a href="https://www.jianshu.com/p/e377c0bebfd0" target="_blank" rel="noopener">background-origin：background-origin 属性规定 background-position 属性相对于什么位置来定位。</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-origin: padding-box|border-box|content-box;</span><br></pre></td></tr></table></figure></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip" target="_blank" rel="noopener">background-clip 规定背景的绘制区域;</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-clip: padding-box|border-box|content-box;</span><br></pre></td></tr></table></figure><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。<br>两个概念：主轴、辅轴(交叉轴)；</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>以下6个属性设置在容器上</p><ul><li>flex-direction</li><li>flex-wrap  —是否换行</li><li><strong>flex-flow 上面二者缩写</strong></li><li>justify-content</li><li>align-items</li><li>align-content 多行（多轴）如何对齐，与align-items意义一样，前者是单行，后者多行；</li></ul><ul><li>order 定义项目的排列顺序，实际中用得少；</li><li>flex-grow 放大</li><li>flex-shrink 收缩</li><li>flex-basis 属性定义了在<strong>分配多余空间之前</strong>，项目占据的主轴空间，容器根据这个属性，计算主轴是否有多余空间，然后决定如何执行- flex-grow或flex-shrink，这个属性是flex中比较难理解的，同时设置width和flex-basic时，flex-basic覆盖width，在flex子项中，建议使用flex-basic，少用width，有些人说，flex-basic是用来代替width的。</li><li><strong>flex 上面三者的简写</strong>  flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]</li><li>align-self  单独垂直对齐，可覆盖align-items属性</li></ul><h4 id="运用技巧"><a href="#运用技巧" class="headerlink" title="运用技巧"></a>运用技巧</h4><h5 id="行内自适应宽度"><a href="#行内自适应宽度" class="headerlink" title="行内自适应宽度"></a>行内自适应宽度</h5><p>一行当中，某几个行元素固定高度，给剩下一个元素随意定义一个flex值，比如1、2、3…都可以，让这个元素自适应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">         display: flex;</span><br><span class="line">     &#125;</span><br><span class="line">     .box-item1&#123;</span><br><span class="line">         width: 80px;</span><br><span class="line">         background: rebeccapurple;</span><br><span class="line">     &#125;</span><br><span class="line">     .box-item2&#123;</span><br><span class="line">         flex: 1;</span><br><span class="line">         background: red;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &lt;div class=&quot;box box-2&quot;&gt;</span><br><span class="line">             &lt;div class=&quot;box-item1&quot;&gt;2&lt;/div&gt;</span><br><span class="line">             &lt;div class=&quot;box-item2&quot;&gt;3&lt;/div&gt;</span><br><span class="line">         &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>效果：<br><figure class="image-box">                <img src="/image/css/flex1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="flex-shrink-IE与谷歌差异"><a href="#flex-shrink-IE与谷歌差异" class="headerlink" title="flex-shrink IE与谷歌差异"></a>flex-shrink IE与谷歌差异</h4><p>flexbox的规范是 当空间小是，元素宽度随之减少，当减少到元素的width时，将不再减少。<br>目前谷歌和火狐以及Op浏览器忽略上面这个规范，也就是说在这些浏览器中，元素可以减少到0px宽度；<br>IE遵守以上规范，当元素减少到width时，将不再减少。</p><h4 id="absolute与flex同时使用的黑特性"><a href="#absolute与flex同时使用的黑特性" class="headerlink" title="absolute与flex同时使用的黑特性"></a>absolute与flex同时使用的黑特性</h4><p>见另外一篇博客《css趣事 - 如何absolute的子元素不换行 - absolute与flex同时使用的黑特性》</p><h3 id="媒体查询-与-响应式布局"><a href="#媒体查询-与-响应式布局" class="headerlink" title="媒体查询 与 响应式布局"></a>媒体查询 与 响应式布局</h3><h4 id="媒体查询能查的特性"><a href="#媒体查询能查的特性" class="headerlink" title="媒体查询能查的特性"></a>媒体查询能查的特性</h4><p>可以尺度查询，如max-width；<br>可以宽高比查询：<br>可以横竖屏方向查询；<br>可以设备像素比查询 min-resolution<br>见P220</p><h4 id="媒体查询的技巧"><a href="#媒体查询的技巧" class="headerlink" title="媒体查询的技巧"></a>媒体查询的技巧</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* 这种媒体查询的写法，很妙，由上到下进行层叠，下面的覆盖上面的，达到不用写 这种形式：30em&lt;width&lt;56em ,使用一个min-width就达到效果*/</span><br><span class="line"></span><br><span class="line">    @media only screen and (min-width: 35em) &#123;</span><br><span class="line">      .row-quartet &gt; * &#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">      .subcategory-featured &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @media only screen and (min-width: 50em) &#123;</span><br><span class="line">      .row-quartet &gt; * &#123;</span><br><span class="line">        width: 25%;</span><br><span class="line">      &#125;</span><br><span class="line">      .subcategory-featured &#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    @media only screen and (min-width: 70em) &#123;</span><br><span class="line">      .subcategory-header &#123;</span><br><span class="line">        width: 20%;</span><br><span class="line">      &#125;</span><br><span class="line">      .subcategory-content &#123;</span><br><span class="line">        width: 80%;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="很妙的响应式布局简单范例"><a href="#很妙的响应式布局简单范例" class="headerlink" title="很妙的响应式布局简单范例"></a>很妙的响应式布局简单范例</h4><p>GitHub 08-05-responsive-news.html</p><h4 id="感受下最简单的响应式设计demo"><a href="#感受下最简单的响应式设计demo" class="headerlink" title="感受下最简单的响应式设计demo"></a>感受下最简单的响应式设计demo</h4><p>E:\css-mastery-16-master\chapter-08\08-05-responsive-news.html</p><h4 id="响应式设计-的一些应用"><a href="#响应式设计-的一些应用" class="headerlink" title="响应式设计 的一些应用"></a>响应式设计 的一些应用</h4><p>对字体的设计：<br>  body {<br>      font-family: ‘Open Sans’, ‘Helvetica Neue’, Arial, sans-serif;<br>      line-height: 1.5;<br>    }<br>    @media only screen and (max-width: 37.5em) {<br>      h1,h2,h3,h4,h5,h6 {<br>        font-family: ‘Open Sans Condensed’, ‘Arial Narrow’, Arial, sans-serif;<br>      }<br>    }<br>高清图或多倍图或大小图查询：<br> .profile-box {<br>      position: relative;<br>      height: 300px;<br>      background-size: cover;<br>      background-position: 50% 50%;<br>      background-image: url(img/small-cat.jpg);<br>    }<br>    @media only screen and (min-width: 600px) {<br>      .profile-box {<br>        height: 600px;<br>        background-image: url(img/big-cat.jpg);<br>      }<br>    }</p><h4 id="更多响应布局知识"><a href="#更多响应布局知识" class="headerlink" title="更多响应布局知识"></a>更多响应布局知识</h4><p>参考博客《css之布局》</p><h3 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>calc能识别 px、百分比、em，且可以混写，如下有效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width: calc(50% + 20px*4 - 1em);</span><br></pre></td></tr></table></figure></p><p>注意，calc值内，运算符两边需要空格，否则无效。</p><h4 id="calc居中-50-xx"><a href="#calc居中-50-xx" class="headerlink" title="calc居中__50%-xx"></a>calc居中__50%-xx</h4><p>以下是常规利用margin auto让img图片居中的方法，弊端是需要给图片设置display: block;,原因参考《margin:0 auto在inline-block失效》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">        background: rebeccapurple;</span><br><span class="line">    &#125;</span><br><span class="line">img&#123;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br><span class="line"> &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;img class=&quot;dd&quot; src=&quot;http://csssecrets.io/images/adamcatlace.jpg&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>可以使用calc来实现，可以让代码更简洁，利用的是数学原理，假设图片长度已知为400px；<br>那么 100%- (50%-200px)*2 = 400px ;这个400px就是图片长度，100%是父级宽度50%-200px是内边距或外边距。<br>记住 50%-xx 是calc居中的套路。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line"> .wrap &#123;</span><br><span class="line">        background: rebeccapurple;</span><br><span class="line">        padding: 0 calc(50% - 200px);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line">img&#123;</span><br><span class="line">    margin: 0 calc(50% - 200px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="css3较好特性"><a href="#css3较好特性" class="headerlink" title="css3较好特性"></a>css3较好特性</h3><h4 id="max-width-min-content"><a href="#max-width-min-content" class="headerlink" title="max-width: min-content"></a>max-width: min-content</h4><p> min-content是css3关键字，<br> 众所周知，如果不给元素一个具体的height,它就会自动适应内容的高度。假如我们希望width也具有同样的类似行为，如何达到，此时可以使用min-content。<br> min-content 这个关键字将解析为这个容器内部最大的不可短行元素高度（即最宽的单词、图片或具有固定宽度的盒元素）<br><a href="https://www.jianshu.com/p/b7c929fce368" target="_blank" rel="noopener">直接参考这里</a><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> .wrap &#123;</span><br><span class="line">max-width: min-content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;http://csssecrets.io/images/adamcatlace.jpg&quot; /&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          The great Sir Adam Catlace was named after Countess Ada Lovelace, the first programmer ever.</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="base64图片"><a href="#base64图片" class="headerlink" title="base64图片"></a>base64图片</h3><p>base64来代替png图片，利于减少http请求，提高性能，但是图片经过编译变成base64文本时，其体积大小增加了三分之一，增加了css或html体积。<br>因此base64一般用于小图片，由于base64文本不利于后期修改和维护，所一般不直接使用base64，而是通过webpack等编译的方式，将png形式的图片编译成base64.<br>因此有以下特点：</p><h4 id="base64是文本"><a href="#base64是文本" class="headerlink" title="base64是文本"></a>base64是文本</h4><h4 id="base64要比原来图片体积增加1-3"><a href="#base64要比原来图片体积增加1-3" class="headerlink" title="base64要比原来图片体积增加1/3"></a>base64要比原来图片体积增加1/3</h4><h4 id="base64用于小图片"><a href="#base64用于小图片" class="headerlink" title="base64用于小图片"></a>base64用于小图片</h4><h4 id="通过打包生成base64"><a href="#通过打包生成base64" class="headerlink" title="通过打包生成base64"></a>通过打包生成base64</h4><h4 id="base64的使用减少了http请求"><a href="#base64的使用减少了http请求" class="headerlink" title="base64的使用减少了http请求"></a>base64的使用减少了http请求</h4><h3 id="css动画相关知识"><a href="#css动画相关知识" class="headerlink" title="css动画相关知识"></a>css动画相关知识</h3><p>参考《css知识点汇 – css动画》</p><h2 id="css黑知识"><a href="#css黑知识" class="headerlink" title="css黑知识"></a>css黑知识</h2><h3 id="css-覆盖原则"><a href="#css-覆盖原则" class="headerlink" title="css 覆盖原则"></a>css 覆盖原则</h3><p>简写的方式，最容易覆盖原来定义好的规则，修改已有代码时，不覆盖以前样式的方式就是不要写简写。<br>例如outline，background的等等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outline-width: 15px;</span><br><span class="line">outline-color: #00BCD4;</span><br><span class="line">outline: solid; //覆盖了以上两句css样式，实际展示的轮廊线将为 默认的size，和黑色</span><br></pre></td></tr></table></figure></p><h3 id="font-family-多值写法"><a href="#font-family-多值写法" class="headerlink" title="font-family 多值写法"></a>font-family 多值写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Times new Roman 使用了引号，因为它有空格，当有空格时，最好加上引号，也可以不加</span><br><span class="line">font-family: Georgia, Times, &quot;Times new Roman&quot;, sefif;</span><br></pre></td></tr></table></figure><p>后备机制是font-family的重要特性。<br>以上是一种后备写法，从左到右，优先级左边最高，当此值在浏览器中无法识别时，往右顺延。</p><h3 id="参照的是父级的什么属性"><a href="#参照的是父级的什么属性" class="headerlink" title="% 参照的是父级的什么属性"></a>% 参照的是父级的什么属性</h3><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 10%;</span><br><span class="line">    left: 10%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>left 参照父级的 width；<br>top 参照父级的 height；</p><h4 id="margin-参照父width"><a href="#margin-参照父width" class="headerlink" title="margin 参照父width"></a>margin 参照父width</h4><p>margin 百分比只参照父级的宽度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    margin-left: 10%;//父级的宽度</span><br><span class="line">    margin-top: 10%;//父级的宽度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="margin-0-auto在inline-block失效"><a href="#margin-0-auto在inline-block失效" class="headerlink" title="margin:0 auto在inline-block失效"></a>margin:0 auto在inline-block失效</h3><p>如下，child将不居中；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    .wrap&#123;</span><br><span class="line">            background: #00bcd4b5;</span><br><span class="line">            height: 90px;</span><br><span class="line">        &#125;</span><br><span class="line">        .child&#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            height: 50px; </span><br><span class="line">            width: 100px;</span><br><span class="line">            background: rebeccapurple;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>解决的方法就是从新设置 child 的display: block;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.child&#123;</span><br><span class="line">    &lt;!-- 其他不变 --&gt;</span><br><span class="line">     display: block;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>为什么margin: 0 auto对inline-block无效呢，对于margin来说，auto是一个特殊关键字，在<a href="https://www.w3schools.com/css/css_margin.asp" target="_blank" rel="noopener">以下是w3c关于margin的auto关键字执行机制的解释</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">You can set the margin property to auto to horizontally center the element within its container.</span><br><span class="line">The element will then take up the specified width, and the remaining space will be split equally between the left and right margins:</span><br><span class="line">可以将Margin属性设置为Auto，使元素在其容器内水平居中。</span><br><span class="line">元素将占用指定的宽度(就是自己的width)，剩余的空间将在左右页边距之间平均分配：</span><br></pre></td></tr></table></figure></p><p>从上面的话中，我们知道，要想auto有效，必须提供如下条件—</p><ul><li>必须给元素设置宽度<br>浏览器要将元素所处的行的宽度减去元素宽度，获得剩余宽度，然后平均分配；</li><li>必须是块级元素<br>必须是block元素，因为在block元素中，这一行只有这一个元素，如果不是block，例如是inline-block时，就算浏览器可以让元素居中，但是该行中还有其他行内元素，那么这个居中元素是覆盖还是将其他行内元素一起居中呢。<br>所以非block元素，auto关键字无效。<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4></li><li>这里说的是auto关键字无效，而不是margin这个属性失效，auto无效，你也可以给定一个具体值，margin都是有效的；</li><li>对于img，button这些元素本身是有宽度的，可以不用设置宽度，只需指定display: block;就可以使用 margin:0 auto居中；</li><li>对于行内元素，含inline-block，要让他们居中的最好方法是text-align,毕竟text-align是针对行内元素居中而创造的，这个故事告诉我们，对于不同类型的居中，虽然很多种方法都可以居中，但要选对规范的犯法;<br>简单点就是，块级元素 使用 margin: 0 auto居中，行内元素使用text-align居中； <h4 id="敲黑板"><a href="#敲黑板" class="headerlink" title="敲黑板"></a>敲黑板</h4>在现代浏览器中，如果要把一些东西水平居中，使用 display:flex; 对于不兼容flex的浏览器如IE8-9 才建议使用 margin: 0 auto;</li></ul><h3 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h3><p>外边距折叠只发生在margin垂直方向，水平方向没有此现象，所以外边距折叠，指的就是margin-top与margin-bottom两个方向。</p><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  .wrap&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            height: 150px;</span><br><span class="line">        &#125;</span><br><span class="line">        .chilid&#123;</span><br><span class="line">            margin-top: 80px;</span><br><span class="line">            height: 50px; </span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;chilid&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><figure class="image-box">                <img src="/image/css/margin1.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>这里的效果并没有达到我们的预期，我们对chilid做了margin-top，那么child理应是相对父wrap进行margin，而实际中，child却相对浏览器边缘进行了margin-top；<br>这就是外边距折叠的现象之一。</p><p>解决方案，就是在wrap中写一个border或者写一个padding，就可以达到预期效果了；</p><h4 id="其他外边距折叠现象："><a href="#其他外边距折叠现象：" class="headerlink" title="其他外边距折叠现象："></a>其他外边距折叠现象：</h4><figure class="image-box">                <img src="/image/css/margin2.png" alt="" title="" class="">                <p></p>            </figure><h4 id="出现外边距折叠的条件"><a href="#出现外边距折叠的条件" class="headerlink" title="出现外边距折叠的条件"></a>出现外边距折叠的条件</h4><p>外边距折贴<strong>只发生在正常文档流中的块级元素的 margin 垂直方向上；</strong><br>margin水平方向无此现象；<br>行内盒子，浮动盒子，绝对定位无此现象；<br>而且块级元素发生此现象的另外重要条件是，父元素<strong>既没有border又没有padding才会发生此现象</strong>。参考上面的例子。<br>所以我们在实际开发中，往往要对header进行margin-top处理时，不要使用margin-top，使用padding-top代替，因为可能会发生折叠现象；<br>外边距折叠现象其实是有很多好处的，可以避免很多多余的margin，可参考 《精通css》P45页，<a href="https://www.w3schools.com/css/css_margin.asp" target="_blank" rel="noopener">外网w3c也提到了margin 垂直方向上的折叠现象</a>;</p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>块格式化上下文，全称Block Formatting Context，你也可以叫它肯德基；相关概念去mdn或w3c查。</p><h4 id="BFC特征"><a href="#BFC特征" class="headerlink" title="BFC特征"></a>BFC特征</h4><p>BFC有以下特征：</p><ul><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的左外边缘（margin-left)， 与包含块的左边（contain box left）相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。</li><li>BFC的区域不会与float box重叠（可阻止因浮动元素引发的文字环绕现象）。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 (利用此特性，解决外边距折叠问题)</li><li>计算BFC的高度时，浮动元素也参与计算 （利用这一特性，使用overflow消除浮动）<br><a href="https://segmentfault.com/a/1190000009545742" target="_blank" rel="noopener">参考1</a><br><a href="https://www.jianshu.com/p/11e764268c0d" target="_blank" rel="noopener">参考2</a></li></ul><h4 id="创建一个BFC"><a href="#创建一个BFC" class="headerlink" title="创建一个BFC"></a>创建一个BFC</h4><p>根元素或其它包含它的元素<br>浮动 (元素的 float 不是 none)<br>绝对定位的元素 (元素具有 position 为 absolute 或 fixed)<br>块级元素具有overflow ，且值不是 visible<br>非块级元素具有 display: inline-block，table-cell, table-caption, flex, inline-flex<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">更多创建方式</a></p><h4 id="为什么要创建BFC"><a href="#为什么要创建BFC" class="headerlink" title="为什么要创建BFC"></a>为什么要创建BFC</h4><p>在MDN中单独讲了BFC的两个作用：消除浮动与避免外边距折叠；<br>所以，在正常编程中，我们不用刻意去关心什么是BFC，不过当遇到消除浮动，消除浮动环绕，消除外边距折叠问题时，为了解决这个问题，<br>我们可以创建一个BFC来解决，为什么BFC能解决？<br>因为BFC有自己的特征，一旦元素变成了一个BFC，它就具备了BFC赋给它的特征，而这些特征可以解决上面说的问题。</p><h4 id="消除浮动"><a href="#消除浮动" class="headerlink" title="消除浮动"></a>消除浮动</h4><p>子元素定义float后，父元素的高度变成很小或者0了，这个时候，我们可以将父元素变成一个BFC，而利用BFC上面的特征6，计算BFC的高度时，浮动元素也参与计算 ，这个时候父元素的高度将包含浮动的子元素高度，解决浮动了。<br>由上面可知，将元素定义一个overflow，可以将该元素编程BFC。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">    background: red;</span><br><span class="line">    width: 100%;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.chilid&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 50px; </span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;chilid&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h4><p><a href="https://segmentfault.com/a/1190000009545742" target="_blank" rel="noopener">不多写了，直接参考这里的—&lt;2. 布局：自适应两栏布局&gt;</a>，效果如下：<br><figure class="image-box">                <img src="/image/css/margin3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="消除外边距折叠"><a href="#消除外边距折叠" class="headerlink" title="消除外边距折叠"></a>消除外边距折叠</h4><p>这里有两个例子<br><a href="https://segmentfault.com/a/1190000009545742" target="_blank" rel="noopener">一个例子，见文中的–防止垂直margin合并</a><br>第二个例子，我们改写下 《外边距折叠》章节的《现象》例子，给wrap添加一个float属性，将.wrap变成一个BFC，利用BFC特征5：BFC就是页面上的一个隔离的独立容器，margin是wrap的一部分，所以margin不受外部影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    float: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="推荐使用伪元素来消除浮动"><a href="#推荐使用伪元素来消除浮动" class="headerlink" title="推荐使用伪元素来消除浮动"></a>推荐使用伪元素来消除浮动</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>参考《精通css》P181，<br>对于小的元素，使用overflow是比较方便，可以使用overflow；<br>对于大的元素，可能元素需要显示滚动条，或者有些定位元素需要放在这个大的元素之外，这时候使用overflow可能产生不利影响，所以大的元素，推荐使用伪元素来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.row&#123;</span><br><span class="line">    content:&apos;&apos;,</span><br><span class="line">    display:block,</span><br><span class="line">    clear:both,</span><br><span class="line">    height:0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="clear为什么能消除浮动"><a href="#clear为什么能消除浮动" class="headerlink" title="clear为什么能消除浮动"></a>clear为什么能消除浮动</h4><p>参考clear 在mdn官网的解释： 指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。<br>因此在父元素内，放置一个块级元素，并且放置在浮动元素后面，设置clear：left／right／both；<br>此时此clear元素将移动到浮动元素下方，由于此clear元素处于父元素文档流内，将让父元素高度撑开到与浮动元素一样高。<br>达到消除浮动效果。<br>详细参考<a href="https://juejin.im/post/59e7190bf265da4307025d91" target="_blank" rel="noopener">清除浮动的四种方式及其原理理解</a></p><p><strong>clear消除浮动方式的步骤</strong></p><h4 id="在父元素最底部放置一个元素"><a href="#在父元素最底部放置一个元素" class="headerlink" title="在父元素最底部放置一个元素"></a>在父元素最底部放置一个元素</h4><h4 id="设置此元素clear属性"><a href="#设置此元素clear属性" class="headerlink" title="设置此元素clear属性"></a>设置此元素clear属性</h4><h4 id="设置此元素为块级元素"><a href="#设置此元素为块级元素" class="headerlink" title="设置此元素为块级元素"></a>设置此元素为块级元素</h4><h3 id="兼容写法-后退机制"><a href="#兼容写法-后退机制" class="headerlink" title="兼容写法(后退机制)"></a>兼容写法(后退机制)</h3><p>background-image写两遍，是为了兼容后退机制写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.item&#123;</span><br><span class="line">    background-image:url(./column.png); </span><br><span class="line">    background-image:url(./column.png), url(./column1.png), url(./column2.png); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="z-index只用于定位元素"><a href="#z-index只用于定位元素" class="headerlink" title="z-index只用于定位元素"></a>z-index只用于定位元素</h3><p>Z-index 仅能在定位元素上奏效（例如 position:absolute;）！<br>很多人将它用于普通元素，没毛病，属于经典地犯错。</p><h3 id="为什么line-height被默认成元素的height了"><a href="#为什么line-height被默认成元素的height了" class="headerlink" title="为什么line-height被默认成元素的height了"></a>为什么line-height被默认成元素的height了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;wills-react-pro&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .wrap&#123;</span><br><span class="line">      height: 30px;</span><br><span class="line">      background: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    .test&#123;</span><br><span class="line">      line-height: 60px;</span><br><span class="line">      display: inline-block;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt; </span><br><span class="line">      &lt;span style=&quot;line-height:20px;&quot;&gt;</span><br><span class="line">        test&lt;span class=&quot;test&quot;&gt;最高1&lt;/span&gt;的值</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/image/css/line-height1.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/css/line-height2.jpg" alt="" title="" class="">                <p></p>            </figure><p>可以看到.test 的span的高度完全被其line-height所确定了，变成60px；<br>其他实验结果有，当给.test 的span设置display: inline;span为行内元素，span没有高度，其高度变成父层高度30px,但是span依然会撑开60px的空间：<br><figure class="image-box">                <img src="/image/css/line-height3.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>小结：对inline还是inline-block，在没有定义它对height时，line-height会被默认为元素高度；<br>此时可以通过给元素定义height达到指定高度的目的，但是line-height比height高的情况下，依然会让元素占满line-height的高度。</p><p>所以在开发时，遇到很多奇葩的元素高度从何而来时，不要指想着height，认为在谷歌浏览器上找不到height就很奇怪这个高度是怎么来的，你还需查看是否是其line-height生成的height。<br>另外，不要随意定义line-height，可能会导致意想不到问题。</p><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>参考 博客《css布局》<br>视口的独有尺寸，vh，vw，</p><h4 id="vh-vw-运用"><a href="#vh-vw-运用" class="headerlink" title="vh/vw 运用"></a>vh/vw 运用</h4><p>vh其实很简单，就是相对视口的1%的长度意思。<br>参考《四种居中方式 — 视口vh方法》<br>参考《分辨率\像素\视口 与 移动开发》</p><h3 id="css编写的建议"><a href="#css编写的建议" class="headerlink" title="css编写的建议"></a>css编写的建议</h3><h4 id="关于媒体查询的使用"><a href="#关于媒体查询的使用" class="headerlink" title="关于媒体查询的使用"></a>关于媒体查询的使用</h4><p>将媒体查询当做最后选择，如果你页面布局足够灵活，可能只需要少量的媒体查询即可，所以解决问题时，优先灵活解决，然后再考虑媒体查询。</p><h4 id="css-书写原则"><a href="#css-书写原则" class="headerlink" title="css 书写原则"></a>css 书写原则</h4><p>尽量不要使用id</p><h3 id="流转块的三种方式"><a href="#流转块的三种方式" class="headerlink" title="流转块的三种方式"></a>流转块的三种方式</h3><ul><li>设置：display:block；</li><li>对inline元素设置float；</li><li>对inline元素设置position:absolute/fixed；<br>大家对第一种熟悉，但没想到后面两种也可以流转块；</li></ul><h3 id="vertical-align、行盒子、baseline"><a href="#vertical-align、行盒子、baseline" class="headerlink" title="vertical-align、行盒子、baseline"></a>vertical-align、行盒子、baseline</h3><p>参考博客《vertical-align、行盒子、baseline》</p><h3 id="分辨率-像素-视口-与-移动开发"><a href="#分辨率-像素-视口-与-移动开发" class="headerlink" title="分辨率\像素\视口 与 移动开发"></a>分辨率\像素\视口 与 移动开发</h3><p>参考博客《css之移动开发》</p><h3 id="css之布局"><a href="#css之布局" class="headerlink" title="css之布局"></a>css之布局</h3><p>参考博客《css之布局》</p><h3 id="inline-block元素之间的间隙"><a href="#inline-block元素之间的间隙" class="headerlink" title="inline-block元素之间的间隙"></a>inline-block元素之间的间隙</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>两个元素之间书写的时候没有紧挨一起，或者有换行，从而导致间隙。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;inline-block&quot;&gt;abc&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;inline-block&quot;&gt;abc&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="设置父元素font-size：0"><a href="#设置父元素font-size：0" class="headerlink" title="设置父元素font-size：0"></a>设置父元素font-size：0</h4><p>在父亲元素设置font-size为0，然后在自己元素内设置回来。</p><h4 id="将元素书写时紧挨一起"><a href="#将元素书写时紧挨一起" class="headerlink" title="将元素书写时紧挨一起"></a>将元素书写时紧挨一起</h4><h4 id="设置元素为float"><a href="#设置元素为float" class="headerlink" title="设置元素为float"></a>设置元素为float</h4><p>利用float元素会脱离文档流的特性。</p><h3 id="transform与坐标变换"><a href="#transform与坐标变换" class="headerlink" title="transform与坐标变换"></a>transform与坐标变换</h3><p>参考《css知识点汇 – transform与坐标变换》</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css趣事</title>
      <link href="/2020/11/28/css_deep/"/>
      <url>/2020/11/28/css_deep/</url>
      
        <content type="html"><![CDATA[<p>本篇用于记录css的一些难点、黑知识，了解并解决他们是一件很有趣的事情。<br>在《css笔记》中也有列举黑知识，不过该篇幅已经很多了，因此又写一篇。</p><h2 id="黑知识"><a href="#黑知识" class="headerlink" title="黑知识"></a>黑知识</h2><h3 id="如何absolute的子元素不换行"><a href="#如何absolute的子元素不换行" class="headerlink" title="如何absolute的子元素不换行"></a>如何absolute的子元素不换行</h3><h4 id="absolute的子元素换行的问题"><a href="#absolute的子元素换行的问题" class="headerlink" title="absolute的子元素换行的问题"></a>absolute的子元素换行的问题</h4><p>不过我不想让absolute子元素换行，如何实现呢。<br>效果：<br><figure class="image-box">                <img src="/image/css_deep/ab.png" alt="" title="" class="">                <p></p>            </figure><br>代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .wrap&#123;</span></span><br><span class="line"><span class="undefined">      width: 300px;</span></span><br><span class="line"><span class="undefined">      position: relative;</span></span><br><span class="line"><span class="undefined">      background-color: grey;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    .content&#123;</span></span><br><span class="line"><span class="undefined">      position: absolute;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    .item&#123;</span></span><br><span class="line"><span class="undefined">      width: 110px;</span></span><br><span class="line"><span class="undefined">      border: 1px solid;</span></span><br><span class="line"><span class="undefined">      /* 使用float是因为 float可以将div元素转为 inline-block，同时消除间隙 */</span></span><br><span class="line"><span class="undefined">      float: left;</span></span><br><span class="line"><span class="undefined">      background-color: blueviolet;</span></span><br><span class="line"><span class="undefined">      height: 100px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="absolute宽度默认不超过父元素"><a href="#absolute宽度默认不超过父元素" class="headerlink" title="absolute宽度默认不超过父元素"></a>absolute宽度默认不超过父元素</h4><p>并不是absolute宽度不能超过父元素，absolute脱离文档流，你可以直接设置absolute元素宽度为任何宽度。<br>但是如果你不设置absolute宽度，absolute将使用默认宽度，由以下三者决定：</p><ul><li>父元素宽度</li><li>left值 默认0</li><li>right值 默认0</li></ul><p>因此当你不设置absolute宽度时，默认就是父元素宽度。<br>但是注意了，如果你设置了left值 10px， 因为没有设置right，right默认使用0，那么absolute宽度将为 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">absolute宽度 = 父元素宽度 - 10px</span><br></pre></td></tr></table></figure></p><h4 id="每设置left多少，自身宽度减多少"><a href="#每设置left多少，自身宽度减多少" class="headerlink" title="每设置left多少，自身宽度减多少"></a>每设置left多少，自身宽度减多少</h4><p>参考《absolute宽度默认不超过父元素》</p><h4 id="设置absolute大于父元素方法"><a href="#设置absolute大于父元素方法" class="headerlink" title="设置absolute大于父元素方法"></a>设置absolute大于父元素方法</h4><ul><li>直接给absolute 设置 width值；</li><li>设置left 或 right 父值；</li><li>设置自己为flex；这个下面当讲，见 《让absolute永远等于子元素之和(flex)》</li></ul><h4 id="让absolute永远等于子元素之和-flex"><a href="#让absolute永远等于子元素之和-flex" class="headerlink" title="让absolute永远等于子元素之和(flex)"></a>让absolute永远等于子元素之和(flex)</h4><p>让absolute下的子元素高保真，且不换行，absolute元素宽度与子元素之和看齐，<br>此时给absolute元素 ，设置 display为flex。<br>display为flex的一大特性就是让所有子元素水平排为一列，<br>在不设置absolute自身宽度下，absolute宽度等于子元素之和。</p><h4 id="absolute与flex同时使用的黑特性"><a href="#absolute与flex同时使用的黑特性" class="headerlink" title="absolute与flex同时使用的黑特性"></a>absolute与flex同时使用的黑特性</h4><p>当一个元素既使用absolute又使用flex时候，<br>因为flex最大特性是保证子元素为一排，且宽度不变；<br>当自身宽度不够时，css系统会给元素设置left或right设置一个负数值，保证自身宽度够长：<br>代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .wrap&#123;</span></span><br><span class="line"><span class="undefined">      width: 300px;</span></span><br><span class="line"><span class="undefined">      position: relative;</span></span><br><span class="line"><span class="undefined">      background-color: grey;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    .content&#123;</span></span><br><span class="line"><span class="undefined">      position: absolute;</span></span><br><span class="line"><span class="undefined">      display: flex;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    .item&#123;</span></span><br><span class="line"><span class="undefined">      width: 110px;</span></span><br><span class="line"><span class="undefined">      border: 1px solid;</span></span><br><span class="line"><span class="undefined">      /* flex下float无效; */</span></span><br><span class="line"><span class="undefined">      float: left;</span></span><br><span class="line"><span class="undefined">      background-color: blueviolet;</span></span><br><span class="line"><span class="undefined">      height: 150px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/css_deep/flex.png" alt="" title="" class="">                <p></p>            </figure><p>当absolute自身又同时设置left和right时，子元素设置flex-shrink为0时，flex优先级最高，依然能保证子元素为一排，且宽度不变，这个可自行试验。</p><h4 id="解决方法-flex"><a href="#解决方法-flex" class="headerlink" title="解决方法(flex)"></a>解决方法(flex)</h4><p>方法代码同 《absolute与flex同时使用的黑特性》</p><h3 id="用float给元素转inline-block的优点"><a href="#用float给元素转inline-block的优点" class="headerlink" title="用float给元素转inline-block的优点"></a>用float给元素转inline-block的优点</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>使用float是因为 float可以将div元素转为 inline-block，同时消除间隙。<br>传统直接给元素设置display为inline-block，多个元素并列时，还要考虑消除间隙问题。<br>如果父元素本身是一个BFC，比如本身定义了postion为absolute或 relative 等，更应该用float，因此BFC元素自带消除浮动。</p><h4 id="postion为absolute更加推荐使用"><a href="#postion为absolute更加推荐使用" class="headerlink" title="postion为absolute更加推荐使用"></a>postion为absolute更加推荐使用</h4><p>参考《概述》</p><h4 id="BFC元素更加推荐用"><a href="#BFC元素更加推荐用" class="headerlink" title="BFC元素更加推荐用"></a>BFC元素更加推荐用</h4><p>参考《概述》，所有BFC元素更应该使用float来转inline-block。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue、react异同</title>
      <link href="/2020/11/09/vue_react/"/>
      <url>/2020/11/09/vue_react/</url>
      
        <content type="html"><![CDATA[<h2 id="父子传值相同"><a href="#父子传值相同" class="headerlink" title="父子传值相同"></a>父子传值相同</h2><h2 id="除了双向绑定，vuex都类似"><a href="#除了双向绑定，vuex都类似" class="headerlink" title="除了双向绑定，vuex都类似"></a>除了双向绑定，vuex都类似</h2><h2 id="生命周期类似"><a href="#生命周期类似" class="headerlink" title="生命周期类似"></a>生命周期类似</h2><h2 id="路由类似"><a href="#路由类似" class="headerlink" title="路由类似"></a>路由类似</h2>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> react </category>
          
          <category> vue基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue笔记</title>
      <link href="/2020/10/28/vue/"/>
      <url>/2020/10/28/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="开发一个页面结构示范"><a href="#开发一个页面结构示范" class="headerlink" title="开发一个页面结构示范"></a>开发一个页面结构示范</h3><p>主要都是组件完成：<br><figure class="image-box">                <img src="/image/vue/demo.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="挂载点，模版与实例"><a href="#挂载点，模版与实例" class="headerlink" title="挂载点，模版与实例"></a>挂载点，模版与实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"root"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> <span class="comment">//挂载点</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;<span class="comment">//实例</span></span><br><span class="line">  el:<span class="string">"#root"</span>,</span><br><span class="line">  template:<span class="string">"&lt;h1&gt;hello &#123;&#123;msg&#125;&#125;&lt;/h1&gt;"</span>, <span class="comment">//模版 //也叫插值表达式</span></span><br><span class="line">  data:&#123;</span><br><span class="line">  msg : <span class="string">"world"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="插值表达式-与-v-text-v-html"><a href="#插值表达式-与-v-text-v-html" class="headerlink" title="插值表达式 与 v-text v-html"></a>插值表达式 与 v-text v-html</h3><h4 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h4><p>参考上面《挂载点，模版与实例》</p><h4 id="插值表达式相当于v-text"><a href="#插值表达式相当于v-text" class="headerlink" title="插值表达式相当于v-text"></a>插值表达式相当于v-text</h4><p>v-text 是vue框架 插值写法一种，<br>另外还有 v-html。<br><figure class="image-box">                <img src="/image/vue/values.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="v-text-v-html可认为是插值表达式的延伸"><a href="#v-text-v-html可认为是插值表达式的延伸" class="headerlink" title="v-text v-html可认为是插值表达式的延伸"></a>v-text v-html可认为是插值表达式的延伸</h4><p>如题。</p><h4 id="几种写法"><a href="#几种写法" class="headerlink" title="几种写法"></a>几种写法</h4><figure class="image-box">                <img src="/image/vue/value2.png" alt="" title="" class="">                <p></p>            </figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>参考《插值表达式》的图片。</p><h3 id="单向绑定与双向绑定"><a href="#单向绑定与双向绑定" class="headerlink" title="单向绑定与双向绑定"></a>单向绑定与双向绑定</h3><p>参考《vue特有写法  -  v-model》</p><h3 id="vue特有写法"><a href="#vue特有写法" class="headerlink" title="vue特有写法"></a>vue特有写法</h3><h4 id="v-text-v-html"><a href="#v-text-v-html" class="headerlink" title="v-text v-html"></a>v-text v-html</h4><p>是一种插值写法，见《插值表达式》，与双花括号写法差不多。</p><h4 id="v-on-click-与-click"><a href="#v-on-click-与-click" class="headerlink" title="v-on:click 与 @click"></a>v-on:click 与 @click</h4><figure class="image-box">                <img src="/image/vue/values.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="v-bind-与-："><a href="#v-bind-与-：" class="headerlink" title="v-bind: 与 ："></a>v-bind: 与 ：</h4><p>后者是前者的缩写，用于html元素属性绑定。<br>当被绑定后，属性等号后面的字符串是一个js表达式，js内表达式变量指向实例中的data下面的属性值：<br><figure class="image-box">                <img src="/image/vue/bind.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>一般用于可交互的html元素，比如input，而不是单纯的div，定义v-model后，就是数据双向绑定，<br>input元素可改变数据，数据改变也同样改变input的显示。<br>与之相对的是单向绑定的v-bind，一般用于纯展示的html元素，如div，只用于数据获取，而不能改变数据。</p><h4 id="v-if-v-show-v-for-key"><a href="#v-if-v-show-v-for-key" class="headerlink" title="v-if v-show v-for :key"></a>v-if v-show v-for :key</h4><figure class="image-box">                <img src="/image/vue/for.jpg" alt="" title="" class="">                <p></p>            </figure><p>如上图， v-if 显示隐藏是删除dom，v-show，通过css display none， v-for用于遍历, :key用于遍历唯一值，与react一致。</p><h4 id="v-if-v-else-if-v-else"><a href="#v-if-v-else-if-v-else" class="headerlink" title="v-if v-else-if v-else"></a>v-if v-else-if v-else</h4><figure class="image-box">                <img src="/image/vue/if.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="v-if-v-else-必须连着写"><a href="#v-if-v-else-必须连着写" class="headerlink" title="v-if v-else 必须连着写"></a>v-if v-else 必须连着写</h4><figure class="image-box">                <img src="/image/vue/if-err.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="v-for列表渲染"><a href="#v-for列表渲染" class="headerlink" title="v-for列表渲染"></a>v-for列表渲染</h3><h4 id="结合v-if"><a href="#结合v-if" class="headerlink" title="结合v-if"></a>结合v-if</h4><figure class="image-box">                <img src="/image/vue/forif.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="结合v-show"><a href="#结合v-show" class="headerlink" title="结合v-show"></a>结合v-show</h4><figure class="image-box">                <img src="/image/vue/for-show.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="v-if-v-show-列表渲染区别"><a href="#v-if-v-show-列表渲染区别" class="headerlink" title="v-if v-show 列表渲染区别"></a>v-if v-show 列表渲染区别</h4><p>v-if，更加灵活；<br>v-show，如果是过滤效果可以使用。</p><h4 id="组件驼峰定义，小斜杠使用"><a href="#组件驼峰定义，小斜杠使用" class="headerlink" title="组件驼峰定义，小斜杠使用"></a>组件驼峰定义，小斜杠使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件定义： --&gt;</span></span><br><span class="line">components:testOk</span><br><span class="line"><span class="comment">&lt;!-- 使用： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test-ok</span>&gt;</span><span class="tag">&lt;/<span class="name">test-ok</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="class绑定-与-style绑定"><a href="#class绑定-与-style绑定" class="headerlink" title="class绑定 与 style绑定"></a>class绑定 与 style绑定</h3><h4 id="class绑定"><a href="#class绑定" class="headerlink" title="class绑定"></a>class绑定</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span></span><br><span class="line">            姓名：&#123;&#123;item.name&#125;&#125;，年龄：&#123;&#123;item.age&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"item.age &gt; 24"</span> <span class="attr">:class</span>=<span class="string">"['banana','more',&#123;'another':item.age &lt; 26&#125;]"</span>&gt;</span></span><br><span class="line">                年龄大于24的人有：&#123;&#123;item.name&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="style绑定"><a href="#style绑定" class="headerlink" title="style绑定"></a>style绑定</h4><figure class="image-box">                <img src="/image/vue/style.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="计算属性-合成属性-computed"><a href="#计算属性-合成属性-computed" class="headerlink" title="计算属性(合成属性)computed"></a>计算属性(合成属性)computed</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>当某一个数据来源于多个数据计算而来时，用这个，并且类似react的hooks功能，此计算具有缓存计算性能优化能力，<br>只有所依赖的数据变化时才重新计算，否则取缓存。<br>computed可以说是data的升级版。<br><figure class="image-box">                <img src="/image/vue/compd.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="使用场景：数据联动"><a href="#使用场景：数据联动" class="headerlink" title="使用场景：数据联动"></a>使用场景：数据联动</h4><p>数据联动时，使用computed。</p><h3 id="数据监听器-watch"><a href="#数据监听器-watch" class="headerlink" title="数据监听器 watch"></a>数据监听器 watch</h3><h4 id="可监听的数据"><a href="#可监听的数据" class="headerlink" title="可监听的数据"></a>可监听的数据</h4><p>可以监听 vue实例中的data和computed内的数据变化，当变化时，定义自定义事件。</p><h4 id="使用场景：异步请求"><a href="#使用场景：异步请求" class="headerlink" title="使用场景：异步请求"></a>使用场景：异步请求</h4><p>类似 react hooks 中的effect 依赖一些如参，根据如参是否变化，决定是否重新post请求。</p><h4 id="如参分别为newVal，oldValue"><a href="#如参分别为newVal，oldValue" class="headerlink" title="如参分别为newVal，oldValue"></a>如参分别为newVal，oldValue</h4><p>如题</p><h4 id="computed与watch区别"><a href="#computed与watch区别" class="headerlink" title="computed与watch区别"></a>computed与watch区别</h4><p>前者可监听多个变量，后者只能监听一个变量变化。</p><h4 id="复合计算的三种方法-computed-watch-methods"><a href="#复合计算的三种方法-computed-watch-methods" class="headerlink" title="复合计算的三种方法(computed\watch\methods)"></a>复合计算的三种方法(computed\watch\methods)</h4><p>推荐用computed，其次watch，最次methods。<br>如下图，<br>computed 性能最好，最简洁；<br>watch 因为只能一次监听一个参数，需要写多个监听；<br>methods 只要vue render时，无论依赖的参数是否变化，都会重新执行一次，性能最差。</p><figure class="image-box">                <img src="/image/vue/watch.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="computed的get和set"><a href="#computed的get和set" class="headerlink" title="computed的get和set"></a>computed的get和set</h4><figure class="image-box">                <img src="/image/vue/setter.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="this指向与优先级"><a href="#this指向与优先级" class="headerlink" title="this指向与优先级"></a>this指向与优先级</h3><p>this指向vue实例，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.namekey 其实是 this.$data.namekey</span><br></pre></td></tr></table></figure></p><p>vue底层做了封装，优先去data找然后是 computed， 然后是 methods。</p><h2 id="基础知识二"><a href="#基础知识二" class="headerlink" title="基础知识二"></a>基础知识二</h2><h3 id="凡事带v的属性，后面都是js表达式，非字符串"><a href="#凡事带v的属性，后面都是js表达式，非字符串" class="headerlink" title="凡事带v的属性，后面都是js表达式，非字符串"></a>凡事带v的属性，后面都是js表达式，非字符串</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-model以 v开头，说明是vue专有属性，被vue封装 names是一个表达式，非字符串，是一个变量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test-ok</span> <span class="attr">v-model</span>=<span class="string">"names"</span>&gt;</span><span class="tag">&lt;/<span class="name">test-ok</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h3><p>可通过下面两种方式定义样式。</p><h4 id="class"><a href="#class" class="headerlink" title=":class"></a>:class</h4><h4 id="style"><a href="#style" class="headerlink" title=":style"></a>:style</h4><h4 id="二者有对象和数组两种定义方式"><a href="#二者有对象和数组两种定义方式" class="headerlink" title="二者有对象和数组两种定义方式"></a>二者有对象和数组两种定义方式</h4><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><h4 id="在dom元素中ref指向dom"><a href="#在dom元素中ref指向dom" class="headerlink" title="在dom元素中ref指向dom"></a>在dom元素中ref指向dom</h4><p>通过<code>this.$refs.refName</code>获取<br><figure class="image-box">                <img src="/image/vue/ref1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="在vue组件中ref指向组件实例"><a href="#在vue组件中ref指向组件实例" class="headerlink" title="在vue组件中ref指向组件实例"></a>在vue组件中ref指向组件实例</h4><p>这个实例就是子组件内的this，拥有一切能力：<br><figure class="image-box">                <img src="/image/vue/ref2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="props是否带-的区别"><a href="#props是否带-的区别" class="headerlink" title="props是否带:的区别"></a>props是否带:的区别</h4><p>给组件test-ok定义props， test值是js表达式，是变量，strtest值是字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;test-ok :test=&quot;names&quot; strtest=&quot;names&quot;&gt;&lt;/test-ok&gt;</span><br></pre></td></tr></table></figure></p><h3 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h3><h4 id="slot和默认值"><a href="#slot和默认值" class="headerlink" title="slot和默认值"></a>slot和默认值</h4><figure class="image-box">                <img src="/image/vue/slot0.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="slot默认值可以是html元素"><a href="#slot默认值可以是html元素" class="headerlink" title="slot默认值可以是html元素"></a>slot默认值可以是html元素</h4><figure class="image-box">                <img src="/image/vue/slot-default.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="具名slot"><a href="#具名slot" class="headerlink" title="具名slot"></a>具名slot</h4><p>如下，父层定义插槽时，可通过定义name，此时就是具名插槽，可有多个，如果不定义name，那么此插槽则代表父层整个所有插槽，此只有一个。<br><figure class="image-box">                <img src="/image/vue/slot.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="不具名插槽只有一个，具名插槽可有多个"><a href="#不具名插槽只有一个，具名插槽可有多个" class="headerlink" title="不具名插槽只有一个，具名插槽可有多个"></a>不具名插槽只有一个，具名插槽可有多个</h4><p>参考《具名slot》</p><h4 id="作用域插槽-render-props模式"><a href="#作用域插槽-render-props模式" class="headerlink" title="作用域插槽(render props模式)"></a>作用域插槽(render props模式)</h4><p>没有用作用域插槽前：<br><figure class="image-box">                <img src="/image/vue/slot-pre.jpg" alt="" title="" class="">                <p></p>            </figure><br>用之后：<br>template 与 slot-scope 属于固定写法。这种模式向极了react的render props模式。<br><figure class="image-box">                <img src="/image/vue/slot-fn.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="template组件与v-once"><a href="#template组件与v-once" class="headerlink" title="template组件与v-once"></a>template组件与v-once</h3><p>template是vue自带标签，可替换 v-if写法，如下，v-once 用于性能优化，让vue显示隐藏组件时不用卸载，可不用。<br><figure class="image-box">                <img src="/image/vue/tep.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/vue/slot-pre1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="css动画原理"><a href="#css动画原理" class="headerlink" title="css动画原理"></a>css动画原理</h3><h4 id="vue自带的transition"><a href="#vue自带的transition" class="headerlink" title="vue自带的transition"></a>vue自带的transition</h4><p>当元素显示时，将元素放在 transition标签内，vue会给显示当元素，分三个阶段，添加或删除不同的class，以便外部做css动画，这就是动画原理。<br>如下，是元素显示时，vue给元素添加或删除class的过程：</p><ul><li>开始时 给元素添加 class fade-enter fade-enter-active，</li><li>接着 删除 fade-enter， 添加 fade-enter-to class</li><li>显示到最后，删除class fade-enter-to fade-enter-active</li></ul><p>在以上过程中，给不同的class定义不同的css，就可以做动画。<br><figure class="image-box">                <img src="/image/vue/css1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="显示时的过程"><a href="#显示时的过程" class="headerlink" title="显示时的过程"></a>显示时的过程</h4><p>参考上面《vue自带的transition》</p><h4 id="隐藏时的过程"><a href="#隐藏时的过程" class="headerlink" title="隐藏时的过程"></a>隐藏时的过程</h4><figure class="image-box">                <img src="/image/vue/css3.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="自定义class-name"><a href="#自定义class-name" class="headerlink" title="自定义class name"></a>自定义class name</h4><p>classname可以根据 transition的name来定义，如果未定义name，默认为v，也就是v-enter。<br><figure class="image-box">                <img src="/image/vue/css2.jpg" alt="" title="" class="">                <p></p>            </figure><br>默认class name 以及动画样式处理：<br><figure class="image-box">                <img src="/image/vue/css4.jpg" alt="" title="" class="">                <p></p>            </figure><br>如下，定义enter-active-class props 可完全重写对应class，如下是结合animate.css库做的动画<br><figure class="image-box">                <img src="/image/vue/css5.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="transition标签自带的事件"><a href="#transition标签自带的事件" class="headerlink" title="transition标签自带的事件"></a>transition标签自带的事件</h4><p>vue给transition标签绑定了一些时间，用于更好的做动画，更多可网上查阅。<br>参考下面《slot来动画封装》</p><h4 id="结合animate-css库做的动画"><a href="#结合animate-css库做的动画" class="headerlink" title="结合animate.css库做的动画"></a>结合animate.css库做的动画</h4><p>参考上面的《自定义class name》</p><h4 id="v-if与v-show效果一样"><a href="#v-if与v-show效果一样" class="headerlink" title="v-if与v-show效果一样"></a>v-if与v-show效果一样</h4><p>transition的显示隐藏效果，主要是结合 v-if 或 v-show 来使用（待进一步验证）。<br>此二者都可以显示隐藏，用在动画上效果一致。</p><h4 id="列表增加、删除过渡动画-transition-group"><a href="#列表增加、删除过渡动画-transition-group" class="headerlink" title="列表增加、删除过渡动画(transition-group)"></a>列表增加、删除过渡动画(transition-group)</h4><p>transition-group 是vue用来做列表添加或删除某条数据时，过渡动画，其原理如下图：<br><figure class="image-box">                <img src="/image/vue/css6.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="slot来动画封装-render-props模式"><a href="#slot来动画封装-render-props模式" class="headerlink" title="slot来动画封装(render props模式)"></a>slot来动画封装(render props模式)</h4><p>使用插槽render props模式，或类似高阶组件，同时用transition自带的绑定事件来写css：<br>貌似这个动画只在v-if有效，在v-show下无效，原因待研究。<br><figure class="image-box">                <img src="/image/vue/css-fn1.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/vue/css-fn2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="keep-alive-与-activated-性能优化"><a href="#keep-alive-与-activated-性能优化" class="headerlink" title="keep-alive 与 activated (性能优化)"></a>keep-alive 与 activated (性能优化)</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>keep-alive可用于页面缓存渲染。<br>keep-alive内的组件，都会多出一个 activated 生命周期函数。</p><h4 id="activated-与-mounted"><a href="#activated-与-mounted" class="headerlink" title="activated 与 mounted"></a>activated 与 mounted</h4><p>当使用keep-alive的时候，第二次渲染页面，不会触发 mounted，但触发 activated，除此之外二者一致。<br>activated 可用于页面的ajax是否重新请求。</p><p>下面讲解keep-alive 使用步骤：</p><h4 id="包裹父节点"><a href="#包裹父节点" class="headerlink" title="包裹父节点"></a>包裹父节点</h4><figure class="image-box">                <img src="/image/vue/keep1.png" alt="" title="" class="">                <p></p>            </figure><h4 id="子组件-页面-使用"><a href="#子组件-页面-使用" class="headerlink" title="子组件(页面)使用"></a>子组件(页面)使用</h4><p>在页面内保存一个装载组件时的key，若key不一样，就发起新请求。<br><figure class="image-box">                <img src="/image/vue/keep2.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>如图：<br><figure class="image-box">                <img src="/image/vue/digui.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h4><p>递归组件运用场景，如一级、二级列表的递归：<br><figure class="image-box">                <img src="/image/vue/digui1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h2 id="黑知识"><a href="#黑知识" class="headerlink" title="黑知识"></a>黑知识</h2><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="操作数组进行列表渲染时，必须用vue指定方法或改变引用"><a href="#操作数组进行列表渲染时，必须用vue指定方法或改变引用" class="headerlink" title="操作数组进行列表渲染时，必须用vue指定方法或改变引用"></a>操作数组进行列表渲染时，必须用vue指定方法或改变引用</h4><p>指定的方法有七种，可看vue官网，也可以改变数组的引用。<br>如果通过下标改变数组，是不会触发重新渲染，估计vue底层也是通过比较两次props是否相同。</p><h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p>如果列表渲染时，要同时渲染多种情况，又不想在外层加div，可用占位符template<br><figure class="image-box">                <img src="/image/vue/template-list.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="可通过对象渲染"><a href="#可通过对象渲染" class="headerlink" title="可通过对象渲染"></a>可通过对象渲染</h4><p>可直接通过改变属性内容，更新渲染，可能是数据劫持的运用；<br><strong>如果要新增属性，必须改变对象引用</strong></p><figure class="image-box">                <img src="/image/vue/list-obj.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="Vue-set-与-vm-set-设置对象或数组"><a href="#Vue-set-与-vm-set-设置对象或数组" class="headerlink" title="Vue.set 与 vm.$set 设置对象或数组"></a>Vue.set 与 vm.$set 设置对象或数组</h4><p>除上面说的方法外，可通过Vue.set 与 vm.$set来改变数组或对象重新渲染。</p><h3 id="Vue-set-与-vm-set"><a href="#Vue-set-与-vm-set" class="headerlink" title="Vue.set 与 vm.$set"></a>Vue.set 与 vm.$set</h3><p>二者是一样的，一般，如果Vue提供了某方法，那么vue的实例中，也会有此方法，不过方法名前需要加$。</p><h3 id="Vue中有的在实例中基本也有，名字前加"><a href="#Vue中有的在实例中基本也有，名字前加" class="headerlink" title="Vue中有的在实例中基本也有，名字前加$"></a>Vue中有的在实例中基本也有，名字前加$</h3><p>Vue中有的方法在实例中基本也有，名字前加$， 如 Vue.set 与 vm.$set</p><h3 id="用is重命名解决渲染异常"><a href="#用is重命名解决渲染异常" class="headerlink" title="用is重命名解决渲染异常"></a>用is重命名解决渲染异常</h3><h4 id="异常描述"><a href="#异常描述" class="headerlink" title="异常描述"></a>异常描述</h4><p>下面渲染异常，渲染位置跑跑偏了：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 异常渲染，因为h5规范 要求tbody下面必须是tr标签 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">row</span>&gt;</span><span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">row</span>&gt;</span><span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">row</span>&gt;</span><span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">'row'</span>, &#123;</span></span><br><span class="line"><span class="xml">            template:'<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>this is wor<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">"#root"</span></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/vue/black.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="用is重命名解决"><a href="#用is重命名解决" class="headerlink" title="用is重命名解决"></a>用is重命名解决</h4><p>其他代码不变，改变如下部分，is很类似es6 的 import as 或es6的重命名：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="ol-ul-select问题以此类推"><a href="#ol-ul-select问题以此类推" class="headerlink" title="ol ul select问题以此类推"></a>ol ul select问题以此类推</h4><p>异常渲染，因为h5规范 要求tbody下面必须是tr标签，ol ul 后可能也必须使用li，select后必须使用option等等，遇到问题可这样分析。</p><h3 id="子组件data必须是函数"><a href="#子组件data必须是函数" class="headerlink" title="子组件data必须是函数"></a>子组件data必须是函数</h3><p>如下，在根组件上data写成对象是没有问题的，但子组件必须是函数，这是因为子组件可能会被父组件使用很多次，<br>为了避免对象引用带来的问题，要求data每次都是最新的，因此通过执行函数，每次获得的是新对象，避免了同一个对象引用的问题。<br><figure class="image-box">                <img src="/image/vue/black-child.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="组件参数校验"><a href="#组件参数校验" class="headerlink" title="组件参数校验"></a>组件参数校验</h3><h4 id="单个用字符串"><a href="#单个用字符串" class="headerlink" title="单个用字符串"></a>单个用字符串</h4><h4 id="多个类型用数组"><a href="#多个类型用数组" class="headerlink" title="多个类型用数组"></a>多个类型用数组</h4><figure class="image-box">                <img src="/image/vue/props1.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="定义required与defaultValue"><a href="#定义required与defaultValue" class="headerlink" title="定义required与defaultValue"></a>定义required与defaultValue</h4><figure class="image-box">                <img src="/image/vue/props2.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="自定义验证validator规则"><a href="#自定义验证validator规则" class="headerlink" title="自定义验证validator规则"></a>自定义验证validator规则</h4><p>如上面的图片</p><h3 id="props特性与非props特性"><a href="#props特性与非props特性" class="headerlink" title="props特性与非props特性"></a>props特性与非props特性</h3><p>在vue中，props不会显示在子组件的dom上。非props会显示在子组件最外层的dom属性上。<br>非props属性是，定义子组件时定义的属性，但在子组件内没有声明为props的属性，是为非props。<br>下面content就是非props。<br><figure class="image-box">                <img src="/image/vue/noprops.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="给组件绑定原生事件"><a href="#给组件绑定原生事件" class="headerlink" title="给组件绑定原生事件"></a>给组件绑定原生事件</h3><p>如下，不是原生事件，如何绑定呢，使用<a href="mailto:`@click.native" target="_blank" rel="noopener">`@click.native</a>=”handleClick”`<br><figure class="image-box">                <img src="/image/vue/event-native.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="非父子组件传值"><a href="#非父子组件传值" class="headerlink" title="非父子组件传值"></a>非父子组件传值</h3><h4 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h4><p>非父子组件传值有三种方式，<br>一个是vuex；<br>一个是总线方式；<br>一个是传统方式，将值传给一个共有的父组件，让父组件分发给非父子组件，这种方式适用于简单的非父子组件传值，比如兄弟组件；</p><h4 id="bus总线方式-复杂"><a href="#bus总线方式-复杂" class="headerlink" title="bus总线方式(复杂)"></a>bus总线方式(复杂)</h4><p>非父子组件传值，可通过vuex，也可以通过面向对象的继承模式，结合事件绑定(观察者模式)来做。<br>这种做法也叫 bus／总线 传值。</p><p>这种方式与window的事件监听也类似，估计用vue自带的事件监听方式，做了很多优化。<br><figure class="image-box">                <img src="/image/vue/value-event.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="传统方式-简单"><a href="#传统方式-简单" class="headerlink" title="传统方式(简单)"></a>传统方式(简单)</h4><p>思想跟react兄弟组件传值是一样的，详细参考上面的《三种方式》，适用于简单的非父子关系，如兄弟组件传值</p><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><h4 id="兄弟组件传值"><a href="#兄弟组件传值" class="headerlink" title="兄弟组件传值"></a>兄弟组件传值</h4><p>参考《传统方式(简单)》</p><h3 id="若为别名，必须加～-style内import其他css"><a href="#若为别名，必须加～-style内import其他css" class="headerlink" title="若为别名，必须加～ (style内import其他css)"></a>若为别名，必须加～ (style内import其他css)</h3><p>style内import其他css，若为别名，必须加～，js没有这个限定，如下css内，import一个全部变量css变量文件，styl文件：<br><figure class="image-box">                <img src="/image/vue/styl.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/vue/styl2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="图片加载的文字抖动问题"><a href="#图片加载的文字抖动问题" class="headerlink" title="图片加载的文字抖动问题"></a>图片加载的文字抖动问题</h3><h4 id="文字抖动原因"><a href="#文字抖动原因" class="headerlink" title="文字抖动原因"></a>文字抖动原因</h4><p>当图片请求未完成时，文字在上面，图片加载完毕，文字跑到下面来。<br><figure class="image-box">                <img src="/image/vue/dou5.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="设置overflow-hidden"><a href="#设置overflow-hidden" class="headerlink" title="设置overflow hidden"></a>设置overflow hidden</h4><p>解决原理，已知图片的宽度是手机屏幕宽度，且高度也是固定的，宽高比为31.25%.<br>预先设置一个宽高比，由于height的百分比参考的是父元素高度，因此使用padding，padding参照自身元素的width。<br>推荐：<br><figure class="image-box">                <img src="/image/vue/dou1.jpg" alt="" title="" class="">                <p></p>            </figure><br>错误：<br><figure class="image-box">                <img src="/image/vue/dou3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="预先设置宽高比"><a href="#预先设置宽高比" class="headerlink" title="预先设置宽高比"></a>预先设置宽高比</h4><p>参考《设置overflow hidden》</p><h4 id="使用padding不用height"><a href="#使用padding不用height" class="headerlink" title="使用padding不用height"></a>使用padding不用height</h4><p>参考《设置overflow hidden》</p><h4 id="也可使用vw，不过有兼容问题"><a href="#也可使用vw，不过有兼容问题" class="headerlink" title="也可使用vw，不过有兼容问题"></a>也可使用vw，不过有兼容问题</h4><figure class="image-box">                <img src="/image/vue/dou2.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="通过Online设置3G-的技巧"><a href="#通过Online设置3G-的技巧" class="headerlink" title="通过Online设置3G 的技巧"></a>通过Online设置3G 的技巧</h4><figure class="image-box">                <img src="/image/vue/dou4.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="样式穿透"><a href="#样式穿透" class="headerlink" title="样式穿透"></a>样式穿透</h3><p>使用 <code>&gt;&gt;&gt;</code>做样式穿透，不受 scoped限制，下图表示 .wrapper下的 .swiper… 类穿透 scoped，是一个全局样式。<br><figure class="image-box">                <img src="/image/vue/port.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="页面路由切换，不在最顶层"><a href="#页面路由切换，不在最顶层" class="headerlink" title="页面路由切换，不在最顶层"></a>页面路由切换，不在最顶层</h3><p>vue-router 官网给了解决方法：<br><figure class="image-box">                <img src="/image/vue/route.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="props的属性名不能用驼峰命名"><a href="#props的属性名不能用驼峰命名" class="headerlink" title="props的属性名不能用驼峰命名"></a>props的属性名不能用驼峰命名</h3><p>这里说的是低版本，可能存在此问题。<br>父组件给子组件属性名不能用驼峰命名。这时就发现两个版本一个是2.4.2，另一个2.5.2。 2.4.2竟然不能用驼峰命名props属性名。</p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><h3 id="vue-cli的vue文件写法"><a href="#vue-cli的vue文件写法" class="headerlink" title="vue-cli的vue文件写法"></a>vue-cli的vue文件写法</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="image-box">                <img src="/image/vue/use.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/vue/template.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="data要写成函数"><a href="#data要写成函数" class="headerlink" title="data要写成函数"></a>data要写成函数</h4><p>在vue-cli开发中data需要定义成一个函数。<br>原来非vue-cli写法是data是对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data : function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        inputValue: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="两种创建工程的方法"><a href="#两种创建工程的方法" class="headerlink" title="两种创建工程的方法"></a>两种创建工程的方法</h3><h4 id="vue-create命令"><a href="#vue-create命令" class="headerlink" title="vue create命令"></a>vue create命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create hello-world</span><br></pre></td></tr></table></figure><h4 id="vue-ui-界面"><a href="#vue-ui-界面" class="headerlink" title="vue ui 界面"></a>vue ui 界面</h4><p>这是将上面 vue create 命令行操作进行可视化配置的改进。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure></p><h3 id="static目录会被放在服务器上-mock"><a href="#static目录会被放在服务器上-mock" class="headerlink" title="static目录会被放在服务器上(mock)"></a>static目录会被放在服务器上(mock)</h3><p>vue-cli创建的工程，会将satic目录放在服务中，类似 node 的static插件。<br>所有mock json可放置其中。<br><figure class="image-box">                <img src="/image/vue/static.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="设计ajax"><a href="#设计ajax" class="headerlink" title="设计ajax"></a>设计ajax</h3><h4 id="业务中使用"><a href="#业务中使用" class="headerlink" title="业务中使用"></a>业务中使用</h4><p>在后台没有接口，使用mock数据完成开发后，为了让接入真实后台api后，不用重新修改业务中api代码，<br>通常做法：业务中使用标准后台API，利用vue-cli生成的config配置代理，代理到mock路径。<br><figure class="image-box">                <img src="/image/vue/ajax1.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="config配置代理-webpack"><a href="#config配置代理-webpack" class="headerlink" title="config配置代理 (webpack)"></a>config配置代理 (webpack)</h4><p>vue-cli的代理底层基于webpack实现。<br><figure class="image-box">                <img src="/image/vue/ajax2.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="保证了业务api不用更改"><a href="#保证了业务api不用更改" class="headerlink" title="保证了业务api不用更改"></a>保证了业务api不用更改</h4><p>参考上面《业务中使用》</p><h2 id="router"><a href="#router" class="headerlink" title="router"></a>router</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>index.html:<br><figure class="image-box">                <img src="/image/vue/router-index.jpg" alt="" title="" class="">                <p></p>            </figure><br>main.js:<br><figure class="image-box">                <img src="/image/vue/router-main.jpg" alt="" title="" class="">                <p></p>            </figure><br>app.vue:<br><figure class="image-box">                <img src="/image/vue/router.jpg" alt="" title="" class="">                <p></p>            </figure><br>router.js:<br><figure class="image-box">                <img src="/image/vue/router1.jpg" alt="" title="" class="">                <p></p>            </figure><br>Info.vue:<br><figure class="image-box">                <img src="/image/vue/router2.jpg" alt="" title="" class="">                <p></p>            </figure><br>页面展示：<br><figure class="image-box">                <img src="/image/vue/router3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="在vue实例中使用router能力"><a href="#在vue实例中使用router能力" class="headerlink" title="在vue实例中使用router能力"></a>在vue实例中使用router能力</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'./home'</span>)</span><br></pre></td></tr></table></figure><h2 id="vuex-1"><a href="#vuex-1" class="headerlink" title="vuex"></a>vuex</h2><h3 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一、Vuex全局状态管理定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">//1.导入vuex</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.use</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line"><span class="comment">//3.vuex 状态</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//4.只有使用mutations 改变state值</span></span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increase: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二、使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.导入store/index.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store/index.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Info'</span>,</span><br><span class="line">  <span class="comment">//2.引入store</span></span><br><span class="line">  store,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        msg: store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add () &#123;</span><br><span class="line">    <span class="comment">//3.通过store.commit('mutations内方法名')</span></span><br><span class="line">      store.commit(<span class="string">'increase'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vuex的store一般跟computed或watch一起使用？"><a href="#vuex的store一般跟computed或watch一起使用？" class="headerlink" title="vuex的store一般跟computed或watch一起使用？"></a>vuex的store一般跟computed或watch一起使用？</h3><p>因为computed或watch会监听变化。<br>为什么有时候也用在data上呢，todo 待研究。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入store/index.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store/index.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Info'</span>,</span><br><span class="line">  <span class="comment">//2.引入store</span></span><br><span class="line">  store,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    msg()&#123;</span><br><span class="line">      <span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>如果不想使用vuex store时写法啰嗦，也可通过 vuex 提供的API做别名map映射。</p><h2 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h2><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><figure class="image-box">                <img src="/image/vue/global.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="定义props"><a href="#定义props" class="headerlink" title="定义props"></a>定义props</h3><h4 id="在创建组件的地方声明有哪些props"><a href="#在创建组件的地方声明有哪些props" class="headerlink" title="在创建组件的地方声明有哪些props"></a>在创建组件的地方声明有哪些props</h4><p>后在创建组件的地方，通过定义props数组，声明使用了哪些prop</p><h4 id="组件template内通过插值方式使用props"><a href="#组件template内通过插值方式使用props" class="headerlink" title="组件template内通过插值方式使用props"></a>组件template内通过插值方式使用props</h4><p>这个template就是一个组件所有内容方式，每个组件又是一个vue实例，拥有vue所有能力</p><h4 id="在调用组件地方-props方式使用和传值"><a href="#在调用组件地方-props方式使用和传值" class="headerlink" title="在调用组件地方:props方式使用和传值"></a>在调用组件地方:props方式使用和传值</h4><p>在调用组件地方，通过 :props 传值</p><h4 id="每个组件又是一个vue实例，拥有vue所有能力"><a href="#每个组件又是一个vue实例，拥有vue所有能力" class="headerlink" title="每个组件又是一个vue实例，拥有vue所有能力"></a>每个组件又是一个vue实例，拥有vue所有能力</h4><p>参考上面</p><h3 id="定义各种属性的方式"><a href="#定义各种属性的方式" class="headerlink" title="定义各种属性的方式"></a>定义各种属性的方式</h3><h4 id="定义普通props用-props"><a href="#定义普通props用-props" class="headerlink" title="定义普通props用:props"></a>定义普通props用:props</h4><h4 id="定义自定义事件用-props"><a href="#定义自定义事件用-props" class="headerlink" title="定义自定义事件用@props"></a>定义自定义事件用@props</h4><h3 id="子组件如何改变父组件值"><a href="#子组件如何改变父组件值" class="headerlink" title="子组件如何改变父组件值"></a>子组件如何改变父组件值</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>通过给子组件定义自定义事件，将父组件的方法传给自定义事件，方式与react相同。<br><figure class="image-box">                <img src="/image/vue/event.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h4><p>使用$emit触发事件。</p><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><figure class="image-box">                <img src="/image/vue/part.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="template、dom节点关系、vue实例、组件"><a href="#template、dom节点关系、vue实例、组件" class="headerlink" title="template、dom节点关系、vue实例、组件"></a>template、dom节点关系、vue实例、组件</h3><p>每个vue实例都有一个template，<br>如果此实例没有template，实例会去挂载点找，挂载点内部所有的dom节点就是template。<br>一般说根vue实例定义了挂载点，所以不用定义template。<br>组件一般不定义挂载点，而是直接定义template</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="npm-script方式"><a href="#npm-script方式" class="headerlink" title="npm script方式"></a>npm script方式</h3><figure class="image-box">                <img src="/image/vue/npm.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="vue调试"><a href="#vue调试" class="headerlink" title="vue调试"></a>vue调试</h3><h4 id="定义var，控制台测试"><a href="#定义var，控制台测试" class="headerlink" title="定义var，控制台测试"></a>定义var，控制台测试</h4><p>如图，将vue实例定义成一个变量，然后在控制台拿这个变量进行一系列设置值的操作：<br><figure class="image-box">                <img src="/image/vue/debug.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="mounted-内定义-window-vue-this"><a href="#mounted-内定义-window-vue-this" class="headerlink" title="mounted 内定义 window.vue=this;"></a>mounted 内定义 window.vue=this;</h4><p>如题，在控制台不用断点，就可以通过window.vue拿到vue实例。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> vue基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>next框架及项目笔记</title>
      <link href="/2020/10/08/next/"/>
      <url>/2020/10/08/next/</url>
      
        <content type="html"><![CDATA[<h2 id="黑知识"><a href="#黑知识" class="headerlink" title="黑知识"></a>黑知识</h2><h3 id="dialog要考虑的"><a href="#dialog要考虑的" class="headerlink" title="dialog要考虑的"></a>dialog要考虑的</h3><h4 id="要考虑内容区域与按钮设计"><a href="#要考虑内容区域与按钮设计" class="headerlink" title="要考虑内容区域与按钮设计"></a>要考虑内容区域与按钮设计</h4><h4 id="内容区域是否滚动"><a href="#内容区域是否滚动" class="headerlink" title="内容区域是否滚动"></a>内容区域是否滚动</h4><h4 id="按钮是否显示、还是滚动显示"><a href="#按钮是否显示、还是滚动显示" class="headerlink" title="按钮是否显示、还是滚动显示"></a>按钮是否显示、还是滚动显示</h4><h4 id="内容更新时，如何设计"><a href="#内容更新时，如何设计" class="headerlink" title="内容更新时，如何设计"></a>内容更新时，如何设计</h4><p>当dialog内的内容重新渲染时，如何重新让dialog布局，保持垂直居中。</p><h4 id="next的isFullScreen与shouldUpdatePosition模式"><a href="#next的isFullScreen与shouldUpdatePosition模式" class="headerlink" title="next的isFullScreen与shouldUpdatePosition模式"></a>next的isFullScreen与shouldUpdatePosition模式</h4><h3 id="项目中数据设计"><a href="#项目中数据设计" class="headerlink" title="项目中数据设计"></a>项目中数据设计</h3><h4 id="用于渲染的-redux数据"><a href="#用于渲染的-redux数据" class="headerlink" title="用于渲染的 redux数据"></a>用于渲染的 redux数据</h4><h4 id="用于渲染的-state数据"><a href="#用于渲染的-state数据" class="headerlink" title="用于渲染的 state数据"></a>用于渲染的 state数据</h4><h4 id="用于逻辑处理-的公共数据-类似单例"><a href="#用于逻辑处理-的公共数据-类似单例" class="headerlink" title="用于逻辑处理 的公共数据(类似单例)"></a>用于逻辑处理 的公共数据(类似单例)</h4><p>这种数据不用于渲染，不应该放置于 redux state 或context上，因为这些都会引起render。<br>可以考虑存储于一个单例下。</p><h4 id="用于逻辑处理-的本地数据-ref"><a href="#用于逻辑处理-的本地数据-ref" class="headerlink" title="用于逻辑处理 的本地数据(ref)"></a>用于逻辑处理 的本地数据(ref)</h4><p>一般存储于this内，或 useRef内。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> next </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端工具</title>
      <link href="/2020/09/04/all/"/>
      <url>/2020/09/04/all/</url>
      
        <content type="html"><![CDATA[<h2 id="parcel"><a href="#parcel" class="headerlink" title="parcel"></a>parcel</h2><p><a href="https://zh.parceljs.org/recipes.html" target="_blank" rel="noopener">官网 react配置</a><br><a href="https://blog.jakoblind.no/react-parcel/" target="_blank" rel="noopener">官网 博客 react详细配置</a><br><a href="https://github.com/YeWills/learns/tree/master/parcel" target="_blank" rel="noopener">parcel react demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>递归及其他</title>
      <link href="/2020/09/03/recursion/"/>
      <url>/2020/09/03/recursion/</url>
      
        <content type="html"><![CDATA[<p>主要是递归专项练习笔记，另外附带其他算法练习。</p><h2 id="有关tree树的数据处理"><a href="#有关tree树的数据处理" class="headerlink" title="有关tree树的数据处理"></a>有关tree树的数据处理</h2><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="string">"parentId"</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">"parentId"</span>: <span class="number">16</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">17</span>,</span><br><span class="line">    <span class="string">"parentId"</span>: <span class="number">16</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">"parentId"</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 转化为:</span></span><br><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  <span class="string">"id"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"children"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">19</span>,</span><br><span class="line">      <span class="string">"parentId"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">16</span>,</span><br><span class="line">      <span class="string">"parentId"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"children"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"id"</span>: <span class="number">18</span>,</span><br><span class="line">          <span class="string">"parentId"</span>: <span class="number">16</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"id"</span>: <span class="number">17</span>,</span><br><span class="line">          <span class="string">"parentId"</span>: <span class="number">16</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> idInfoMap = list.reduce(<span class="function">(<span class="params">acc,item</span>)=&gt;</span>&#123;</span><br><span class="line">    acc[item[<span class="string">'id'</span>]]=item;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'idInfoMap..'</span>, idInfoMap)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idChildsMap = list.reduce(<span class="function">(<span class="params">acc,item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;id, parentId&#125; = item;</span><br><span class="line">    acc[parentId] = [...(acc[parentId]??[]), id]</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;,&#123;&#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'idChildsMap..'</span>, idChildsMap)</span><br><span class="line"><span class="keyword">const</span> getTree = <span class="function">(<span class="params">id, parentId</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> model = &#123;</span><br><span class="line">        id,</span><br><span class="line">        parentId</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> childs = idChildsMap[id];</span><br><span class="line">    <span class="keyword">if</span>(childs)&#123;</span><br><span class="line">        model.children=childs.map(<span class="function">(<span class="params">childId</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(idChildsMap[childId])&#123;</span><br><span class="line">                <span class="keyword">return</span> getTree(idInfoMap[childId].id, idInfoMap[childId].parentId)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> idInfoMap[childId]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> treeDatas = getTree(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'treeDatas..'</span>,treeDatas)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>grid布局</title>
      <link href="/2020/08/20/css_grid/"/>
      <url>/2020/08/20/css_grid/</url>
      
        <content type="html"><![CDATA[<h2 id="网格项上的属性"><a href="#网格项上的属性" class="headerlink" title="网格项上的属性"></a>网格项上的属性</h2><h3 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><figure class="image-box">                <img src="/image/grid/grid-area.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="等效写法"><a href="#等效写法" class="headerlink" title="等效写法"></a>等效写法</h4><figure class="image-box">                <img src="/image/grid/area.jpg" alt="" title="" class="">                <p></p>            </figure><h2 id="黑知识"><a href="#黑知识" class="headerlink" title="黑知识"></a>黑知识</h2><h3 id="justify-content的start-stretch区别"><a href="#justify-content的start-stretch区别" class="headerlink" title="justify-content的start stretch区别"></a>justify-content的start stretch区别</h3><p>在固定宽度下，没有区别：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 固定宽度下，无区别，中间元素宽度始终为150px */</span></span><br><span class="line"><span class="selector-tag">grid-template-columns</span><span class="selector-pseudo">:150px</span> 150<span class="selector-tag">px</span> 150<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span><span class="selector-pseudo">:start</span>／<span class="selector-tag">stretch</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 中间的元素能有多窄就有多窄 */</span></span><br><span class="line"><span class="selector-tag">grid-template-columns</span><span class="selector-pseudo">:150px</span> <span class="selector-tag">auto</span> 150<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span><span class="selector-pseudo">:start</span>;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 中间的元素有多宽就有多宽 */</span></span><br><span class="line"><span class="selector-tag">grid-template-columns</span><span class="selector-pseudo">:150px</span> <span class="selector-tag">auto</span> 150<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span><span class="selector-pseudo">:stretch</span>;</span><br></pre></td></tr></table></figure><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><h4 id="等效写法-1"><a href="#等效写法-1" class="headerlink" title="等效写法"></a>等效写法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>:<span class="built_in">repeat</span>(3, 20px [clo-start]) <span class="number">5%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>:<span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start] <span class="number">5%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="auto-fill"><a href="#auto-fill" class="headerlink" title="auto-fill"></a>auto-fill</h4><p>auto-fill不能跟具体的数值一起，否则将不起效果。一般与minmax使用，如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>:<span class="built_in">repeat</span>(auto-fill, minmax(100px, 150px));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>auto-fit与auto-fill类似。</p><h3 id="fit-content"><a href="#fit-content" class="headerlink" title="fit-content"></a>fit-content</h3><p>fit-content 给定网格项定义的宽度，但网格项按照自身的宽度展示。<br>这个属性有个作用是，在多行中，保证定义的列宽度是一致的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span><span class="selector-pseudo">:100px</span> <span class="selector-tag">fit-content</span>(200<span class="selector-tag">px</span>) <span class="selector-tag">fit-content</span>(300<span class="selector-tag">px</span>) 10% 1<span class="selector-tag">fr</span> <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/grid/fit.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="合并写法的改名"><a href="#合并写法的改名" class="headerlink" title="合并写法的改名"></a>合并写法的改名</h3><h4 id="place-content"><a href="#place-content" class="headerlink" title="place-content"></a>place-content</h4><p>这个是合并了 justify-content align-content 的写法。<br>隐式轨道</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grid布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vscode笔记</title>
      <link href="/2020/08/19/vscode/"/>
      <url>/2020/08/19/vscode/</url>
      
        <content type="html"><![CDATA[<h2 id="vscode调试"><a href="#vscode调试" class="headerlink" title="vscode调试"></a>vscode调试</h2><h3 id="普通调试"><a href="#普通调试" class="headerlink" title="普通调试"></a>普通调试</h3><h4 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // workspaceFolder 其实就是项目根目录</span><br><span class="line">    "version": "0.2.0",</span><br><span class="line">    "configurations": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"nodemon启动"</span>,</span><br><span class="line">            <span class="attr">"runtimeExecutable"</span>: <span class="string">"nodemon"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/src/app.js"</span>,</span><br><span class="line">            <span class="attr">"restart"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"console"</span>: <span class="string">"integratedTerminal"</span>,</span><br><span class="line">            <span class="attr">"internalConsoleOptions"</span>: <span class="string">"neverOpen"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"node启动"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/src/app.js"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"调试当前文件"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;file&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好后，debugge 界面会变成：<br><figure class="image-box">                <img src="/image/node/pre.jpg" alt="" title="" class="">                <p></p>            </figure><br>项目目录：<br><figure class="image-box">                <img src="/image/node/deb.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="node调试"><a href="#node调试" class="headerlink" title="node调试"></a>node调试</h4><p>参考上面</p><h4 id="nodemon调试"><a href="#nodemon调试" class="headerlink" title="nodemon调试"></a>nodemon调试</h4><p>参考上面</p><h3 id="inspertor方式"><a href="#inspertor方式" class="headerlink" title="inspertor方式"></a>inspertor方式</h3><p>另外也可以使用跟移动端调试一样的一种方式，就是inspertor 谷歌控制台方式，详细参考慕课网中的node调试入门的课程。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="">慕课 node调试入门</a><br><a href="https://coding.imooc.com/class/chapter/342.html#Anchor" target="_blank" rel="noopener">Node.js+Koa2+MySQL打造前后端分离精品项目《旧岛》 - vscode+nodemon调试配置</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>后端demo</title>
      <link href="/2020/08/17/end_demo/"/>
      <url>/2020/08/17/end_demo/</url>
      
        <content type="html"><![CDATA[<h2 id="egg简单demo"><a href="#egg简单demo" class="headerlink" title="egg简单demo"></a>egg简单demo</h2><p>这是一个后端demo<br>功能有：</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h3 id="view-模版引擎文件-配合插件-egg-view-ejs-一起用"><a href="#view-模版引擎文件-配合插件-egg-view-ejs-一起用" class="headerlink" title="view 模版引擎文件 配合插件 egg-view-ejs 一起用"></a>view 模版引擎文件 配合插件 egg-view-ejs 一起用</h3><h3 id="存储静态文件-public-目录中"><a href="#存储静态文件-public-目录中" class="headerlink" title="存储静态文件 - public 目录中"></a>存储静态文件 - public 目录中</h3><h3 id="下载文件功能"><a href="#下载文件功能" class="headerlink" title="下载文件功能"></a>下载文件功能</h3><h3 id="抽取service"><a href="#抽取service" class="headerlink" title="抽取service"></a>抽取service</h3><h3 id="接口返回必须加上await"><a href="#接口返回必须加上await" class="headerlink" title="接口返回必须加上await"></a>接口返回必须加上await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> index() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> ctx.service.product.index();</span><br><span class="line">    <span class="comment">//await 这里必须加上await ，不然访问路由会报错 404 not found</span></span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">'index.html'</span>, &#123; res &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="post请求需禁用csrf安全攻击验证"><a href="#post请求需禁用csrf安全攻击验证" class="headerlink" title="post请求需禁用csrf安全攻击验证"></a>post请求需禁用csrf安全攻击验证</h3><p>加入以下代码，不然会报异常。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//egg-demo/config/config.default.js</span></span><br><span class="line"> <span class="comment">// 禁止post安全攻击验证功能</span></span><br><span class="line">  config.security = &#123;</span><br><span class="line">    csrf: &#123;</span><br><span class="line">      enable: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p><a href="https://github.com/YeWills/learns/tree/master/egg-demo" target="_blank" rel="noopener">demo</a></p><h2 id="egg-vue入门demo-前后端实战"><a href="#egg-vue入门demo-前后端实战" class="headerlink" title="egg+vue入门demo(前后端实战)"></a>egg+vue入门demo(前后端实战)</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>前端启动<code>npm run serve</code>,后端启动<code>npm run dev</code>.</p><h3 id="vant-的使用"><a href="#vant-的使用" class="headerlink" title="vant 的使用"></a>vant 的使用</h3><h3 id="babel-plugin-import按需加载vant"><a href="#babel-plugin-import按需加载vant" class="headerlink" title="babel-plugin-import按需加载vant"></a>babel-plugin-import按需加载vant</h3><p>(参考)[<a href="https://youzan.github.io/vant/#/zh-CN/quickstart]" target="_blank" rel="noopener">https://youzan.github.io/vant/#/zh-CN/quickstart]</a></p><h3 id="跨域-1"><a href="#跨域-1" class="headerlink" title="跨域"></a>跨域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123; <span class="comment">// 配置代理信息</span></span><br><span class="line">            <span class="string">'/article'</span>: &#123;</span><br><span class="line">                target: <span class="string">'http://127.0.0.1:7001'</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                ws: <span class="literal">true</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建后端工程"><a href="#创建后端工程" class="headerlink" title="创建后端工程"></a>创建后端工程</h3><p>创建项目，详细参考egg官网：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init egg --type=simple</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure></p><h3 id="编写mysql"><a href="#编写mysql" class="headerlink" title="编写mysql"></a>编写mysql</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- egg-mysql-serve/vue_egg_test.sql</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`article`</span>  (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`summary`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`content`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`img`</span> MEDIUMTEXT <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`createTime`</span> <span class="built_in">timestamp</span>(<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="生成数据库、表"><a href="#生成数据库、表" class="headerlink" title="生成数据库、表"></a>生成数据库、表</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>有两种方式，一种通过cmd命令方式，另外一种通过navicate方式图形化生成。<br>具体参考《后端笔记 - sequlize集成使用 - 新建数据库》<br>用navicate创建好后，在cmd中再次show databases;即可查看新增数据库。</p><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>有以下方式：</p><ul><li>直接将上面的sql 内容放在cmd中执行，生成数据库。</li><li>cmd 中 source sql文件。</li><li>利用navicate创建表，然后将表数据导出。</li></ul><h3 id="egg-mysql桥接数据库"><a href="#egg-mysql桥接数据库" class="headerlink" title="egg-mysql桥接数据库"></a>egg-mysql桥接数据库</h3><p>egg-mysql获取配置信息中的数据库登陆用户信息 登陆连接数据库。<br>让后通过<code>this.app.mysql.select(&#39;article&#39;)</code>等进行数据库的增删改查。<br>更多查看网上。</p><h3 id="egg开发规范"><a href="#egg开发规范" class="headerlink" title="egg开发规范"></a>egg开发规范</h3><ul><li>使用命令生产egg项目</li><li>命名规范：文件小写，文件内class大写驼峰。</li><li>egg的router写法等</li><li>接口数据处理使用 async await</li><li>controller的概念</li><li>service的概念<h3 id="demo与参考"><a href="#demo与参考" class="headerlink" title="demo与参考"></a>demo与参考</h3></li></ul><p><a href="https://github.com/YeWills/learns/tree/master/egg-client" target="_blank" rel="noopener">前端demo</a></p><p><a href="https://github.com/YeWills/learns/tree/master/egg-mysql-serve" target="_blank" rel="noopener">后端demo</a></p><p><a href="https://www.imooc.com/learn/1185" target="_blank" rel="noopener">慕课教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
            <tag> demo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>node笔记</title>
      <link href="/2020/08/13/node/"/>
      <url>/2020/08/13/node/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="认识node的魔力很重要"><a href="#认识node的魔力很重要" class="headerlink" title="认识node的魔力很重要"></a>认识node的魔力很重要</h3><h4 id="脱离浏览器下运行js"><a href="#脱离浏览器下运行js" class="headerlink" title="脱离浏览器下运行js"></a>脱离浏览器下运行js</h4><p>node最大的作用之一，就是让你在脱离浏览器的情况下运行js。一般js只能运行在浏览器上。<br>但node可以让你在脱离浏览器的情况下，写js，这点非常重要。</p><h4 id="提供底层操作能力"><a href="#提供底层操作能力" class="headerlink" title="提供底层操作能力"></a>提供底层操作能力</h4><p>除此之外，node还提供了很多能力，让你通过js就可以操作cpu，内存，读写文件 这些以前后端才能做的底层的操作能力。</p><h4 id="中间层：服务器中负责IO读写的中间层服务器"><a href="#中间层：服务器中负责IO读写的中间层服务器" class="headerlink" title="中间层：服务器中负责IO读写的中间层服务器"></a>中间层：服务器中负责IO读写的中间层服务器</h4><p>待完善。</p><h3 id="把玩node的技巧"><a href="#把玩node的技巧" class="headerlink" title="把玩node的技巧"></a>把玩node的技巧</h3><h4 id="使用commonjs而不用import"><a href="#使用commonjs而不用import" class="headerlink" title="使用commonjs而不用import"></a>使用commonjs而不用import</h4><p>node可以识别commonjs规范，但不能识别import es6。<br>在自己玩一玩node的时候，使用commonjs而不用import，避开webpack babel ts 等等干扰。</p><h4 id="commonjs畅通无阻"><a href="#commonjs畅通无阻" class="headerlink" title="commonjs畅通无阻"></a>commonjs畅通无阻</h4><p>如果玩一玩node，使用commonjs可以用得很爽。</p><h4 id="可以写个小js打印下node的各种模块变量"><a href="#可以写个小js打印下node的各种模块变量" class="headerlink" title="可以写个小js打印下node的各种模块变量"></a>可以写个小js打印下node的各种模块变量</h4><p>排除其他比如 webpack babel 等干扰，写一个小js，js中打印以下node的各种模块，比如 __dirname等等。</p><h3 id="全局模块"><a href="#全局模块" class="headerlink" title="全局模块"></a>全局模块</h3><h4 id="好用的process-argv"><a href="#好用的process-argv" class="headerlink" title="好用的process.argv"></a>好用的process.argv</h4><p>process.argv可以获取控制台命令的参数。<br>比如在控制台输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node ./src/app.js node -v</span><br></pre></td></tr></table></figure></p><p>js中 console.log(process.argv) 就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;/usr/local/bin/node&apos;,</span><br><span class="line">  &apos;/Users/js/Desktop/work/git/learns/sequelize-demo/src/app.js&apos;,</span><br><span class="line">  &apos;node&apos;,</span><br><span class="line">  &apos;-v&apos; ]</span><br></pre></td></tr></table></figure></p><p>你在js中获取到命令中最后两个参数是node 和 -v 后，就判定用户想知道版本号，那么就在js中console.log的方式打印版本号出来，在cmd中将会看到打印出来的版本号。<br>这只是其中一个例子，<strong>你可以以此类推，可以自己写一些命令工具。</strong></p><h4 id="dirname在编译和未编译的js中的区别"><a href="#dirname在编译和未编译的js中的区别" class="headerlink" title="__dirname在编译和未编译的js中的区别"></a>__dirname在编译和未编译的js中的区别</h4><p>在没有编译的地方<strong>dirname就是文件当前的目录；<br>如果这个文件是webpack将会被编辑的，一般是前端业务js，此时的</strong>dirname是webpack编译完成后的js所处文件的目录，也可能这个js经过webpack编译后，被合并到一个统一的versor.js文件中，此时__dirname就是此文件目录。</p><h3 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h3><p>指的是需要require，但不需要下载的模块，比如path模块。</p><h3 id="exports-与-module-exports"><a href="#exports-与-module-exports" class="headerlink" title="exports 与 module.exports"></a>exports 与 module.exports</h3><h4 id="优先用module-exports"><a href="#优先用module-exports" class="headerlink" title="优先用module.exports"></a>优先用module.exports</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.a = <span class="number">1</span>;</span><br><span class="line">exports.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  a:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过导出时一般用 module.exports;</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">girl</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  love(u) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"你是个好人!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把她导出去</span></span><br><span class="line">exports = girl  <span class="comment">// 出错！ 不能重写exports！</span></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="built_in">module</span>.exports = girl</span><br></pre></td></tr></table></figure><h3 id="http-createServer"><a href="#http-createServer" class="headerlink" title="http.createServer"></a>http.createServer</h3><h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><p>http.createServer表明启了一个服务，光一个服务还不行，你需要告诉我端口，因为服务的完整地址肯定包括端口。<br>下面的listen的意思<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我来了'</span>)</span><br><span class="line">&#125;).listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure></p><h4 id="res-req"><a href="#res-req" class="headerlink" title="res req"></a>res req</h4><p>接着上面，既然访问了服务器，那么肯定要给一定响应,不然访问者就会一致访问且等待。<br>因此就有了req，res。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> file = req.url.replace(<span class="string">'/'</span>,<span class="string">''</span>) || <span class="string">'test.html'</span></span><br><span class="line">    fs.readFile(path.resolve(__dirname,file), (err, data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.writeHead(<span class="number">404</span>);</span><br><span class="line">            res.end(<span class="string">'404 not found'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        res.end(data)<span class="comment">//可以读取图片或html</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(port, ()=&gt;<span class="built_in">console</span>.log(<span class="string">`open port <span class="subst">$&#123;port&#125;</span>`</span>))</span><br></pre></td></tr></table></figure></p><h4 id="在浏览器中显示html或图片"><a href="#在浏览器中显示html或图片" class="headerlink" title="在浏览器中显示html或图片"></a>在浏览器中显示html或图片</h4><p>参考《res req》，demo看参考里面。</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p><a href="">图片和html 浏览器显示</a></p><h3 id="设置不同响应头类型，html显示不一样"><a href="#设置不同响应头类型，html显示不一样" class="headerlink" title="设置不同响应头类型，html显示不一样"></a>设置不同响应头类型，html显示不一样</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> file = req.url.replace(<span class="string">'/'</span>,<span class="string">''</span>) || <span class="string">'test.html'</span></span><br><span class="line">    fs.readFile(path.resolve(__dirname,file), (err, data)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.writeHead(<span class="number">404</span>);</span><br><span class="line">            res.end(<span class="string">'404 not found'</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">                <span class="comment">// "Content-Type":"text/plain;charset=utf-8"//作为txt文件返回</span></span><br><span class="line">                <span class="string">"Content-Type"</span>:<span class="string">"text/html;charset=utf-8"</span><span class="comment">//作为html文件返回</span></span><br><span class="line">            &#125;);</span><br><span class="line">            res.end(data)</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).listen(port, ()=&gt;<span class="built_in">console</span>.log(<span class="string">`open port <span class="subst">$&#123;port&#125;</span>`</span>))</span><br></pre></td></tr></table></figure><p>这里是一个<a href="">demo  参看 typeApp.js</a>，表现了不同响应头类型后，html在浏览器上显示效果不一样，一个以txt文件渲染，一个以html实际解析效果渲染</p><h3 id="res-writeHead设置响应头"><a href="#res-writeHead设置响应头" class="headerlink" title="res.writeHead设置响应头"></a>res.writeHead设置响应头</h3><p>参考《设置不同响应头类型，html显示不一样》</p><h2 id="黑知识"><a href="#黑知识" class="headerlink" title="黑知识"></a>黑知识</h2><h3 id="神奇的相对路径"><a href="#神奇的相对路径" class="headerlink" title="神奇的相对路径"></a>神奇的相对路径</h3><h4 id="报错not-suce-file"><a href="#报错not-suce-file" class="headerlink" title="报错not suce file"></a>报错not suce file</h4><p>已知 test.md的路径为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sequelize-demo/src/test.md</span><br></pre></td></tr></table></figure></p><p>已知 app.js的路径为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sequelize-demo/src/app.js</span><br></pre></td></tr></table></figure></p><p>app.js的代码为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'./test.md'</span>,(err,data)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>那么在根目录下执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node ./sequelize-demo/src/app.js</span><br></pre></td></tr></table></figure></p><p>会报错 找不到 ./test.md 这个文件。</p><h4 id="解决方式一"><a href="#解决方式一" class="headerlink" title="解决方式一"></a>解决方式一</h4><p>原来是因为readFile的相对地址，不是以 app.js所在目录作为参考的，而是以执行node命令的目录为参考的。<br>因为我们是在根目录下执行node命令，因此需要修改readFile地址如下，就可以正常了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./sequelize-demo/src/test.md'</span>,(err,data)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="解决方式二-推荐"><a href="#解决方式二-推荐" class="headerlink" title="解决方式二(推荐)"></a>解决方式二(推荐)</h4><p>上面的相对地址容易出问题，在此推荐以绝对路径来处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(path.resolve(__dirname,<span class="string">'test.md'</span>),(err,data)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="如果同在根目录就没有此异常"><a href="#如果同在根目录就没有此异常" class="headerlink" title="如果同在根目录就没有此异常"></a>如果同在根目录就没有此异常</h4><p>如果上面的app.js在根目录下，就不会出现上面的问题，原因参考《解决方式一》</p><h3 id="JSON-stringify与toString使用"><a href="#JSON-stringify与toString使用" class="headerlink" title="JSON.stringify与toString使用"></a>JSON.stringify与toString使用</h3><h4 id="JSON-stringify输出内容的二进制"><a href="#JSON-stringify输出内容的二进制" class="headerlink" title="JSON.stringify输出内容的二进制"></a>JSON.stringify输出内容的二进制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(pa,(err,data)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data))<span class="comment">//&#123;"type":"Buffer","data":[97,98,99]&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())<span class="comment">//abc</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="toString可输出字符串的Buffer二进制流"><a href="#toString可输出字符串的Buffer二进制流" class="headerlink" title="toString可输出字符串的Buffer二进制流"></a>toString可输出字符串的Buffer二进制流</h4><p>如果我们知道这个二进制流Buffer是一个字符串，那么可以使用toString来解析成字符串。</p><h4 id="toString输出正常内容"><a href="#toString输出正常内容" class="headerlink" title="toString输出正常内容"></a>toString输出正常内容</h4><p>参考上面《JSON.stringify输出内容的二进制》《toString可输出字符串的Buffer二进制流》</p><h4 id="读取文件内容推荐toString"><a href="#读取文件内容推荐toString" class="headerlink" title="读取文件内容推荐toString"></a>读取文件内容推荐toString</h4><p>参考上面《JSON.stringify输出内容的二进制》</p><h3 id="require的路径"><a href="#require的路径" class="headerlink" title="require的路径"></a>require的路径</h3><ul><li>如果有路径，就去路径里面找   – require(‘./ph.js’)</li><li>没有路径就去 node_modules里面找  – require(‘./react’)</li><li>如果node_modules没有，就去node的全局安装目录找</li></ul><h3 id="webpack编译时可使用fs，页面js中不行，why？"><a href="#webpack编译时可使用fs，页面js中不行，why？" class="headerlink" title="webpack编译时可使用fs，页面js中不行，why？"></a>webpack编译时可使用fs，页面js中不行，why？</h3><p>原来，node script 进行webpack编译的时候，其实是基于node环境的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"start"</span>: <span class="string">"npx webpack-dev-server --config webpack.dev.js"</span></span><br></pre></td></tr></table></figure></p><p>node script 本身就是基于node环境的，所以能够在webpack.dev.js中使用node的各种模块。<br>由webpack编译出来的html，放在webpack的devServe服务器上，我们才可以通过浏览器访问。<br>webpack编译完后会启动一个本地服务，因此从我们通过浏览器访问页面开始，我们所使用的环境已经不是node了，从编译完后，node的工作基本上就结束了。<br>运行在浏览器上的html，其运行环境是浏览器，非node环境，因此html不能获取node模块的各种包，当然了，也不排除webpack将node的一些包内置给html，<br>不过从目前看，fs是没有内置到html上的。</p><p>小结下：编译环境是运行在node上，html文件是运行在浏览器上，前者具备node各个模块，后者不具备。</p><h3 id="为什么前端工程化都使用node"><a href="#为什么前端工程化都使用node" class="headerlink" title="为什么前端工程化都使用node"></a>为什么前端工程化都使用node</h3><h4 id="node让js脱离浏览器运行成为可能"><a href="#node让js脱离浏览器运行成为可能" class="headerlink" title="node让js脱离浏览器运行成为可能"></a>node让js脱离浏览器运行成为可能</h4><p>前端工程化需要对前端文件进行压缩打包，需要提供前端开发环境或实时编译的开发模式。<br>要实现上面的文件压缩打包，就必然用到对文件的读写能力；<br>要提供开发环境或模式，就必然需要启动服务；<br>对文件的读写，你可以使用很多其他语言，比如java等等。<br>但一个前端人员肯定希望js能够做到底层操作，而node满足了这点。<br>原本js是运行在浏览器上的一门语言，脱离浏览器就能运行了。<br>而上面的编译或者提供服务器功能，都是在非浏览器环境下的。<br>因此在node出现前，上面的这些功能若使用js完全是不可能。</p><h4 id="node为js提供了很多底层操作能力"><a href="#node为js提供了很多底层操作能力" class="headerlink" title="node为js提供了很多底层操作能力"></a>node为js提供了很多底层操作能力</h4><p>node提供了fs文件操作能力，提供了http服务器能力，还有很多其他功能，如操作系统内存等等。<br>在node环境下，js具备了操作底层的能力，而这些在浏览器下js所不具备的。</p><h4 id="强大的npm生态"><a href="#强大的npm生态" class="headerlink" title="强大的npm生态"></a>强大的npm生态</h4><p>node提供了强大的npm生态，各种高手可以开发一个npm包，然后在node或js中运行。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>基于以上，所以一般前端工程化（编译阶段），包括js的后端工程化基本上都是基于node(基于npm)</p><h4 id="node后端工程的业务js都有node功能"><a href="#node后端工程的业务js都有node功能" class="headerlink" title="node后端工程的业务js都有node功能"></a>node后端工程的业务js都有node功能</h4><p>与前端工程化不一样的是，前端一般只有编译阶段的代码具有node的环境。<br>node后端工程，包括后端工程的编译以及后端工程的接口业务逻辑代码，都是运行在node环境下的，都能使用node模块。<br><strong>后端工程中的代码，无论编译和运行都是在node环境内，都具有node模块能力</strong>，如果不是这样，为什么后端能够到处使用express或koa来写接口逻辑呢。因为express是一个抽象了原生nodejs的框架。</p><h2 id="node调试"><a href="#node调试" class="headerlink" title="node调试"></a>node调试</h2><p>参考另外一篇博客《vscode笔记 - vscode调试》</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>0到1快速构建自己的后台管理系统</title>
      <link href="/2020/07/28/end/"/>
      <url>/2020/07/28/end/</url>
      
        <content type="html"><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><h3 id="mysql安装和使用"><a href="#mysql安装和使用" class="headerlink" title="mysql安装和使用"></a>mysql安装和使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装的过程可以参照网上，不过安装的过程中，mysql会给你一个初始密码，需要记住。<br><figure class="image-box">                <img src="/image/end/pd.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@localhost: xxxxxxxxx   //root 超级用户， localhost 本地环境， 本地环境下的超级用户密码</span><br></pre></td></tr></table></figure></p><h4 id="not-found-报错"><a href="#not-found-报错" class="headerlink" title="not found 报错"></a>not found 报错</h4><p>有一个not found 报错，可能是mysql正在运行，切掉mysql进程即可，（mac下，打开偏好设置配置，在底部就会出现mysql图标，点击进去，手动停止）</p><h4 id="show-databases-报错重置密码"><a href="#show-databases-报错重置密码" class="headerlink" title="show databases 报错重置密码"></a>show databases 报错重置密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.</span><br><span class="line">修改</span><br></pre></td></tr></table></figure><p>解决如下：<br><figure class="image-box">                <img src="/image/end/1820.jpg" alt="" title="" class="">                <p></p>            </figure><br><a href="https://www.youtube.com/watch?v=q1UNz5eisN8" target="_blank" rel="noopener">参考</a></p><h4 id="设置-新-密码相关"><a href="#设置-新-密码相关" class="headerlink" title="设置(新)密码相关"></a>设置(新)密码相关</h4><p>像上面的密码设置好后，需要设置密码的使用期限，并且刷新mysql密码信息，才能使得新密码生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD = PASSWORD(&apos;新密码&apos;);  //上面的设置新密码</span><br><span class="line">ALTER USER &apos;root&apos;@&apos;localhost&apos; PASSWORD EXPIRE NEVER; //设置本地环境下的超级用户root 密码的使用期限是永远不过期(never)。</span><br><span class="line">FLUSH PRIVILEGES;//刷新特权，让刚才设置的密码相关生效</span><br></pre></td></tr></table></figure></p><h4 id="mysql命令以分号结尾"><a href="#mysql命令以分号结尾" class="headerlink" title="mysql命令以分号结尾"></a>mysql命令以分号结尾</h4><p>如果不以分号结尾，mysql则会认为命令还未执行完成，将不予执行。</p><h4 id="登陆mysql账户-root"><a href="#登陆mysql账户-root" class="headerlink" title="登陆mysql账户(root)"></a>登陆mysql账户(root)</h4><p>mysql里面可能有很多账号，因此需要登陆mysql账号。<br>命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p  //user root 使用-p密码登陆</span><br><span class="line">//输入上面设置的 root的账户密码</span><br></pre></td></tr></table></figure></p><h3 id="修改koa项目下的secure-js用户名和密码"><a href="#修改koa项目下的secure-js用户名和密码" class="headerlink" title="修改koa项目下的secure.js用户名和密码"></a>修改koa项目下的secure.js用户名和密码</h3><p>如果不修改，npm启动lin-cms-koa-master就会报错。无法与数据库链接。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lin-cms-koa-master/app/config/secure.js</span></span><br><span class="line">    database: <span class="string">'lin_cms'</span>,<span class="comment">//需要将中斜杠改成下斜杠</span></span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    dialect: <span class="string">'mysql'</span>,</span><br><span class="line">    port: <span class="number">3306</span>,</span><br><span class="line">    username: <span class="string">'root'</span>,</span><br><span class="line">    password: <span class="string">'xxx'</span>, <span class="comment">//数据库中密码</span></span><br><span class="line">    logging: <span class="literal">false</span>,</span><br><span class="line">    timezone: <span class="string">'+08:00'</span></span><br></pre></td></tr></table></figure></p><h3 id="项目导入数据库"><a href="#项目导入数据库" class="headerlink" title="项目导入数据库"></a>项目导入数据库</h3><h4 id="mysql的source命令"><a href="#mysql的source命令" class="headerlink" title="mysql的source命令"></a>mysql的source命令</h4><p><a href="https://doc.cms.talelin.com/start/koa/" target="_blank" rel="noopener">详细参考</a><br>主要使用mysql的source命令来做，后期可以了解下<br><figure class="image-box">                <img src="/image/end/db.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="navicat-mysql图形化工具"><a href="#navicat-mysql图形化工具" class="headerlink" title="navicat - mysql图形化工具"></a>navicat - mysql图形化工具</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p><a href="https://www.macwk.com/soft/navicat-premium" target="_blank" rel="noopener">破解版安装</a><br><figure class="image-box">                <img src="/image/end/db.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="操作mysql"><a href="#操作mysql" class="headerlink" title="操作mysql"></a>操作mysql</h4><p>可通过这个图形化工具，对mysql进行增删改查，实时生效。</p><h3 id="sequelize-桥接koa与mysql的工具"><a href="#sequelize-桥接koa与mysql的工具" class="headerlink" title="sequelize - 桥接koa与mysql的工具"></a>sequelize - 桥接koa与mysql的工具</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">   "@koa/cors": "^2.2.3",</span><br><span class="line">   "koa": "^2.7.0",</span><br><span class="line">   "koa-bodyparser": "^4.2.1",</span><br><span class="line">   "koa-mount": "^4.0.0",</span><br><span class="line">   "koa-static": "^5.0.0",</span><br><span class="line">   "lin-mizar": "^0.3.5",</span><br><span class="line">   "mysql2": "^2.1.0",</span><br><span class="line">   "sequelize": "^5.21.13",//</span><br><span class="line">   "validator": "^13.1.1"</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="post请求的演变"><a href="#post请求的演变" class="headerlink" title="post请求的演变"></a>post请求的演变</h2><h3 id="传统非权限方式"><a href="#传统非权限方式" class="headerlink" title="传统非权限方式"></a>传统非权限方式</h3><p>代码主要放置于 <code>default-post</code>分支中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddContentValidator</span> <span class="keyword">extends</span> <span class="title">LinValidator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.image = [</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isNotEmpty'</span>, <span class="string">'内容封面不能为空'</span>)</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">this</span>.type = [</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isNotEmpty'</span>, <span class="string">'内容类型不能为空'</span>),</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isInt'</span>, <span class="string">'内容类型id必须是数字'</span>)</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">this</span>.title = [</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isNotEmpty'</span>, <span class="string">'内容标题不能为空'</span>)</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">this</span>.content = [</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isNotEmpty'</span>, <span class="string">'内容介绍不能为空'</span>)</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">this</span>.url = [</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isOptional'</span>),</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isURL'</span>, <span class="string">'内容外链必须是合法url地址'</span>)</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">this</span>.pubdate = [</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isNotEmpty'</span>, <span class="string">'发布不能为空'</span>),</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isISO8601'</span>, <span class="string">'发布日期格式不正确'</span>)</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">this</span>.status = [</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isNotEmpty'</span>, <span class="string">'内容有效状态未指定'</span>),</span><br><span class="line">      <span class="keyword">new</span> Rule(<span class="string">'isInt'</span>, <span class="string">'内容有效状态标识不正确'</span>)</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AddContentValidator&#125; <span class="keyword">from</span> <span class="string">'../../validator/content'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> contentApi = <span class="keyword">new</span> LinRouter(&#123;</span><br><span class="line">  prefix: <span class="string">'/v1/content'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">contentApi.post(<span class="string">'/'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> v = <span class="keyword">await</span> <span class="keyword">new</span> AddContentValidator().validate(ctx);</span><br><span class="line">  <span class="keyword">return</span> ctx.json(v.get(<span class="string">'body'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>post请求<br>url:<code>http://localhost:5000/v1/content</code><br>body：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"image"</span>: <span class="string">"https://www.imooc.com/video/21672"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"100"</span>,</span><br><span class="line">        <span class="attr">"title"</span>: <span class="string">"七月"</span>,</span><br><span class="line">        <span class="attr">"content"</span>: <span class="string">"七月的三伏天"</span>,</span><br><span class="line">        <span class="attr">"pubdate"</span>: <span class="string">"2020-05-20"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="string">"1"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/end/post.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="权限验证方式"><a href="#权限验证方式" class="headerlink" title="权限验证方式"></a>权限验证方式</h3><h4 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h4><p>lin-cms框架封装好了权限验证，只需要将上面请求的post改为linPost即可。<br>以下说明，可参考官方文档。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contentApi = <span class="keyword">new</span> LinRouter(&#123;</span><br><span class="line">  prefix: <span class="string">'/v1/content'</span></span><br><span class="line">&#125;);</span><br><span class="line">contentApi.linPost(</span><br><span class="line">  <span class="string">'addContent'</span>,   <span class="comment">//请求这个事件的唯一id，可随意定义，保持唯一即可</span></span><br><span class="line">  <span class="string">'/'</span>,   <span class="comment">//请求的路由</span></span><br><span class="line">  &#123;</span><br><span class="line">    permission: <span class="string">'添加期刊内容'</span>,     <span class="comment">// 需要什么权限</span></span><br><span class="line">    <span class="built_in">module</span>: <span class="string">'内容管理'</span>,   <span class="comment">//是哪个模块的权限</span></span><br><span class="line">    mount: <span class="literal">true</span>   <span class="comment">//权限是否挂载到全局</span></span><br><span class="line">  &#125;,</span><br><span class="line">  groupRequired,   <span class="comment">//守卫函数  需登陆且被授予相应的权限后才可访问</span></span><br><span class="line">  logger(<span class="string">'&#123;user.username&#125;新增了期刊内容'</span>),   <span class="comment">//用户操作日志</span></span><br><span class="line">  <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> v = <span class="keyword">await</span> <span class="keyword">new</span> AddContentValidator().validate(ctx);</span><br><span class="line">    <span class="keyword">await</span> ContentService.addContent(v.get(<span class="string">'body'</span>));</span><br><span class="line">    ctx.success(&#123;</span><br><span class="line">      msg: <span class="string">'期刊内容新增成功'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h4 id="登陆前端页面获取令牌"><a href="#登陆前端页面获取令牌" class="headerlink" title="登陆前端页面获取令牌"></a>登陆前端页面获取令牌</h4><p>打开前端页面，登陆进去后，打开控制台，获取 请求头中的Authorization，这里的内容就是token 令牌。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTYzNTkxMzcsImlkZW50aXR5IjoxLCJzY29wZSI6ImxpbiIsInR5cGUiOiJhY2Nlc3MiLCJpYXQiOjE1OTYzNTU1Mzd9.HYrFWNES78tMGYd6O-Wdb_PBnp7XFGRy1boNIAb1Rkk</span><br></pre></td></tr></table></figure></p><p>注意的是，上面令牌码中 Bearer 是定义令牌的类型，因此不是令牌码本身，因此真正的令牌是去掉Bearer后的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1OTYzNTkxMzcsImlkZW50aXR5IjoxLCJzY29wZSI6ImxpbiIsInR5cGUiOiJhY2Nlc3MiLCJpYXQiOjE1OTYzNTU1Mzd9.HYrFWNES78tMGYd6O-Wdb_PBnp7XFGRy1boNIAb1Rkk</span><br></pre></td></tr></table></figure></p><h4 id="postman使用令牌请求"><a href="#postman使用令牌请求" class="headerlink" title="postman使用令牌请求"></a>postman使用令牌请求</h4><p>如下图，postman中，带令牌的和不带令牌的区别不大，其他照旧，就增加了一个如下的token，由上面可知，lin-cms用的是bearer类型token，因此就用bearer Token<br><figure class="image-box">                <img src="/image/end/token.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="普通用户与超级用户"><a href="#普通用户与超级用户" class="headerlink" title="普通用户与超级用户"></a>普通用户与超级用户</h4><p>可以使用超级用户root，创建一些普通用户测试相关权限的问题，普通用户登陆后，将令牌给postman，会发现令牌权限不足，这个时候可以通过前端来管理用户权限。<br>具体的权限管理，在前端项目中的分组管理中。</p><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><p>为了查看用户做了哪些曾删改查的操作，在每个请求中，使用logger，这样的话，在前端页面中就可以查看到日志信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contentApi = <span class="keyword">new</span> LinRouter(&#123;</span><br><span class="line">  prefix: <span class="string">'/v1/content'</span></span><br><span class="line">&#125;);</span><br><span class="line">contentApi.linPost(</span><br><span class="line">  <span class="string">'addContent'</span>,   <span class="comment">//请求这个事件的唯一id，可随意定义，保持唯一即可</span></span><br><span class="line">  <span class="string">'/'</span>,   <span class="comment">//请求的路由</span></span><br><span class="line">  &#123;</span><br><span class="line">    permission: <span class="string">'添加期刊内容'</span>,     <span class="comment">// 需要什么权限</span></span><br><span class="line">    <span class="built_in">module</span>: <span class="string">'内容管理'</span>,   <span class="comment">//是哪个模块的权限</span></span><br><span class="line">    mount: <span class="literal">true</span>   <span class="comment">//权限是否挂载到全局</span></span><br><span class="line">  &#125;,</span><br><span class="line">  groupRequired,   <span class="comment">//守卫函数  需登陆且被授予相应的权限后才可访问</span></span><br><span class="line">  logger(<span class="string">'&#123;user.username&#125;新增了期刊内容'</span>),   <span class="comment">//用户操作日志</span></span><br><span class="line">  <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> v = <span class="keyword">await</span> <span class="keyword">new</span> AddContentValidator().validate(ctx);</span><br><span class="line">    <span class="keyword">await</span> ContentService.addContent(v.get(<span class="string">'body'</span>));</span><br><span class="line">    ctx.success(&#123;</span><br><span class="line">      msg: <span class="string">'期刊内容新增成功'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/end/log.jpg" alt="" title="" class="">                <p></p>            </figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>lin-cms框架使用了组件<code>NotFound</code>做错误处理，只要使用了这个错误码，框架层面就会给你处理好报错信息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">async</span> editMovie (id, params) &#123;</span><br><span class="line">  <span class="keyword">const</span> movie = <span class="keyword">await</span> MovieModel.findByPk(id);</span><br><span class="line">  <span class="keyword">if</span> (!movie) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotFound();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> movie.update(&#123; ...params &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 10040,</span><br><span class="line">    &quot;message&quot;: &quot;令牌失效&quot;,</span><br><span class="line">    &quot;request&quot;: &quot;PUT /v1/content/3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请求流程与目录"><a href="#请求流程与目录" class="headerlink" title="请求流程与目录"></a>请求流程与目录</h2><h3 id="发起请求与最后结果"><a href="#发起请求与最后结果" class="headerlink" title="发起请求与最后结果"></a>发起请求与最后结果</h3><p>下面两种图是发起请求的参数和最后数据库结果。<br>下面一小节会讲如何处理这个请求流程。<br><figure class="image-box">                <img src="/image/end/post1.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/end/post2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="处理请求的流程"><a href="#处理请求的流程" class="headerlink" title="处理请求的流程"></a>处理请求的流程</h3><p>如下图，从左至右，<br>业务模块目录下的的js中接收到请求后，转发给服务层目录下的js，<br>服务层本该转发给模型层目录，但为了后期易维护性，将模型层的业务分割层dao目录和专门写模型的模型层。<br>因此服务层将请求转发给 dao目录，dao目录再转发给模型层。<br>模型层连接数据库，对数据库进行增删改查的写入。<br><figure class="image-box">                <img src="/image/end/db_flow.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="service-服务层"><a href="#service-服务层" class="headerlink" title="service 服务层"></a>service 服务层</h3><p>如上图</p><h3 id="model-模型"><a href="#model-模型" class="headerlink" title="model 模型"></a>model 模型</h3><p>模型都放在 model目录，一个模型对应一张表。<br>模型相关的逻辑，为了维护方便，部分写在dao目录下。</p><h3 id="dao-模型逻辑的分割"><a href="#dao-模型逻辑的分割" class="headerlink" title="dao 模型逻辑的分割"></a>dao 模型逻辑的分割</h3><p>模型相关的逻辑，为了维护方便，部分写在dao目录下。</p><h3 id="全局数据库实例目录"><a href="#全局数据库实例目录" class="headerlink" title="全局数据库实例目录"></a>全局数据库实例目录</h3><p>如上图，最右侧的 db.js，配置数据库相关信息。</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>主要看<a href="https://doc.cms.talelin.com/client/authority.html" target="_blank" rel="noopener">官方文档</a><br>前端主要对菜单路由、按钮做了权限控制，表现形式就是显隐与disabled等；<br>后端同时也对相应权限处理，主要对请求的接口做权限控制。<br>注意的是前后端的权限名字需要约定成一致。<br>详细可参考 上面的官方文档 以及 <a href="https://www.imooc.com/video/21690" target="_blank" rel="noopener">慕课网 - 核心机制权限控制联调</a></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="返回的数据中包含日期格式时报错处理"><a href="#返回的数据中包含日期格式时报错处理" class="headerlink" title="返回的数据中包含日期格式时报错处理"></a>返回的数据中包含日期格式时报错处理</h3><p>比如在项目中，如下的get请求会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">async</span> getContentList () &#123;</span><br><span class="line">  <span class="keyword">const</span> movieList = <span class="keyword">await</span> MovieDao.getMovieList();</span><br><span class="line">  <span class="keyword">const</span> musicList = <span class="keyword">await</span> MusicDao.getMusicList();</span><br><span class="line">  <span class="keyword">const</span> sentenceList = <span class="keyword">await</span> SentenceDao.getSentenceList();</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  res.push.apply(res, movieList);</span><br><span class="line">  res.push.apply(res, musicList);</span><br><span class="line">  res.push.apply(res, sentenceList);</span><br><span class="line">  res.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.created_at.localeCompare(a.created_at));<span class="comment">//报错</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解决方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lin-cms-koa-master/app/config/secure.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  db: &#123;</span><br><span class="line">    database: <span class="string">'lin_cms'</span>, <span class="comment">// 需要与原来视频修改</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//处理日期格式</span></span><br><span class="line">    dialectOptions: &#123;</span><br><span class="line">      dateStrings: <span class="literal">true</span>,</span><br><span class="line">      typeCast: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  secret:</span><br><span class="line">    <span class="string">'\x88W\xf09\x91\x07\x98\x89\x87\x96\xa0A\xc68\xf9\xecJJU\x17\xc5V\xbe\x8b\xef\xd7\xd8\xd3\xe6\x95*4'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="postman使用"><a href="#postman使用" class="headerlink" title="postman使用"></a>postman使用</h2><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><figure class="image-box">                <img src="/image/end/post.jpg" alt="" title="" class="">                <p></p>            </figure><h2 id="navicat使用"><a href="#navicat使用" class="headerlink" title="navicat使用"></a>navicat使用</h2><h3 id="逆向表到模型"><a href="#逆向表到模型" class="headerlink" title="逆向表到模型"></a>逆向表到模型</h3><p>可以看表的结构<br><figure class="image-box">                <img src="/image/end/navicat_dir.jpg" alt="" title="" class="">                <p></p>            </figure></p><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>通过设置如下文件，然后在axios中直接使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//lin-cms-vue-demo/.env.development</span><br><span class="line">VUE_APP_BASE_URL = &apos;http://localhost:5000/&apos;</span><br></pre></td></tr></table></figure></p><h2 id="github与参考资料"><a href="#github与参考资料" class="headerlink" title="github与参考资料"></a>github与参考资料</h2><p><a href="https://github.com/demopark/sequelize-docs-Zh-CN/tree/v5" target="_blank" rel="noopener">sequelize中文文档</a><br><a href="https://www.imooc.com/learn/1247" target="_blank" rel="noopener">慕课网教程</a><br><a href="https://doc.cms.talelin.com/" target="_blank" rel="noopener">lin-cms官方文档</a><br><a href="https://github.com/YeWills/lin-cms-vue-demo" target="_blank" rel="noopener">前端github</a><br><a href="https://github.com/YeWills/lin-cms-koa" target="_blank" rel="noopener">后端github</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack笔记新</title>
      <link href="/2020/05/09/webpack_new/"/>
      <url>/2020/05/09/webpack_new/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack常用知识"><a href="#webpack常用知识" class="headerlink" title="webpack常用知识"></a>webpack常用知识</h2><h3 id="webpack几种使用方式"><a href="#webpack几种使用方式" class="headerlink" title="webpack几种使用方式"></a>webpack几种使用方式</h3><h4 id="cmd-通过指令直接编译"><a href="#cmd-通过指令直接编译" class="headerlink" title="cmd (通过指令直接编译)"></a>cmd (通过指令直接编译)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//启用电脑全局下的webpack</span><br><span class="line">webpack src/js/index.js -o build/js/built.js --mode=development </span><br><span class="line">//使用webpack开发模式，webpack 以 src/js/index.js为入口文件打包，打包后输出到  build/js/built.js</span><br><span class="line"></span><br><span class="line">//使用项目下安装的webpack</span><br><span class="line">(node) ./node_modules/.bin/webpack ./src/test.js -o build/js/built.js --mode=production</span><br></pre></td></tr></table></figure><h4 id="npm-script"><a href="#npm-script" class="headerlink" title="npm script"></a>npm script</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  //打印git日志</span><br><span class="line">  &quot;lookGitLog&quot;: &quot;git log -2&quot;,</span><br><span class="line">  //启用电脑全局下的webpack</span><br><span class="line">  &quot;startWithGlobal&quot;: &quot;webpack --config webpack.config.js&quot;,</span><br><span class="line">  //项目下安装的webpack</span><br><span class="line">  &quot;startWithLocal&quot;: &quot;./node_modules/.bin/webpack --config webpack.config.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="注意区别全局下webpack与项目下webpack"><a href="#注意区别全局下webpack与项目下webpack" class="headerlink" title="注意区别全局下webpack与项目下webpack"></a>注意区别全局下webpack与项目下webpack</h4><p>如上，不同的webpack使用方式会引用本地webpack或者项目下webpack，从而导致你想不到的问题，因此注意好。</p><h4 id="webpack-dev-server-启动"><a href="#webpack-dev-server-启动" class="headerlink" title="webpack-dev-server 启动"></a>webpack-dev-server 启动</h4><p>此时不需要使用webpack，只需要webpack-dev-server即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="string">"start"</span>: <span class="string">"node ./node_modules/.bin/webpack-dev-server --config ./打包样式/webpack.config.js"</span>,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="npx启动（终极方案）"><a href="#npx启动（终极方案）" class="headerlink" title="npx启动（终极方案）"></a>npx启动（终极方案）</h4><p>上面所有关于 <code>./node_modules/.bin/webpack-dev-server</code>都可以通过npx来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="string">"start"</span>: <span class="string">"npx webpack-dev-server --config ./打包样式/webpack.config.js"</span>,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>npx是npm从5.x版本后自带的功能，用于运行包，先找项目下的包，若无，再找全局下的包，若无，就会安装。<br>你也可以禁止若无就安装的行为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx some-package --no-install</span><br></pre></td></tr></table></figure></p><h3 id="–watch-与-webpack-dev-server区别"><a href="#–watch-与-webpack-dev-server区别" class="headerlink" title="–watch 与 webpack-dev-server区别"></a>–watch 与 webpack-dev-server区别</h3><p>–watch 是webpack自带的，一旦修改了相关文件，就会自动重新编译，但与webpack-dev-server不同的是，它并不能提供服务器等功能，<br>无法通过服务器来访问html。</p><h3 id="优化输出路径"><a href="#优化输出路径" class="headerlink" title="优化输出路径"></a>优化输出路径</h3><h4 id="outputPath-基于-output-path"><a href="#outputPath-基于-output-path" class="headerlink" title="outputPath 基于 output.path"></a>outputPath 基于 output.path</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'js/built.js'</span>, <span class="comment">//基于下面的path</span></span><br><span class="line">  path: resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 处理图片资源</span></span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        name: <span class="string">'[hash:10].[ext]'</span>,<span class="comment">//也可通过name来生产文件目录，可能基于下面的outputPath</span></span><br><span class="line">        outputPath: <span class="string">'imgs'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h4 id="通过name创建目录"><a href="#通过name创建目录" class="headerlink" title="通过name创建目录"></a>通过name创建目录</h4><p>如上。</p><h2 id="黑知识"><a href="#黑知识" class="headerlink" title="黑知识"></a>黑知识</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul><li>hash ext<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// [hash:10]取图片的hash的前10位</span></span><br><span class="line">  <span class="comment">// [ext]取文件原来扩展名</span></span><br><span class="line">  name: <span class="string">'[hash:10].[ext]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="想不到的依赖关系"><a href="#想不到的依赖关系" class="headerlink" title="想不到的依赖关系"></a>想不到的依赖关系</h3><h4 id="less-loader-依赖-less"><a href="#less-loader-依赖-less" class="headerlink" title="less-loader 依赖 less"></a>less-loader 依赖 less</h4><p>如果要使用，就要安装二者。</p><h4 id="url-loader-依赖-file-loader"><a href="#url-loader-依赖-file-loader" class="headerlink" title="url-loader 依赖 file-loader"></a>url-loader 依赖 file-loader</h4><p>如果要使用，就要安装二者。</p><h3 id="node环境变量与webpack-mode区别"><a href="#node环境变量与webpack-mode区别" class="headerlink" title="node环境变量与webpack mode区别"></a>node环境变量与webpack mode区别</h3><p>参考下面的《node环境变量与webpack mode区别》</p><h3 id="图片的使用"><a href="#图片的使用" class="headerlink" title="图片的使用"></a>图片的使用</h3><h4 id="css中引用没有问题"><a href="#css中引用没有问题" class="headerlink" title="css中引用没有问题"></a>css中引用没有问题</h4><p>css中直接使用url-loader即可，没有问题。</p><h4 id="html中引用需另外处理"><a href="#html中引用需另外处理" class="headerlink" title="html中引用需另外处理"></a>html中引用需另外处理</h4><p>如下，url-loader默认处理不了html中img引用，需要配合html-loader一起使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       <span class="comment">// 问题：默认处理不了html中img图片</span></span><br><span class="line">       <span class="comment">// 处理图片资源</span></span><br><span class="line">       test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">       loader: <span class="string">'url-loader'</span>,</span><br><span class="line">       options: &#123;</span><br><span class="line">         <span class="comment">// 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs</span></span><br><span class="line">         <span class="comment">// 解析时会出问题：[object Module]</span></span><br><span class="line">         <span class="comment">// 解决：关闭url-loader的es6模块化，使用commonjs解析</span></span><br><span class="line">         esModule: <span class="literal">false</span>,</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">       test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">       <span class="comment">// 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）</span></span><br><span class="line">       loader: <span class="string">'html-loader'</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><h3 id="如何处理剩下的所有类型文件"><a href="#如何处理剩下的所有类型文件" class="headerlink" title="如何处理剩下的所有类型文件"></a>如何处理剩下的所有类型文件</h3><p>如果我们知道项目中只有js css html less 。<br>其他的文件都是一个图标字体文件，那我们可以通过file-loader来集中处理这些：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">   &#123;</span><br><span class="line">     test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">     use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">// 打包其他资源(除了html/js/css资源以外的资源)</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">// 排除css/js/html资源</span></span><br><span class="line">     exclude: <span class="regexp">/\.(css|js|html|less)$/</span>,</span><br><span class="line">     loader: <span class="string">'file-loader'</span>,</span><br><span class="line">     options: &#123;</span><br><span class="line">       name: <span class="string">'[hash:10].[ext]'</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure></p><h2 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h2><h3 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h3><ul><li>js css 分离 （闪屏现象）<br>参考下面的《js css 分离 （闪屏现象）》</li><li>代码压缩<h3 id="js-css-分离-（闪屏现象）"><a href="#js-css-分离-（闪屏现象）" class="headerlink" title="js css 分离 （闪屏现象）"></a>js css 分离 （闪屏现象）</h3>如果css内嵌在js内，那么页面解析时，必须要等js加载完成了，再来解析css，造成闪屏现象。<br>因此要通过<code>const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);</code>分离css。<h3 id="css浏览器兼容处理"><a href="#css浏览器兼容处理" class="headerlink" title="css浏览器兼容处理"></a>css浏览器兼容处理</h3><h4 id="postcss-loader-postcss-preset-env-browserslist"><a href="#postcss-loader-postcss-preset-env-browserslist" class="headerlink" title="postcss-loader postcss-preset-env browserslist"></a>postcss-loader postcss-preset-env browserslist</h4>postcss-preset-env 是 postcss-loader的一个插件，帮助postcss-loader找到在package.json中browserslist内定义的规则。<br>以上是处理css浏览器兼容的常规用法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">         </span><br><span class="line">          <span class="comment">// 使用loader的默认配置</span></span><br><span class="line">          <span class="comment">// 'postcss-loader',</span></span><br><span class="line">          <span class="comment">// 修改loader的配置</span></span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: <span class="string">'postcss'</span>,</span><br><span class="line">              plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">                <span class="comment">// postcss的插件</span></span><br><span class="line">                <span class="built_in">require</span>(<span class="string">'postcss-preset-env'</span>)()</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> //package.json</span><br><span class="line">// css兼容性处理：postcss --&gt; postcss-loader postcss-preset-env</span><br><span class="line">// 帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式</span><br><span class="line">"browserslist": &#123;</span><br><span class="line">  // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development</span><br><span class="line">  "development": [</span><br><span class="line">    "last 1 chrome version",//兼容最新一个版本</span><br><span class="line">    "last 1 firefox version",//兼容最新一个版本</span><br><span class="line">    "last 1 safari version"//兼容最新一个版本</span><br><span class="line">  ],</span><br><span class="line">  // 生产环境：默认是看生产环境</span><br><span class="line">  "production": [</span><br><span class="line">    "&gt;0.2%",//兼容99.8的版本</span><br><span class="line">    "not dead",//弃用的版本不兼容</span><br><span class="line">    "not op_mini all"//op_mini all是一个上古版本，早就弃用，所有不用兼容</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更多配置可查看browserslist包"><a href="#更多配置可查看browserslist包" class="headerlink" title="更多配置可查看browserslist包"></a>更多配置可查看browserslist包</h4><p>GitHub上有个库browserslist，可查看更多配置</p><h4 id="设置node环境变量"><a href="#设置node环境变量" class="headerlink" title="设置node环境变量"></a>设置node环境变量</h4><p>node环境变量通过固定名字process.env.NODE_ENV设置，如果未设置node环境变量，默认使用生产配置。<br>设置不同生产环境，将启动postcss使用browserslist内development、production不同配置。</p><h4 id="node环境变量与webpack-mode区别-1"><a href="#node环境变量与webpack-mode区别-1" class="headerlink" title="node环境变量与webpack mode区别"></a>node环境变量与webpack mode区别</h4><p>node环境变量是通过process.env.NODE_ENV设置。<br>与webpack mode无关。<br>虽然webpack mode 的值与node环境变量值一样，都是 development、production。</p><h3 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br></pre></td></tr></table></figure><h3 id="eslint-检查和修复"><a href="#eslint-检查和修复" class="headerlink" title="eslint 检查和修复"></a>eslint 检查和修复</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>eslint 首选需要 eslint-loader  eslint，<br>不考虑react，只考虑单纯的es6+代码检查，选用规则eslint-config-airbnb-base，<br>此规则依赖 eslint-config-airbnb-base  eslint-plugin-import。<br>如下配置好后，执行webpack编译命令 将列举有异常的页面，并自动修复。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">     &#123;</span><br><span class="line">       test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">       exclude: <span class="regexp">/node_modules/</span>,<span class="comment">//一定要排除node_modules，否则会检查node_modules</span></span><br><span class="line">       loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">       options: &#123;</span><br><span class="line">         <span class="comment">// webpack构建时 自动修复eslint的错误</span></span><br><span class="line">         fix: <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//package.json</span><br><span class="line"> "eslintConfig": &#123;</span><br><span class="line">   "extends": "airbnb-base"//airbnb-base是检查不含react的es6+，如果是react，请使用airbnb</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="一定要排除node-modules"><a href="#一定要排除node-modules" class="headerlink" title="一定要排除node_modules"></a>一定要排除node_modules</h4><p>如上。</p><h4 id="自动修复配置"><a href="#自动修复配置" class="headerlink" title="自动修复配置"></a>自动修复配置</h4><p>如上。</p><h4 id="检查react和非react代码"><a href="#检查react和非react代码" class="headerlink" title="检查react和非react代码"></a>检查react和非react代码</h4><p>airbnb-base 只包含了单纯的es6+检查，如果要包含react代码检查，使用 airbnb，详细参考airbnb官网。</p><h4 id="eslint-与js兼容处理-执行顺序"><a href="#eslint-与js兼容处理-执行顺序" class="headerlink" title="eslint 与js兼容处理 执行顺序"></a>eslint 与js兼容处理 执行顺序</h4><p>参考后面的《FAQ - eslint 与js兼容处理 执行顺序》</p><h4 id="禁用某一行eslint"><a href="#禁用某一行eslint" class="headerlink" title="禁用某一行eslint"></a>禁用某一行eslint</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eslint-disable-next-line</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="js兼容处理"><a href="#js兼容处理" class="headerlink" title="js兼容处理"></a>js兼容处理</h3><h4 id="基本依赖"><a href="#基本依赖" class="headerlink" title="基本依赖"></a>基本依赖</h4><p>处理js的基本依赖包 babel-loader @babel/core。</p><h4 id="js基本语法处理"><a href="#js基本语法处理" class="headerlink" title="js基本语法处理"></a>js基本语法处理</h4><p>如下 @babel/preset-env 做基本语法处理，但无法处理promise高级语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      js兼容性处理：babel-loader @babel/core </span></span><br><span class="line"><span class="comment">        1. 基本js兼容性处理 --&gt; @babel/preset-env</span></span><br><span class="line"><span class="comment">          问题：只能转换基本语法，如promise高级语法不能转换</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="comment">// 预设：指示babel做怎么样的兼容性处理</span></span><br><span class="line">        presets: [</span><br><span class="line">          [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="全量兼容处理-babel-polyfill-（不推荐）"><a href="#全量兼容处理-babel-polyfill-（不推荐）" class="headerlink" title="全量兼容处理 @babel/polyfill （不推荐）"></a>全量兼容处理 @babel/polyfill （不推荐）</h4><p>这种不用配置webpack，只需要在业务js中直接引用,但是有个问题，无法按需加载，除了有promise依赖，还有很多其他项目未用到的运行依赖，导致编译的包很大：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'@babel/polyfill'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="按需加载兼容core-js-（推荐）"><a href="#按需加载兼容core-js-（推荐）" class="headerlink" title="按需加载兼容core-js （推荐）"></a>按需加载兼容core-js （推荐）</h4><p>在上面兼容基本语法的基础上，进行按需加载配置，此时需要安装 core-js包，并配置相关：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  需要做兼容性处理的就做：按需加载  --&gt; 需要安装包 core-js</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">     &#123;</span><br><span class="line">       test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">       exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">       loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">       options: &#123;</span><br><span class="line">         <span class="comment">// 预设：指示babel做怎么样的兼容性处理</span></span><br><span class="line">         presets: [</span><br><span class="line">           [</span><br><span class="line">             <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">             &#123;</span><br><span class="line">               <span class="comment">// usage 是 按需加载 的意思</span></span><br><span class="line">               useBuiltIns: <span class="string">'usage'</span>,</span><br><span class="line">               <span class="comment">// 指定core-js版本，一般指定3</span></span><br><span class="line">               corejs: &#123;</span><br><span class="line">                 version: <span class="number">3</span> </span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="comment">// 指定兼容性做到哪个版本浏览器</span></span><br><span class="line">               targets: &#123;</span><br><span class="line">                 chrome: <span class="string">'60'</span>,</span><br><span class="line">                 firefox: <span class="string">'60'</span>,</span><br><span class="line">                 ie: <span class="string">'9'</span>,</span><br><span class="line">                 safari: <span class="string">'10'</span>,</span><br><span class="line">                 edge: <span class="string">'17'</span></span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           ]</span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><h4 id="构建缓存处理"><a href="#构建缓存处理" class="headerlink" title="构建缓存处理"></a>构建缓存处理</h4><p>一个项目中js是最多的，构建缓存一般只处理js文件。<br>开启下面cacheDirectory缓存后，第二次构建时，webpack只会重新编译修改过的js，未修改的使用上次缓存，提高构建速度。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 开启babel缓存</span></span><br><span class="line">    <span class="comment">// 第二次构建时，会读取之前的缓存</span></span><br><span class="line">    cacheDirectory: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="代码上线运行缓存优化处理"><a href="#代码上线运行缓存优化处理" class="headerlink" title="代码上线运行缓存优化处理"></a>代码上线运行缓存优化处理</h4><p>内存较多，单独在下面《代码上线运行缓存优化处理》见解。</p><h3 id="代码上线运行缓存优化处理-1"><a href="#代码上线运行缓存优化处理-1" class="headerlink" title="代码上线运行缓存优化处理"></a>代码上线运行缓存优化处理</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>后端处理：<br>给html引用的js，css静态文件 设置强制缓存，例如强制缓存三个月。<br>三个月内浏览器直接从本地读取，不用请求服务器。<br>前端处理：<br>给js、css等文件指定一个hash值的文件名。<br>利用html-webpack-plugin嵌入上面js、css等引用到html。<br>当hash码未改变时，html响应速度非常快，因为直接读取浏览器缓存。<br>当hash码改变时，只会从服务器从新读取最新hash值文件，未改变的静态文件依然从浏览器缓存读取。</p><h4 id="webpack中的hash值处理方式"><a href="#webpack中的hash值处理方式" class="headerlink" title="webpack中的hash值处理方式"></a>webpack中的hash值处理方式</h4><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hash: 每次wepack构建时会生成一个唯一的hash值。</span><br><span class="line">   问题: 因为js和css同时使用一个hash值。</span><br><span class="line"><span class="code">     如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）</span></span><br><span class="line"> chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样</span><br><span class="line">   问题: js和css的hash值还是一样的</span><br><span class="line"><span class="code">     因为css是在js中被引入的，所以同属于一个chunk</span></span><br><span class="line"> contenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样</span><br></pre></td></tr></table></figure><h4 id="推荐contenthash"><a href="#推荐contenthash" class="headerlink" title="推荐contenthash"></a>推荐contenthash</h4><p>参考上面所讲</p><h4 id="对chunk及chunkhash的说明"><a href="#对chunk及chunkhash的说明" class="headerlink" title="对chunk及chunkhash的说明"></a>对chunk及chunkhash的说明</h4><p>chunk的定义在entry上,下面就是两个chunk，<br>chunk1:<code>./src/js/index.js</code>,<br>chunk2:<code>./src/js/test.js</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: [<span class="string">'./src/js/index.js'</span>, <span class="string">'./src/js/test.js'</span>],</span><br></pre></td></tr></table></figure></p><p>对应上面两个chunk编译出来的文件，同一个chunk，其无论是css，js等的文件输出，其chunkhash都一样。</p><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h3><p>tree shaking 是很形象一个比喻，比喻你摇一棵树，将树上无用的一些残枝败叶摇掉。从而将树轻装上阵。<br>webpack自带功能，</p><ul><li>只要设置 webpack mode 为production即可</li><li>在项目 package.json 文件中，添加一个 “sideEffects” 入口。</li><li>引入一个能够删除未引用代码(dead code)的压缩工具(minifier)（例如 UglifyJSPlugin）</li><li>使用 ES2015 模块语法（即 import 和 export）<br>详细参考官网。<h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><h4 id="分割方式"><a href="#分割方式" class="headerlink" title="分割方式"></a>分割方式</h4>无论是单入口还是多入口编译，都是通过optimization进行代码分割。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   1. 可以将node_modules中代码单独打包一个chunk最终输出。(可以设置多少大小的包进行chunk抽取打包)</span></span><br><span class="line"><span class="comment">   2. 自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk //此功能对单入口工程失效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">     chunks: <span class="string">'all'</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li></ul><h4 id="多入口多chunk模式"><a href="#多入口多chunk模式" class="headerlink" title="多入口多chunk模式"></a>多入口多chunk模式</h4><p>如下，打包出来的代码自然就是多文件，实现了代码分割，再结合上面说的optimization，还可以optimization自带的分割能力。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: [<span class="string">'./src/js/index.js'</span>, <span class="string">'./src/js/test.js'</span>],</span><br></pre></td></tr></table></figure></p><h4 id="单入口分割（import动态导入语法的运行）"><a href="#单入口分割（import动态导入语法的运行）" class="headerlink" title="单入口分割（import动态导入语法的运行）"></a>单入口分割（import动态导入语法的运行）</h4><p>对于但入口分割，因为只有一个chunk，因此optimization的第二个功能（将公共的文件单独打包一个chunk）对单入口项目无效。<br>但我们又想实现这个功能，<br>只能对js进行处理了，这里使用import动态导入语法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  通过js代码，让某个文件被单独打包成一个chunk</span></span><br><span class="line"><span class="comment">  import动态导入语法：能将某个文件单独打包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'test' */</span><span class="string">'./test'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; mul, count &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 文件加载成功~</span></span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件加载失败~'</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h4 id="代码分割与dllplugin区别"><a href="#代码分割与dllplugin区别" class="headerlink" title="代码分割与dllplugin区别"></a>代码分割与dllplugin区别</h4><p>代码分割，比如node module 内打包成一个chunk，好像与dllplugin类似。<br>二者结果是一样的，但解决的问题不一样。<br>代码分割，目的在于加速页面渲染。<br>主要用于生产环境，将一个大js分割成小js，加速页面渲染。<br>dllplugin ，目的在于极快提高webpack构建速度，同时也可进一步分割node module代码，可运用于页面优化。<br>可用于开发和生产环境，第一次打包好的代码，下次打包不用重新编译。</p><h4 id="代码分割与懒加载的联系-import动态导入语法"><a href="#代码分割与懒加载的联系-import动态导入语法" class="headerlink" title="代码分割与懒加载的联系(import动态导入语法)"></a>代码分割与懒加载的联系(import动态导入语法)</h4><p>import动态导入语法会导致代码进行代码分割。<br>然后等待渲染某一页面时，再调用import动态导入语法，就是一种懒加载设计模式。</p><h4 id="optimization用于生产环境"><a href="#optimization用于生产环境" class="headerlink" title="optimization用于生产环境"></a>optimization用于生产环境</h4><p>optimization一般用于生产环境，用在开发环境的话，意义不大。</p><h3 id="懒加载-预加载"><a href="#懒加载-预加载" class="headerlink" title="懒加载 预加载"></a>懒加载 预加载</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 懒加载~：当文件需要使用时才加载~</span></span><br><span class="line">  <span class="comment">// 预加载 prefetch：会在使用之前，提前加载js文件 </span></span><br><span class="line">  <span class="comment">// 正常加载可以认为是并行加载（同一时间加载多个文件）  </span></span><br><span class="line">  <span class="comment">// 预加载 prefetch：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'test', webpackPrefetch: true */</span><span class="string">'./test'</span>).then(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mul(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="webpackPrefetch-做预加载"><a href="#webpackPrefetch-做预加载" class="headerlink" title="webpackPrefetch 做预加载"></a>webpackPrefetch 做预加载</h4><p>pc端用得多，谷歌兼容较好，但ie比较差，移动端可能兼容会有些问题。<br>上面的预加载，是项目一启动，等http请求完毕后，又空闲了，再来加载动态导入的文件。<br>不过此时项目并不会引入该文件执行，只有点击上面的按钮时，才执行文件里面的代码。</p><h3 id="其他处理"><a href="#其他处理" class="headerlink" title="其他处理"></a>其他处理</h3><h4 id="js、html压缩"><a href="#js、html压缩" class="headerlink" title="js、html压缩"></a>js、html压缩</h4><p>webpack 自带js压缩，只要将webpack 的mode 改成 production 模式，就自动压缩js。<br>html的压缩可通过html插件来做：<code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);</code></p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="eslint-与js兼容处理-执行顺序-1"><a href="#eslint-与js兼容处理-执行顺序-1" class="headerlink" title="eslint 与js兼容处理 执行顺序"></a>eslint 与js兼容处理 执行顺序</h4><p>应该先执行eslint，后执行js babel-loader。<br>一旦eslint报错，就没必要再执行 babel-loader来了，<br>反过来，一旦babel-loader编译后，其编译代码肯定报一大堆eslint错误。</p><p>另外一个问题，配置，保证eslint先执行呢？<br>首先插件顺序上，eslint在前，而且给配置一个参数即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  enforce: <span class="string">'pre'</span>,<span class="comment">// 优先执行</span></span><br><span class="line">  loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p><a href="https://github.com/YeWills/webpack-code/tree/web4.4/webpack%E6%95%99%E7%A8%8B%E4%BB%A3%E7%A0%81/3.webpack%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/16.%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">基础生产配置 demo</a></p><h2 id="构建优化"><a href="#构建优化" class="headerlink" title="构建优化"></a>构建优化</h2><h3 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h3><p>HMR: 称之为 热模块替换 / 模块热替换<br>作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块），极大提升构建速度，同时提升页面渲染速度，因为不用重新渲染整个页面。</p><h4 id="开启HMR："><a href="#开启HMR：" class="headerlink" title="开启HMR："></a>开启HMR：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="comment">// 开启HMR功能</span></span><br><span class="line">  hot: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同种类文件HMR"><a href="#不同种类文件HMR" class="headerlink" title="不同种类文件HMR"></a>不同种类文件HMR</h4><ul><li>样式文件：可以使用HMR功能，不用再进行配置：因为style-loader内部实现了，因此开发模式下，css请使用style-loader处理。</li><li>js文件：默认不能使用HMR功能 –&gt; 需要修改js代码，添加支持HMR功能的代码<br>  注意：HMR功能对js的处理，只能处理非入口js文件的其他文件。</li><li>html文件: 默认不能使用HMR功能.如果实在想做HMR，解决方法：修改entry入口，将html文件引入。不过spa应用不用做html的HMR。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: [<span class="string">'./src/js/index.js'</span>, <span class="string">'./src/index.html'</span>],</span><br></pre></td></tr></table></figure></li></ul><h4 id="js的HMR"><a href="#js的HMR" class="headerlink" title="js的HMR"></a>js的HMR</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> print <span class="keyword">from</span> <span class="string">'./print'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'index.js文件被加载了~'</span>);</span><br><span class="line">print(); <span class="comment">// 这里写一遍</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="comment">// 一旦 module.hot 为true，说明开启了HMR功能。 --&gt; 让HMR功能代码生效</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建。</span></span><br><span class="line">    <span class="comment">// 会执行后面的回调函数</span></span><br><span class="line">    print(); <span class="comment">// 这里重复写一遍</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js的HMR主要利用 module.hot.accept方法的第二参数callback，此方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建。<br>要注意的是<strong>HMR功能对js的处理，只能处理非入口js文件的其他文件。</strong>在非入口文件也可以，但失去意义。</p><h4 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h4><p><a href="https://github.com/YeWills/webpack-code/tree/web4.4/webpack%E6%95%99%E7%A8%8B%E4%BB%A3%E7%A0%81/4.webpack%E4%BC%98%E5%8C%96%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/18.HMR" target="_blank" rel="noopener">demo</a></p><h3 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h3><p>source map主要在 构建速度 调试信息显示 是否隐藏源码 三方面做平衡。<br>在选择哪一种时，基本上基于以上三方面进行平衡。<br>是否隐藏源码主要用于生产环境下，不过也不一定，有些生产环境下也不要求隐藏源码。<br>就react而言，<br>开发模式下 选择eval-source-map<br>生产模式根据是否隐藏源码 选择 nosources-source-map hidden-source-map source-map 或不source map。<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">source-map: 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）</span><br><span class="line"></span><br><span class="line"><span class="code">    [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</span></span><br><span class="line"></span><br><span class="line"><span class="code">    source-map：外部</span></span><br><span class="line"><span class="code">      错误代码准确信息 和 源代码的错误位置</span></span><br><span class="line"><span class="code">    inline-source-map：内联</span></span><br><span class="line"><span class="code">      只生成一个内联source-map</span></span><br><span class="line"><span class="code">      错误代码准确信息 和 源代码的错误位置</span></span><br><span class="line"><span class="code">    hidden-source-map：外部</span></span><br><span class="line"><span class="code">      错误代码错误原因，但是没有错误位置</span></span><br><span class="line"><span class="code">      不能追踪源代码错误，只能提示到构建后代码的错误位置</span></span><br><span class="line"><span class="code">    eval-source-map：内联</span></span><br><span class="line"><span class="code">      每一个文件都生成对应的source-map，都在eval</span></span><br><span class="line"><span class="code">      错误代码准确信息 和 源代码的错误位置</span></span><br><span class="line"><span class="code">    nosources-source-map：外部</span></span><br><span class="line"><span class="code">      错误代码准确信息, 但是没有任何源代码信息</span></span><br><span class="line"><span class="code">    cheap-source-map：外部</span></span><br><span class="line"><span class="code">      错误代码准确信息 和 源代码的错误位置 </span></span><br><span class="line"><span class="code">      只能精确的行</span></span><br><span class="line"><span class="code">    cheap-module-source-map：外部</span></span><br><span class="line"><span class="code">      错误代码准确信息 和 源代码的错误位置 </span></span><br><span class="line"><span class="code">      module会将loader的source map加入</span></span><br><span class="line"></span><br><span class="line"><span class="code">    内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快</span></span><br><span class="line"></span><br><span class="line"><span class="code">    开发环境：速度快，调试更友好</span></span><br><span class="line"><span class="code">      速度快(eval&gt;inline&gt;cheap&gt;...)</span></span><br><span class="line"><span class="code">        eval-cheap-souce-map</span></span><br><span class="line"><span class="code">        eval-source-map</span></span><br><span class="line"><span class="code">      调试更友好  </span></span><br><span class="line"><span class="code">        souce-map</span></span><br><span class="line"><span class="code">        cheap-module-souce-map</span></span><br><span class="line"><span class="code">        cheap-souce-map</span></span><br><span class="line"></span><br><span class="line"><span class="code">      --&gt; eval-source-map  / eval-cheap-module-souce-map</span></span><br><span class="line"></span><br><span class="line"><span class="code">    生产环境：源代码要不要隐藏? 调试要不要更友好</span></span><br><span class="line"><span class="code">      内联会让代码体积变大，所以在生产环境不用内联</span></span><br><span class="line"><span class="code">      nosources-source-map 全部隐藏</span></span><br><span class="line"><span class="code">      hidden-source-map 只隐藏源代码，会提示构建后代码错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="code">      --&gt; source-map / cheap-module-souce-map</span></span><br></pre></td></tr></table></figure></p><h3 id="oneof-只让一个loader处理"><a href="#oneof-只让一个loader处理" class="headerlink" title="oneof(只让一个loader处理)"></a>oneof(只让一个loader处理)</h3><p>常规的loader写法会将所有文件给每个loader都过一遍，只是有些能被loader处理，有些不能，但都会被过一遍，这样不利于构建速度，oneof解决了这个问题，一旦文件被命中，就不会过下面的loader，提高了构建速度。</p><p>如果一个类型文件 被多个loader 同时处理，留一个loader在oneof里面就行。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>thread-loader ，如果项目比较小，可不用启动多线程，因此多线程的启动也需要1秒时间。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: [</span><br><span class="line">              <span class="comment">/* </span></span><br><span class="line"><span class="comment">                开启多进程打包。 </span></span><br><span class="line"><span class="comment">                进程启动大概为600ms，进程通信也有开销。</span></span><br><span class="line"><span class="comment">                只有工作消耗时间比较长，才需要多进程打包</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">              &#123;</span><br><span class="line">                loader: <span class="string">'thread-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  workers: <span class="number">2</span> <span class="comment">// 进程2个</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  presets: [</span><br><span class="line">                    [</span><br><span class="line">                      <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">                    ]</span><br><span class="line">                  ],</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="cdn-与-external"><a href="#cdn-与-external" class="headerlink" title="cdn 与 external"></a>cdn 与 external</h3><p>一旦使用了cdn，就需要使用external，以此告诉webpack，不要打包通过cdn依赖的包。</p><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>用到的包：</p><ul><li>webpack.DllPlugin</li><li>webpack.DllReferencePlugin</li><li>require(‘add-asset-html-webpack-plugin’)<br>原理：<br>webpack.dll.js：</li><li>定义编译后的包的输出路径和名字</li><li>通过webpack.DllPlugin生成manifest.json映射文件，并定义生成路径<br>webpack.config.js</li><li>DllReferencePlugin 利用manifest.json 告诉webpack不要编译哪些依赖包</li><li>AddAssetHtmlWebpackPlugin 将webpack.dll.js中生成的编译包引入到html中，并定义好script标签。</li></ul><h4 id="webpack-dll-js"><a href="#webpack-dll-js" class="headerlink" title="webpack.dll.js"></a>webpack.dll.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包</span></span><br><span class="line"><span class="comment">    当你运行 webpack 时，默认查找 webpack.config.js 配置文件</span></span><br><span class="line"><span class="comment">    需求：需要运行 webpack.dll.js 文件</span></span><br><span class="line"><span class="comment">      --&gt; webpack --config webpack.dll.js</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 最终打包生成的[name] --&gt; jquery</span></span><br><span class="line">    <span class="comment">// ['jquery'] --&gt; 要打包的库是jquery</span></span><br><span class="line">    jquery: [<span class="string">'jquery'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">'dll'</span>),</span><br><span class="line">    library: <span class="string">'[name]_[hash]'</span> <span class="comment">// 打包的库里面向外暴露出去的内容叫什么名字</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 打包生成一个 manifest.json --&gt; 提供和jquery映射</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name: <span class="string">'[name]_[hash]'</span>, <span class="comment">// 映射库的暴露的内容名称</span></span><br><span class="line">      path: resolve(__dirname, <span class="string">'dll/manifest.json'</span>) <span class="comment">// 输出文件路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> AddAssetHtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'add-asset-html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'built.js'</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 告诉webpack哪些库不参与打包，同时使用时的名称也得变~</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: resolve(__dirname, <span class="string">'dll/manifest.json'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 将某个文件打包输出去，并在html中自动引入该资源</span></span><br><span class="line">    <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">      filepath: resolve(__dirname, <span class="string">'dll/jquery.js'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>开发环境性能优化：</p><ul><li>优化打包构建速度<ul><li>HMR</li></ul></li><li>优化代码调试<ul><li>source-map</li></ul></li></ul><p>生产环境性能优化：</p><ul><li>优化打包构建速度<ul><li>oneof</li><li>babel缓存</li><li>多进程打包</li><li>externals</li><li>dll</li></ul></li><li>优化代码运行性能<ul><li>缓存（hash码）</li><li>tree shaking</li><li>code split</li><li>懒加载／预加载</li><li>pwa</li></ul></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><p>定义服务器中路径，可以通过插件，编译后在html中看到变化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- publicPath：'/test/' --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/test/built.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h4><p>定义非chunk入口文件名，如import动态写法的，optimization 生成的。</p><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><h4 id="enfore"><a href="#enfore" class="headerlink" title="enfore"></a>enfore</h4><p>可以让loader提前或延迟执行。</p><h4 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h4><p>参看本文其他地方提到都 oneOf</p><h3 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h3><h4 id="runtimeChunk"><a href="#runtimeChunk" class="headerlink" title="runtimeChunk"></a>runtimeChunk</h4><p>如果有import动态引入写法，runtimeChunk必须配置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">     chunks: <span class="string">'all'</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">// 将当前模块的记录其他模块的hash单独打包为一个文件 runtime</span></span><br><span class="line">   <span class="comment">// 解决：修改a文件导致b文件的contenthash变化</span></span><br><span class="line">   runtimeChunk: &#123;</span><br><span class="line">     name: <span class="function"><span class="params">entrypoint</span> =&gt;</span> <span class="string">`runtime-<span class="subst">$&#123;entrypoint.name&#125;</span>`</span></span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h2><h4 id="webpack-与-webpack-cli"><a href="#webpack-与-webpack-cli" class="headerlink" title="webpack 与 webpack-cli"></a>webpack 与 webpack-cli</h4><p>这关系就好比 umi 与 create umi 的关系。</p><h4 id="配置文件为什么使用commonjs"><a href="#配置文件为什么使用commonjs" class="headerlink" title="配置文件为什么使用commonjs"></a>配置文件为什么使用commonjs</h4><p>所有的构建工具都是基于node运行，node模块化默认采用commonjs。</p><h4 id="loader做的事情少-plugin做的事情多"><a href="#loader做的事情少-plugin做的事情多" class="headerlink" title="loader做的事情少 plugin做的事情多"></a>loader做的事情少 plugin做的事情多</h4><p>loader一般就转义，和兼容css，压缩给plugin。</p><h4 id="import动态导入语法"><a href="#import动态导入语法" class="headerlink" title="import动态导入语法"></a>import动态导入语法</h4><p>import动态导入语法写法必然会导致webpack进行代码分割。</p><p>通过如下的注释写法，让webpack代码分割时，设置输出文件名称，<br>通过webpackPrefetch设置预加载。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'test', webpackPrefetch: true */</span><span class="string">'./test'</span>).then(<span class="function">(<span class="params">&#123; mul &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mul(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="dll与代码分割的联系与分工"><a href="#dll与代码分割的联系与分工" class="headerlink" title="dll与代码分割的联系与分工"></a>dll与代码分割的联系与分工</h4><p>代码分割说的是optimization与import动态写法<br>项目代码分为两种：</p><ul><li>node module<br>可通过optimization进行分割，缺点是所有的node module包只能打包成一个；<br>也可通过dll进行分割，优点在于可将node module包进行一个个分割打包成多个；</li><li>业务js<br>可通过import动态写法打包。<h4 id="4-26版本后使用terser-webpack-plugin作压缩"><a href="#4-26版本后使用terser-webpack-plugin作压缩" class="headerlink" title="4.26版本后使用terser-webpack-plugin作压缩"></a>4.26版本后使用terser-webpack-plugin作压缩</h4>新的webpack版本使用terser-webpack-plugin来作压缩。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端demo讲解</title>
      <link href="/2020/01/18/js_demo/"/>
      <url>/2020/01/18/js_demo/</url>
      
        <content type="html"><![CDATA[<h2 id="画一个时钟"><a href="#画一个时钟" class="headerlink" title="画一个时钟"></a>画一个时钟</h2><h3 id="demo与效果"><a href="#demo与效果" class="headerlink" title="demo与效果"></a>demo与效果</h3><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/clock.html" target="_blank" rel="noopener">查看demo</a><br><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/clock.html">查看demo 效果</a></p><figure class="image-box">                <img src="/image/js_demo/clock.jpg" alt="" title="" class="">                <p></p>            </figure><h3 id="将元素按圆弧排放的两种方法"><a href="#将元素按圆弧排放的两种方法" class="headerlink" title="将元素按圆弧排放的两种方法"></a>将元素按圆弧排放的两种方法</h3><h4 id="css方法-–表盘刻度"><a href="#css方法-–表盘刻度" class="headerlink" title="css方法 –表盘刻度"></a>css方法 –表盘刻度</h4><p>将元素旋转后，自身坐标系改变，再对所有元素等距离等方向位移即可。<br><figure class="image-box">                <img src="/image/js_demo/clock_css.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="计算坐标点方法-–表盘数字"><a href="#计算坐标点方法-–表盘数字" class="headerlink" title="计算坐标点方法  –表盘数字"></a>计算坐标点方法  –表盘数字</h4><p>见上面《css方法》图</p><h3 id="度与弧度制转换"><a href="#度与弧度制转换" class="headerlink" title="度与弧度制转换"></a>度与弧度制转换</h3><p>π 相当于 180度， 1度转换为弧度制的值就是 π ／180：</p><p>1度=π ／180=Math.PI/180</p><h3 id="cos、sin与圆几何度经典应用"><a href="#cos、sin与圆几何度经典应用" class="headerlink" title="cos、sin与圆几何度经典应用"></a>cos、sin与圆几何度经典应用</h3><h3 id="transform-origin的细微处理"><a href="#transform-origin的细微处理" class="headerlink" title="transform-origin的细微处理"></a>transform-origin的细微处理</h3><p>时针与刻度都用了transform-origin：left center；</p><h3 id="更多讲解参考"><a href="#更多讲解参考" class="headerlink" title="更多讲解参考"></a>更多讲解参考</h3><p><a href="http://jiaolonghuang.github.io/2014/12/13/clock/" target="_blank" rel="noopener">如何制作一个时钟</a></p><h2 id="全屏切换效果-轮播"><a href="#全屏切换效果-轮播" class="headerlink" title="全屏切换效果(轮播)"></a>全屏切换效果(轮播)</h2><h3 id="demo与效果-1"><a href="#demo与效果-1" class="headerlink" title="demo与效果"></a>demo与效果</h3><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/switch-plugin/demo.html" target="_blank" rel="noopener">查看demo</a><br><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/switch-plugin/demo.html">查看demo效果</a><br><a href="https://www.imooc.com/learn/374" target="_blank" rel="noopener">demo讲解视频</a><br><figure class="image-box">                <img src="/image/js_demo/switch.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="轮播切换设计方案"><a href="#轮播切换设计方案" class="headerlink" title="轮播切换设计方案"></a>轮播切换设计方案</h3><h4 id="三层div设计"><a href="#三层div设计" class="headerlink" title="三层div设计"></a>三层div设计</h4><p>如下图,代码如下，说明的是，设置overflow: hidden;起到裁剪的作用，设置外层（container）是为了在文档流中预定位置。<br><figure class="image-box">                <img src="/image/js_demo/switch_idea.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">data-PageSwitch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sections"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section active"</span> <span class="attr">id</span>=<span class="string">"section0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span> <span class="attr">id</span>=<span class="string">"section1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span> <span class="attr">id</span>=<span class="string">"section2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span> <span class="attr">id</span>=<span class="string">"section3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span>&#123;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* sections设置成100%也好，当内部高度依赖外层高度时，将三层高度都设置成100% */</span></span><br><span class="line">    <span class="selector-id">#container</span>,<span class="selector-class">.sections</span>,<span class="selector-class">.section</span>&#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="translateY实现切换显示"><a href="#translateY实现切换显示" class="headerlink" title="translateY实现切换显示"></a>translateY实现切换显示</h4><p>根据上面的三层div设置后，外层因为使用overflow hidden 遮挡了 sections壳的全部内容，形成裁剪效果，不过sections实际是全部显示的，<br>因此对sections使用translateY实现切换显示。</p><h4 id="内外三层都使用-height-100-技巧"><a href="#内外三层都使用-height-100-技巧" class="headerlink" title="内外三层都使用 height: 100%技巧"></a>内外三层都使用 height: 100%技巧</h4><p>如上面代码， #container,.sections,.section都使用了height: 100%;让三者的高度保持一致。因为切换显示也是将内层的section全屏展示在container上，因此这种方法非常棒。</p><h4 id="offsetTop获取translateY偏移值"><a href="#offsetTop获取translateY偏移值" class="headerlink" title="offsetTop获取translateY偏移值"></a>offsetTop获取translateY偏移值</h4><p>offsetTop是非常棒的方法，使用方法自行网上查询。虽然上面的section0 section1 section2 section3可能没有被显示，但是它们相对于container或sections的offsetTop是确定好的。<br>每次轮播的时候，记住index值，根据index获取轮播单元 section，获取它的offsetTop获取translateY偏移值。</p><h3 id="记住轮播单元的index很关键"><a href="#记住轮播单元的index很关键" class="headerlink" title="记住轮播单元的index很关键"></a>记住轮播单元的index很关键</h3><p>显示哪一页都是index进行标识，设计这个轮播插件，关键是处理index，处理好index了，其他都是围绕这个处理。</p><h3 id="有趣的动画监听事件transitionend"><a href="#有趣的动画监听事件transitionend" class="headerlink" title="有趣的动画监听事件transitionend"></a>有趣的动画监听事件transitionend</h3><p>本demo为了效果立体，设置了transitionend，有兴趣可参看demo</p><h2 id="图片跑马灯-轮播"><a href="#图片跑马灯-轮播" class="headerlink" title="图片跑马灯(轮播)"></a>图片跑马灯(轮播)</h2><h3 id="demo与效果-2"><a href="#demo与效果-2" class="headerlink" title="demo与效果"></a>demo与效果</h3><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/animation-master/html/marquee-modify.html" target="_blank" rel="noopener">查看demo</a><br><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/animation-master/html/marquee-modify.html">查看demo效果</a></p><p>这里还有一个<a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/animation-master/html/marquee.html" target="_blank" rel="noopener">jquery版本的demo</a> <a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/animation-master/html/marquee.html">jquery版本的demo 效果</a>，方便理解，可以看看。<br>基本原理同上面的《全屏切换效果(轮播)》</p><h3 id="最后位置重复添加第一张图片"><a href="#最后位置重复添加第一张图片" class="headerlink" title="最后位置重复添加第一张图片"></a>最后位置重复添加第一张图片</h3><p>如果不在最后的位置添加第一张图片，会有一个留白的效果。<br>原理在于，当transform: translateX(-1800px);时，此时页面将显示那张重复放置的第一张图片，<br>因为animation的动画在translateX(-1800px)时完成，设置的infinite特性，将瞬间0秒回到初始位置，也就是页面只有第一张图片的时候，此时就不会出现空白页，且图片循环播放流畅。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"marquee"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./../css/i/timg.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./../css/i/timg1.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./../css/i/timg2.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 重复放置第一张图片 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./../css/i/timg.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.marquee</span>, <span class="selector-class">.content</span>, <span class="selector-class">.list</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.marquee</span>, <span class="selector-class">.list</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="comment">/* width 600px * 3 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1800px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: run <span class="number">9s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> run&#123;</span><br><span class="line">  100%&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-1800px);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页面留白问题分析与解决"><a href="#页面留白问题分析与解决" class="headerlink" title="页面留白问题分析与解决"></a>页面留白问题分析与解决</h3><p>参考上面《最后位置重复添加第一张图片》</p><h3 id="使用animation的infinite特性保持循环流畅"><a href="#使用animation的infinite特性保持循环流畅" class="headerlink" title="使用animation的infinite特性保持循环流畅"></a>使用animation的infinite特性保持循环流畅</h3><p>参考上面《最后位置重复添加第一张图片》</p><h3 id="怎么做左到右的循环播放"><a href="#怎么做左到右的循环播放" class="headerlink" title="怎么做左到右的循环播放"></a>怎么做左到右的循环播放</h3><p>上面的例子是右到左的轮播，因此在最后的位置添加了第一张图片，如果需要左到右轮播，则在最开始的位置添加最后一张图片。</p><h2 id="JS实现京东无延迟菜单效果"><a href="#JS实现京东无延迟菜单效果" class="headerlink" title="JS实现京东无延迟菜单效果"></a>JS实现京东无延迟菜单效果</h2><h3 id="demo与效果-3"><a href="#demo与效果-3" class="headerlink" title="demo与效果"></a>demo与效果</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/nonDelay/index.html" target="_blank" rel="noopener">查看demo</a><br><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/nonDelay/index.html">查看demo 效果</a></p><p><a href="https://www.imooc.com/video/14717" target="_blank" rel="noopener">demo讲解视频</a><br><figure class="image-box">                <img src="/image/js_demo/delay.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="一级菜单与二级菜单"><a href="#一级菜单与二级菜单" class="headerlink" title="一级菜单与二级菜单"></a>一级菜单与二级菜单</h4><p>如上图，左侧菜单称之为一级，右侧内容显示称之为二级菜单。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="垂直运动不延时"><a href="#垂直运动不延时" class="headerlink" title="垂直运动不延时"></a>垂直运动不延时</h4><p>在一级菜单如下图做垂直运动时不延时，当测斜运动并处于三角区内时，做延时显示右侧面板，以达到选择好一级后，光标移到右侧二级时，二级不消失。<br><figure class="image-box">                <img src="/image/js_demo/delay_idea.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="三角区内移到二级时做延时"><a href="#三角区内移到二级时做延时" class="headerlink" title="三角区内移到二级时做延时"></a>三角区内移到二级时做延时</h4><p>分析如上《垂直运动不延时》</p><h3 id="判断三角区内的方案"><a href="#判断三角区内的方案" class="headerlink" title="判断三角区内的方案"></a>判断三角区内的方案</h3><h4 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h4><p>通过mousemove记录光标的移动路径，在全局内存储光标移动路径（坐标点），以二级菜单区域的右上角和右下角作为三角区内亮点，<br>给一级菜单都绑定mouseenter。<br>当mouseenter触发时，取全局移动路径的最后两个点，倒数第二个点为三角区第三个点，最后一个点为p点，判断p点是否处于上面三个点构成的三角区内。</p><h4 id="document-绑定mouseenter"><a href="#document-绑定mouseenter" class="headerlink" title="document 绑定mouseenter"></a>document 绑定mouseenter</h4><p>以此记录光标移动路径，这是常规做法。记住不用的时候需要解绑。</p><h4 id="一级菜单mouseenter触发时计算三角区"><a href="#一级菜单mouseenter触发时计算三角区" class="headerlink" title="一级菜单mouseenter触发时计算三角区"></a>一级菜单mouseenter触发时计算三角区</h4><p>如上面《方案分析》</p><h4 id="二维向量叉乘判断是否在三角内"><a href="#二维向量叉乘判断是否在三角内" class="headerlink" title="二维向量叉乘判断是否在三角内"></a>二维向量叉乘判断是否在三角内</h4><ul><li>向量：Vab=Pb-Pa</li><li>二维向量叉乘公式：<br>a(x1,y1)<em>b(x2,y2)=x1</em>y2-x2*y1</li><li>用叉乘法判断点在三角形内<figure class="image-box">                <img src="/image/js_demo/delay_ang.jpg" alt="" title="" class="">                <p></p>            </figure>代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断 a b 是否全部为负数 或 正数；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameSign</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span>(a * b) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vector</span>(<span class="params">p, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">x: b.x - p.x,</span><br><span class="line">y: b.y - p.y</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vectorProduct</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1.x * v2.y - v2.x * v1.y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPointInTrangle</span>(<span class="params">p, a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> pa = vector(p, a)</span><br><span class="line"><span class="keyword">var</span> pb = vector(p, b)</span><br><span class="line"><span class="keyword">var</span> pc = vector(p, c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = vectorProduct(pa, pb)</span><br><span class="line"><span class="keyword">var</span> t2 = vectorProduct(pb, pc)</span><br><span class="line"><span class="keyword">var</span> t3 = vectorProduct(pc, pa)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sameSign(t1, t2) &amp;&amp; sameSign(t2, t3)</span><br><span class="line">&#125;</span><br><span class="line">isPointInTrangle(currMousePos, leftCorner, topLeft, bottomLeft)</span><br></pre></td></tr></table></figure></li></ul><h4 id="二级菜单定义mouseenter"><a href="#二级菜单定义mouseenter" class="headerlink" title="二级菜单定义mouseenter"></a>二级菜单定义mouseenter</h4><p>二级菜单定义mouseenter，当鼠标移到二级菜单时，说明二级菜单处于打开状态，此时，在延时处理时不做任何处理。</p><h3 id="光标路径移动趋势分析"><a href="#光标路径移动趋势分析" class="headerlink" title="光标路径移动趋势分析"></a>光标路径移动趋势分析</h3><p>通过光标移动的最后两个点，来判断光标的移动方向(趋势)，这点非常妙。</p><h3 id="向量二叉乘"><a href="#向量二叉乘" class="headerlink" title="向量二叉乘"></a>向量二叉乘</h3><p>只需要知道坐标，就可以通过向量二叉乘知道某一点是否处于区域内。太妙。</p><h3 id="tab二级菜单显示方案"><a href="#tab二级菜单显示方案" class="headerlink" title="tab二级菜单显示方案"></a>tab二级菜单显示方案</h3><h4 id="二级菜单样式都一样"><a href="#二级菜单样式都一样" class="headerlink" title="二级菜单样式都一样"></a>二级菜单样式都一样</h4><p>二级菜单的布局样式都一样（大小宽高等），需要显示哪一个时，display block／none进行切换。</p><h4 id="display的none／block"><a href="#display的none／block" class="headerlink" title="display的none／block"></a>display的none／block</h4><p>每次只显示对应的二级菜单，其他二级菜单 display ：none。</p><h2 id="动画demo-及-css动画知识点"><a href="#动画demo-及-css动画知识点" class="headerlink" title="动画demo 及 css动画知识点"></a>动画demo 及 css动画知识点</h2><h3 id="会动的兔八公-与-step"><a href="#会动的兔八公-与-step" class="headerlink" title="会动的兔八公 与 step"></a>会动的兔八公 与 step</h3><h4 id="demo与效果-4"><a href="#demo与效果-4" class="headerlink" title="demo与效果"></a>demo与效果</h4><p><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/animation-master/html/rabbit.html">查看demo效果</a><br><a href="https://github.com/YeWills/canvas-demo/tree/master/pages/multy/css-animation/animation-master/html/rabbit.html" target="_blank" rel="noopener">demo地址</a><br><figure class="image-box">                <img src="/image/js_demo/rabbit.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="step是针对keyframes内定义的每个百分比的"><a href="#step是针对keyframes内定义的每个百分比的" class="headerlink" title="step是针对keyframes内定义的每个百分比的"></a>step是针对keyframes内定义的每个百分比的</h4><p>下面有方式一和方式二，效果是一样的，<br>step是针对keyframes内定义的每个百分比的，在方式一中keyframes内只定义了一个100%，<br>因此步进范围与速度为 100%／12<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//方式一</span><br><span class="line"><span class="selector-class">.tuzi0</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: run2 <span class="number">0.2s</span> <span class="built_in">steps</span>(12) infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(./i/tuzi.png) no-repeat;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> run2 &#123;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">background-position-x</span>: -<span class="number">2400px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在方式二中keyframes内只定义了一个50% 100%，<br>在0到50%时，步进范围与速度为 50%／6；<br>在50%到100%时，步进范围与速度为(100%-50%)／6；<br>因此方式一方式二效果一致。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//方式二</span><br><span class="line"><span class="selector-class">.tuzi</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: run <span class="number">0.2s</span> <span class="built_in">steps</span>(6) infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(./i/tuzi.png) no-repeat;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> run &#123;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">background-position-x</span>: -<span class="number">1200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">background-position-x</span>: -<span class="number">2400px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="step的一些认识"><a href="#step的一些认识" class="headerlink" title="step的一些认识"></a>step的一些认识</h4><p>动画片一定要用step，比如loading demo；<br>loading为什么定义成线性时间函数时，会出现晕眼的情况，是因为两个原因：<br>上一个loading刻度到下一个step时，没有完全踩在上一步step的脚印上，会乱，同时也会造成晕眼；<br>反之推算出，要实现这种拍浪或loading的效果，或跑火车的效果，就只能完全踩在上一步的脚印上的方案。</p><h4 id="step更适合动画片相关场景"><a href="#step更适合动画片相关场景" class="headerlink" title="step更适合动画片相关场景"></a>step更适合动画片相关场景</h4><p>参考上面《会动的兔八公 与 step》讲解。</p><h3 id="loading效果-step"><a href="#loading效果-step" class="headerlink" title="loading效果 - step"></a>loading效果 - step</h3><h4 id="demo与效果-5"><a href="#demo与效果-5" class="headerlink" title="demo与效果"></a>demo与效果</h4><p><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/animation-master/html/loading.html">查看demo效果</a><br><a href="https://github.com/YeWills/canvas-demo/tree/master/pages/multy/css-animation/animation-master/html/loading.html" target="_blank" rel="noopener">demo地址</a></p><h4 id="step时间函数的经典应用"><a href="#step时间函数的经典应用" class="headerlink" title="step时间函数的经典应用"></a>step时间函数的经典应用</h4><p>看demo的效果就知道，loading图片是一个12个刻度的圆，为了不晕图或者混乱，有一种递进的效果，就必须每走一个step，每个刻度踩在上一个刻度的上面，这样就不晕眼，因此，设置了step(12)，每个step旋转30度；<br>而原图的每个刻度之间刚好也是30度；<br>因此每走一个step，刚好完全踩在上一个刻度上。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.loading</span> &#123;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">108px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">108px</span>;</span><br><span class="line">       <span class="attribute">background</span>: <span class="built_in">url</span>(../css/i/loading.png) no-repeat;</span><br><span class="line">       <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">animation</span>: round <span class="number">1s</span> <span class="built_in">steps</span>(12) <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   @<span class="keyword">keyframes</span> round &#123;</span><br><span class="line">       100% &#123;</span><br><span class="line">           <span class="attribute">transform</span>: <span class="built_in">rotate</span>(360deg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="红包雨"><a href="#红包雨" class="headerlink" title="红包雨"></a>红包雨</h3><h4 id="demo与效果-6"><a href="#demo与效果-6" class="headerlink" title="demo与效果"></a>demo与效果</h4><p><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/animation-master/html/rain.html">查看demo效果</a><br><a href="https://github.com/YeWills/canvas-demo/tree/master/pages/multy/css-animation/animation-master/html/rain.html" target="_blank" rel="noopener">demo地址</a></p><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content</span> <span class="selector-class">.yudi</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">-webkit-animation</span>: drops <span class="number">1.2s</span> <span class="built_in">cubic-bezier</span>(0.54, 0, 0.18, 0.34) infinite;</span><br><span class="line">          <span class="attribute">animation</span>: drops <span class="number">1.2s</span> <span class="built_in">cubic-bezier</span>(0.54, 0, 0.18, 0.34) infinite;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(./i/hongbao.png) no-repeat;</span><br><span class="line">    <span class="comment">/* 因为背景图片尺寸太大，背景图片宽度自适应，高度设置为60px */</span></span><br><span class="line">  <span class="attribute">background-size</span>: auto <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> drops &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  20% &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  90% &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 可以设置translateY为0，设置为-10px有立体效果 */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate3d</span>(10px, 100vh, -10px);</span><br><span class="line">            <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(10px, 100vh, -10px);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> $content = $(<span class="string">'.content'</span>);</span><br><span class="line">   <span class="keyword">let</span> initNumber = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">let</span> lefts =<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">5</span>+<span class="number">2</span>);</span><br><span class="line">       <span class="keyword">let</span> delay = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">50</span>+<span class="number">2</span>)</span><br><span class="line">       initNumber+= lefts;</span><br><span class="line">       <span class="keyword">let</span> $div = $(<span class="string">'&lt;div/&gt;'</span>).addClass(<span class="string">'yudi'</span>).css(&#123;</span><br><span class="line">           <span class="string">"left"</span>:<span class="string">`<span class="subst">$&#123;initNumber&#125;</span>%`</span>,</span><br><span class="line">           <span class="string">"top"</span>:<span class="string">`<span class="subst">$&#123;lefts&#125;</span>%`</span>,</span><br><span class="line">           <span class="string">"animation-delay"</span>:<span class="string">`<span class="subst">$&#123;delay<span class="regexp">/10&#125;s`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">       &#125;);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">       $content.append($div);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">   &#125;</span></span></span></span><br></pre></td></tr></table></figure><h4 id="animation-delay的应用"><a href="#animation-delay的应用" class="headerlink" title="animation-delay的应用"></a>animation-delay的应用</h4><p>见上面代码</p><h4 id="position-relative-与-absolute的方案"><a href="#position-relative-与-absolute的方案" class="headerlink" title="position: relative 与 absolute的方案;"></a>position: relative 与 absolute的方案;</h4><p>见源码</p><h4 id="彩蛋-background-size"><a href="#彩蛋-background-size" class="headerlink" title="彩蛋 - background-size"></a>彩蛋 - background-size</h4><p>见上面代码</p><h3 id="animation的时间函数"><a href="#animation的时间函数" class="headerlink" title="animation的时间函数"></a>animation的时间函数</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>下面的ease-in-out就是时间函数，animation的时间函数分为线性时间函数与非线性；<br>线性时间函数全部是三次贝塞尔函数(浏览器控制台调试css时间函数时，通常显示的是一个三次贝塞尔函数正好印证了这一点)，<br>非线性时间函数主要指step。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tuzi</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: run <span class="number">0.2s</span> ease-in-out infinite;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(./i/tuzi.png) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="线性函数-三次贝塞尔函数bezier"><a href="#线性函数-三次贝塞尔函数bezier" class="headerlink" title="线性函数 - 三次贝塞尔函数bezier"></a>线性函数 - 三次贝塞尔函数bezier</h4><p>animation的线性时间函数都是三次贝塞尔函数(cubic-bezier)：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo-3</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">40px</span> auto;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">animation</span>: jump <span class="number">1s</span> <span class="built_in">cubic-bezier</span>(0.41, -0.04, 0.93, 0.29) infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一些常规的cubic-bezier(x, x, x, x)值，我们直接用linear ease ease-in ease-out ease-in-out这些关键字来表示，这些关键字也称之为预设值。<br>就好比 我们用 black 关键字表示 #000000 这种颜色一样。</p><h4 id="非线性函数-step"><a href="#非线性函数-step" class="headerlink" title="非线性函数 - step"></a>非线性函数 - step</h4><p>时间函数的非线性函数一般用step，参考上面的讲解。</p><h4 id="预设值linear-ease"><a href="#预设值linear-ease" class="headerlink" title="预设值linear ease .."></a>预设值linear ease ..</h4><p>参考上面《线性函数-三次贝塞尔函数bezier》</p><h4 id="时间函数的控制台调试"><a href="#时间函数的控制台调试" class="headerlink" title="时间函数的控制台调试"></a>时间函数的控制台调试</h4><p>谷歌浏览器提供了强大的css时间函数调试功能，参考<a href="https://beat-the-buzzer.github.io/2019/11/27/c3-animation/" target="_blank" rel="noopener">一位朋友的博客 - CSS3 动画</a></p><h4 id="动画监听事件animationstart等等"><a href="#动画监听事件animationstart等等" class="headerlink" title="动画监听事件animationstart等等"></a>动画监听事件animationstart等等</h4><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/animation-master/html/rabbit.html" target="_blank" rel="noopener">demo</a><br><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/animation-master/html/rabbit.html">demo效果</a><br>用这个的时候，注意以下兼容问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$loading.addEventListener(<span class="string">'animationstart'</span>,runstart);</span><br><span class="line">$loading.addEventListener(<span class="string">'webkitAnimationStart'</span>,runstart);</span><br><span class="line">$loading.addEventListener(<span class="string">'animationend'</span>,runend)</span><br><span class="line">$loading.addEventListener(<span class="string">'animationiteration'</span>,intertation)</span><br></pre></td></tr></table></figure></p><h2 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>写一个div，内部有两个div，一个用于撑开高度，让滚动条真实显示，不过隐藏显示；<br>一个用于真正渲染数据的div；<br>下面监听整个div的 scroll事件，通过滑动距离scrollTop，计算实时显示的数据。<br>主要通过scrollTop与每条数据高度进行计算此时scrollTop应该位于哪个start index，然后通过整个div高度，计算出end index， 实时改变渲染的data。<br>注意的是，需要通过Transform来模拟滚动的这个技巧。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">updateVisibleData(scrollTop) &#123;</span><br><span class="line">   scrollTop = scrollTop || <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">const</span> visibleCount = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.$el.clientHeight / <span class="keyword">this</span>.itemHeight);</span><br><span class="line">     <span class="keyword">const</span> start = <span class="built_in">Math</span>.floor(scrollTop / <span class="keyword">this</span>.itemHeight);</span><br><span class="line">     <span class="keyword">const</span> end = start + visibleCount;</span><br><span class="line">     <span class="keyword">this</span>.visibleData = <span class="keyword">this</span>.data.slice(start, end);</span><br><span class="line">     <span class="keyword">this</span>.$refs.content.style.webkitTransform = <span class="string">`translate3d(0, <span class="subst">$&#123; start * <span class="keyword">this</span>.itemHeight &#125;</span>px, 0)`</span>;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="css与html设计"><a href="#css与html设计" class="headerlink" title="css与html设计"></a>css与html设计</h3><figure class="image-box">                <img src="/image/js_demo/list.png" alt="" title="" class="">                <p></p>            </figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-view"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 撑开全部长度 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-view-phantom"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 实际显示内容区域 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list-view-content"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list-view</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#aaa</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="selector-class">.list-view-phantom</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>虽然滚动在list-view-content，但会冒泡到 父层；<br>当滚动发生时，.list-view-content 也随着滚动上去，因为我们只给.list-view-content渲染可视区域长度，滚动发生时，.list-view-content内容将马上被滚动上去，内容隐藏看不见，此时，就必须给.list-view-content一个<code>webkitTransform = translate3d(0, ${ start * this.itemHeight }</code>. 才能让页面正常显示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 也可以不使用绝对定位,直接普通 */</span></span><br><span class="line"><span class="selector-class">.list-view-content</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高度不定时"><a href="#高度不定时" class="headerlink" title="高度不定时"></a>高度不定时</h3><h4 id="预判高度的策略"><a href="#预判高度的策略" class="headerlink" title="预判高度的策略"></a>预判高度的策略</h4><p>参考《高度不定时，预判高度设计为固定高度》</p><h4 id="没有滚动到底时，总高度一直在变"><a href="#没有滚动到底时，总高度一直在变" class="headerlink" title="没有滚动到底时，总高度一直在变"></a>没有滚动到底时，总高度一直在变</h4><p>高度不定时，一直滚动，总高度一直变，这时因为没有滚动到底时，总高度用的是预判高度，而预判高度与实际计算高度有差距。<br>当滚到底后，使用的是缓存高度，总高度不变。</p><h3 id="你想不到的"><a href="#你想不到的" class="headerlink" title="你想不到的"></a>你想不到的</h3><h4 id="监听到的scrollTop值用于list-view偏移时非常精确"><a href="#监听到的scrollTop值用于list-view偏移时非常精确" class="headerlink" title="监听到的scrollTop值用于list-view偏移时非常精确"></a>监听到的scrollTop值用于list-view偏移时非常精确</h4><p>监听到父层到scrolltop值，用于给list-view偏移，非常精确，始终让list-view基本上达到不偏不倚正常显示内容区。</p><h4 id="高度不定时，预判高度设计为固定高度"><a href="#高度不定时，预判高度设计为固定高度" class="headerlink" title="高度不定时，预判高度设计为固定高度"></a>高度不定时，预判高度设计为固定高度</h4><p>当高度不定时，需要预先计算位置的剩余index高度，这些高度虽然实际高度不一样，但在未滚动到前，一律设定一个默认高度，<br>用于计算整个列表高度。</p><h4 id="如何保证滚动条正常高度"><a href="#如何保证滚动条正常高度" class="headerlink" title="如何保证滚动条正常高度"></a>如何保证滚动条正常高度</h4><figure class="image-box">                <img src="/image/js_demo/scroll.png" alt="" title="" class="">                <p></p>            </figure><p>解决之道在于要设计一个div框拥有实际列表总长，隐藏这个div，但又让此div撑开父层，因此设计z-index  -1 。</p><h4 id="要设计一个div框拥有实际列表总长"><a href="#要设计一个div框拥有实际列表总长" class="headerlink" title="要设计一个div框拥有实际列表总长"></a>要设计一个div框拥有实际列表总长</h4><p>参考《如何保证滚动条正常高度》</p><h4 id="不用担心父层滚动条被遮住问题"><a href="#不用担心父层滚动条被遮住问题" class="headerlink" title="不用担心父层滚动条被遮住问题"></a>不用担心父层滚动条被遮住问题</h4><p>就算你有多层div叠加，上层div也不会覆盖父层滚动条，浏览器只会让滚动条在右侧再增加个位置放置滚动条。</p><h4 id="被误解的滚动条遮住问题"><a href="#被误解的滚动条遮住问题" class="headerlink" title="被误解的滚动条遮住问题"></a>被误解的滚动条遮住问题</h4><p>一开始以为如果上层 left 0  right 0 时，父层的滚动条会被遮住，后来发现是对浏览器的滚动行为误解了。<br>参考上面《不用担心父层滚动条被遮住问题》</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="高度一致最好"><a href="#高度一致最好" class="headerlink" title="高度一致最好"></a>高度一致最好</h4><p>高度一致，意味着不用重新计算全部条数据高度，单凭数据length即可计算，性能最高。</p><h4 id="拓展：高度不一致、缓存计算"><a href="#拓展：高度不一致、缓存计算" class="headerlink" title="拓展：高度不一致、缓存计算"></a>拓展：高度不一致、缓存计算</h4><p>如果高度不一致时，就需要做缓存计算，否则比较耗性能，</p><h3 id="参考-与-源码"><a href="#参考-与-源码" class="headerlink" title="参考 与 源码"></a>参考 与 源码</h3><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://juejin.im/post/6844903577807241223" target="_blank" rel="noopener">参考博客</a><br><a href="https://www.bilibili.com/s/video/BV1qz4y1o7QA" target="_blank" rel="noopener">先看原理视频</a></p><h4 id="源码如下"><a href="#源码如下" class="headerlink" title="源码如下"></a>源码如下</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list-view</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#aaa</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list-view-phantom</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list-view-content</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.list-view-item</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//unpkg.com/vue@2.5.15/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"list-template"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  &lt;div </span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span></span>=<span class="string">"list-view"</span> </span></span><br><span class="line"><span class="javascript">    ref=<span class="string">"list"</span> </span></span><br><span class="line"><span class="javascript">    @scroll=<span class="string">"handleScroll"</span>&gt;</span></span><br><span class="line"><span class="xml">     <span class="comment">&lt;!-- 用于撑开高度，隐藏显示，这个是全部数据的长度 --&gt;</span></span></span><br><span class="line"><span class="undefined">    &lt;div     </span></span><br><span class="line"><span class="javascript">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"list-view-phantom"</span>       </span></span><br><span class="line"><span class="undefined">      :style="&#123;</span></span><br><span class="line"><span class="undefined">         height: contentHeight</span></span><br><span class="line"><span class="undefined">      &#125;"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 覆盖上面的div，父级监听scroll，实时设置transform驱动此div，模拟滚动，也称虚拟滚动 --&gt;</span></span></span><br><span class="line"><span class="undefined">    &lt;div</span></span><br><span class="line"><span class="javascript">      ref=<span class="string">"content"</span></span></span><br><span class="line"><span class="javascript">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"list-view-content"</span>&gt;</span></span><br><span class="line"><span class="undefined">      &lt;div</span></span><br><span class="line"><span class="javascript">        <span class="class"><span class="keyword">class</span></span>=<span class="string">"list-view-item"</span></span></span><br><span class="line"><span class="undefined">        :style="&#123;</span></span><br><span class="line"><span class="javascript">          height: itemHeight + <span class="string">'px'</span></span></span><br><span class="line"><span class="undefined">        &#125;"</span></span><br><span class="line"><span class="javascript">        v-<span class="keyword">for</span>=<span class="string">"item in visibleData"</span>&gt;</span></span><br><span class="line"><span class="undefined">        &#123;&#123; item.value &#125;&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">list-view</span> <span class="attr">:data</span>=<span class="string">"data"</span>&gt;</span><span class="tag">&lt;/<span class="name">list-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ListView = &#123;</span><br><span class="line">name: <span class="string">'ListView'</span>,</span><br><span class="line"></span><br><span class="line">  template: <span class="string">'#list-template'</span>,</span><br><span class="line"></span><br><span class="line">props: &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    type: <span class="built_in">Array</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    itemHeight: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  computed: &#123;</span><br><span class="line">  contentHeight() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length * <span class="keyword">this</span>.itemHeight + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateVisibleData();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      visibleData: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">  updateVisibleData(scrollTop) &#123;</span><br><span class="line">    scrollTop = scrollTop || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> visibleCount = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.$el.clientHeight / <span class="keyword">this</span>.itemHeight);</span><br><span class="line">      <span class="keyword">const</span> start = <span class="built_in">Math</span>.floor(scrollTop / <span class="keyword">this</span>.itemHeight);</span><br><span class="line">      <span class="keyword">const</span> end = start + visibleCount;</span><br><span class="line">      <span class="keyword">this</span>.visibleData = <span class="keyword">this</span>.data.slice(start, end);</span><br><span class="line">      <span class="keyword">this</span>.$refs.content.style.webkitTransform = <span class="string">`translate3d(0, <span class="subst">$&#123; start * <span class="keyword">this</span>.itemHeight &#125;</span>px, 0)`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    handleScroll() &#123;</span><br><span class="line">      <span class="keyword">const</span> scrollTop = <span class="keyword">this</span>.$el.scrollTop;</span><br><span class="line">      <span class="keyword">this</span>.updateVisibleData(scrollTop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">  ListView</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">      data.push(&#123; <span class="attr">value</span>: i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h2 id="其他demo"><a href="#其他demo" class="headerlink" title="其他demo"></a>其他demo</h2><h3 id="图片预加载"><a href="#图片预加载" class="headerlink" title="图片预加载"></a>图片预加载</h3><h4 id="方案设计-1"><a href="#方案设计-1" class="headerlink" title="方案设计"></a>方案设计</h4><p>通常的做法是，在页面打开后，先添加一个进度条，监听加载进度，设置new Image()用来加载，加载好后，图片哪里需要就在src赋值上即可。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>图片通过new Image()加载后，下一次在具体位置再使用src时，就不用等待了，直接就可以用。因此使用new Image() 达到预加载目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var images = [&#123;</span><br><span class="line">        url: &apos;https://github.com/CruxF/IMOOC/blob/master/ProImages/ImgPreloading01.jpg?raw=true&apos;,</span><br><span class="line">        name: &apos;无敌美少女一号&apos;</span><br><span class="line">      &#125;]</span><br><span class="line">  var $progress = $(&apos;.progress&apos;);</span><br><span class="line">      // 遍历数组,i代表的是数组下标，src代表的是对应数组下标的对象或者属性值</span><br><span class="line">      $.each(images, function(i, src) &#123;</span><br><span class="line">  //此imgObj不会使用，只用来预加载</span><br><span class="line">        var imgObj = new Image();</span><br><span class="line">//当图片有缓存时，不触发load事件，只能使用error来监听兼容此情况</span><br><span class="line">        $(imgObj).on(&apos;load error&apos;, function() &#123;</span><br><span class="line">//通过已加载的图片个数百分比来做进度条</span><br><span class="line">          $progress.html(Math.round((count + 1) / len * 100) + &apos;%&apos;);</span><br><span class="line">          if(count &gt;= len - 1) &#123;</span><br><span class="line">            $(&apos;.loading&apos;).hide();</span><br><span class="line">          &#125;</span><br><span class="line">          count++;</span><br><span class="line">        &#125;);</span><br><span class="line">        imgObj.src = src.url;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  //以后使用时，直接赋给src，此时因为之前已经加载过，此时不会再次后台请求，直接秒显示</span><br><span class="line">   $(&apos;#img&apos;).attr(&#123;</span><br><span class="line">          &apos;src&apos;: images[index].url,</span><br><span class="line">          &apos;title&apos;: images[index].name,</span><br><span class="line">          &apos;alt&apos;: images[index].name</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><h4 id="所有图片提前到页面初始时一起加载"><a href="#所有图片提前到页面初始时一起加载" class="headerlink" title="所有图片提前到页面初始时一起加载"></a>所有图片提前到页面初始时一起加载</h4><p>参考《原理》</p><h4 id="图片加载百分比进度方案"><a href="#图片加载百分比进度方案" class="headerlink" title="图片加载百分比进度方案"></a>图片加载百分比进度方案</h4><p>通过已加载的图片个数百分比来做进度条，此方法是普遍做法，见上面代码《原理》；</p><h4 id="设置new-Image"><a href="#设置new-Image" class="headerlink" title="设置new Image()"></a>设置new Image()</h4><p>参考《原理》</p><h4 id="监听load事件"><a href="#监听load事件" class="headerlink" title="监听load事件"></a>监听load事件</h4><p>参考《原理》</p><h4 id="监听error事件兼容缓存"><a href="#监听error事件兼容缓存" class="headerlink" title="监听error事件兼容缓存"></a>监听error事件兼容缓存</h4><p>当图片有缓存时，不触发load事件，只能使用error来监听兼容此情况，参考《原理》</p><h4 id="页面要用时再取值"><a href="#页面要用时再取值" class="headerlink" title="页面要用时再取值"></a>页面要用时再取值</h4><p>参考《原理》</p><h4 id="load与src顺序有讲究"><a href="#load与src顺序有讲究" class="headerlink" title="load与src顺序有讲究"></a>load与src顺序有讲究</h4><p>上面的代码中src必须写在on(‘load’)下面，先load，后src赋值，这样可以避免一些隐蔽的问题，比如图片缓存等等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> imgObj = <span class="keyword">new</span> Image();</span><br><span class="line">$(imgObj).on(<span class="string">'load error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">imgObj.src = src.url;</span><br></pre></td></tr></table></figure></p><h4 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a>demo地址</h4><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/ImgPreloading/index2-3_ok.html" target="_blank" rel="noopener">demo</a><br><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/ImgPreloading/index2-3_ok.html">demo效果</a></p><h3 id="可调大小面板实现"><a href="#可调大小面板实现" class="headerlink" title="可调大小面板实现"></a>可调大小面板实现</h3><h4 id="demo与介绍"><a href="#demo与介绍" class="headerlink" title="demo与介绍"></a>demo与介绍</h4><p>本demo基于<a href="https://www.imooc.com/learn/193" target="_blank" rel="noopener">慕课网视频</a>优化而来，<a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/resizeable.html" target="_blank" rel="noopener">demo 地址</a> <a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/resizeable.html">demo 效果</a></p><h4 id="方案分析"><a href="#方案分析" class="headerlink" title="方案分析"></a>方案分析</h4><p>如下图，要实现左侧，下边，右下侧，三个位置可以拖动，<br>具体做法是在这三个地方添加一个看不见的拖动用的dom，给这三个dom绑定mouse事件，<br>在mouseMove中对矩形框持续设置宽高样式，<br>同时通过css设置三个位置Dom跟随。<br><figure class="image-box">                <img src="/image/js_demo/resizable.jpg" alt="" title="" class="">                <p></p>            </figure><br>具体步骤如下：</p><h4 id="设置左、下、左下侧-拖动dom"><a href="#设置左、下、左下侧-拖动dom" class="headerlink" title="设置左、下、左下侧 拖动dom"></a>设置左、下、左下侧 拖动dom</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">panelDom = document.getElementById(panelId);</span><br><span class="line">[&apos;right&apos;, &apos;bottom&apos;, &apos;lean&apos;].forEach(dragDomType=&gt;&#123;</span><br><span class="line">const dragDom = document.createElement(&quot;div&quot;);</span><br><span class="line">dragDom.class = dragDom.className   = `ui-Resizable-$&#123;dragDomType&#125; ui-Resizable-ctrl`;</span><br><span class="line">panelDom.appendChild(dragDom);</span><br><span class="line">dragDom.addEventListener(&apos;mousedown&apos;, onMousemove);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="css设置拖动dom样式跟随矩形框"><a href="#css设置拖动dom样式跟随矩形框" class="headerlink" title="css设置拖动dom样式跟随矩形框"></a>css设置拖动dom样式跟随矩形框</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.ui-Resizable-right&#123;</span><br><span class="line">position:absolute;</span><br><span class="line">right:0px;</span><br><span class="line">top:0px;</span><br><span class="line">width:10px;</span><br><span class="line">height:100%;</span><br><span class="line">cursor: e-resize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mouseMove中改变矩形框宽高"><a href="#mouseMove中改变矩形框宽高" class="headerlink" title="mouseMove中改变矩形框宽高"></a>mouseMove中改变矩形框宽高</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let newPanelWidth = panelDom.offsetWidth - 2 + moveDistance.x;</span><br><span class="line">let newPanelHeight = panelDom.offsetHeight - 2 + moveDistance.y;</span><br><span class="line">newPanelWidth = Math.max(newPanelWidth, 150);</span><br><span class="line">newPanelHeight = Math.max(newPanelHeight, 50);</span><br><span class="line">switch(mouseType)&#123;</span><br><span class="line">case &apos;movehorizontal&apos;:</span><br><span class="line">panelDom.style.width = newPanelWidth + &apos;px&apos;;</span><br><span class="line">break;</span><br><span class="line">case &apos;moveVertical&apos;:</span><br><span class="line">panelDom.style.height = newPanelHeight + &apos;px&apos;;</span><br><span class="line">break;</span><br><span class="line">case &apos;moveLean&apos;:</span><br><span class="line">panelDom.style.width = newPanelWidth + &apos;px&apos;;</span><br><span class="line">panelDom.style.height = newPanelHeight + &apos;px&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="固定侧边栏滚动"><a href="#固定侧边栏滚动" class="headerlink" title="固定侧边栏滚动"></a>固定侧边栏滚动</h3><h4 id="demo与介绍-1"><a href="#demo与介绍-1" class="headerlink" title="demo与介绍"></a>demo与介绍</h4><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/fixedSide/index.htm" target="_blank" rel="noopener">demo 地址</a><br><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/fixedSide/index.htm">demo 效果</a></p><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>要求右侧的侧边栏，正常滚动的时候，正常滚动；<br>当侧边栏滚到底，但左侧内容还有，需要继续往下滚动时，右侧侧边栏固定显示最后面一段内容。</p><h4 id="window-addEventListener-‘scroll’-监听滚动"><a href="#window-addEventListener-‘scroll’-监听滚动" class="headerlink" title="window.addEventListener(‘scroll’)监听滚动"></a>window.addEventListener(‘scroll’)监听滚动</h4><p>设置window的滚动事件scroll，当发生滚动时实时监听并设置侧边栏样式。</p><h4 id="滚动距离-视口高度-与-侧边栏实际高度-比较"><a href="#滚动距离-视口高度-与-侧边栏实际高度-比较" class="headerlink" title="滚动距离+视口高度 与 侧边栏实际高度 比较"></a>滚动距离+视口高度 与 侧边栏实际高度 比较</h4><p>当 滚动距离+视口高度 大于 侧边栏实际高度，启动bottom为0的 position：fixed；<br>反之，一切正常 position设置为static。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sideHeight = domSider.offsetHeight;</span><br><span class="line"><span class="keyword">var</span> screenHeight =<span class="built_in">document</span>.documentElement.clientHeight||<span class="built_in">document</span>.body.clientHeight;</span><br><span class="line"><span class="keyword">var</span> scrollHeight = <span class="built_in">document</span>.documentElement.scrollTop||<span class="built_in">document</span>.body.scrollTop;</span><br><span class="line"><span class="comment">//这种思想值得借鉴</span></span><br><span class="line"><span class="keyword">if</span>(scrollHeight+screenHeight&gt;sideHeight)&#123;</span><br><span class="line">domSider.style.cssText = <span class="string">'position:fixed;right:0px;bottom: 0px'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">domSider.style.position=<span class="string">'static'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="scrollTop的应用"><a href="#scrollTop的应用" class="headerlink" title="scrollTop的应用"></a>scrollTop的应用</h4><p>参考上面《滚动距离+视口高度 与 侧边栏实际高度 比较》</p><h3 id="拖动导航条实时显示对应内容"><a href="#拖动导航条实时显示对应内容" class="headerlink" title="拖动导航条实时显示对应内容"></a>拖动导航条实时显示对应内容</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>如下，当touchstart 按住左侧导航条，往下拖动时，让左侧显示对应内容。<br><figure class="image-box">                <img src="/image/js_demo/touch.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><p>左侧内容区是一个组件，导航条是一个组件。<br>在导航条上监听三个事件 touchstart 等，三个事件，<br><figure class="image-box">                <img src="/image/js_demo/touch1.png" alt="" title="" class="">                <p></p>            </figure><br>通过touchmove计算鼠标当前位置坐标，已知导航条顶部A字母所在位置的坐标，已知每个字母高度，鼠标位置坐标减去导航条顶部坐标，就可计算鼠标当前位于哪个字母上面，<br>然后通过touchmove实时将对应的字母传给左侧内容组件，<br><figure class="image-box">                <img src="/image/js_demo/touch2.png" alt="" title="" class="">                <p></p>            </figure><br>内容组件使用一个scoll插件，此插件可设置滚动到指定的位置，或滚动到指定的元素element上。<br>因此要实现上面的功能，需要以下元素：</p><ul><li>获取对应字母的计算方案</li><li>左侧内容区最好用一个scoll包裹，可设置显示指定位置</li></ul><h4 id="touchstart-touchmove-touchend"><a href="#touchstart-touchmove-touchend" class="headerlink" title="touchstart touchmove touchend"></a>touchstart touchmove touchend</h4><p>touchstart 与touchend的作用就是设置一个touchStatus，标识按住开始拖动时，允许做滚动逻辑处理，松开拖动时，不允许逻辑处理。<br>剩下的逻辑处理交给touchmove。</p><h3 id="网页定位导航特效"><a href="#网页定位导航特效" class="headerlink" title="网页定位导航特效"></a>网页定位导航特效</h3><h4 id="demo与介绍-2"><a href="#demo与介绍-2" class="headerlink" title="demo与介绍"></a>demo与介绍</h4><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/location/location.html" target="_blank" rel="noopener">demo</a><br><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/location/location.html">demo效果</a></p><figure class="image-box">                <img src="/image/js_demo/location.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="html的锚点做业内跳转"><a href="#html的锚点做业内跳转" class="headerlink" title="html的锚点做业内跳转"></a>html的锚点做业内跳转</h4><p>如下，更多参考网上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;add&quot;&gt;&lt;/a&gt; 或者 &lt;a id=&quot;add&quot;&gt;&lt;/a&gt; （ps：用id兼容性好些）</span><br><span class="line">&lt;a href=&quot;#add&quot;&gt;跳转到add&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><h4 id="window-addEventListener-‘scroll’-监听滚动-1"><a href="#window-addEventListener-‘scroll’-监听滚动-1" class="headerlink" title="window.addEventListener(‘scroll’)监听滚动"></a>window.addEventListener(‘scroll’)监听滚动</h4><p>监听滚动距离，实时点亮上图右侧的菜单。</p><h3 id="CSS-Sprite雪碧图应用"><a href="#CSS-Sprite雪碧图应用" class="headerlink" title="CSS Sprite雪碧图应用"></a>CSS Sprite雪碧图应用</h3><h4 id="demo与介绍-3"><a href="#demo与介绍-3" class="headerlink" title="demo与介绍"></a>demo与介绍</h4><p><a href="https://github.com/YeWills/canvas-demo/blob/master/pages/multy/css-animation/priatice/priatice.html" target="_blank" rel="noopener">demo</a><br><a href="https://yewills.github.io/canvas-demo/pages/multy/css-animation/priatice/priatice.html">demo效果</a><br>雪碧图用多个图标合成一个，可以用来减少http请求，优化性能，主要原理是对background-position的应用。</p><h4 id="减少http请求，优化性能"><a href="#减少http请求，优化性能" class="headerlink" title="减少http请求，优化性能"></a>减少http请求，优化性能</h4><p>参考上面的讲解。</p><h4 id="核心是对background-position的应用"><a href="#核心是对background-position的应用" class="headerlink" title="核心是对background-position的应用"></a>核心是对background-position的应用</h4><p>下面是background-position的坐标系：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.regnow</span> <span class="selector-tag">input</span>&#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(sp.png) no-repeat;</span><br><span class="line"><span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">38px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="/image/js_demo/sprite.jpg" alt="" title="" class="">                <p></p>            </figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端demo讲解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>node模块</title>
      <link href="/2019/08/13/node_module/"/>
      <url>/2019/08/13/node_module/</url>
      
        <content type="html"><![CDATA[<h2 id="node好用模块"><a href="#node好用模块" class="headerlink" title="node好用模块"></a>node好用模块</h2><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>一款用于 使用node启动的项目，监听当项目文件变动时，自动启动类似npm start命令的模块。<br><a href="https://github.com/YeWills/koa-demo/tree/master" target="_blank" rel="noopener">demo示例</a></p><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><p>使用非常简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;koa-book-pro&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;server/index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;nodemon ./start.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;YeWills&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;koa&quot;: &quot;^2.4.1&quot;,</span><br><span class="line">    &quot;koa-bodyparser&quot;: &quot;^4.2.1&quot;,</span><br><span class="line">    &quot;koa-router&quot;: &quot;^7.4.0&quot;,</span><br><span class="line">    &quot;koa-static&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;koa2-cors&quot;: &quot;^2.0.6&quot;,</span><br><span class="line">    &quot;nodemon&quot;: &quot;^1.18.10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>package.json 同级目录下 配置 nodemon.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//nodemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;restartable&quot;: &quot;rs&quot;,</span><br><span class="line">  &quot;ignore&quot;: [</span><br><span class="line">    &quot;.git&quot;,</span><br><span class="line">    &quot;node_modules/**/node_modules&quot;,</span><br><span class="line">    &quot;README.md&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;verbose&quot;: true,</span><br><span class="line">  &quot;execMap&quot;: &#123;</span><br><span class="line">    &quot;js&quot;: &quot;node --harmony&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;watch&quot;: [</span><br><span class="line">    &quot;server/&quot;,</span><br><span class="line">    &quot;src/&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;ext&quot;: &quot;js json&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后用npm start 启动项目，files改变时，会自动npm start，非常好用。<br><a href="http://www.cnblogs.com/JuFoFu/p/5140302.html" target="_blank" rel="noopener">关于上面代码的解释</a><br>或自行查询GitHub官网</p><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><p>以上代码注意的是:<br>nodemon.json 中 js属性配置了 node –harmony 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;execMap&quot;: &#123;</span><br><span class="line">   &quot;js&quot;: &quot;node --harmony&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>那么请在 package.json中 start中，把node关键字去掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//正确配置</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;nodemon ./start.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//错误配置 ，配置了多余的node</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;nodemon node ./start.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="视频参考"><a href="#视频参考" class="headerlink" title="视频参考"></a>视频参考</h4><p><a href="https://www.imooc.com/video/20683" target="_blank" rel="noopener">nodemon介绍</a></p><h3 id="parcel"><a href="#parcel" class="headerlink" title="parcel"></a>parcel</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>parcel 一款非常好用的工具，你只是想写一个小页面，页面只有一个单纯的html，但你又想使用less写css；<br>有一天，你又想写一个小页面，需要用到一些交互，想使用react框架，当又不想配置webpack，又想用到less；<br>此时，parcel就是你的不二选择。<br>parcel最大的亮点之一就是 简单和自带热重载特性 ，就凭这两个，你值得拥有。</p><h4 id="想使用less又不想配置webpack"><a href="#想使用less又不想配置webpack" class="headerlink" title="想使用less又不想配置webpack"></a>想使用less又不想配置webpack</h4><p>参考上面</p><h4 id="无需webpack让你使用react、vue"><a href="#无需webpack让你使用react、vue" class="headerlink" title="无需webpack让你使用react、vue"></a>无需webpack让你使用react、vue</h4><p>参考上面</p><h4 id="简单简单简单"><a href="#简单简单简单" class="headerlink" title="简单简单简单"></a>简单简单简单</h4><p>重要的事情说三遍，parcel非常简单，非常适合小型项目，或者小型demo，或者自己的小demo<br>参考上面</p><h4 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h4><h4 id="build功能"><a href="#build功能" class="headerlink" title="build功能"></a>build功能</h4><p>parcel又build功能，build后生成的文件，可用于生产。</p><h4 id="demo／参考"><a href="#demo／参考" class="headerlink" title="demo／参考"></a>demo／参考</h4><p><a href="https://createapp.dev/parcel" target="_blank" rel="noopener">官方demo</a><br><a href="https://github.com/YeWills/parcel-demo" target="_blank" rel="noopener">demo</a><br><a href="https://github.com/parcel-bundler/parcel" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> nodemon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端笔记</title>
      <link href="/2019/05/21/font_end/"/>
      <url>/2019/05/21/font_end/</url>
      
        <content type="html"><![CDATA[<h2 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h2><h3 id="浏览器直接使用import-JavaScript-modules"><a href="#浏览器直接使用import-JavaScript-modules" class="headerlink" title="浏览器直接使用import (JavaScript modules)"></a>浏览器直接使用import (JavaScript modules)</h3><p>参考《d3图形、demo讲解、使用经验  –   走势图  – import module 的经典使用》</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>浏览器缓存分为强、协商缓存；<br>上面是根据页面如何利用缓存的态度来分的。<br>强缓存是指，只要浏览器有这个缓存，页面就直接拿来用，也不去问这个缓存是否最新或改变；<br>协商缓存是指，页面在用浏览器缓存时，会根据这个缓存的状态，决定是否使用这个缓存。<br><figure class="image-box">                <img src="/image/font_end/cache.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>解释如上</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>解释如上</p><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><ul><li>强缓存返回状态码是200，但不往服务器发请求；</li><li>协商缓存返回状态码是304，会给服务器发请求；</li><li>二者的区别也在这个图片上，协商缓存会有 last-modified，if-modified-since 等，强缓存则没有，可依此来判断是否强或协商。<figure class="image-box">                <img src="/image/font_end/cache.jpg" alt="" title="" class="">                <p></p>            </figure></li></ul><h3 id="安全类"><a href="#安全类" class="headerlink" title="安全类"></a>安全类</h3><h4 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h4><ul><li><p>原理<br>CSRF中文称之为 跨站请求伪造。<br>如下，用户登陆网站A后，获得cookie，<br>之后，用户再登陆网站B，B站引诱用户访问A网站，<br>由于这个访问接口与之前的cookie同域名，因此再次访问A网站时浏览器自动带上cookie，<br>从而访问成功，导致非法转账或者用户数据盗取等等。</p><figure class="image-box">                <img src="/image/font_end/csrf.jpg" alt="" title="" class="">                <p></p>            </figure></li><li><p>防御</p><ul><li>Token 验证：浏览器不会自动给接口带上token，因此后台如果做token验证，是可以避免csrf的。</li><li>Referer 验证：服务端会比对接口请求的referer(接口的页面来源)，如果不是我这个站点的referer，若不是就阻止。</li></ul></li><li><p>更多<br><a href="https://www.bilibili.com/video/BV1Dt411V7ao?p=1" target="_blank" rel="noopener">查看</a></p></li></ul><h4 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h4><ul><li>原理<br>想网站注入一些js脚本，输入的这些脚本在浏览器端运行，实现攻击，可获取cookie或者串改页面信息以及转账等等。<br>其特点主要是 利用浏览器端运行 注入的js脚本，因此其防御也与此有关。</li><li>防御<ul><li>对用户输入内容进行转义，对脚本语言进行识别过滤。</li><li>对cookie等敏感信息进行设置，比如设置cookie 通过js不可读。</li></ul></li><li>demo<br><a href="https://github.com/YeWills/learns/tree/master/node/xss" target="_blank" rel="noopener">小demo</a></li></ul><h2 id="http知识"><a href="#http知识" class="headerlink" title="http知识"></a>http知识</h2><h3 id="cookie-与-http"><a href="#cookie-与-http" class="headerlink" title="cookie 与 http"></a>cookie 与 http</h3><p>参考另外博客《http协议  - cookie》</p><h3 id="post与get区别"><a href="#post与get区别" class="headerlink" title="post与get区别"></a>post与get区别</h3><p>1.get在浏览器回退时是无害的，而post会再次提交请求；<br>2.get请求会被浏览器主动缓存，而post不会，除非手动设置；<br>3.get请求在url中传送的参数是有长度限制的，而post没有限制；<br>4.get请求参数会被完整保留在浏览器历史记录中，而post请求参数不会被保留；</p><p>其他一些明显区别，在此不列举 。</p><h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>2xx：成功 –表示请求已被成功接收；<br>3xx：重定向 –要完成请求必须进行更进一步的操作；<br>4xx：客户端错误 –请求有语法错误或请求无法实现；<br>5xx：服务器错误 –服务器未能实现合法请求；</p><h4 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h4><p>200 ok ： 成功；<br>206 ：客户发起一个带有range头的get请求，服务器完成了它；（通常用于视频分片段的请求）；<br>301／302 : 请求的页面已经转移到新的url，前者是永久重定向，后者302是临时重定向；<br>304 ： 服务器数据无变化，使用浏览器缓存；<br>401 ： 请求未经授权；<br>403 ： 禁止访问；<br>404 ： 请求资源不存在；<br>500／503 ： 服务器发生错误；</p><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><h4 id="token与Authorization关系"><a href="#token与Authorization关系" class="headerlink" title="token与Authorization关系"></a>token与Authorization关系</h4><p>Authorization是http的请求头，Authorization的值就是token。<br>可以说token是定义在http中的Authorization属性上的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">"http://localhost:3000/api/userInfo"</span>,</span><br><span class="line">    beforeSend: <span class="function"><span class="keyword">function</span>(<span class="params">xhr</span>) </span>&#123; </span><br><span class="line">                xhr.setRequestHeader(<span class="string">"Authorization"</span>, <span class="string">"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiaWF0IjoxNTk4Mzg5OTIyLCJleHAiOjE1OTgzOTM1MjJ9.-SgGux78wAT2N9cxNCFOReg9v3EO8XVoH8M_2FzynXU"</span>);  </span><br><span class="line">            &#125;,&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>token也成为令牌。</p><h4 id="jsonwebtoken生成token"><a href="#jsonwebtoken生成token" class="headerlink" title="jsonwebtoken生成token"></a>jsonwebtoken生成token</h4><p>参考下面的demo</p><h4 id="jwt进行token验证"><a href="#jwt进行token验证" class="headerlink" title="jwt进行token验证"></a>jwt进行token验证</h4><p>参考下面的demo</p><h4 id="jsonwebtoken-与-koa-jwt"><a href="#jsonwebtoken-与-koa-jwt" class="headerlink" title="jsonwebtoken 与 koa-jwt"></a>jsonwebtoken 与 koa-jwt</h4><p>参考另外一篇博客《koa2笔记 - jsonwebtoken 与 koa-jwt》</p><h4 id="postman进行token请求"><a href="#postman进行token请求" class="headerlink" title="postman进行token请求"></a>postman进行token请求</h4><p>参考博客《0到1快速构建自己的后台管理系统   – 登陆前端页面获取令牌》<br>《0到1快速构建自己的后台管理系统   – postman使用令牌请求》</p><h4 id="cmd进行token请求"><a href="#cmd进行token请求" class="headerlink" title="cmd进行token请求"></a>cmd进行token请求</h4><p>参考下面的demo</p><h4 id="html进行token请求"><a href="#html进行token请求" class="headerlink" title="html进行token请求"></a>html进行token请求</h4><p>参考下面的demo</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p><a href="https://github.com/YeWills/koa-demo/tree/router-Token" target="_blank" rel="noopener">demo</a></p><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><p><a href="https://www.jianshu.com/p/d3725391af59" target="_blank" rel="noopener">参考</a></p><h3 id="访问一个url经历了哪些"><a href="#访问一个url经历了哪些" class="headerlink" title="访问一个url经历了哪些"></a>访问一个url经历了哪些</h3><p><a href="https://blog.csdn.net/g291976422/article/details/88984859" target="_blank" rel="noopener">参考</a><br>客户端获取URL - &gt; DNS解析 - &gt; TCP连接 - &gt;发送HTTP请求 - &gt;服务器处理请求 - &gt;返回报文 - &gt;浏览器解析渲染页面 - &gt; TCP断开连接<br>tcp连接属于 传输层，只用于连接，不用于数据收发，<br>http连接属于 应用层，用于数据收发。</p><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p><a href="https://github.com/YeWills/learns/tree/master/node/websocket" target="_blank" rel="noopener">websocket的小demo</a></p><h2 id="js通信"><a href="#js通信" class="headerlink" title="js通信"></a>js通信</h2><h3 id="同源策略及限制"><a href="#同源策略及限制" class="headerlink" title="同源策略及限制"></a>同源策略及限制</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>同源策略是浏览器端做的安全策略。<br>包含以下特点：</p><h4 id="Cookie、LocalStaorage和indexDB无法读取；"><a href="#Cookie、LocalStaorage和indexDB无法读取；" class="headerlink" title="Cookie、LocalStaorage和indexDB无法读取；"></a>Cookie、LocalStaorage和indexDB无法读取；</h4><p>非同源下，无法读取非同源的以上缓存；</p><h4 id="DOM无法获取"><a href="#DOM无法获取" class="headerlink" title="DOM无法获取"></a>DOM无法获取</h4><h4 id="浏览器屏蔽非同源请求的消息（跨域）"><a href="#浏览器屏蔽非同源请求的消息（跨域）" class="headerlink" title="浏览器屏蔽非同源请求的消息（跨域）"></a>浏览器屏蔽非同源请求的消息（跨域）</h4><h3 id="前后端如何通信"><a href="#前后端如何通信" class="headerlink" title="前后端如何通信"></a>前后端如何通信</h3><h4 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h4><h4 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h4><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>cors是一个新的通信标准</p><h3 id="如何创建ajax"><a href="#如何创建ajax" class="headerlink" title="如何创建ajax"></a>如何创建ajax</h3><h4 id="xmlhttpRequest对象的工作流程"><a href="#xmlhttpRequest对象的工作流程" class="headerlink" title="xmlhttpRequest对象的工作流程"></a>xmlhttpRequest对象的工作流程</h4><h4 id="兼容处理-（ie）"><a href="#兼容处理-（ie）" class="headerlink" title="兼容处理 （ie）"></a>兼容处理 （ie）</h4><p>new XMLHttpRequest<br>new window.ActiveXObeject (ie 兼容)</p><h4 id="事件触发条件"><a href="#事件触发条件" class="headerlink" title="事件触发条件"></a>事件触发条件</h4><h4 id="事件的触发顺序"><a href="#事件的触发顺序" class="headerlink" title="事件的触发顺序"></a>事件的触发顺序</h4><h3 id="跨域通信的几种方式"><a href="#跨域通信的几种方式" class="headerlink" title="跨域通信的几种方式"></a>跨域通信的几种方式</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>在postMessage与CORS出现前，基本上都是通过jsonp来实现跨域；<br>jsonp的原理是利用script异步加载实现。<br>此方法需要后台配合。<br>实现方法：</p><ul><li><p>在script标签中定义一串url，并且使用callback作为关键字，告诉服务器前台已经定义了一个全局函数jsonpCunstomFnName来接收数据。<br>（callback、jsonpCunstomFnName 这些都可以随便定义，跟后台商量好就行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://www.google.com/?data=name&amp;callback=jsonpCunstomFnName&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>js代码定义全局函数jsonpCunstomFnName</p></li><li>服务器返回一段以下script字符，执行全局函数jsonpCunstomFnName,并且将请求返回数据作为参数；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    jsonpCunstomFnName(&#123;</span><br><span class="line">        data:[]</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><figure class="image-box">                <img src="/image/font_end/f-postm.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//利用hash，场景是当前页面A通过iframe嵌入来跨域的页面B</span><br><span class="line">//在A的代码如下</span><br><span class="line">var B = document.getElementsByTagName(&apos;iframe&apos;)</span><br><span class="line">B.src = B.src + &apos;#&apos; + &apos;data&apos;;</span><br><span class="line"></span><br><span class="line">//在B的代码如下</span><br><span class="line">window.onhashchange = function()&#123;</span><br><span class="line">    var data = window.location.hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="websocket-1"><a href="#websocket-1" class="headerlink" title="websocket"></a>websocket</h4><figure class="image-box">                <img src="/image/font_end/f-webs.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="CORS-1"><a href="#CORS-1" class="headerlink" title="CORS"></a>CORS</h4><p>cors通信必须配合fetch使用。<br>cors是变种的ajax，浏览器识别到是cors时，自定增加origin参数到请求头中，达到可跨域请求<br> <figure class="image-box">                <img src="/image/font_end/f-cors.jpg" alt="" title="" class="">                <p></p>            </figure></p><h2 id="页面优化"><a href="#页面优化" class="headerlink" title="页面优化"></a>页面优化</h2><h3 id="资源合并、压缩"><a href="#资源合并、压缩" class="headerlink" title="资源合并、压缩"></a>资源合并、压缩</h3><p>gzip压缩</p><h3 id="减少http请求"><a href="#减少http请求" class="headerlink" title="减少http请求"></a>减少http请求</h3><h3 id="利用浏览器缓存"><a href="#利用浏览器缓存" class="headerlink" title="利用浏览器缓存"></a>利用浏览器缓存</h3><p>参考《高效前端》P72<br>cache-control\last-modified\if-Modified-Since\etag\if-None-Match</p><h3 id="非核心代码异步加载"><a href="#非核心代码异步加载" class="headerlink" title="非核心代码异步加载"></a>非核心代码异步加载</h3><h4 id="异步加载的方式"><a href="#异步加载的方式" class="headerlink" title="异步加载的方式"></a>异步加载的方式</h4><p>动态脚本加载(用js创建script标签)，defer，async。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>defer是在html解析完后才执行，如果是多个，按顺序依次执行；<br><figure class="image-box">                <img src="/image/font_end/async.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/font_end/async-result.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>async使用方法与defer相同。<br>async是在html解析完后才执行，如果是多个，则同时执行多个文件；</p><h3 id="使用cdn"><a href="#使用cdn" class="headerlink" title="使用cdn"></a>使用cdn</h3><h3 id="预解析dns"><a href="#预解析dns" class="headerlink" title="预解析dns"></a>预解析dns</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//强制打开a标签的dns解析，一般a标签默认开启dns解析，但对于有些浏览器可能没有打开，此时加上这句话可开启。</span><br><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</span><br><span class="line">//开启页面预解析dns</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot;  href=&quot;//host_name_to_prefetch.com&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="把css写成内联"><a href="#把css写成内联" class="headerlink" title="把css写成内联"></a>把css写成内联</h3><p>css只有10或20k时，写成内联，谷歌和百度和淘宝pc版都是这样干的。<br>放在内联上，最大的好处是节省了一次cdn请求,从而加快页面响应。<br>注意只适合css不是非常大的情况。</p><h2 id="hybrid"><a href="#hybrid" class="headerlink" title="hybrid"></a>hybrid</h2><h3 id="为什么hybrid版本更新方便，更快捷"><a href="#为什么hybrid版本更新方便，更快捷" class="headerlink" title="为什么hybrid版本更新方便，更快捷"></a>为什么hybrid版本更新方便，更快捷</h3><p>因为hybrid使用的是js语言开发，相比原生开发使用的java语言，js语言无法操作设备的相机、横屏竖屏、语音、通讯录等等，而java是能操作这些的。所以每当版本更新时，java原生开发要进行代码审核安全验证，js的hybrid则不需要，所以版本更新更加便捷；</p><h3 id="页面无法直接向服务器发请求，需要原生层面中转"><a href="#页面无法直接向服务器发请求，需要原生层面中转" class="headerlink" title="页面无法直接向服务器发请求，需要原生层面中转"></a>页面无法直接向服务器发请求，需要原生层面中转</h3><p>hybrid的js页面的ajax需要调去原生提供的请求API，才能向后端发起请求，所以的ajax请求会经过原生转发</p><h3 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h3><ul><li>是app中的一个组件（app可以有webview，也可以没有）</li><li>用于加载h5页面，即一个小型的浏览器内核<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="需要了解的算法："><a href="#需要了解的算法：" class="headerlink" title="需要了解的算法："></a>需要了解的算法：</h3>还有兴趣的话，也学习下 冒泡排序：<figure class="image-box">                <img src="/image/font_end/f-calc1.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/font_end/f-calc2.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/font_end/f-calc3.jpg" alt="" title="" class="">                <p></p>            </figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="获取并使用字体图标"><a href="#获取并使用字体图标" class="headerlink" title="获取并使用字体图标"></a>获取并使用字体图标</h3><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">可以通过阿里的开源字体库</a>使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>http协议</title>
      <link href="/2019/05/21/http/"/>
      <url>/2019/05/21/http/</url>
      
        <content type="html"><![CDATA[<h2 id="html协议基础"><a href="#html协议基础" class="headerlink" title="html协议基础"></a>html协议基础</h2><h3 id="5层网络模型"><a href="#5层网络模型" class="headerlink" title="5层网络模型"></a>5层网络模型</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>如图，我们只需理解应用层与传输层的作用，其他三层，知道就行。<br><figure class="image-box">                <img src="/image/http/compose.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p><a href="https://www.jianshu.com/p/e1f33cc26aca" target="_blank" rel="noopener">参考</a></p><ul><li>向用户提供可靠的端到端（end-to-end）服务；</li><li>传输层向高层屏蔽了下层数据通信的细节（比如一个post请求，如何分片如何发送使服务端很好接收到，这个规则由传输层实现，应用层的HTTP不用关心这些，但是适当理解对HTTP更好地使用是很有帮助的）。</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul><li>为应用软件提供了很多服务；</li><li>帮我们实现了HTTP协议，我们只要按照规则去使用HTTP协议；</li><li>它构建于TCP协议之上；屏蔽了网络传输相关细节。</li></ul><h3 id="HTTP协议的发展历史"><a href="#HTTP协议的发展历史" class="headerlink" title="HTTP协议的发展历史"></a>HTTP协议的发展历史</h3><h4 id="http-0-9"><a href="#http-0-9" class="headerlink" title="http/0.9"></a>http/0.9</h4><ul><li>只有get</li><li>么有header等描述信息</li><li>服务器发送完毕，就关闭tcp连接<h4 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http/1.0"></a>http/1.0</h4></li><li>增加很多方式如 post put。。。</li><li>增加 status code 和 header</li><li>缓存、权限等<h4 id="http-1-1-（当前的http协议）"><a href="#http-1-1-（当前的http协议）" class="headerlink" title="http/1.1 （当前的http协议）"></a>http/1.1 （当前的http协议）</h4></li><li>持久连接</li><li>pipeline</li><li>增加host和其他命令<h4 id="http2-（还未普及）"><a href="#http2-（还未普及）" class="headerlink" title="http2 （还未普及）"></a>http2 （还未普及）</h4></li><li>所有数据以二进制传输</li><li>同一个连接里面发送多个请求不再需要按顺序来</li><li>头信息压缩以及后端主动推送等功能<br>关于头信息压缩：<br>在http1中，头信息如 Content-Type等，都是以字符串的形式保存，这些都比较占带宽；<br>在http2中，对头信息进行压缩，从而减少对带宽的占用。<br>关于 主动推送：<br>在http1中，向后台发送一个html请求，前台获得html后，经过浏览器解析，再次向后台发起css或js的请求；<br>http2中，向后台发起一个页面请求时，后台会将html和html内的css js 主动一次性推送给浏览器，提高性能。</li></ul><h3 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h3><p>如图，tcp三次握手，<strong>主要是解决客户端与服务端相隔很多远，通过光纤传输，容易出现延时和连接中断等问题</strong>；<br>第一次握手：客户端发消息给服务端，申请建立tcp连接；<br>第二次握手：客户端接收请求后，新建端口，用于tcp连接，并且向客户端发消息，验证客户端是否能正常接收来自客户端的消息；<br>第三次握手：客户端向服务端发消息说，我能正常接收到你那边发来的消息，你就放心的建立tcp连接吧。服务端接收到此消息后，建立tcp连接成功。</p><p>进一步解释下：<br>第一次握手，验证服务端能正常接收到客户端消息；<br>第二次握手，验证客服端能正常接收到服务端消息；<br>一来一往，两边都能接收到双方消息；<br>第三次握手，直接与服务端建立tcp连接。<br><figure class="image-box">                <img src="/image/http/tcp.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="uri-url-urn"><a href="#uri-url-urn" class="headerlink" title="uri url urn"></a>uri url urn</h3><p>uri 包含 url 和 urn；uri与url一样用来定位资源地址。</p><h3 id="url上的哈希值-起到锚点作用"><a href="#url上的哈希值-起到锚点作用" class="headerlink" title="url上的哈希值 起到锚点作用"></a>url上的哈希值 起到锚点作用</h3><p><code>#</code>号后的哈希值，用来给前端渲染用，起到一个锚点作用，比如在mokedown文档博客总，通过#跳转到某个章节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:4000/2019/05/21/koa2#chapter1</span><br></pre></td></tr></table></figure></p><h3 id="http-报文"><a href="#http-报文" class="headerlink" title="http 报文"></a>http 报文</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><figure class="image-box">                <img src="/image/http/header.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="首行／起始行"><a href="#首行／起始行" class="headerlink" title="首行／起始行"></a>首行／起始行</h4><p>首行里面是一些请求头以外的信息，上图中，请求的首行上定义了http的版本，method；<br>响应头包含了状态码等消息。<br>首行也是下面的矩形框内的 General<br><figure class="image-box">                <img src="/image/http/httpline.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="请求header／响应header"><a href="#请求header／响应header" class="headerlink" title="请求header／响应header"></a>请求header／响应header</h4><p>参考上图</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="认识跨域"><a href="#认识跨域" class="headerlink" title="认识跨域"></a>认识跨域</h4><p>跨域纯属浏览器端做的限制，请求是否跨域不影响浏览器是否将其发送到后台，浏览器都会将请求发送到后台，无论跨域与否。<br>服务器，无论跨域与否，都会正常将响应数据发送给浏览器。<br>浏览器接收到服务器的响应数据时，不同的是，浏览器对于跨域请求，<br>会读取响应数据的参数 <code>Access-Control-Allow-Origin</code>;<br>如果没有此参数，或此参数不允许客户端页面的host，那么浏览器将不会将响应的数据显示出来，并且抛异常不允许跨域。</p><h4 id="浏览器并非不发送跨域请求"><a href="#浏览器并非不发送跨域请求" class="headerlink" title="浏览器并非不发送跨域请求"></a>浏览器并非不发送跨域请求</h4><p>参考上面《认识跨域》</p><h4 id="跨域是浏览器做的限制"><a href="#跨域是浏览器做的限制" class="headerlink" title="跨域是浏览器做的限制"></a>跨域是浏览器做的限制</h4><p>跨域只是浏览器做的限制，其他客户端都不做跨域限制，比如git bash上运行 curl，服务器端给服务器发请求等等，都不会屏蔽跨域数据。</p><h4 id="跨域是浏览器根据Access-Control-Allow-xxx做的限制"><a href="#跨域是浏览器根据Access-Control-Allow-xxx做的限制" class="headerlink" title="跨域是浏览器根据Access-Control-Allow-xxx做的限制"></a>跨域是浏览器根据Access-Control-Allow-xxx做的限制</h4><p>跨域与否，几乎只于 与后台设置的Access-Control-Allow-xxx值有关，浏览器只是根据 Access-Control-Allow-xxx的值，决定是否屏蔽响应消息，限制跨域。<br>Access-Control-Allow-xxx可以是以下值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin</span><br><span class="line">Access-Control-Allow-Headers</span><br><span class="line">Access-Control-Allow-Methods</span><br><span class="line">Access-Control-Max-Age //多长时间内，不需要再发预请求进行验证</span><br></pre></td></tr></table></figure></p><p>下面以 Access-Control-Allow-Origin讲解。</p><h4 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h4><p>看请求是否跨域，主要是看后台的响应头否设置了 Access-Control-Allow-Origin；<br>Access-Control-Allow-Origin的值可以为 *,这样的话，任何域名下发的请求，响应数据都会允许获取到，是有一定危险的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;</span><br></pre></td></tr></table></figure></p><p>所以更可行的方法是设置一个具体值，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//允许host为http://127.0.0.1:8888的请求显示数据</span><br><span class="line">&apos;Access-Control-Allow-Origin&apos;: &apos;http://127.0.0.1:8888&apos;</span><br></pre></td></tr></table></figure></p><p>如果要允许多个host，可以设置多个值，这些都是很好做的。</p><p>Access-Control-Allow-xxx都可以在浏览器的响应头中看到：<br><figure class="image-box">                <img src="/image/http/cor0.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="跨域解决方式"><a href="#跨域解决方式" class="headerlink" title="跨域解决方式"></a>跨域解决方式</h4><ul><li>设置 Access-Control-Allow-Origin；</li><li>jsonp</li><li>通过服务器转发请求</li></ul><h4 id="其他跨域解决方法"><a href="#其他跨域解决方法" class="headerlink" title="其他跨域解决方法"></a>其他跨域解决方法</h4><p>跨域时，除了要放开Access-Control-Allow-Origin，有时候，还会限制你的请求方法，请求头的设置，这个时候，<br>在后台就需要设置如下，进行approve：<br><figure class="image-box">                <img src="/image/http/cor5.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="CORS预请求"><a href="#CORS预请求" class="headerlink" title="CORS预请求"></a>CORS预请求</h4><p>在跨域请求时，还有一些其他限制，CORS预请求就是当中的一种:<br>跨域请求中，不需要预请求的方法：</p><ul><li>GET </li><li>HEAD</li><li>POST<br>跨域请求中，不需要预请求的content-Type：</li><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded<br>除了上述请求方法或content-type，当跨域时，浏览器都要进行预请求，<br>比如DELETE PUT 请求，<br>除以上设置外，如果你自定义header头，也会要求进行预请求，还有一些其他的预请求的限制，可以网上查阅。<br>下面展示一下预请求<h4 id="CORS预请求-与-OPTIONS-method"><a href="#CORS预请求-与-OPTIONS-method" class="headerlink" title="CORS预请求 与 OPTIONS method"></a>CORS预请求 与 OPTIONS method</h4>cors预请求是通过OPTIONS method请求实现，在发送实际请求前，发一次OPTIONS method请求。</li><li><p>这是正常的post 跨域请求，不需要cors预请求</p><figure class="image-box">                <img src="/image/http/cor1.jpg" alt="" title="" class="">                <p></p>            </figure></li><li><p>这是put 跨域请求，需要cors预请求<br>因此首先发一个method OPTIONS的请求，向服务器询问是否允许获取数据。<br>如果允许，则再发实际的put请求。</p><figure class="image-box">                <img src="/image/http/cor2.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/http/cor3.jpg" alt="" title="" class="">                <p></p>            </figure></li><li><p>默认在一定时间内，再次发起跨域请求，不需再次发送options请求进行cors预请求<br>当上面请求正常后，立刻再次发起同样的put请求，浏览器不会再次重复需要进行预请求，当然这个时间是可以在服务器上配置的。<br>通过下面可以设置，如果不设置，就使用默认时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age : 1000, //多长时间内，不需要再发预请求进行验证</span><br></pre></td></tr></table></figure></li></ul><figure class="image-box">                <img src="/image/http/cor4.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="CORS预请求-只-与-跨域有关"><a href="#CORS预请求-只-与-跨域有关" class="headerlink" title="CORS预请求 只 与 跨域有关"></a>CORS预请求 只 与 跨域有关</h4><p>参考上面的讲解。</p><h3 id="CORS预请求-1"><a href="#CORS预请求-1" class="headerlink" title="CORS预请求"></a>CORS预请求</h3><p>参考《跨域 — CORS预请求》</p><h3 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h3><p>Cache-control是服务端设置，告诉浏览器资源的缓存方式,可取的值：</p><ul><li>public 允许包含<strong>代理</strong>客户端的所有客户端进行缓存</li><li>private 只允许发起请求的客户端进行缓存</li><li>no-cache 允许客户端(使用)缓存资源，但需要到服务器上去验证</li><li>no-store 不允许客户端缓存<br>其他指：</li><li>max-age 缓存过期时间<br>在<strong>koa 服务端</strong>设置如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(&apos;Cache-control&apos;, &apos;max-age=200, public&apos;); //可以一次设置多个值</span><br><span class="line">  ctx.set(&apos;Content-Type&apos;, &apos;text/javascript&apos;);</span><br><span class="line">  ctx.set(&apos;Access-Control-Allow-Headers&apos;, &apos;Origin, X-Requested-With, Content-Type, Accept&apos;);</span><br><span class="line">  await next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="浏览器读取缓存的过程"><a href="#浏览器读取缓存的过程" class="headerlink" title="浏览器读取缓存的过程"></a>浏览器读取缓存的过程</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>浏览器发起请求，首先读取本地缓存，然后读取代理缓存，如果都没有命中，就从服务器获取资源。<br><figure class="image-box">                <img src="/image/http/cache1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="注意，有个代理缓存"><a href="#注意，有个代理缓存" class="headerlink" title="注意，有个代理缓存"></a>注意，有个代理缓存</h4><p>参考上图。</p><h3 id="缓存验证-Last-Modified和Etag的使用"><a href="#缓存验证-Last-Modified和Etag的使用" class="headerlink" title="缓存验证 - Last-Modified和Etag的使用"></a>缓存验证 - Last-Modified和Etag的使用</h3><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>上次修改时间，配合 if-modified-since或if-unmodified-since使用</p><h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4><p>数据签名，比Last-Modified更为严格的一种验证方式；<br>配合if-match或if-non-match使用；</p><h4 id="后端配置（koa）"><a href="#后端配置（koa）" class="headerlink" title="后端配置（koa）"></a>后端配置（koa）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//If-Modified-Since: 对应  Last-Modified值</span><br><span class="line">//If-None-Match:  对应  etag值</span><br><span class="line"> const etag = ctx.headers[&apos;if-none-match&apos;]</span><br><span class="line">    if (etag === &apos;777&apos;) &#123;</span><br><span class="line">      ctx.status=304;</span><br><span class="line">      ctx.set(&#123;</span><br><span class="line">        //缓存有效时间为2000000，允许缓存，但需要验证</span><br><span class="line">        &apos;Cache-Control&apos;: &apos;max-age=2000000, no-cache&apos;,</span><br><span class="line">        &apos;Last-Modified&apos;: &apos;123&apos;,</span><br><span class="line">        &apos;Etag&apos;: &apos;777&apos;</span><br><span class="line">      &#125;);</span><br><span class="line">      //因为定义了 304，此时就不用给前台返回数据，前台会取缓存数据。</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ctx.status=200;</span><br><span class="line">      ctx.set(&#123;</span><br><span class="line">        &apos;Cache-Control&apos;: &apos;max-age=2000000, no-cache&apos;,</span><br><span class="line">        &apos;Last-Modified&apos;: &apos;123&apos;,</span><br><span class="line">        &apos;Etag&apos;: &apos;777&apos;</span><br><span class="line">      &#125;);</span><br><span class="line">      ctx.body = &#123;abc: &apos;good boy&apos;&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="浏览器表现行为"><a href="#浏览器表现行为" class="headerlink" title="浏览器表现行为"></a>浏览器表现行为</h4><p>浏览器第一次请求时，没有缓存，状态吗为200，此时的请求头上是没有etag等信息的：<br><figure class="image-box">                <img src="/image/http/cache2.jpg" alt="" title="" class="">                <p></p>            </figure><br>浏览器第一次请求完后，第二次发起请求，前台不用做任何设置，浏览器会自动将第一次请求返回给前台的 etag、Last-Modified等相关验证缓存的参数，发送给后台，后台对比验证后，通知前台使用缓存304.<br><figure class="image-box">                <img src="/image/http/cache3.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="If-Modified-Since-对应-Last-Modified"><a href="#If-Modified-Since-对应-Last-Modified" class="headerlink" title="If-Modified-Since 对应 Last-Modified"></a>If-Modified-Since 对应 Last-Modified</h4><p>当后台返回前台的响应头包含 Last-Modified时，浏览器下次请求时，请求头将包含Last-Modified信息，而这个信息换成If-Modified-Since来表示。<br>同理If-None-Match:  对应  etag值</p><h4 id="If-None-Match-对应-etag"><a href="#If-None-Match-对应-etag" class="headerlink" title="If-None-Match 对应 etag"></a>If-None-Match 对应 etag</h4><p>参考《If-Modified-Since 对应 Last-Modified》</p><h4 id="浏览器会自动将etag等发给后台"><a href="#浏览器会自动将etag等发给后台" class="headerlink" title="浏览器会自动将etag等发给后台"></a>浏览器会自动将etag等发给后台</h4><p>浏览器自动将etag等自动传给后台，不需要前台做任何设置，这是浏览器的http协议机制决定的。</p><h4 id="勾选控制台Disable-cache"><a href="#勾选控制台Disable-cache" class="headerlink" title="勾选控制台Disable cache"></a>勾选控制台Disable cache</h4><p>勾选浏览器控制台Disable cache时，浏览器将不会把etag等缓存验证相关的参数传给后台，因为不需要缓存了。</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>通过set-cookie设置</li><li>下次请求会自动带上</li><li>键值对，可以设置多个</li><li>默认关闭浏览器失效</li><li>可通过设置cookie的有效期，让浏览器关闭后，cookie仍然有效</li></ul><figure class="image-box">                <img src="/image/http/setcookie1.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="cookie概述"><a href="#cookie概述" class="headerlink" title="cookie概述"></a>cookie概述</h4><p>cookie是后台传给前台，前台再利用浏览器的cookie可以随http发回给后台的特性，对发回对cookie进行验证。</p><ul><li>第一次向后台发起请求后，后台返回的响应头（response headers）包含了给浏览器设置cookie对功能（set-cookie）<figure class="image-box">                <img src="/image/font_end/cookie.jpg" alt="" title="" class="">                <p></p>            </figure></li><li>浏览器拿到cookie后，cookie有个特性，同域名下的cookie在发起请求时，都会发回给后台</li><li>后台通过比对session的cookie，进行超时、登陆等校验</li></ul><p>补充一点cookie知识：<br>如下图 Expires／max-age 的值为 N／A是session永久有效的意思，另外一个每个cookie对应一个域名。<br><figure class="image-box">                <img src="/image/font_end/cookie1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="关于cookie设置"><a href="#关于cookie设置" class="headerlink" title="关于cookie设置"></a>关于cookie设置</h4><p>前后端都可以设置cookie，一次设置好，下次发请求，同域名下，cookie自动带上。</p><h4 id="cookie与localStorage区别"><a href="#cookie与localStorage区别" class="headerlink" title="cookie与localStorage区别"></a>cookie与localStorage区别</h4><p>cookie 主要给后端服务器用的，用于用户的验证，因为一旦后端服务器设置了cookie，比如在登陆成功后，设置好cookie，那么同域名下，再次发起请求时，cookie会自动带上，后台可以凭借这个cookie进行认证。<br>localStorage主要给前端使用。</p><h4 id="cookie实现验证的原理"><a href="#cookie实现验证的原理" class="headerlink" title="cookie实现验证的原理"></a>cookie实现验证的原理</h4><p>参考上面《cookie与localStorage区别》</p><h4 id="koa端设置cookie"><a href="#koa端设置cookie" class="headerlink" title="koa端设置cookie"></a>koa端设置cookie</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if(ctx.url === &apos;/getData&apos;)&#123;</span><br><span class="line">    ctx.cookies.set(&apos;abc1111&apos;,  &apos;123111&apos;)</span><br><span class="line">    ctx.cookies.set(</span><br><span class="line">      &apos;cid&apos;, </span><br><span class="line">      &apos;hello world1111&apos;,</span><br><span class="line">      &#123;</span><br><span class="line">        domain: &apos;127.0.0.1&apos;,  // 写cookie所在的域名</span><br><span class="line">        maxAge: 80000, // cookie有效时长</span><br><span class="line">        httpOnly: false,  // 是否只用于http请求中获取</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">      ctx.set(&#123;</span><br><span class="line">        &apos;Cache-Control&apos;: &apos;max-age=2000000, no-cache&apos;,</span><br><span class="line">      &#125;);</span><br><span class="line">      ctx.body = &#123;abc: &apos;good boy&apos;&#125;;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="httpOnly-与-document-cookie"><a href="#httpOnly-与-document-cookie" class="headerlink" title="httpOnly 与 document.cookie"></a>httpOnly 与 document.cookie</h4><p>设置 httpOnly 为true时， 将无法通过document.cookie获取到该cookie。</p><h4 id="控制台的Application"><a href="#控制台的Application" class="headerlink" title="控制台的Application"></a>控制台的Application</h4><p>cookie可在控制台的 Application上查看，如果设置了cookie的maxAge，有效期过后，Application上将查不到此cookie。<br><figure class="image-box">                <img src="/image/http/setcookie2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>这里是一个前后端一体的cookie demo，既实现了前端 又实现了后端 设置cookie。<br><a href="https://github.com/YeWills/learns/tree/master/node/cookie" target="_blank" rel="noopener">demo</a></p><h3 id="connect与HTTP长连接"><a href="#connect与HTTP长连接" class="headerlink" title="connect与HTTP长连接"></a>connect与HTTP长连接</h3><h4 id="长连接的意义"><a href="#长连接的意义" class="headerlink" title="长连接的意义"></a>长连接的意义</h4><p>http请求是建立在tcp连接上的，一个tcp连接可发多个http连接；<br>如果每个http请求都要创建一个tcp连接，就相当影响性能，所以需要长连接，让多个http请求共用一个tcp连接。</p><h4 id="后台设置长链接"><a href="#后台设置长链接" class="headerlink" title="后台设置长链接"></a>后台设置长链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.writeHead(200, &#123;</span><br><span class="line">     &apos;Content-Type&apos;: &apos;image/jpg&apos;,</span><br><span class="line">     &apos;Connection&apos;: &apos;keep-alive&apos; // or close</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><h4 id="控制台查看connect-id"><a href="#控制台查看connect-id" class="headerlink" title="控制台查看connect-id"></a>控制台查看connect-id</h4><p>一个tcp连接会产生一个对应的connect-id作为标识。可通过connectid来看建立了多少个tcp连接。<br><figure class="image-box">                <img src="/image/http/setcookie2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h4 id="不同域名下的请求，connect-id不一样"><a href="#不同域名下的请求，connect-id不一样" class="headerlink" title="不同域名下的请求，connect-id不一样"></a>不同域名下的请求，connect-id不一样</h4><p>在谷歌浏览器用的是http2，一个页面只有一个tcp连接，都是长链接，所以只有一个connectid，不过不同域名的资源需要再建一个tcp连接。</p><h4 id="http1-1-tcp最大http请求数为6"><a href="#http1-1-tcp最大http请求数为6" class="headerlink" title="http1.1 tcp最大http请求数为6"></a>http1.1 tcp最大http请求数为6</h4><h3 id="Content-Type-数据协商"><a href="#Content-Type-数据协商" class="headerlink" title="Content-Type (数据协商)"></a>Content-Type (数据协商)</h3><h4 id="请求头的Content-Type"><a href="#请求头的Content-Type" class="headerlink" title="请求头的Content-Type"></a>请求头的Content-Type</h4><p>这里说都是 请求头上都 Content-Type，这个的作用主要是告诉服务器，请求参数要以什么的形式进行解析；<br>比如，一个包含图片等信息的form表单提交的时候，如果不设置Content-Type，服务器就无法正确解析form表单中的图片信息；<br>此时应该设置Content-Type:multipart/form-data，让服务器用流的来解析请求参数。</p><h4 id="响应头的Content-Type"><a href="#响应头的Content-Type" class="headerlink" title="响应头的Content-Type"></a>响应头的Content-Type</h4><p>响应头的Content-Type，告诉前台数据类型，让前台按正确的方式解析响应数据。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>所以Content-Type其实就是前后台用来进行协商如何进行数据转换的。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>重定向一般用于一个url地址已经被废弃，但为了兼容，需要将废弃地址重定向到新的url中。<br>所以它需要在服务端设置响应码为302，这样，浏览器的http机制就会记住，下次发同样请求时，就自动跳转到重定向的url地址。</p><h4 id="需要服务端设置302"><a href="#需要服务端设置302" class="headerlink" title="需要服务端设置302"></a>需要服务端设置302</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (request.url === &apos;/&apos;) &#123;</span><br><span class="line">    response.writeHead(302, &#123;  // or 301</span><br><span class="line">      &apos;Location&apos;: &apos;/new&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="302-与-301"><a href="#302-与-301" class="headerlink" title="302 与 301"></a>302 与 301</h4><p>302是临时重定向；<br>301是永久重定向；</p><h3 id="资源获取策略-Content-Security-Policy"><a href="#资源获取策略-Content-Security-Policy" class="headerlink" title="资源获取策略 Content-Security-Policy"></a>资源获取策略 Content-Security-Policy</h3><p>服务端设置Content-Security-Policy，限制接口数据获取的方式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response.writeHead(200, &#123;</span><br><span class="line">     &apos;Content-Type&apos;: &apos;text/html&apos;,</span><br><span class="line">     //限制浏览器只能通过https来发起请求</span><br><span class="line">     &apos;Content-Security-Policy&apos;: &apos;script-src https&apos;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></p><p>前台接到服务器的返回后，读取Content-Security-Policy值，如果浏览器是通过非https发起的请求，那么改响应数据将不被显示，并且抛错提示资源获取策略异常</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p><a href="https://coding.imooc.com/class/chapter/225.html#Anchor" target="_blank" rel="noopener">参考4-3</a><br>https主要通过公钥和私钥实现。<br><figure class="image-box">                <img src="/image/http/https.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="输入一个url后发生了什么"><a href="#输入一个url后发生了什么" class="headerlink" title="输入一个url后发生了什么"></a>输入一个url后发生了什么</h3><figure class="image-box">                <img src="/image/http/page.jpg" alt="" title="" class="">                <p></p>            </figure> ]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> http协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js笔记</title>
      <link href="/2019/05/21/js/"/>
      <url>/2019/05/21/js/</url>
      
        <content type="html"><![CDATA[<h2 id="js-常用知识"><a href="#js-常用知识" class="headerlink" title="js 常用知识"></a>js 常用知识</h2><h3 id="自运行函数"><a href="#自运行函数" class="headerlink" title="自运行函数"></a>自运行函数</h3><h4 id="自运行函数的17种写法"><a href="#自运行函数的17种写法" class="headerlink" title="自运行函数的17种写法"></a>自运行函数的17种写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125;() );</span><br><span class="line">( function() &#123;&#125; )();</span><br><span class="line">[ function() &#123;&#125;() ];</span><br><span class="line"></span><br><span class="line">~ function() &#123;&#125;();</span><br><span class="line">! function() &#123;&#125;();</span><br><span class="line">+ function() &#123;&#125;();</span><br><span class="line">- function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">delete function() &#123;&#125;();</span><br><span class="line">typeof function() &#123;&#125;();</span><br><span class="line">void function() &#123;&#125;();</span><br><span class="line">new function() &#123;&#125;();</span><br><span class="line">new function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f = function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">1, function() &#123;&#125;();</span><br><span class="line">1 ^ function() &#123;&#125;();</span><br><span class="line">1 &gt; function() &#123;&#125;();</span><br><span class="line"></span><br><span class="line">;( function() &#123;&#125;() );</span><br></pre></td></tr></table></figure><h4 id="函数表达式-和-函数声明"><a href="#函数表达式-和-函数声明" class="headerlink" title="函数表达式 和 函数声明"></a>函数表达式 和 函数声明</h4><p>要弄懂自运行函数的原理，需弄懂函数表达式 和 函数声明概念；<br>函数声明，也叫函数定义；<br><a href="https://www.cnblogs.com/lenther2002/p/5894964.html" target="_blank" rel="noopener">参考</a><br>Javascript中有2个语法都与function关键字有关，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数声明：function FunctionName(FormalParameterList) &#123; FunctionBody &#125;</span><br><span class="line">函数表达式：function [FunctionName](FormalParameterList) &#123; FunctionBody &#125;</span><br></pre></td></tr></table></figure></p><p>从语法的定义上看，这两者几乎是一模一样的（唯一的区别是函数表达式可以省略函数名称），那么就解释器而言，当遇到这个结构的语句时，判定为函数表达式还是函数定义呢？<br>就javascript的语法而言，如果一条语句是以function关键字开始，那么这段会被判定为函数定义(声明)；<br>如果不是以function关键字开始，那么就是函数表达式；</p><p><strong>为什么要分清 函数表达式和函数声明呢?</strong><br>因为<a href="https://www.zhihu.com/question/20249179" target="_blank" rel="noopener">函数表达式是不能拿来直接用的</a>，必须在<strong>左侧</strong>有字符或表达式与这个函数表达式共同构成一句可执行的函数语句；<br>（之所以在左侧，不是右侧，是因为在不要行函数语句以关键字function开始，避免被识别为函数声明，导致报错）<br>函数声明是可以拿过来直接用；<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;&#125;</span><br><span class="line">fn()//不报错；</span><br><span class="line">function ()&#123;&#125;() //报错</span><br><span class="line">-function ()&#123;console.log(5)&#125;() //不报错 因为在funtion左侧有表达式-</span><br></pre></td></tr></table></figure></p><h4 id="16种含函数表达式的不报错的函数语句"><a href="#16种含函数表达式的不报错的函数语句" class="headerlink" title="16种含函数表达式的不报错的函数语句"></a>16种含函数表达式的不报错的函数语句</h4><p>结合上节的知识，将《自运行函数的17种写法》整理下，以下17种包含了函数表达式的函数语句不报错,注意的是，<br>以下函数表达式内的函数体都将不会执行，至于如何执行，下面会讲。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125; );</span><br><span class="line">( function() &#123;&#125; );</span><br><span class="line">[ function() &#123;&#125; ];</span><br><span class="line"></span><br><span class="line">~ function() &#123;&#125;;</span><br><span class="line">! function() &#123;&#125;;</span><br><span class="line">+ function() &#123;&#125;;</span><br><span class="line">- function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">delete function() &#123;&#125;;</span><br><span class="line">typeof function() &#123;&#125;;</span><br><span class="line">void function() &#123;&#125;;</span><br><span class="line">new function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">1, function() &#123;&#125;;</span><br><span class="line">1 ^ function() &#123;&#125;;</span><br><span class="line">1 &gt; function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">;( function() &#123;&#125; );</span><br></pre></td></tr></table></figure><h4 id="是否以function开始对js解释器很重要"><a href="#是否以function开始对js解释器很重要" class="headerlink" title="是否以function开始对js解释器很重要"></a>是否以function开始对js解释器很重要</h4><p><a href="https://www.zhihu.com/question/20249179" target="_blank" rel="noopener">参考</a><br>以下两种报错形式的原因分析：</p><ul><li>function (){ }()<br>期望是立即调用一个匿名函数表达式，结果是进行了函数声明，函数声明必须要有标识符做为函数名称。</li><li>function g(){ }()<br>期望是立即调用一个具名函数表达式，结果是声明了函数 g。末尾的括号作为分组运算符，<strong>必须要提供表达式做为参数</strong>，这个表达式可以是一个值或一个语句，例如改成下面的就不会报错：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function g()&#123; &#125;(1) //不报错，因为末尾的小括号有值作为表达式</span><br><span class="line">function g()&#123; &#125;(1,2) //不报错</span><br></pre></td></tr></table></figure></li></ul><p>以上说明了，是否以function开始对js解释器很重要;<br>如果以function开始，js解释器会认为它是一个函数声明，此时就要符合函数声明的标准，否则报错；<br>如果function左侧还有表达式，js解释器会认为它是一个函数表达式，此时该函数表达式配合左右两侧的表达式就构成了一个函数语句,要符合函数语句标准；<br>（例如 var a = function(){} 这就是一条函数语句）</p><h4 id="1种立即执行的函数声明形式"><a href="#1种立即执行的函数声明形式" class="headerlink" title="1种立即执行的函数声明形式"></a>1种立即执行的函数声明形式</h4><p>目前知道的，可以让函数声明内的函数体立即执行的只有这种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function g(a)&#123;console.log(a) &#125;(1) //不报错</span><br></pre></td></tr></table></figure></p><p>注意，末尾小括号一定要有 表达式，原因查看《是否以function开始对js解释器很重要》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function g(a)&#123;console.log(a) &#125;() //报错</span><br></pre></td></tr></table></figure></p><h4 id="如何让函数表达式、声明内的函数体立即执行"><a href="#如何让函数表达式、声明内的函数体立即执行" class="headerlink" title="如何让函数表达式、声明内的函数体立即执行"></a>如何让函数表达式、声明内的函数体立即执行</h4><p>如何让 函数表达式和函数声明 内的函数体立即执行呢；<br><strong>只能</strong>通过小括号();<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;console.log(&apos;work&apos;)&#125; //不打印</span><br><span class="line">var a = function()&#123;console.log(&apos;work&apos;)&#125;() //打印work</span><br></pre></td></tr></table></figure></p><p>因此可以认为()是一个让立即执行的运算符，可以让函数表达式或函数声明内的函数体立即执行；</p><h4 id="函数表达式、声明-与-立即执行-关系"><a href="#函数表达式、声明-与-立即执行-关系" class="headerlink" title="函数表达式、声明 与 立即执行 关系"></a>函数表达式、声明 与 立即执行 关系</h4><p>参看上面的《如何让函数表达式、声明内的函数体立即执行》</p><h4 id="与-立即执行"><a href="#与-立即执行" class="headerlink" title="() 与 立即执行"></a>() 与 立即执行</h4><p>参看上面的《如何让函数表达式、声明内的函数体立即执行》</p><h4 id="放在哪些位置可以让函数体立即执行"><a href="#放在哪些位置可以让函数体立即执行" class="headerlink" title="()放在哪些位置可以让函数体立即执行"></a>()放在哪些位置可以让函数体立即执行</h4><p>一般而言，() 紧跟在 function(){} 的花括号后面的位置，通过这样的方式让函数表达式或函数声明 内的函数体立刻执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = function()&#123;console.log(&apos;work&apos;)&#125;()</span><br><span class="line">~ function() &#123;&#125;()</span><br><span class="line">( function() &#123;&#125;() )</span><br><span class="line">function fn(t)&#123;console.log(t)&#125;(&apos;work&apos;)</span><br></pre></td></tr></table></figure></p><p>不过有个例外，请看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125;() ); //可以立即执行函数体</span><br><span class="line">( function() &#123;&#125; )(); //()放在了左侧(  )的右侧，不过也可以立即执行函数体</span><br></pre></td></tr></table></figure></p><p>()紧跟在中括号后就不行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ function() &#123;&#125;()]; //不报错，这个函数语句其实就是一个数组</span><br><span class="line">[ function() &#123;&#125;](); //报错，因为[]是一个数组，数组不是方法，类似这种写法，都错：[]()</span><br></pre></td></tr></table></figure></p><p><strong>小结，从目前看，小括号一般紧跟如上的花括号，也可跟在如上的 (  )后面。</strong>现在再回过头，看这《自运行函数的17种写法》应该就明白了吧</p><h4 id="与-函数传参"><a href="#与-函数传参" class="headerlink" title="() 与 函数传参"></a>() 与 函数传参</h4><p>这个简单，不多介绍，一般自运行传参的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( function(a) &#123;console.log(a)&#125; )(888) //888</span><br></pre></td></tr></table></figure></p><p>注意的是，将()写在里面也是可以传参的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( function(a) &#123;console.log(a)&#125;(888) ) //888</span><br></pre></td></tr></table></figure></p><h4 id="分号-与-立即执行"><a href="#分号-与-立即执行" class="headerlink" title="分号 ; 与 立即执行"></a>分号 ; 与 立即执行</h4><p>有些人喜欢用分号;来配合函数表达式写一个自运行，;分号本来是用来给函数语句断句的；<br>所以用这个的好处就是自带断句功能，避免不必要的错误；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//会报错</span><br><span class="line">var f = function() &#123;&#125;;</span><br><span class="line">f()</span><br><span class="line">( function() &#123;&#125; )();</span><br></pre></td></tr></table></figure></p><p>加分号;后不报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//会报错</span><br><span class="line">var f = function() &#123;&#125;;</span><br><span class="line">f()</span><br><span class="line">;( function() &#123;&#125; )();</span><br></pre></td></tr></table></figure></p><h4 id="，-，！比（-）立即执行方式少一个字符"><a href="#，-，！比（-）立即执行方式少一个字符" class="headerlink" title="+，-，！比（ ）立即执行方式少一个字符"></a>+，-，！比（ ）立即执行方式少一个字符</h4><p>通过+，-，！这三个符号运行的匿名函数比（）运行的匿名函数可以减少一个字符的使用<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( function() &#123;&#125; );</span><br><span class="line">~ function() &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>不过这不影响使用(  )还是+，-，！ 配合使用函数表达式，这里只是提取这个现象出来。</p><h4 id="难点立即执行的demo分析"><a href="#难点立即执行的demo分析" class="headerlink" title="难点立即执行的demo分析"></a>难点立即执行的demo分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new(function P()&#123;console.log(1)&#125;)()</span><br></pre></td></tr></table></figure><p>以上相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new (function P()&#123;console.log(1)&#125;)()</span><br></pre></td></tr></table></figure></p><p>左侧是new表达式，右侧是一个立即执行的函数；<br>右侧立即执行的函数其实就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function P()&#123;console.log(1)&#125;</span><br><span class="line">P()</span><br></pre></td></tr></table></figure></p><p>所以以上相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function P()&#123;console.log(1)&#125;</span><br><span class="line">new P()</span><br></pre></td></tr></table></figure></p><p>问题：为什么new(function() {})()，new可以与()紧挨着，不用空格；<br>因为(function() {})()是一个函数表达式语句，可以挨着，也可以不挨着，都不会报错<br>你把new当成+ - ！ ~来看，就好理解了；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ function() &#123;&#125;; //不紧挨着，不报错</span><br><span class="line">~function() &#123;&#125;; //紧挨着，不报错</span><br></pre></td></tr></table></figure></p><h4 id="重要运用之一"><a href="#重要运用之一" class="headerlink" title="重要运用之一"></a>重要运用之一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var map = document.querySelector(&apos;#id&apos;)</span><br><span class="line">map.style.height=&apos;600px&apos;;</span><br></pre></td></tr></table></figure><p>相比之下，下面的写法，map变成块级变量，不再污染全局作用域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;(function()&#123;</span><br><span class="line">    var map = document.querySelector(&apos;#id&apos;)</span><br><span class="line">    map.style.height=&apos;600px&apos;;</span><br><span class="line">     &#125;())</span><br></pre></td></tr></table></figure></p><h4 id="自运行-参考资料"><a href="#自运行-参考资料" class="headerlink" title="自运行 参考资料"></a>自运行 参考资料</h4><p><a href="http://www.softwhy.com/article-2022-1.html" target="_blank" rel="noopener">JavaScript 小括号()分组运算符</a><br><a href="https://www.cnblogs.com/lenther2002/p/5894964.html" target="_blank" rel="noopener">JS中函数定义和函数表达式的区别</a><br><a href="https://www.zhihu.com/question/20249179" target="_blank" rel="noopener">JavaScript 匿名函数有哪几种执行方式?</a></p><h3 id="js规范写法"><a href="#js规范写法" class="headerlink" title="js规范写法"></a>js规范写法</h3><h4 id="给常量起个名"><a href="#给常量起个名" class="headerlink" title="给常量起个名"></a>给常量起个名</h4><p>必要的时候，给常量起个名，可读性更强<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">car.handle(&apos;seller&apos;,&apos;sell&apos;,5,true);</span><br></pre></td></tr></table></figure></p><p>修改后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var carType = &apos;seller&apos;;</span><br><span class="line">var carName = &apos;sell&apos;;</span><br><span class="line">var sellNum = 5;</span><br><span class="line">var isNeedLoan = true;</span><br><span class="line">car.handle(carType,carName,sellNum,isNeedLoan);</span><br></pre></td></tr></table></figure></p><h3 id="js运行机制"><a href="#js运行机制" class="headerlink" title="js运行机制"></a>js运行机制</h3><h4 id="如何理解js的单线程"><a href="#如何理解js的单线程" class="headerlink" title="如何理解js的单线程"></a>如何理解js的单线程</h4><p>js的单线程指的是，一个时间内只能执行一个任务。</p><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>任务队列的任务将被运行栈(执行栈、调用栈)执行</p><h4 id="event-loop-事件循环"><a href="#event-loop-事件循环" class="headerlink" title="event loop (事件循环)"></a>event loop (事件循环)</h4><p>比较多，单独出来分析，参考《event loop (事件循环)》</p><h4 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h4><p>其实比较简单，参考<a href="https://www.jianshu.com/p/a697e9bfdaef" target="_blank" rel="noopener">这篇讲得好</a>。<br>大白话，由语言标准提供的就是微任务，比如ES6提供的promise。<br>当前用得最多微任务也就promise。<br>其他由浏览器或node运行环境提供的，比如setTimeout、ajax等是宏任务。</p><h4 id="理解setTimeout-0"><a href="#理解setTimeout-0" class="headerlink" title="理解setTimeout 0"></a>理解setTimeout 0</h4><p>小于4毫秒时，浏览器认为都是0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;&#125;, 2)</span><br></pre></td></tr></table></figure></p><h4 id="触发异步任务的API"><a href="#触发异步任务的API" class="headerlink" title="触发异步任务的API"></a>触发异步任务的API</h4><p>setTimeout或setInInterval<br>Dom事件<br>Promise</p><h3 id="event-loop-事件循环-1"><a href="#event-loop-事件循环-1" class="headerlink" title="event loop (事件循环)"></a>event loop (事件循环)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><figure class="image-box">                <img src="/image/js/loop.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="区分出同步、异步任务"><a href="#区分出同步、异步任务" class="headerlink" title="区分出同步、异步任务"></a>区分出同步、异步任务</h4><p>浏览器引擎会对所有任务进行识别，会将同步任务放置到运行栈中;<br>会将其中的异步任务取出放在浏览器的线程中，等待如setTimeout任务的时间到了变成0后，再放到任务队列中；</p><h4 id="异步任务时间为0后放入任务队列中"><a href="#异步任务时间为0后放入任务队列中" class="headerlink" title="异步任务时间为0后放入任务队列中"></a>异步任务时间为0后放入任务队列中</h4><p>参考上面</p><h4 id="运行栈执行同步任务"><a href="#运行栈执行同步任务" class="headerlink" title="运行栈执行同步任务"></a>运行栈执行同步任务</h4><p>运行栈也成为执行栈、调用栈。<br>同步任务放在运行栈中，运行栈只会放置同步任务，运行栈执行的是同步任务；</p><h4 id="运行栈与任务队列之间的Loop循环"><a href="#运行栈与任务队列之间的Loop循环" class="headerlink" title="运行栈与任务队列之间的Loop循环"></a>运行栈与任务队列之间的Loop循环</h4><p>运行栈执行完后，发现运行栈清空后；<br>运行栈就从任务队列中取出任务进行执行。<br>运行栈再次执行完后，发现运行栈中又清空了，<br>于是运行栈又从任务队列中取出任务进行执行。<br>如此运行，就是事件循环，也叫Event Loop</p><h3 id="generator-yeild"><a href="#generator-yeild" class="headerlink" title="generator yeild"></a>generator yeild</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>yeild用于单步执行代码；<br>每执行一次it.next,就会按定义的yeild顺序单步执行到给定的代码中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="string">'hel'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'step one'</span>,a);<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">yield</span> <span class="string">'wol'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'step two'</span>,b);<span class="comment">//66</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = test();</span><br><span class="line"><span class="built_in">console</span>.log(it.next())<span class="comment">//第一次next传参是没有任何意义的//&#123; value: 'hel', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">1</span>))<span class="comment">//传递上一次的yield返回值&#123; value: 'wol', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">66</span>))<span class="comment">//&#123; value: undefined, done: false &#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="it-next-返回-value-done"><a href="#it-next-返回-value-done" class="headerlink" title="it.next()返回{value,done}"></a>it.next()返回{value,done}</h4><p>参考《概述》</p><h4 id="it-next的传参是上一个yeild的值"><a href="#it-next的传参是上一个yeild的值" class="headerlink" title="it.next的传参是上一个yeild的值"></a>it.next的传参是上一个yeild的值</h4><p>参考《概述》</p><h3 id="async是-generator-co-promise的语法糖"><a href="#async是-generator-co-promise的语法糖" class="headerlink" title="async是 generator+co+promise的语法糖"></a>async是 generator+co+promise的语法糖</h3><h4 id="co"><a href="#co" class="headerlink" title="co"></a>co</h4><p><a href="https://github.com/tj/co" target="_blank" rel="noopener">co</a> 是koa作者tj的一个开源库，如下，在read函数内，实现了将异步代码使用同步的方式编写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> content1 = <span class="keyword">yield</span> axios.get(<span class="string">'http://127.0.0.1:3000'</span>).then(<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'先执行'</span>);<span class="keyword">return</span> e&#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'step one'</span>,content1.data)</span><br><span class="line">        <span class="keyword">let</span> content2 = <span class="keyword">yield</span> axios.get(<span class="string">'http://127.0.0.1:3000'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'step two'</span>,content2.data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err'</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//co简化版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">it</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> &#123; value, done&#125; = it.next(data);</span><br><span class="line">            <span class="keyword">if</span>(!done)&#123;</span><br><span class="line">                <span class="built_in">Promise</span>.resolve(value).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">                    next(data);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(read()).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'result'</span>,data.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="使用async实现"><a href="#使用async实现" class="headerlink" title="使用async实现"></a>使用async实现</h4><p>要想实现上面同样的功能：在read函数内，实现了将异步代码使用同步的方式编写，使用async很简单，async底层基于generator+co+promise实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncRead</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> content1 = <span class="keyword">await</span> axios.get(<span class="string">'http://127.0.0.1:3000'</span>).then(<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">'先执行'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'async step one'</span>,content1.data)</span><br><span class="line">        <span class="keyword">let</span> content2 = <span class="keyword">await</span> axios.get(<span class="string">'http://127.0.0.1:3000'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'async step two'</span>,content2.data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err'</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncRead()</span><br></pre></td></tr></table></figure></p><h3 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h3><h4 id="手写源码要点"><a href="#手写源码要点" class="headerlink" title="手写源码要点"></a>手写源码要点</h4><ul><li>定义一个构造函数<ul><li>构造函数内三个状态：pending resolved rejected</li><li>定义内部resolve与reject方法</li><li>reject时候存储value，以便给下个then使用，以此类推reject</li></ul></li><li>定义一个原型方法then</li><li>then方法内递归构造函数实现链式调用</li><li>定义静态方法all、race、resolve等等</li><li>基于发布订阅模式</li></ul><p>除此之外，以下几点要注意：</p><h4 id="setTimeout内需要重新try-catch"><a href="#setTimeout内需要重新try-catch" class="headerlink" title="setTimeout内需要重新try catch"></a>setTimeout内需要重新try catch</h4><p>尽管,这里已经做了try catch。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// 立即同步执行executor</span></span><br><span class="line">      executor(resolve,reject)</span><br><span class="line">  &#125;<span class="keyword">catch</span> (e) &#123; <span class="comment">// 如果执行器抛出异常，promise对象变为rejected状态</span></span><br><span class="line">      reject(e)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>但是setTimeout内还必须加try，因为try catch无法捕捉一个定时器内部函数的错误，因此有定时器时，必须这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">              <span class="keyword">try</span>&#123;</span><br><span class="line">              </span><br><span class="line">              &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                  </span><br><span class="line">              &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">  &#125;<span class="keyword">catch</span> (e) &#123; </span><br><span class="line">      reject(e)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="建议使用class而非function原型来做继承"><a href="#建议使用class而非function原型来做继承" class="headerlink" title="建议使用class而非function原型来做继承"></a>建议使用class而非function原型来做继承</h4><p>class可以避免原型的浅拷贝问题。</p><h4 id="reslove-reject是异步因为用了setTimeout"><a href="#reslove-reject是异步因为用了setTimeout" class="headerlink" title="reslove\reject是异步因为用了setTimeout"></a>reslove\reject是异步因为用了setTimeout</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       handle(onResolved)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.bilibili.com/video/BV1AA411h75Q/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">珠峰公开课（手写promise - 上）</a><br><a href="https://www.bilibili.com/video/BV1sZ4y1j71K/?spm_id_from=333.788.videocard.1" target="_blank" rel="noopener">珠峰公开课（手写promise - 下）</a><br><a href="https://juejin.im/post/6856213486633304078" target="_blank" rel="noopener">promise 同学笔记）</a><br><a href="https://github.com/Sunny-lucking/howToBuildMyPromise" target="_blank" rel="noopener">同学源码 </a><br><a href="https://github.com/YeWills/learns/tree/master/promise" target="_blank" rel="noopener">demo</a></p><h2 id="Dom-API"><a href="#Dom-API" class="headerlink" title="Dom API"></a>Dom API</h2><h3 id="为什么都可绑定事件：dom-onclick-function-dom-addEventListener-‘click’"><a href="#为什么都可绑定事件：dom-onclick-function-dom-addEventListener-‘click’" class="headerlink" title="为什么都可绑定事件：dom.onclick=function(){}\dom.addEventListener(‘click’)"></a>为什么都可绑定事件：dom.onclick=function(){}\dom.addEventListener(‘click’)</h3><p>这是dom事件级别，这两种方式是新老时代的绑定事件方式，参考《dom事件级别》</p><h3 id="dom事件级别"><a href="#dom事件级别" class="headerlink" title="dom事件级别"></a>dom事件级别</h3><p>dom0 时代 ：dom.onclick=function(){}<br>dom2 时代 ：dom.addEventListener(‘click’, function(){})<br>dom3 时代，绑定事件方式与dom2相同，不同的是，dom3时代增加了很多事件类型，例如 鼠标事件、键盘事件‘keyup’；</p><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>事件模型有 冒泡和捕获 两种。</p><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p><a href="https://www.jianshu.com/p/e7c403e6e2da" target="_blank" rel="noopener">参考</a><br>当事件触发时，无论你做了什么，事件都会完整经历捕获、目标处理、冒泡阶段。这里很多人歧义，认为事件只会单独执行捕获或冒泡阶段，这是不对的，事件会完整经历以上三阶段。<br>只是绑定事件时，可以选择事件在冒泡或捕获阶段触发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//true 捕获， false 冒泡 (默认)， 无论设置为true或false，事件都会执行</span><br><span class="line">document.addEventListener(&quot;click&quot;, myFunction, true);</span><br></pre></td></tr></table></figure></p><p>dom事件流分为三阶段：</p><h4 id="捕获阶段"><a href="#捕获阶段" class="headerlink" title="捕获阶段"></a>捕获阶段</h4><p>一个事件比如 click，顶级对象window发出一个事件流，事件从window&gt;document&gt;html&gt;body&gt;button到达目标元素。<br>注意此阶段不出发事件绑定的函数。</p><h4 id="目标处理阶段"><a href="#目标处理阶段" class="headerlink" title="目标处理阶段"></a>目标处理阶段</h4><p>事件到达目标元素后，目标元素分析传给自己的是什么事件，是click还是change等等事件？确认好事件类型后，开始触发事件对应的绑定函数。<br>进入冒泡阶段。</p><h4 id="冒泡阶段"><a href="#冒泡阶段" class="headerlink" title="冒泡阶段"></a>冒泡阶段</h4><p>沿着目标函数一步步到window对象，触发对应事件绑定函数。</p><h4 id="document-addEventListener"><a href="#document-addEventListener" class="headerlink" title="document.addEventListener"></a>document.addEventListener</h4><p>document.addEventListener(“click”, myFunction, true)的第三个参数 true或false，这第三个参数类似一个转换阀，当为true时，捕获阶段就执行。<br>当false时，冒泡阶段才执行。</p><h3 id="事件捕获的具体流程"><a href="#事件捕获的具体流程" class="headerlink" title="事件捕获的具体流程"></a>事件捕获的具体流程</h3><p>事件捕获具体流程是window&gt;document&gt;html&gt;body&gt;button。<br>这也就解释了，很多人将<strong>全局</strong>事件绑定在body或document或window上，放在这些地方，在项目中任何地方都能被捕获触发对应事件函数。</p><h3 id="Event对象常见运用"><a href="#Event对象常见运用" class="headerlink" title="Event对象常见运用"></a>Event对象常见运用</h3><h4 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event.preventDefault()"></a>event.preventDefault()</h4><p>阻止元素的默认行为，例如a标签定义click事件，在事件函数上加上这个，可以阻止a标签跳转。</p><h4 id="event-stopPropagation"><a href="#event-stopPropagation" class="headerlink" title="event.stopPropagation()"></a>event.stopPropagation()</h4><p>阻止冒泡或捕获，当元素使用这个的时候，监听事件比如click，所触发的函数就到此为止，再也不会向上冒泡或像下捕获。</p><h4 id="event-stopImmediatePropagation"><a href="#event-stopImmediatePropagation" class="headerlink" title="event.stopImmediatePropagation()"></a>event.stopImmediatePropagation()</h4><p>同一个元素绑定同一事件如click多次时，当元素click触发时，所有的click事件全部被触发。<br>如果不想全部触发绑定的click事件，可以在某个click事件函数中加这个，阻止再触发其他click事件函数。</p><h4 id="event-currentTarget"><a href="#event-currentTarget" class="headerlink" title="event.currentTarget"></a>event.currentTarget</h4><p>获取真正写onclick函数的元素，如下，当点击child1时，通过event.currentTarget获取到的是wrap的dom，通过event.target获取到的是真正被点击的目标元素child1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrap&quot; onclick=&quot;function(e)&#123;e.target&#125;&quot;&gt;</span><br><span class="line">           &lt;div class=&quot;child1&quot;&gt;&lt;/div&gt;</span><br><span class="line">           &lt;div class=&quot;child2&quot;&gt;&lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="event-target"><a href="#event-target" class="headerlink" title="event.target"></a>event.target</h4><p>见《event.currentTarget》</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>event还有很多其他的作用，比如获取键盘值等等。</p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var eve = new Event(&apos;abcTest&apos;);</span><br><span class="line">dom.addEventListener(&apos;abcTest&apos;, ()=&gt;&#123;&#125;, false)</span><br><span class="line">dom.dispatchEvent(eve)</span><br></pre></td></tr></table></figure><p>IE下有一定兼容问题，解决方法很简单，参看mdn关于<code>new Event</code>章节。</p><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><h4 id="keyDown"><a href="#keyDown" class="headerlink" title="keyDown"></a>keyDown</h4><p>当用户按下键盘上的任意键时触发，而且如果按住不放的话，会<strong>重复</strong>触发此事件，注意，如果事件可选用keyDown与keyUp时，请使用keyUp，因为它不会重复触发。</p><h4 id="keyPress"><a href="#keyPress" class="headerlink" title="keyPress"></a>keyPress</h4><p>当用户按下键盘上的<strong>字符键</strong>时触发，而且如果按住不放的话，会<strong>重复</strong>触发此事件</p><h4 id="keyUp"><a href="#keyUp" class="headerlink" title="keyUp"></a>keyUp</h4><p>当用户释放键盘上的键时触发,天然地<strong>不会重复</strong>触发</p><h4 id="用keyUp代替keyDown"><a href="#用keyUp代替keyDown" class="headerlink" title="用keyUp代替keyDown"></a>用keyUp代替keyDown</h4><p>因为keyUp的不会重复触发性，在做键盘事件时，可以选择keyUp，而避免keyDown。</p><h4 id="避免this的使用-同时支持鼠标与键盘事件时"><a href="#避免this的使用-同时支持鼠标与键盘事件时" class="headerlink" title="避免this的使用-(同时支持鼠标与键盘事件时)"></a>避免this的使用-(同时支持鼠标与键盘事件时)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> play=<span class="built_in">document</span>.getElementById(<span class="string">'play'</span>);</span><br><span class="line">    <span class="comment">// 开始抽奖</span></span><br><span class="line">    play.onclick=playFun;</span><br><span class="line">   <span class="comment">// 键盘事件</span></span><br><span class="line">   <span class="built_in">document</span>.onkeyup=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">      event = event || <span class="built_in">window</span>.event;</span><br><span class="line">      <span class="keyword">if</span>(event.keyCode==<span class="number">13</span>)&#123;</span><br><span class="line">        playFun();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//最好不要用this，鼠标事件时，this时被点击节点；键盘事件时this指向document</span></span><br><span class="line">    <span class="comment">//this.style.background='#999';</span></span><br><span class="line">    play.style.background=<span class="string">'#999'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dom-API-黑知识"><a href="#Dom-API-黑知识" class="headerlink" title="Dom API 黑知识"></a>Dom API 黑知识</h2><h3 id="获取dom-width-与-内联样式-的关系"><a href="#获取dom-width-与-内联样式-的关系" class="headerlink" title="获取dom width 与 内联样式 的关系"></a>获取dom width 与 内联样式 的关系</h3><h4 id="dom-style-width-只能获取内联样式"><a href="#dom-style-width-只能获取内联样式" class="headerlink" title="dom.style.width 只能获取内联样式"></a>dom.style.width 只能获取内联样式</h4><p>dom.style.width 只能获取内联样式，无法获取 通过css给dom设置的width。<br>这就造成明明dom是有宽高的，但使用dom.style.width获取的高度为0；<br>解决的方法是，使用 window.getComputedStyle(dom).width 获取，此方法始终能获取宽高度。</p><h4 id="window-getComputedStyle-dom-width-获取宽高"><a href="#window-getComputedStyle-dom-width-获取宽高" class="headerlink" title="window.getComputedStyle(dom).width 获取宽高"></a>window.getComputedStyle(dom).width 获取宽高</h4><p>推荐使用此方法获取dom宽高度。<br>参考《dom.style.width 只能获取内联样式》</p><h4 id="dom-getBoundingClientRect-width"><a href="#dom-getBoundingClientRect-width" class="headerlink" title="dom.getBoundingClientRect().width"></a>dom.getBoundingClientRect().width</h4><p>此方法是一个dom API神器，能做很多事情，获取宽高度不在话下。</p><h2 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h2><h3 id="为什么jq插件要写在-fn对象中"><a href="#为什么jq插件要写在-fn对象中" class="headerlink" title="为什么jq插件要写在$.fn对象中"></a>为什么jq插件要写在$.fn对象中</h3><p>本可以将jq插件直接扩展到$.prototype原型上，为什么要在$.fn上呢，原因是为了广大jq用户，有一个统一的接口（fn对象）来进行插件扩展。<br>这样，大家插件的写法也更加统一。</p><h2 id="场景运用"><a href="#场景运用" class="headerlink" title="场景运用"></a>场景运用</h2><h3 id="拖拽的原生实现"><a href="#拖拽的原生实现" class="headerlink" title="拖拽的原生实现"></a>拖拽的原生实现</h3><h4 id="onmousemove的坐标实时计算"><a href="#onmousemove的坐标实时计算" class="headerlink" title="onmousemove的坐标实时计算"></a>onmousemove的坐标实时计算</h4><p>见下面代码</p><h4 id="clientX-与-offsetLeft"><a href="#clientX-与-offsetLeft" class="headerlink" title="clientX 与 offsetLeft"></a>clientX 与 offsetLeft</h4><p>见下面代码</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=drag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> oTitle=getByClass(<span class="string">'login_logo_webqq'</span>,<span class="string">'loginPanel'</span>)[<span class="number">0</span>];</span><br><span class="line">   <span class="comment">// 拖曳</span></span><br><span class="line">   oTitle.onmousedown=fnDown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnDown</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event = event || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">var</span> oDrag=<span class="built_in">document</span>.getElementById(<span class="string">'loginPanel'</span>),</span><br><span class="line">      <span class="comment">// 光标按下时光标和面板之间的距离</span></span><br><span class="line">      disX=event.clientX-oDrag.offsetLeft,</span><br><span class="line">      disY=event.clientY-oDrag.offsetTop;</span><br><span class="line">  <span class="comment">// 移动</span></span><br><span class="line">  <span class="built_in">document</span>.onmousemove=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event = event || <span class="built_in">window</span>.event;</span><br><span class="line">  fnMove(event,disX,disY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 释放鼠标</span></span><br><span class="line">  <span class="built_in">document</span>.onmouseup=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.onmousemove=<span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">document</span>.onmouseup=<span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnMove</span>(<span class="params">e,posX,posY</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oDrag=<span class="built_in">document</span>.getElementById(<span class="string">'loginPanel'</span>),</span><br><span class="line">      l=e.clientX-posX,</span><br><span class="line">      t=e.clientY-posY,</span><br><span class="line">      winW=<span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">      winH=<span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight,</span><br><span class="line">      maxW=winW-oDrag.offsetWidth<span class="number">-10</span>,</span><br><span class="line">      maxH=winH-oDrag.offsetHeight;</span><br><span class="line">  <span class="comment">//边界控制</span></span><br><span class="line">  <span class="keyword">if</span>(l&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l&gt;maxW)&#123;</span><br><span class="line">    l=maxW;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    t=<span class="number">10</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t&gt;maxH)&#123;</span><br><span class="line">    t=maxH;</span><br><span class="line">  &#125;</span><br><span class="line">  oDrag.style.left=l+<span class="string">'px'</span>;</span><br><span class="line">  oDrag.style.top=t+<span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自运行函数写法形式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>koa2笔记</title>
      <link href="/2019/05/21/koa2/"/>
      <url>/2019/05/21/koa2/</url>
      
        <content type="html"><![CDATA[<h2 id="koa2常用知识"><a href="#koa2常用知识" class="headerlink" title="koa2常用知识"></a>koa2常用知识</h2><h3 id="context的别名"><a href="#context的别名" class="headerlink" title="context的别名"></a>context的别名</h3><p><a href="https://koajs.com/#introduction" target="_blank" rel="noopener">更多参看 官网 Request aliases Response aliases</a><br>摘录部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Request aliases 下面的简写，都指的是Request</span><br><span class="line">ctx.url  -- ctx.request.url 的别名</span><br><span class="line">ctx.method  -- ctx.request.method 的别名</span><br><span class="line">ctx.header</span><br><span class="line">ctx.path</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Response aliases 下面的简写，都指的是Request</span><br><span class="line">ctx.body  -- ctx.response.body 的别名</span><br><span class="line">ctx.status  -- ctx.response.status 的别名</span><br></pre></td></tr></table></figure><p>另外 ctx.req 是 ctx.request 的别名；<br>另外 ctx.res 是 ctx.response 的别名；</p><h3 id="POST请求参数的获取"><a href="#POST请求参数的获取" class="headerlink" title="POST请求参数的获取"></a>POST请求参数的获取</h3><p>koa 没有封装获取post请求参数的方法，要么通过ctx.req.on原生方式，要么通过koa-bodyparser</p><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>使用ctx.req.on原生方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line">  let postdata=&apos;&apos;;</span><br><span class="line">  ctx.req.on(&apos;data&apos;, (data)=&gt;&#123;</span><br><span class="line">    postdata +=data;</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.req.on(&apos;end&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(postdata);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 另起一个git bash 窗口执行以下命令，注意，</span><br><span class="line">//一定用git bash， 因为cmd 没有curl命令</span><br><span class="line">curl -d &quot;param1=abc&amp;param2=qqw&quot; http://localhost:3000/</span><br><span class="line"></span><br><span class="line">// 在npm start 所在的cmd或git bash窗口，会出现 打印：</span><br><span class="line">//param1=abc&amp;param2=qqw</span><br></pre></td></tr></table></figure></p><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>使用koa-bodyparser方式。koa-bodyparser的底层也是使用ctx.req.on实现的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  let postData = ctx.request.body;</span><br><span class="line">  console.log(postData);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br><span class="line"></span><br><span class="line">// 另起一个git bash 窗口执行以下命令，</span><br><span class="line">curl -d &quot;param1=abc&amp;param2=qqw&quot; http://localhost:3000/</span><br><span class="line"></span><br><span class="line">// 在npm start 所在的cmd或git bash窗口，会出现 打印：</span><br><span class="line">//&#123; param1: &apos;abc&apos;, param2: &apos;qqw&apos; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="有关content-type"><a href="#有关content-type" class="headerlink" title="有关content-type"></a>有关content-type</h3><h4 id="先来看一个实例demo，感受下："><a href="#先来看一个实例demo，感受下：" class="headerlink" title="先来看一个实例demo，感受下："></a>先来看一个实例demo，感受下：</h4><p>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://127.0.0.1:3000/test&apos;, &#123;</span><br><span class="line">    method: &apos;GET&apos;, // or &apos;PUT&apos;</span><br><span class="line">    headers: new Headers(&#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;image/png&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; res.text())</span><br><span class="line">  .catch(error =&gt; console.error(&apos;Error:&apos;, error))</span><br><span class="line">  .then(response =&gt; console.log(&apos;Success:&apos;, response));</span><br></pre></td></tr></table></figure></p><p>后台代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><p>页面响应：<br><figure class="image-box">                <img src="/image/koa2/content-type.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/koa2/content-res.png" alt="" title="" class="">                <p></p>            </figure></p><p>后续操作：</p><ul><li>当切换设置不同的ctx.response.type=’text’;对应的Response Header 的 Content-type随之改变</li></ul><h4 id="另外一个实验："><a href="#另外一个实验：" class="headerlink" title="另外一个实验："></a>另外一个实验：</h4><p>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;http://127.0.0.1:3000/test&apos;, &#123;</span><br><span class="line">  method: &apos;GET&apos;,</span><br><span class="line">  headers: new Headers(&#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;image/png&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; res.json())</span><br><span class="line">.catch(error =&gt; console.error(&apos;Error:&apos;, error))</span><br><span class="line">.then(response =&gt; console.log(&apos;Success:&apos;, response));</span><br></pre></td></tr></table></figure></p><p>后台代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;html&apos;;</span><br><span class="line">  ctx.response.body=&#123;data:&apos;Hello World&apos;&#125;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><p>发现的现象：</p><ul><li>设置不同的ctx.response.type=’html’时，Response Header 的 Content-type没有随之改变，还是显示为application/json</li><li>后台ctx.response.body={data:’Hello World’};改成  ctx.response.body=’<html>‘;<br>前台代码不变，发现res.json()解析报错，Unexpected token &lt; in JSON at position 0，<br>将res.json改成res.text就好了</html></li><li>后端实际的数据是json数据(ctx.response.body={data:’Hello World’})，但设置 ctx.response.type=’html’;然而并不影响前台通过res.json()正常解析到正确数据；</li><li>后端实际的数据是json数据(ctx.response.body={data:’Hello World’})，虽然前端设置了自定义Header content-type为image/png，但不影响前端正常解析，前端一样能正常获取数据。</li></ul><h4 id="得出结论："><a href="#得出结论：" class="headerlink" title="得出结论："></a>得出结论：</h4><p>结合上面页面响应的图片中：</p><ul><li>一个请求，有两个content-type,分别是Response Header 和 Request Header上的。</li><li>小区别是 Response Header 的是首字母大写的 Content-type ，Request Header 的是首字母小写的 content-type;</li><li>fetch 的 headers: new Headers({‘Content-Type’: ‘image/png’}) 设置的是 Request Header 的 content-type；</li><li>Response Header 的 Content-type 是 原则上是ctx.response.type控制设置的，但如上例，有时Response Header 的 Content-type 是 浏览器或koa自动识别ctx.response.body数据类型设置的。</li><li>fetch要想正确解析数据，需要根据后台实际数据，使用对应的解析方式，如 res.json() 、res.text()等等，如果解析方式不对，就报错。</li><li>另外注意的是，前端fetch的时候，如果自定义header，而且请求是跨域的，每发一次fetch，可能会产生两次请求，具体分析参见《koa2黑知识 – 跨域请求有时会发两次请求》：</li></ul><h4 id="常见的-content-type值–对应的ctx-response-type："><a href="#常见的-content-type值–对应的ctx-response-type：" class="headerlink" title="常见的 content-type值–对应的ctx.response.type："></a>常见的 content-type值–对应的ctx.response.type：</h4><p>application/json  – ctx.response.type=’json’<br>text/html  – ctx.response.type=’html’<br>image/png  – ctx.response.type=’image/png’<br>text/plain  – ctx.response.type=’text’  浏览器默认text/plain</p><h3 id="设置响应状态码"><a href="#设置响应状态码" class="headerlink" title="设置响应状态码"></a>设置响应状态码</h3><p>通过ctx.status设置，ctx.status是ctx.response.status的别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.status=562;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><p>页面响应：<br><figure class="image-box">                <img src="/image/koa2/status.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>koa-bodyparser的底层也是使用ctx.req.on实现的，所以不能同时使用 koa-bodyparser与ctx.req.on，否则，可能报错，<br>详见《koa2黑知识 – koa-bodyparser导致ctx.req.on事件失效》</p><h3 id="如何在koa使用中间件"><a href="#如何在koa使用中间件" class="headerlink" title="如何在koa使用中间件"></a>如何在koa使用中间件</h3><h4 id="中间件是由app-use加载的"><a href="#中间件是由app-use加载的" class="headerlink" title="中间件是由app.use加载的"></a>中间件是由app.use加载的</h4><p>中间件一般都通过 app.use 函数来加载中间件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const app = new Koa()</span><br><span class="line">app.use(cors());</span><br><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.response.type=&apos;text&apos;;</span><br><span class="line">  ctx.response.body=&apos;&lt;p/&gt;999&lt;p/&gt;&apos;;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><h4 id="中间件执行顺序"><a href="#中间件执行顺序" class="headerlink" title="中间件执行顺序"></a>中间件执行顺序</h4><p>中间件在 koa中执行顺序，遵循洋葱模型方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/image/koa2/middle.jpg)</span><br></pre></td></tr></table></figure></p><p>代码展示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;one start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;one end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;two start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;two end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(&apos;three start&apos;);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(&apos;three end&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// one start</span><br><span class="line">// two start</span><br><span class="line">// three start</span><br><span class="line">// three end</span><br><span class="line">// two end</span><br><span class="line">// one end</span><br></pre></td></tr></table></figure></p><h4 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h4><p>next()返回一个Promise对象，配合await使用，可以达到阻塞后面程序执行，等待 next() 返回类似reject()才最终执行nex()后面的程序。<br>每个中间件必须使用next()，否则异常。</p><h3 id="写一个中间件"><a href="#写一个中间件" class="headerlink" title="写一个中间件"></a>写一个中间件</h3><p>这里动手写一个logger中间件小demo，用来打印日志：<br>原代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  console.log(ctx.method,ctx.host + ctx.url)</span><br><span class="line">  await next();</span><br><span class="line">  ctx.body = &apos;hellow world&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>动手写一个logger中间件，用于打印日志，改造后如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line">const logger = async function(ctx, next)&#123;</span><br><span class="line">  console.log(ctx.method,ctx.host + ctx.url)</span><br><span class="line">  await next();</span><br><span class="line">&#125;</span><br><span class="line">app.use(logger)</span><br><span class="line">app.use(async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.body = &apos;hellow world&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><h3 id="两种鉴权方式"><a href="#两种鉴权方式" class="headerlink" title="两种鉴权方式"></a>两种鉴权方式</h3><p>一种是广泛使用的Cookie认证模式；<br>一种是基于Token的认证模式, koa中可以结合jsonwebtoken 与 koa-jwt实现Token鉴权.异步到这里了解更多《jsonwebtoken 与 koa-jwt》.<br><a href="https://github.com/YeWills/koa-demo/tree/router-Token" target="_blank" rel="noopener">这里是一个基于Token的鉴权demo</a></p><h3 id="写一个返回文件的接口"><a href="#写一个返回文件的接口" class="headerlink" title="写一个返回文件的接口"></a>写一个返回文件的接口</h3><h4 id="使用fs实现的方式"><a href="#使用fs实现的方式" class="headerlink" title="使用fs实现的方式"></a>使用fs实现的方式</h4><p>写一个接口，可以将本地的文件，返回给客户端,主要使用fs开完成，核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const extname = path.extname;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const fpath = path.join(__dirname, &apos;./files/test.xlsx&apos;);</span><br><span class="line">const fstat = await stat(fpath);</span><br><span class="line">if (fstat.isFile()) &#123;</span><br><span class="line">  ctx.type = extname(fpath);</span><br><span class="line">  ctx.body = fs.createReadStream(fpath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function stat(file) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    fs.stat(file, function(err, stat) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve(stat);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/YeWills/koa-demo/tree/response-file" target="_blank" rel="noopener">完整demo</a>;<br>本demo 参考了 <a href="https://github.com/YeWills/examples" target="_blank" rel="noopener">koa 官网example</a>，koa 官网example挺好，展示了很多功能，如果有需求，可先到这里找示例实现。</p><h4 id="使用koa-static实现的方式"><a href="#使用koa-static实现的方式" class="headerlink" title="使用koa-static实现的方式"></a>使用koa-static实现的方式</h4><p>此方法参见《koa-static》，弊端是，无法自定义路由名称，只能以文件名称为接口url。</p><h3 id="让html在浏览器中访问的四种方法"><a href="#让html在浏览器中访问的四种方法" class="headerlink" title="让html在浏览器中访问的四种方法"></a>让html在浏览器中访问的四种方法</h3><p>本方法同样适用于 jpg、txt、docx等等文件。</p><h4 id="浏览器访问html的前身"><a href="#浏览器访问html的前身" class="headerlink" title="浏览器访问html的前身"></a>浏览器访问html的前身</h4><p>这是一种原始的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">    let html = `</span><br><span class="line">  &lt;h1&gt;登录&lt;\h1&gt;</span><br><span class="line">  &lt;form method = &quot;POST&quot; action= &quot;/&quot;&gt;</span><br><span class="line">  &lt;p&gt;用户名&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;p&gt;密码&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  `;</span><br><span class="line">  ctx.body=html;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="koa-view方法一"><a href="#koa-view方法一" class="headerlink" title="koa-view方法一"></a>koa-view方法一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/gethtml&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    await ctx.render(&apos;/static/test.html&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="koa-view方法二"><a href="#koa-view方法二" class="headerlink" title="koa-view方法二"></a>koa-view方法二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">    await ctx.render(&apos;/static/test.html&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">// 缺点在于无法访问到 http://localhost:3000/abc 此路由，都会被截获转发上面的/static/test.html</span><br><span class="line">router.get(&apos;/abc&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body=&apos;888999&apos;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="koa-static方法一"><a href="#koa-static方法一" class="headerlink" title="koa-static方法一"></a>koa-static方法一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const serve = require(&apos;koa-static&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">// http://localhost:3000/redis.html</span><br><span class="line">app.use(serve(handlePath(&apos;../pages/static/test_redirect&apos;)))</span><br><span class="line">// http://localhost:3000</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  ctx.redirect(&apos;/redis.html&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="最佳方法-koa-static方法二"><a href="#最佳方法-koa-static方法二" class="headerlink" title="最佳方法(koa-static方法二)"></a>最佳方法(koa-static方法二)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const serve = require(&apos;koa-static&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">// 在static内定义一个index.html，利用服务器默认找index.html特性</span><br><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在浏览器中输入<a href="http://localhost:3000，然后显示自己的index.html文件，一般使用的是koa-static或者是koa-views来实现。" target="_blank" rel="noopener">http://localhost:3000，然后显示自己的index.html文件，一般使用的是koa-static或者是koa-views来实现。</a><br>最好的方法是使用koa-static来做，好处多多,窍门在于给在static内定义一个index.html，利用服务器默认找index.html特性，这样在浏览器中只干干净净显示url <a href="http://localhost:3000，非常好，而且koa-static自己封装路由处理很好，不会影响你在koa中定义的其他路由。" target="_blank" rel="noopener">http://localhost:3000，非常好，而且koa-static自己封装路由处理很好，不会影响你在koa中定义的其他路由。</a><br>用koa-view也能达到目的，局限性大，会让你定义的其他路由失效,如果有疑问，可以用下面的demo测试研究一番。<br><a href="https://github.com/YeWills/koa-demo/tree/show-file-in-Browser" target="_blank" rel="noopener">以上四种情况，详细的demo</a></p><h3 id="前后端一体的小demo"><a href="#前后端一体的小demo" class="headerlink" title="前后端一体的小demo"></a>前后端一体的小demo</h3><p>通过对上面两节的总结，写了一个有图片、xls、正常json的三种接口，<br>以及前端对于这三种不同类型数据如何处理。<br>本demo也可用于理解blob。<br><a href="https://github.com/YeWills/koa-demo/tree/response-file" target="_blank" rel="noopener">《写一个返回文件的接口 –为同一个demo》</a></p><h3 id="文件上传-file和drap拖拽两种方式"><a href="#文件上传-file和drap拖拽两种方式" class="headerlink" title="文件上传-file和drap拖拽两种方式"></a>文件上传-file和drap拖拽两种方式</h3><p>服务端主要运用 koa-multer。<br><a href="https://github.com/YeWills/file-upload" target="_blank" rel="noopener">详细参考demo</a><br>也可参考：<br>《html笔记–文件上传-file和drap拖拽两种方式》</p><h3 id="截取前端请求方案"><a href="#截取前端请求方案" class="headerlink" title="截取前端请求方案"></a>截取前端请求方案</h3><p>koa启动服务，使用koa-view render 整个编译好的前端工程index.html, 此时index.html自然处于koa的同域名下，index.html发的每个请求都被koa 的app.use截取，在app.use内，再使用《服务端发起请求的方法》，组装数据，修改url，向指定服务器发起请求，而服务器之间请求没有跨域限制，成功的解决跨域。<br>这种方式最理想，因为不用修改后台，因为很多公司升级改造时，后台可以给你提供测试用户账号，因为老的项目客户正在使用，不能修改放开跨域限制的代码,遇到这种场景，就必须使用以上解决跨域的方式。<br><a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">服务端截取请求向另外服务器发请求的demo</a><br>参考《服务端发起请求的方法》了解更多<br>参考《跨域请求有时会发两次请求》了解更多</p><h3 id="服务端发起请求的方法"><a href="#服务端发起请求的方法" class="headerlink" title="服务端发起请求的方法"></a>服务端发起请求的方法</h3><p>服务端发起请求可以轻松实现，koa截取前端请求组装数据后 转发请求的功能。</p><h4 id="http方式"><a href="#http方式" class="headerlink" title="http方式"></a>http方式</h4><p>参考《http》</p><h4 id="request方式"><a href="#request方式" class="headerlink" title="request方式"></a>request方式</h4><p>参考《request-promise-native request》</p><h3 id="ctx-state"><a href="#ctx-state" class="headerlink" title="ctx.state"></a>ctx.state</h3><p>此属性，在做笔记为止，用的比较少，不用深究，用时再了解。<br>Koa 还约定了一个中间件的存储空间 ctx.state。通过 state 可以存储一些数据，比如用户数据，版本信息等。如果你使用 webpack 打包的话，可以使用中间件，将加载资源的方法作为 ctx.state 的属性传入到 view 层，方便获取资源路径。<a href="https://www.jianshu.com/p/d3afa36aa17a" target="_blank" rel="noopener">摘自此文</a></p><h2 id="koa2黑知识"><a href="#koa2黑知识" class="headerlink" title="koa2黑知识"></a>koa2黑知识</h2><h3 id="favicon-ico"><a href="#favicon-ico" class="headerlink" title="/favicon.ico"></a>/favicon.ico</h3><p>我们常加载dom时，会看到有一个/favicon.ico请求，这个是Dom渲染时，默认自带的静态资源。</p><h3 id="this-指向-ctx"><a href="#this-指向-ctx" class="headerlink" title="this 指向 ctx"></a>this 指向 ctx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line"> this; //此this其实就是ctx，就是Context</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;run in 3000&apos;)</span><br></pre></td></tr></table></figure><h3 id="koa-bodyparser导致ctx-req-on事件失效"><a href="#koa-bodyparser导致ctx-req-on事件失效" class="headerlink" title="koa-bodyparser导致ctx.req.on事件失效"></a>koa-bodyparser导致ctx.req.on事件失效</h3><p>下面代码会报错，因为koa-bodyparser的底层就是基于ctx.req.on实现的，如果使用了koa-bodyparser，它可能会劫持ctx.req.on这个事件，导致ctx.req.on事件失效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(bodyparser())</span><br><span class="line">app.use(async (ctx)=&gt;&#123;</span><br><span class="line">  let postdata=&apos;&apos;;</span><br><span class="line">  ctx.req.on(&apos;data&apos;, (data)=&gt;&#123;</span><br><span class="line">    postdata +=data;</span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.req.on(&apos;end&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(postdata);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;run in 3000&apos;)</span><br></pre></td></tr></table></figure></p><p>解决的方法也简单，koa-bodyparser本来是为了方便获取ctx.req.on,使用了koa-bodyparser就没必要使用ctx.req.on。<br>或者用kctx.req.on，就不要用koa-bodyparser；</p><h3 id="跨域的两种解决方式"><a href="#跨域的两种解决方式" class="headerlink" title="跨域的两种解决方式"></a>跨域的两种解决方式</h3><h4 id="koa2-cors解决跨域"><a href="#koa2-cors解决跨域" class="headerlink" title="koa2-cors解决跨域"></a>koa2-cors解决跨域</h4><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>var cors = require(‘koa2-cors’);<br>app.use(cors());</p><h5 id="将koa2-cors放在最上面"><a href="#将koa2-cors放在最上面" class="headerlink" title="将koa2-cors放在最上面"></a>将koa2-cors放在最上面</h5><p>将koa2-cors放在最上面，让koa2-cors先于其他中间件执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">app.use(cors()) // 解决跨域，跨域代码最好放在所有中间件前面</span><br><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">const serve = require(&apos;koa-static&apos;)</span><br><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const handlePath = path =&gt; resolve(__dirname, path)</span><br><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  await ctx.render(&apos;index.html&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(bodyparser())// 解析post参数</span><br><span class="line">app.use(router.routes())// 调用路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br><span class="line">app.listen(3000, ()=&gt;&#123;</span><br><span class="line">  console.log(&apos;server is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>需要修改后台，需要后台放开跨域限制，如果后台已经投产，客户正在使用该后台，那么肯定不能放开跨域限制，这种跨域解决方法就满足不了需求。</p><h4 id="服务端向服务端发请求解决跨域"><a href="#服务端向服务端发请求解决跨域" class="headerlink" title="服务端向服务端发请求解决跨域"></a>服务端向服务端发请求解决跨域</h4><h5 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h5><p>参考《截取前端请求方案》<br>参考《跨域请求有时会发两次请求》<br>参考《跨域请求有时会发两次请求》<br>这里有一个服务端截取前端请求，转发给指定服务器的<a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">demo</a>，不过该demo只做了一个接口的转发,看本例了解下这种模式</p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点是，不用修改后台，这种方法非常适合后台在使用，而要做产品升级的项目，缺点是，前端项目工程配置麻烦。</p><h3 id="home-id-name-路由对应的url"><a href="#home-id-name-路由对应的url" class="headerlink" title="/home/:id/:name 路由对应的url"></a>/home/:id/:name 路由对应的url</h3><p>router.get(‘/home’  —对应 <a href="http://localhost:3000/home?id=01&amp;name=admin" target="_blank" rel="noopener">http://localhost:3000/home?id=01&amp;name=admin</a><br>router.get(‘/home/:id/:name’  —对应 <a href="http://localhost:3000/home/01/admin" target="_blank" rel="noopener">http://localhost:3000/home/01/admin</a></p><h3 id="跨域请求有时会发两次请求"><a href="#跨域请求有时会发两次请求" class="headerlink" title="跨域请求有时会发两次请求"></a>跨域请求有时会发两次请求</h3><p>当前端fetch自定了header时，且接口跨域时，fetch一次，可能会发两次相同请求，两次请求一次是Request Method: OPTIONS的，<br>一次是Request Method: GET的，<br>原来fetch在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(preflight request), 用于试探服务端是否能接受真正的请求<a href="https://blog.csdn.net/cc1314_/article/details/78272329" target="_blank" rel="noopener">详细原因参见这里</a>；<br>解决之道就是把自定义headers字段删掉后；<br>或者不要使用require(‘koa2-cors’)的方式解决跨域，可以通过服务端请求服务器的方式解决跨域；<br>因为跨域是浏览器的限制机制，而服务器与服务器之间不存在跨域问题，具体思路：<br>在同域名下通过 koa 截取 项目的所有fetch请求，然后使用 request 模块，通过 request 给另外域名下的服务器发请求,<a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">服务端截取请求向另外服务器发请求的demo</a></p><h3 id="后台报错app有错误日志，也会报跨域错误"><a href="#后台报错app有错误日志，也会报跨域错误" class="headerlink" title="后台报错app有错误日志，也会报跨域错误"></a>后台报错app有错误日志，也会报跨域错误</h3><p>如果配置了koa2-cors解决跨域，但请求时有跨域报错，可能是app.use内部程序执行报错，会导致后台响应异常，然后前台可能显示为跨域限制错误</p><h3 id="奇怪的阻塞"><a href="#奇怪的阻塞" class="headerlink" title="奇怪的阻塞"></a>奇怪的阻塞</h3><h4 id="不带async"><a href="#不带async" class="headerlink" title="不带async"></a>不带async</h4><p>如下，执行顺序将为： 1 3 2 4。<br>首先打印1；<br>然后进入下个中间件，打印3；<br>因为加了await，所以下面的程序被阻塞了；<br>一旦阻塞，程序将先执行未被阻塞的 2，所以打印了2；<br>当get请求完毕，阻塞解除，执行4；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">     ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">     next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">await</span> axios.get(<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">    next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>上面这种执行顺序没有按照洋葱模型顺序执行，不是我们想要的，如何解决呢？</p><h4 id="带async"><a href="#带async" class="headerlink" title="带async"></a>带async</h4><p>其他不变，就下面的变化,打印顺序就是洋葱模型执行的正常顺序：<br>1 3 4 2<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span>(ctx, next)=&gt;&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">     ctx.body = <span class="string">'Hello World'</span>;</span><br><span class="line">     <span class="keyword">await</span> next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="保证洋葱模型-中间件必须带async、await"><a href="#保证洋葱模型-中间件必须带async、await" class="headerlink" title="保证洋葱模型-中间件必须带async、await"></a>保证洋葱模型-中间件必须带async、await</h3><p>具体参考《奇怪的阻塞》，为了保证中间件像洋葱模型的顺序一层一层执行程序，必须带上async、await。</p><h3 id="为什么要保证洋葱模型"><a href="#为什么要保证洋葱模型" class="headerlink" title="为什么要保证洋葱模型"></a>为什么要保证洋葱模型</h3><p>如果保证了洋葱模型，我们就可以确定，await next()之后，执行的代码肯定是后面中间件以及执行完成了的；<br>也就是说，console.log(2)肯定是下面的中间件程序执行完后才执行的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span>(ctx, next)=&gt;&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">await</span> next()</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">2</span>)<span class="comment">//保证这个打印是在下面所以中间件执行完成之后，才执行。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="koa2模块上"><a href="#koa2模块上" class="headerlink" title="koa2模块上"></a>koa2模块上</h2><h3 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h3><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const bodyparser = require(&apos;koa-bodyparser&apos;)</span><br><span class="line">const router = require(&apos;koa-router&apos;)()</span><br><span class="line">var cors = require(&apos;koa2-cors&apos;);</span><br><span class="line">const app = new Koa()</span><br><span class="line"> router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = `&lt;h1&gt;index page&lt;/h1&gt;`</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/home&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &apos;&lt;h1&gt;HOME page&lt;/h1&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">router.get(&apos;/404&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.body = &apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(cors()) // 解决跨域</span><br><span class="line">app.use(bodyparser())// 解析post参数</span><br><span class="line">app.use(router.routes())// 注册路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br><span class="line">app.listen(3000, ()=&gt;&#123;</span><br><span class="line">  console.log(&apos;server is running at http://localhost:3000&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关键 是在最后使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(router.routes())// 调用路由中间件</span><br><span class="line">app.use(router.allowedMethods())// 对异常状态码处理</span><br></pre></td></tr></table></figure></p><p>当然，如果你不想处理异常状态码，完全可以不使用router.allowedMethods(),单独使用router.routes()即可。</p><h4 id="模拟路由中间件"><a href="#模拟路由中间件" class="headerlink" title="模拟路由中间件"></a>模拟路由中间件</h4><p>下面模拟路由写的中间件，可以加深对路由中间件的理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Router&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this._routers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  get(url, handler)&#123;</span><br><span class="line">    this._routers.push(&#123;</span><br><span class="line">      url:url,</span><br><span class="line">      method:&apos;GET&apos;,</span><br><span class="line">      handler</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  routes()&#123;</span><br><span class="line">    return async (ctx, next) =&gt; &#123;</span><br><span class="line">      const &#123;method, url&#125; = ctx;</span><br><span class="line">      const matchedRouter = this._routers.find(r =&gt; r.method === method &amp;&amp; r.url === url);</span><br><span class="line">      if( matchedRouter &amp;&amp;</span><br><span class="line">        matchedRouter.handler)&#123;</span><br><span class="line">          await matchedRouter.handler(context, next);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          await next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="koa-static"><a href="#koa-static" class="headerlink" title="koa-static"></a>koa-static</h3><h4 id="介绍-和-demo"><a href="#介绍-和-demo" class="headerlink" title="介绍 和 demo"></a>介绍 和 demo</h4><p>koa-static是静态资源请求中间件，这里写了一个<a href="https://github.com/YeWills/koa-demo/tree/static-views" target="_blank" rel="noopener">简单的demo</a>，可启动感受下，下面以该demo源码作为示例讲解koa-static；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure></p><p>通过图片可以看出项目静态文件目录结构<br><figure class="image-box">                <img src="/image/koa2/static.jpg" alt="" title="" class="">                <p></p>            </figure></p><p>配置上面这句代码后，你讲可以在浏览器上运行可现实文件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:3000/css/style.css</span><br><span class="line">http://127.0.0.1:3000/img/films.jpg</span><br></pre></td></tr></table></figure></p><p>注意哦，不是 <a href="http://127.0.0.1:3000/pages/static/css/style.css" target="_blank" rel="noopener">http://127.0.0.1:3000/pages/static/css/style.css</a> !!这个地址是找不到的，很多刚用koa-static时都会犯这个错，认为就是handlePath(‘../pages/static’) 定义的url，然后就拼接成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这个地址是访问不到的</span><br><span class="line">http://127.0.0.1:3000/pages/static/css/style.css</span><br></pre></td></tr></table></figure></p><h4 id="理解koa-static"><a href="#理解koa-static" class="headerlink" title="理解koa-static"></a>理解koa-static</h4><p>koa-static是静态资源请求中间件，不过这样说，我们并不能直观理解koa-static是什么，原理是什么。<br>我们大可将koa-static看成是一个 为提供目录下每个文件 配置路由的中间件，<br>只要你提供一个文件的具体位置给koa-static，koa-static会结合路由的功能，为每个该文件位置下的文件配置一个 url 路由；<br>这个url路由其实就是一个普通的接口url，我们将这个普通的url输入浏览器，回车就可以看到改接口url的返回内容；</p><h4 id="koa-static是个批量配置接口url的中间件"><a href="#koa-static是个批量配置接口url的中间件" class="headerlink" title="koa-static是个批量配置接口url的中间件"></a>koa-static是个批量配置接口url的中间件</h4><p>所以，koa-static其实是一个很棒批量配置接口url的中间件，可以为你提供的文件目录下的所有文件批量配置好url接口，<br>你就可以轻松通过此url接口访问此文件。</p><h3 id="koa-views"><a href="#koa-views" class="headerlink" title="koa-views"></a>koa-views</h3><h4 id="介绍-和-demo-1"><a href="#介绍-和-demo-1" class="headerlink" title="介绍 和 demo"></a>介绍 和 demo</h4><p>如果我们只需要ctx.body只需要返回一段简单的代码如下，那么就用不到koa-views。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.response.body = &apos;&lt;h1&gt;404 Not Found&lt;/h1&gt;&apos;</span><br></pre></td></tr></table></figure></p><p>如果我们要ctx.response.body直接返回一个如下复杂的html，这个时候，再去拼接字符串太麻烦，<br>koa-views就是让body返回html变得简单，你直接单独定义好一个html，然后直接引用此html即可，非常方便。<br>koa-views可以用于<strong>普通的html文件</strong>，也可以用于模板引擎，用于模板引擎的时候，可通过ctx.state传值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let html = `</span><br><span class="line">  &lt;h1&gt;登录&lt;\h1&gt;</span><br><span class="line">  &lt;form method = &quot;POST&quot; action= &quot;/&quot;&gt;</span><br><span class="line">  &lt;p&gt;用户名&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;p&gt;密码&lt;/p&gt;</span><br><span class="line">  &lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  `</span><br><span class="line">  ctx.body=html;</span><br></pre></td></tr></table></figure></p><p>这里写了一个<a href="https://github.com/YeWills/koa-demo/tree/static-views" target="_blank" rel="noopener">简单的demo</a>，可启动感受下加深理解。<br>此demo和《koa-static》demo是同一个</p><h4 id="koa-views的使用"><a href="#koa-views的使用" class="headerlink" title="koa-views的使用"></a>koa-views的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const views = require(&apos;koa-views&apos;)</span><br><span class="line">app.use(views(handlePath(&apos;../pages&apos;)), &#123;</span><br><span class="line">  extension: &apos;html&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async (ctx) =&gt; &#123;</span><br><span class="line">  await ctx.render(&apos;index.html&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="render是koa-views集成到ctx的"><a href="#render是koa-views集成到ctx的" class="headerlink" title="render是koa-views集成到ctx的"></a>render是koa-views集成到ctx的</h4><p>如上的代码，ctx本身没有render方法，只是使用koa-views中间件后，ctx才有这个方法的</p><h4 id="index-html中静态文件的路径"><a href="#index-html中静态文件的路径" class="headerlink" title="index.html中静态文件的路径"></a>index.html中静态文件的路径</h4><p>请结合上面demo源码看(此demo和《koa-static》demo是同一个)<br>项目路径和请看参看 《koa-static》的图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(serve(handlePath(&apos;../pages/static&apos;)))</span><br></pre></td></tr></table></figure><p>我们在《koa-static》中知道css和jpg的访问接口url是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:3000/css/style.css</span><br><span class="line">http://127.0.0.1:3000/img/films.jpg</span><br></pre></td></tr></table></figure></p><p>此时，index.html的css和img的路径应该配置为如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">  &lt;title&gt;东成西就&lt;/title&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/style.css&quot;&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;films&quot;&gt;东成西就就是棒！&lt;/div&gt;</span><br><span class="line">  &lt;img src=&quot;/img/films.jpg&quot; /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h3><p>此中间件的作用 是 把POST请求的参数解析到ctx.request.body中，koa-bodyparser底层就是基于ctx.req.on实现的。<br>其他信息见《koa-bodyparser导致ctx.req.on事件失效》  《POST请求参数的获取》</p><h3 id="jsonwebtoken-与-koa-jwt"><a href="#jsonwebtoken-与-koa-jwt" class="headerlink" title="jsonwebtoken 与 koa-jwt"></a>jsonwebtoken 与 koa-jwt</h3><p>jsonwebtoken 简称 JWT，用来实现Token的生成、校验和解码。<br>使用koa-jwt中间件可以将 jsonwebtoken与koa有机结合起来。<br>jsonwebtoken 与 koa-jwt 的关系，就跟 redux 与react-redux的关系。<br><a href="https://github.com/YeWills/koa-demo/tree/router-Token" target="_blank" rel="noopener">这里是一个基于Token的鉴权demo</a>。</p><p>使用方法：<br>一般方案为：登录是，koa通过jsonwebtoken给用户一个Token编码，之后客户端发送请求时，在Header上都带上此Token码，<br>后端接受请求时，验证此Token码进行鉴权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const &#123; sign &#125; = require(&apos;jsonwebtoken&apos;);</span><br><span class="line">const secret = &apos;demo&apos;;</span><br><span class="line">const jwt = require(&apos;koa-jwt&apos;)(&#123; secret &#125;);</span><br><span class="line"></span><br><span class="line">//生成Token，secret作为密钥开发者自定义设置，expiresIn为失效时间，不要设置太久</span><br><span class="line">//登陆成功后，后台通过jsonwebtoken为该用户生成Token编码，</span><br><span class="line">//客户端拿到Token编码后，下次发请求时，在Header中带上Token码</span><br><span class="line">router.post(&apos;/api/login&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    const &#123; username &#125; = ctx.request.body;</span><br><span class="line">    const token = sign(&#123; username &#125;, secret, &#123; expiresIn: &apos;1h&apos; &#125;);</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      message: &apos;Get Token Success&apos;,</span><br><span class="line">      code: 1,</span><br><span class="line">      token</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)</span><br><span class="line">  //登录之后的接口请求，都要验证Token，所以都要在Header中将上一步登录是获得的Token传给后台</span><br><span class="line">    .get(&apos;/api/userInfo&apos;, jwt, async ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      username: ctx.state.user.username</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>http说的是 require(‘http’)模块。<br>koa利用http直接从服务端向其他服务器发起请求，<br>如下，koa服务端，接收到请求时，在路由函数体内，将请求参数重新组装，通过http，转发给对应服务器。<br>这种方法好处之一是避免跨域问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Http = require(&apos;http&apos;);</span><br><span class="line">router.get(&apos;/&apos;, async (ctx, next) =&gt; &#123;</span><br><span class="line">    let &#123; kw &#125; = ctx.query;</span><br><span class="line">    let resData = await new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">          //http://m.maoyan.com/ajax/search?kw=捉妖记&amp;cityId=10</span><br><span class="line">            Http.request(&#123;</span><br><span class="line">                hostname: &apos;m.maoyan.com&apos;,</span><br><span class="line">                path: &apos;/ajax/search?&apos; + Querystring.stringify(&#123;</span><br><span class="line">                    kw,</span><br><span class="line">                    cityId: 10</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;, (res) =&gt; &#123;</span><br><span class="line">                res.setEncoding(&apos;utf8&apos;);</span><br><span class="line">                let data = [];</span><br><span class="line">                res.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">                    data.push(chunk)</span><br><span class="line">                &#125;).on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">                    resolve(data.join(&apos;&apos;));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;).end();</span><br><span class="line">        &#125;);</span><br><span class="line">    ctx.body = Render(JSON.parse(resData), kw);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">完整http request的demo</a></p><h3 id="request-promise-native-request"><a href="#request-promise-native-request" class="headerlink" title="request-promise-native request"></a>request-promise-native request</h3><p>以下是自己对request-promise-native request的直观理解，没有深入研究，对不对待考：<br>request-promise-native 可能依赖 request，安装好request-promise-native会自动安装request，<br>所以request-promise-native 和request是一回事，request-promise-native是request的增强版，<br>他们都只做一件事，在服务器发起接口请求，与同为服务器发请求的http效果一样；<br>与浏览器端发请求的fetch axios功能一样，作用的环境不一样而已。</p><p>暂时不用过多了解，用时深究，这里有一个用到request-promise-native request的demo，<br><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">完整http request的demo</a>。</p><h3 id="koa-multer"><a href="#koa-multer" class="headerlink" title="koa-multer"></a>koa-multer</h3><p>express或koa，收到前台的上传请求后，因为上传文件的请求时一个多类型文件数据(multipart/form-data)请求，<br>必须通过require(‘multer’)才能正常处理这样的请求。<br>multer就是为了 处理多文件接口而生。<br>multer同koa-multer，去koa-multer的GitHub上，已经说明其文档直接参考express的multer。<br>更多参考《文件上传-file和drap拖拽两种方式》<br>koa-multer 用来做文件上传功能，需要配合 fs模块一起，比较简单，<a href="https://github.com/YeWills/koa-demo/tree/upload-file" target="_blank" rel="noopener">这是文件上传koa-multer 和fs demo</a>。</p><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p>demo和介绍，参考《koa-multer》《写一个返回文件的接口》，这两部分都有demo，使用fs做了一个文件上传和读取本地文件并返回给前台的功能</p><h2 id="koa2模块下"><a href="#koa2模块下" class="headerlink" title="koa2模块下"></a>koa2模块下</h2><h3 id="koa2-cors"><a href="#koa2-cors" class="headerlink" title="koa2-cors"></a>koa2-cors</h3><p>参考《koa2-cors解决跨域》</p><h3 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h3><p>querystring模块有以下作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Querystring = require(&apos;querystring&apos;)</span><br><span class="line">Querystring.escape(&apos;id=1&apos;) //返回 id%3D1</span><br><span class="line">Querystring.unescape(&apos;id%3D1&apos;) //返回 id=1</span><br><span class="line">querystring.parse(&apos;foo=bar&amp;abc=xyz&amp;abc=123&apos;) //返回 &#123;foo: &apos;bar&apos;,abc: [&apos;xyz&apos;, &apos;123&apos;]&#125;</span><br><span class="line">querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;) // 返回 &apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;</span><br></pre></td></tr></table></figure></p><p><a href="http://nodejs.cn/api/querystring.html" target="_blank" rel="noopener">更多点击官网</a></p><p><a href="https://github.com/YeWills/koa-demo/tree/http-request" target="_blank" rel="noopener">这里有一个querystring的demo</a></p><h3 id="koa-json、log4js、ip"><a href="#koa-json、log4js、ip" class="headerlink" title="koa-json、log4js、ip"></a>koa-json、log4js、ip</h3><p><a href="https://github.com/YeWills/koa-demo/tree/pro-static" target="_blank" rel="noopener">这里只放一个demo</a>，不深入了解，用到的时候再深究，此demo包含koa-static、log4js与ip、koa-json、koa-nunjucks</p><h3 id="koa-nunjucks"><a href="#koa-nunjucks" class="headerlink" title="koa-nunjucks"></a>koa-nunjucks</h3><p>koa-nunjucks是基于nunjucks的html 模板中间件。<br>没有什么太复杂的需求，只是用koa玩玩，如果不用html模板，用koa-views就可以了，如果要用html模板，可以用koa-nunjucks，当然也可以用ejs模板，等等，有很多这方面的模板。<br>这里只放一个demo，不过多解释，用到的时候再了解。<br><a href="https://github.com/YeWills/koa-demo/tree/web-pro" target="_blank" rel="noopener">koa-nunjucks的使用demo</a></p><h3 id="ejs-pug"><a href="#ejs-pug" class="headerlink" title="ejs pug"></a>ejs pug</h3><p>暂时不用过多了解，用时深究，<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">参见demo</a>。</p><h3 id="puppeteer-parcel-bundler-glob"><a href="#puppeteer-parcel-bundler-glob" class="headerlink" title="puppeteer parcel-bundler  glob"></a>puppeteer parcel-bundler  glob</h3><p>暂时不用过多了解，用时深究，<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">参见demo</a>。</p><h2 id="RESTfull-和-http"><a href="#RESTfull-和-http" class="headerlink" title="RESTfull 和  http"></a>RESTfull 和  http</h2><h3 id="RESTful-规范"><a href="#RESTful-规范" class="headerlink" title="RESTful 规范"></a>RESTful 规范</h3><p>非RESTful规范定义的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.get(/app/adduser)</span><br><span class="line">router.get(/app/edituser)</span><br><span class="line">router.get(/app/deleteuser)</span><br></pre></td></tr></table></figure></p><p>基于RESTful规范设计的API，全局只提供唯一的URI /app/user<br>设计如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.post(/app/user) //新增用户id</span><br><span class="line">router.edit(/app/user:id) 编辑名字为id的用户</span><br><span class="line">router.delete(/app/user:id) 删除名字为id的用户</span><br></pre></td></tr></table></figure></p><h3 id="URL-的7个部分组成："><a href="#URL-的7个部分组成：" class="headerlink" title="URL 的7个部分组成："></a>URL 的7个部分组成：</h3><p>scheme:[//[user[:password]@]host[:post][/path][?query][#fragemnt]<br>scheme:使用协议 如FTP、HTTP等<br>user[:password] : 表示访问资源的用户和密码，常见于FTP协议<br>host 主机<br>port 端口<br>path 访问资源路径<br>query 请求数据，以？开头<br>fragment 定位锚点，以#开头，可用于快速定位网页对应段落</p><h3 id="常用http状态码"><a href="#常用http状态码" class="headerlink" title="常用http状态码"></a>常用http状态码</h3><p>1<strong> 消息   100 继续，继续响应剩余部分，如已完成，可忽略<br>2</strong> 成功<br>3<strong> 重定向  301 永久移动； 302 临时移动； 304 未修改，请求资源对比上次没有修改<br>4</strong> 请求错误 401 未授权 ； 403 禁止； 404 未找到；<br>5<strong> 和 6</strong> 服务器错误  500 服务器内部错误； 503 服务不可用；</p><h2 id="相关demo"><a href="#相关demo" class="headerlink" title="相关demo"></a>相关demo</h2><h3 id="koa-demo"><a href="#koa-demo" class="headerlink" title="koa-demo"></a>koa-demo</h3><p>主要的示例demo:<a href="https://github.com/YeWills/koa-demo" target="_blank" rel="noopener">koa-demo</a>;</p><h3 id="koa2-films"><a href="#koa2-films" class="headerlink" title="koa2_films"></a>koa2_films</h3><p>很好的综合运行demo(含爬虫，mongodb，koa,前后端一体化编译开发):<a href="https://github.com/YeWills/koa2_films/tree/koa_web" target="_blank" rel="noopener">koa2_films/koa_web</a>,<br>此仓库其他分支还有单纯的 开发后台的分支;<br>也有单纯的爬虫demo：<a href="https://github.com/YeWills/koa2_films/tree/puppeteer" target="_blank" rel="noopener">爬虫小demo</a>；<br>还有一个分支为：<a href="https://github.com/YeWills/koa2_films/tree/event_IO_loop" target="_blank" rel="noopener">nodejs 异步io的理解 阻塞非阻塞，事件循环与驱动，单线程，子进程，进程通讯)events 框架demo</a>；<br><a href="https://github.com/YeWills/koa2_films/tree/forward-cors" target="_blank" rel="noopener">服务端截取请求向另外服务器发请求的demo</a>;</p><h3 id="films-new"><a href="#films-new" class="headerlink" title="films_new"></a>films_new</h3><p><a href="https://github.com/YeWills/react-redux-demo/tree/films_new" target="_blank" rel="noopener">films_new</a>是react-redux-demo仓库下的分支。<br>这是前端代码，用来像后台发起请求。</p><h3 id="koa-miniprogram"><a href="#koa-miniprogram" class="headerlink" title="koa-miniprogram"></a>koa-miniprogram</h3><p>此项目为微信开发，《koa与node.js开发实战》 书第九章以后的代码，在此仓库，我整理成单独几份，暂时没有微信学习，将源码整理备份，以备以后用。<br>其中<a href="https://github.com/YeWills/koa-miniprogram/tree/particle-css" target="_blank" rel="noopener">particle-css分支</a>挺好的一个css页面，同时还有超炫背景粒子-particlesJS插件的使用 效果：</p><h2 id="参考和学习资料"><a href="#参考和学习资料" class="headerlink" title="参考和学习资料"></a>参考和学习资料</h2><p><a href="">koa与node.js开发实战</a><br><a href="">Koa2框架从0开始构建预告片网站</a><br><a href="https://koajs.com/#context" target="_blank" rel="noopener">koa 官网</a><br><a href="https://github.com/koajs/koa#readme" target="_blank" rel="noopener">koa github </a><br><a href="https://github.com/YeWills/examples" target="_blank" rel="noopener">koa example，挺好的官方示例，比较全，做需求时可先在这找示例</a><br><a href="https://www.jianshu.com/p/d3afa36aa17a" target="_blank" rel="noopener">koa2入门笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> koa2 </tag>
            
            <tag> 鉴权 </tag>
            
            <tag> content-type </tag>
            
            <tag> RESTfull </tag>
            
            <tag> 解决跨域 </tag>
            
            <tag> 截取前端请求 </tag>
            
            <tag> 服务端转发请求 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用算法</title>
      <link href="/2019/04/09/calc/"/>
      <url>/2019/04/09/calc/</url>
      
        <content type="html"><![CDATA[<h2 id="阅读说明"><a href="#阅读说明" class="headerlink" title="阅读说明"></a>阅读说明</h2><p>为了让每个算法模块能够有更多的的目录层级，本文直接将各模块单列出一个章节讲，这样的弊端是，知识点看起来比较乱，<br>一眼看不出他们对应的是什么算法内容。<br>所以本章节用于将各章节对应的算法知识点，进行目录分类。具体模块内容请跳转到相关章节看。</p><p>算法模块：</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="电话号码"><a href="#电话号码" class="headerlink" title="电话号码"></a>电话号码</h4><h4 id="卡牌分组"><a href="#卡牌分组" class="headerlink" title="卡牌分组"></a>卡牌分组</h4><h4 id="种花问题"><a href="#种花问题" class="headerlink" title="种花问题"></a>种花问题</h4><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h4 id="最大间距-冒泡排序实现"><a href="#最大间距-冒泡排序实现" class="headerlink" title="最大间距 (冒泡排序实现)"></a>最大间距 (冒泡排序实现)</h4><h4 id="数组中的第K个最大元素-冒泡排序实现"><a href="#数组中的第K个最大元素-冒泡排序实现" class="headerlink" title="数组中的第K个最大元素 (冒泡排序实现)"></a>数组中的第K个最大元素 (冒泡排序实现)</h4><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="复原ip地址"><a href="#复原ip地址" class="headerlink" title="复原ip地址"></a>复原ip地址</h4><h4 id="递归阶乘"><a href="#递归阶乘" class="headerlink" title="递归阶乘"></a>递归阶乘</h4><h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h4><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><p><strong>基础算法篇</strong></p><h2 id="电话号码-1"><a href="#电话号码-1" class="headerlink" title="电话号码"></a>电话号码</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">力扣原题 – 电话号码的字母组合</a><br>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function calc(str) &#123;</span><br><span class="line">     let map = [&apos;&apos;, 1, &apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;, &apos;jkl&apos;, &apos;mno&apos;, &apos;pqrs&apos;, &apos;tuv&apos;, &apos;wxyz&apos;]</span><br><span class="line">     let num = str.split(&apos;&apos;)</span><br><span class="line">     let code = []</span><br><span class="line">     num.forEach(item =&gt; &#123;</span><br><span class="line">       if (map[item]) &#123;</span><br><span class="line">         code.push(map[item])</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     let comb = (arr) =&gt; &#123;</span><br><span class="line">       // 临时变量用来保存前两个组合的结果</span><br><span class="line">       let tmp = []</span><br><span class="line">       // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素</span><br><span class="line">       for (let i = 0; i &lt; arr[0].length; i++) &#123;</span><br><span class="line">         for (let j = 0; j &lt; arr[1].length; j++) &#123;</span><br><span class="line">           tmp.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       arr.splice(0, 2, tmp)</span><br><span class="line">       if (arr.length &gt; 1) &#123;</span><br><span class="line">         comb(arr)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         return tmp</span><br><span class="line">       &#125;</span><br><span class="line">       return arr[0]</span><br><span class="line">     &#125;</span><br><span class="line">     return comb(code)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //calc(&apos;32&apos;)</span><br></pre></td></tr></table></figure></p><p>现在对上面方法进行思路和要点解析</p><h3 id="每次只让第一个和第二个元素两两组合"><a href="#每次只让第一个和第二个元素两两组合" class="headerlink" title="每次只让第一个和第二个元素两两组合"></a>每次只让第一个和第二个元素两两组合</h3><p>不管输入多少位数，都让前两位数字进行组合，组合的结果 再跟 第三位数字进行组合，逻辑一样，依次类推。 逻辑一样的部分，则突出了使用递归的需求。<br><figure class="image-box">                <img src="/image/calc/phone.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="递归是重头戏"><a href="#递归是重头戏" class="headerlink" title="递归是重头戏"></a>递归是重头戏</h3><p>参考上面《两两组合》</p><h3 id="return-arr-0-很需要"><a href="#return-arr-0-很需要" class="headerlink" title="return arr[0] 很需要"></a>return arr[0] 很需要</h3><p>咋一看，觉得这一句不需要，以为有 if else，就不会走到 return arr[0]。这也是我误解的，其实下面的comb(arr)递归，执行完后，就会执行后面的return arr[0]。<br>以上也是我对于递归的误区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (arr.length &gt; 1) &#123;</span><br><span class="line">       comb(arr)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       return tmp</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">return arr[0]</span><br></pre></td></tr></table></figure></p><h3 id="递归完了还会往下执行"><a href="#递归完了还会往下执行" class="headerlink" title="递归完了还会往下执行"></a>递归完了还会往下执行</h3><p>参考上面 《return arr[0] 很需要》</p><h3 id="解决方法优化"><a href="#解决方法优化" class="headerlink" title="解决方法优化"></a>解决方法优化</h3><p>上面解决代码中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (arr.length &gt; 1) &#123;</span><br><span class="line">         comb(arr)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         //带有一定歧义</span><br><span class="line">         return tmp</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>可写成如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function calc(str) &#123;</span><br><span class="line">   let map = [&apos;&apos;, 1, &apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;, &apos;jkl&apos;, &apos;mno&apos;, &apos;pqrs&apos;, &apos;tuv&apos;, &apos;wxyz&apos;]</span><br><span class="line">   let num = str.split(&apos;&apos;)</span><br><span class="line">   let code = []</span><br><span class="line">   num.forEach(item =&gt; &#123;</span><br><span class="line">     if (map[item]) &#123;</span><br><span class="line">       code.push(map[item])</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   let comb = (arr) =&gt; &#123;</span><br><span class="line">     // 临时变量用来保存前两个组合的结果</span><br><span class="line">     let tmp = []</span><br><span class="line">     // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素</span><br><span class="line">     for (let i = 0; i &lt; arr[0].length; i++) &#123;</span><br><span class="line">       for (let j = 0; j &lt; arr[1].length; j++) &#123;</span><br><span class="line">         tmp.push(`$&#123;arr[0][i]&#125;$&#123;arr[1][j]&#125;`)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     arr.splice(0, 2, tmp)</span><br><span class="line">     if (arr.length &gt; 1) &#123;</span><br><span class="line">       return comb(arr)</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">       return arr[0]</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return comb(code)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="再一次优化"><a href="#再一次优化" class="headerlink" title="再一次优化"></a>再一次优化</h3><p>上面的代码看起来有点晕，下面将两两组合的逻辑提出来，让代码更清晰，本次优化的逻辑与上面是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function combile(a1,b1)&#123;</span><br><span class="line">    let arr=[];</span><br><span class="line">    a1.forEach(ai=&gt;&#123;</span><br><span class="line">        b1.forEach(bi=&gt;&#123;</span><br><span class="line">            arr.push(`$&#123;ai&#125;$&#123;bi&#125;`);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">function calc1(str)&#123;</span><br><span class="line">   let map = [&apos;&apos;, 1, &apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;, &apos;jkl&apos;, &apos;mno&apos;, &apos;pqrs&apos;, &apos;tuv&apos;, &apos;wxyz&apos;];</span><br><span class="line">   const allStr = str.split(&apos;&apos;).map(num=&gt;map[Number(num)]);</span><br><span class="line">   const cur = (strarr)=&gt;&#123;</span><br><span class="line">     //第一次strarr[0]是一个字符串， 以后strarr[0]经过splice后，都是数组</span><br><span class="line">    const one = typeof strarr[0] === &apos;string&apos; ? strarr[0].split(&apos;&apos;) : strarr[0];</span><br><span class="line">    const two = strarr[1].split(&apos;&apos;);</span><br><span class="line">    const newItem0 = combile(one, two);</span><br><span class="line">    strarr.splice(0,2,newItem0);</span><br><span class="line">       if(strarr.length&lt;2)&#123;</span><br><span class="line">           return strarr[0];</span><br><span class="line">       &#125;</span><br><span class="line">     return cur(strarr)</span><br><span class="line">   &#125;</span><br><span class="line">  return cur(allStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="考察算法要点"><a href="#考察算法要点" class="headerlink" title="考察算法要点"></a>考察算法要点</h3><p>给定一个数组，如何让内部元素两两组和，返回一个全组合结果；<br>其核心思想是，不管数组有多少元素，每次只让第一个元素和第二个元素两两组和；<br>递归以上行为，经过递归后，最终数组只有一个元素。这个元素就是组合结果。<br>所以核心是第一个和第二个两两组和；<br>技术实施是递归；<br>利用的原则是数组两两组和到最后必然只有一个元素；</p><h2 id="卡牌分组-1"><a href="#卡牌分组-1" class="headerlink" title="卡牌分组"></a>卡牌分组</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>给定一副牌，每张牌上都写着一个整数。<br>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：<br>每组都有 X 张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X &gt;= 2 时返回 true。<br><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards" target="_blank" rel="noopener">力扣原题 – 卡牌分组</a></p><p>用白话解释原题：给定一副牌，这副牌可以是1张或1万张，将这副牌分成一组或多组，每组牌的数字都相同，每组牌的个数不少于2.</p><h3 id="解法一：-数组前后两两比较"><a href="#解法一：-数组前后两两比较" class="headerlink" title="解法一： 数组前后两两比较"></a>解法一： 数组前后两两比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr) &#123;</span><br><span class="line">      // 将卡牌按值排序保证相同的卡牌是挨着的</span><br><span class="line">      let str = arr.sort((a, b) =&gt; a - b).join(&apos;&apos;)</span><br><span class="line">      // 分组(单张或者多张)  \1 在正则中表示连续一样的匹配</span><br><span class="line">      let group = str.match(/(\d)\1+|\d/g)</span><br><span class="line">      // 求两个数的最大公约数</span><br><span class="line">      let gcd = (a, b) =&gt; &#123;    </span><br><span class="line">        if(b === 0)  return a;   </span><br><span class="line">        return gcd(b, a % b)</span><br><span class="line">       &#125;</span><br><span class="line">      // 思想：只要所有的分组具有最大公约数(大于1)就满足条件</span><br><span class="line">      // 对所有的分组进行最大公约数验证，相邻两个分组的最大公约数，再与后面的公约数进行验证，以此类推，有一个最大公约数为1就退出</span><br><span class="line">      while (group.length &gt; 1) &#123;</span><br><span class="line">        let a = group.shift().length</span><br><span class="line">        let b = group.shift().length</span><br><span class="line">        let v = gcd(a, b)</span><br><span class="line">        if (v === 1) &#123;</span><br><span class="line">          return false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 将前两个分组的最大公约数推进数组与下一个分组再次验证是否有最大公约数</span><br><span class="line">          group.unshift(&apos;0&apos;.repeat(v))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 考虑边界[&apos;11&apos;]即只有一个分组的时候</span><br><span class="line">      return group.length ? group[0].length &gt; 1 : false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>下面是最大公约数的求法，可以不必理解，知道这样用就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let gcd = (a, b) =&gt; &#123;    </span><br><span class="line">    if(b === 0)  return a;   </span><br><span class="line">    return gcd(b, a % b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最大公约数除了1值外，其他值都合法"><a href="#最大公约数除了1值外，其他值都合法" class="headerlink" title="最大公约数除了1值外，其他值都合法"></a>最大公约数除了1值外，其他值都合法</h4><h3 id="数组前后两两比较"><a href="#数组前后两两比较" class="headerlink" title="数组前后两两比较"></a>数组前后两两比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (group.length &gt; 1) &#123;</span><br><span class="line">        let a = group.shift().length</span><br><span class="line">        let b = group.shift().length</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="找出元素出现次数的方法-推荐-–match正则"><a href="#找出元素出现次数的方法-推荐-–match正则" class="headerlink" title="找出元素出现次数的方法(推荐)–match正则"></a>找出元素出现次数的方法(推荐)–match正则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 分组(单张或者多张)  \1 在正则中表示连续一样的匹配</span><br><span class="line"> let group = str.match(/(\d)\1+|\d/g)</span><br></pre></td></tr></table></figure><h3 id="找出元素出现次数的方法–object-key方式"><a href="#找出元素出现次数的方法–object-key方式" class="headerlink" title="找出元素出现次数的方法–object key方式"></a>找出元素出现次数的方法–object key方式</h3><p>参考下面的《最小相同数与所有相同数比较的 实现方式》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const hash = deck.reduce((pre, num) =&gt; &#123;    //统计出每种数字的数目</span><br><span class="line">  if(!pre[num]) &#123;</span><br><span class="line">    pre[num] = 1</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    pre[num]++</span><br><span class="line">  &#125;</span><br><span class="line">  return pre</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="while-实现-递归效果"><a href="#while-实现-递归效果" class="headerlink" title="while 实现 递归效果"></a>while 实现 递归效果</h3><p>见上面的代码。</p><h3 id="解法一优化：用递归代替while写法"><a href="#解法一优化：用递归代替while写法" class="headerlink" title="解法一优化：用递归代替while写法"></a>解法一优化：用递归代替while写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr) &#123;</span><br><span class="line">     let str = arr.sort((a, b) =&gt; a - b).join(&apos;&apos;)</span><br><span class="line">     let group = str.match(/(\d)\1+|\d/g)</span><br><span class="line">     let gcd = (a, b) =&gt; &#123;    </span><br><span class="line">       if(b === 0)  return a;   </span><br><span class="line">       return gcd(b, a % b)</span><br><span class="line">      &#125;</span><br><span class="line">      const cur = (arr)=&gt;&#123;</span><br><span class="line">        if(arr.length&lt;2)&#123;</span><br><span class="line">          return arr[0].length &gt; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        const one = arr.shift().length;</span><br><span class="line">        const two = arr.shift().length;</span><br><span class="line">        let v = gcd(one, two);</span><br><span class="line">        if (v === 1) &#123;</span><br><span class="line">         return false</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         arr.unshift(&apos;0&apos;.repeat(v));</span><br><span class="line">        return cur(arr);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     return cur(group);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="解法二：最小相同数与所有相同数比较"><a href="#解法二：最小相同数与所有相同数比较" class="headerlink" title="解法二：最小相同数与所有相同数比较"></a>解法二：最小相同数与所有相同数比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var hasGroupsSizeX = function(deck) &#123;</span><br><span class="line">  let getResult = (a, b) =&gt; &#123;    //定义一个寻找公约数的方法</span><br><span class="line">    if(b === 0)  return a;   </span><br><span class="line">    return getResult(b, a % b)</span><br><span class="line">  &#125;</span><br><span class="line">  const hash = deck.reduce((pre, num) =&gt; &#123;    //统计出每种数字的数目</span><br><span class="line">    if(!pre[num]) &#123;</span><br><span class="line">      pre[num] = 1</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      pre[num]++</span><br><span class="line">    &#125;</span><br><span class="line">    return pre</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">  const numCount = Object.values(hash)     //将hash中的每项数值存入数组，便于后续遍历</span><br><span class="line">  const min = numCount.sort((a, b) =&gt; a-b)[0];         //利用数组排序快速获取最小值</span><br><span class="line">  if (min &lt; 2) return false; //根据题意，如果最分组最小数量小于2，直接返回false</span><br><span class="line">  return !numCount.some((item,index) =&gt; &#123;</span><br><span class="line">    if(index &gt; 0) return getResult(item, min) === 1</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两种方案的利弊"><a href="#两种方案的利弊" class="headerlink" title="两种方案的利弊"></a>两种方案的利弊</h3><p>尽管两种方法都能实现，但是解法一比解法二节省了一次遍历，当数据量大时，这种性能上的差别就会比较大，所以推荐第一种方案。</p><h2 id="种花问题-1"><a href="#种花问题-1" class="headerlink" title="种花问题"></a>种花问题</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。<br>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花，算出n的最大值。<br><a href="https://leetcode-cn.com/problems/can-place-flowers" target="_blank" rel="noopener">力扣原题 – 种花问题</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr)&#123;</span><br><span class="line">    // 计数器</span><br><span class="line">    let max = 0</span><br><span class="line">    for (let i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">      //只有arr[i] === 0时，说明可以种花，因此只需考虑arr[i] === 0的逻辑，其他情况不用考虑</span><br><span class="line">      if (arr[i] === 0) &#123;</span><br><span class="line">        //当 arr[i] === 0 时都符合条件，唯有边界值 i===0 与 i === arr.length-2 时需要特殊考虑</span><br><span class="line">        if (i === 0 &amp;&amp; arr[1] === 0) &#123;</span><br><span class="line">          max++</span><br><span class="line">          //跳转，这里i++，加上for循环自动也++，所以i实际加了2</span><br><span class="line">          i++</span><br><span class="line">        &#125; else if (i === arr.length-2 &amp;&amp; arr[arr.length-1] === 0) &#123;</span><br><span class="line">          max++</span><br><span class="line">        &#125;else if (arr[i - 1] === 0 &amp;&amp; arr[i + 1] === 0) &#123;</span><br><span class="line">          max++</span><br><span class="line">           //跳转，这里i++，加上for循环自动也++，所以i实际加了2</span><br><span class="line">          i++</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  calc([1, 0, 0, 0, 1, 0, 0])// 2</span><br><span class="line">  calc([1, 0, 0, 0, 1])//1</span><br><span class="line">  calc([0,0,1, 0, 0, 0, 1])//2</span><br></pre></td></tr></table></figure><h3 id="要点分析"><a href="#要点分析" class="headerlink" title="要点分析"></a>要点分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,0,0,0,0,0,0,0,1]</span><br></pre></td></tr></table></figure><p>其实就是在数组中找000的模型，有000就可以变成010，达到要求。<br>另外一个要考虑的是边界问题，比如，[0,0,1]，这不符合 000，但依然可以在最左侧加1；<br>这种问题其实就是在数组中找 000 这种模型，就涉及到用数学建模的思想来解决。</p><h3 id="核心一：-000的数学建模"><a href="#核心一：-000的数学建模" class="headerlink" title="核心一： 000的数学建模"></a>核心一： 000的数学建模</h3><p>以后遇到类似的找这种000的形式的东西，就考虑用数学建模。</p><h3 id="核心二：-遍历"><a href="#核心二：-遍历" class="headerlink" title="核心二： 遍历"></a>核心二： 遍历</h3><p>种花问题，主要运用遍历来解决，使用了很多遍历技巧，比如跳级忽略遍历，以及i+1等的处理，<br>i+1的遍历技巧本质上就是多个遍历元素的技巧；<br>因为一般遍历元素只有一个arr[i]（姑且称这种遍历为单元遍历）,多个遍历元素是指遍历体中同时存在 arr[i] arr[i+n] （多元遍历）。</p><h3 id="单元遍历-与-多元遍历"><a href="#单元遍历-与-多元遍历" class="headerlink" title="单元遍历 与 多元遍历"></a>单元遍历 与 多元遍历</h3><p>参考《核心二： 遍历》</p><h3 id="遍历体用-i-跳级忽略遍历"><a href="#遍历体用-i-跳级忽略遍历" class="headerlink" title="遍历体用 i++ 跳级忽略遍历"></a>遍历体用 i++ 跳级忽略遍历</h3><p>例如下面的，index位置 1 2 3 符合 000；<br>2 3 4 也符合 000；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,0,0,0,0,1]</span><br></pre></td></tr></table></figure></p><p>但实际上当遍历了index 123后，下一次只要求遍历index 345；<br>如何做到呢，可通过在for循环内，i++ :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0, len = arr.length - 1; i &lt; len; i++) &#123;</span><br><span class="line">   //跳转，这里i++，加上for循环自动也++，所以i实际加了2</span><br><span class="line">   i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h3><p>参考《要点分析》</p><h3 id="arr-i-1-与arr-i-1-的遍历技巧"><a href="#arr-i-1-与arr-i-1-的遍历技巧" class="headerlink" title="arr[i+1]与arr[i-1]的遍历技巧"></a>arr[i+1]与arr[i-1]的遍历技巧</h3><h4 id="arr-i-1-与-arr-i-1-与-i-lt-arr-length-1-的妙用"><a href="#arr-i-1-与-arr-i-1-与-i-lt-arr-length-1-的妙用" class="headerlink" title="arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用"></a>arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用</h4><p>因为for循环体内用了arr[i+1]，那么在for的title上能遍历的最大值是 arr.length - 2，也就是i &lt; arr.length - 1；<br>这个是一个很实用的用法，我们在写for循环时，如果for循环体内有这样的情况，就应该考虑好for的title上最大的i &lt; arr.length值也应响应配合增加或减少。并且这个最大的arr.length值到底多少<strong>与函数体内最大的arr[i+1]有关，而与arr[i-1]无关。</strong>，当然，如果用到arr[i-1]时，<strong>就要考虑边界值的问题</strong>，也就是当i为0时的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">       ...</span><br><span class="line">         &#125; else if (arr[i - 1] === 0 &amp;&amp; arr[i + 1] === 0) &#123;</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><h4 id="arr-i-1-时考虑边界值，arr-i-1-时考虑i值最大值"><a href="#arr-i-1-时考虑边界值，arr-i-1-时考虑i值最大值" class="headerlink" title="arr[i-1]时考虑边界值，arr[i-1]时考虑i值最大值"></a>arr[i-1]时考虑边界值，arr[i-1]时考虑i值最大值</h4><p>参考《arr[i-1] 与 arr[i+1] 与 i&lt;arr.length-1 的妙用》</p><h3 id="遍历的经典练习题"><a href="#遍历的经典练习题" class="headerlink" title="遍历的经典练习题"></a>遍历的经典练习题</h3><p>种花问题基于遍历实现，用到了比较多的遍历技巧，可称为经典遍历的运用练习题。</p><h2 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>冒泡排序大白话解释就是，将数组内的最大值，从左到右或右带左地排序，这个过程好像数组内的最大值好像冒泡一样，从水底上浮的过程。<br>冒泡排序是每次比较左右两个值，每次进行比较交换位置。<br><figure class="image-box">                <img src="/image/calc/water.jpg" alt="" title="" class="">                <p></p>            </figure><br>如下图，要实现如下的一个渐进的排序过程：<br><figure class="image-box">                <img src="/image/calc/bubble.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/calc/bubble1.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/calc/bubble2.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="将最值移到边缘的技巧"><a href="#将最值移到边缘的技巧" class="headerlink" title="将最值移到边缘的技巧"></a>将最值移到边缘的技巧</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">let</span> c = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">            arr[j + <span class="number">1</span>] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="排序是最值移动的多次重复"><a href="#排序是最值移动的多次重复" class="headerlink" title="排序是最值移动的多次重复"></a>排序是最值移动的多次重复</h3><p>既然有一种算法可以将最值移动至边缘，那么这种算法就构成了排序的可能，我们可以将最值移动称之为排序的最小组成。<br>就好比，复杂的现象 无非都是 将简单的现象重复多遍的结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">let</span> c = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">            arr[j + <span class="number">1</span>] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calc([<span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">999</span>,<span class="number">6</span>]) <span class="comment">//[0, 1, 2, 3, 4, 5, 6, 9, 999]</span></span><br></pre></td></tr></table></figure></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过最值移动，将最值移至边缘，那么下次遍历的时候，只需排除这个最值，将剩余的元素重复最值的移动。<br>现在最值移动的算法我们已经知道了，要做的是，每次最值移动时不包含边缘的最值。</p><h3 id="处理i-1-遍历的技巧"><a href="#处理i-1-遍历的技巧" class="headerlink" title="处理i+1 遍历的技巧"></a>处理i+1 遍历的技巧</h3><p>参考 《将最值移到边缘的技巧》</p><h2 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="概述-以及-选择、冒泡区别"><a href="#概述-以及-选择、冒泡区别" class="headerlink" title="概述 以及 选择、冒泡区别"></a>概述 以及 选择、冒泡区别</h3><figure class="image-box">                <img src="/image/calc/select-dubble.jpeg" alt="" title="" class="">                <p></p>            </figure><p>如下图，要实现如下的一个渐进的排序过程：<br><figure class="image-box">                <img src="/image/calc/select.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/calc/select1.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="选定第1个位置放置最小值"><a href="#选定第1个位置放置最小值" class="headerlink" title="选定第1个位置放置最小值"></a>选定第1个位置放置最小值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var i = 0 //第1个位置</span><br><span class="line"> for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">          if (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">            let c = arr[i]</span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            arr[j] = c</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="选定第2个位置放置剩余数组的最小值"><a href="#选定第2个位置放置剩余数组的最小值" class="headerlink" title="选定第2个位置放置剩余数组的最小值"></a>选定第2个位置放置剩余数组的最小值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var i = 1 //第2个位置</span><br><span class="line"> for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">          if (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">            let c = arr[i]</span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            arr[j] = c</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>将上面选定位置最值算法重复多遍，就达到排序的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function calc(arr) &#123;</span><br><span class="line">      // 选择排序</span><br><span class="line">      for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">          if (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">            let c = arr[i]</span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            arr[j] = c</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return arr</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a>最大间距</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><a href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" rel="noopener">力扣原题 – 最大间距</a><br>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>如果数组元素个数小于 2，则返回 0。</p><h3 id="推荐方法"><a href="#推荐方法" class="headerlink" title="推荐方法"></a>推荐方法</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>这种题一般通过排序完成，并且在排序的过程中，获取最大值，以下通过 冒泡排序的方式来做，主要利用冒泡的时候，其他已经逐步排序好最大值了，利用这逐步排序好的最大值，逐步求出间距：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getDistance(a, b, max) &#123;</span><br><span class="line">     const num = a - b;</span><br><span class="line">     if (max &lt; num) &#123;</span><br><span class="line">       max = Math.abs(num);</span><br><span class="line">     &#125;</span><br><span class="line">     return max;</span><br><span class="line">   &#125;</span><br><span class="line">   function calc(arr) &#123;</span><br><span class="line">     let max=0;</span><br><span class="line">     for (let i = arr.length - 1, tmp; i &gt; 0; i--) &#123;</span><br><span class="line">       for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">         if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">           let c = arr[j];</span><br><span class="line">           arr[j] = arr[j + 1];</span><br><span class="line">           arr[j + 1] = c;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (i &lt; (arr.length - 1)) &#123;</span><br><span class="line">         max = getDistance(arr[i + 1], arr[i], max);</span><br><span class="line">         if (i === 1) &#123;</span><br><span class="line">           max = getDistance(arr[1], arr[0], max);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="边界处理"><a href="#边界处理" class="headerlink" title="边界处理"></a>边界处理</h4><p>当i === (arr.length - 2)与i=1时需要处理不同逻辑。</p><h3 id="借助冒泡或选择排序实现"><a href="#借助冒泡或选择排序实现" class="headerlink" title="借助冒泡或选择排序实现"></a>借助冒泡或选择排序实现</h3><p>如上代码，因为冒泡或选择排序是，最左或最右端值已经排序好，排序好的就可以计算差值。所以可利用这一特性，找出最大间距。</p><h3 id="不推荐方法"><a href="#不推荐方法" class="headerlink" title="不推荐方法"></a>不推荐方法</h3><p>不推荐理由，利用sort进行了一次遍历，然后又用遍历求最大间距，用了两次遍历，相比上面的推荐方法的一次遍历，这种方法性能不好。<br><figure class="image-box">                <img src="/image/calc/max.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="遍历是核心"><a href="#遍历是核心" class="headerlink" title="遍历是核心"></a>遍历是核心</h3><p>最大间距的解决主要借助遍历实现。</p><h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">力扣原题 – 数组中的第K个最大元素</a><br>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>示例 1:<br>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5<br>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4<br>说明:</p><p>先说不推荐方法</p><h3 id="不推荐方法-1"><a href="#不推荐方法-1" class="headerlink" title="不推荐方法"></a>不推荐方法</h3><p>这种方法非常容易理解，但是却有浪费之嫌，因为根本不需要对整个数组先排序再查找，因为一旦找到第k个值，就可以停止程序了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default (arr, k) =&gt; &#123;</span><br><span class="line">  return arr.sort((a, b) =&gt; b - a)[k - 1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="推荐方法-1"><a href="#推荐方法-1" class="headerlink" title="推荐方法"></a>推荐方法</h3><p>利用冒泡排序来做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default (arr, k) =&gt; &#123;</span><br><span class="line">  let len = arr.length - 1</span><br><span class="line">  for (let i = len, tmp; i &gt; len - k; i--) &#123;</span><br><span class="line">    for (let j = 0; j &lt; i; j++) &#123;</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">        tmp = arr[j]</span><br><span class="line">        arr[j] = arr[j + 1]</span><br><span class="line">        arr[j + 1] = tmp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // arr[len+1-k]</span><br><span class="line">  return arr[len - (k - 1)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="借助冒泡或选择排序实现-1"><a href="#借助冒泡或选择排序实现-1" class="headerlink" title="借助冒泡或选择排序实现"></a>借助冒泡或选择排序实现</h3><p>如上代码，因为冒泡或选择排序是，最左或最右端值已经排序好，排序到第k个时，马上停止遍历，有助于性能。</p><h2 id="快速排序-最好的排序方式"><a href="#快速排序-最好的排序方式" class="headerlink" title="快速排序(最好的排序方式)"></a>快速排序(最好的排序方式)</h2><h3 id="要点分析-1"><a href="#要点分析-1" class="headerlink" title="要点分析"></a>要点分析</h3><p>快速排序，以数组中间一个元素为基准，小于的放在左边，大于的放在右边，然后递归，排序完成。<br><figure class="image-box">                <img src="/image/calc/quick0.jpg" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(ary)&#123;</span><br><span class="line">       if(ary.length&lt;=1)&#123;</span><br><span class="line">           return ary;</span><br><span class="line">       &#125;</span><br><span class="line">       var pointIndex = Math.floor(ary.length/2);</span><br><span class="line">       //从ary中删除pointIndex，并且通过[0]取出pointValue值</span><br><span class="line">       var pointValue = ary.splice(pointIndex, 1)[0];</span><br><span class="line">       var left = [];</span><br><span class="line">       var right = [];</span><br><span class="line">       for (var i=0; i&lt;ary.length; i++)&#123;</span><br><span class="line">           var cur = ary[i];</span><br><span class="line">           cur &lt; pointValue ? left.push(cur) : right.push(cur);</span><br><span class="line">       &#125;</span><br><span class="line">       return quickSort(left).concat([pointValue],quickSort(right));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="中间元素，左右两边分组"><a href="#中间元素，左右两边分组" class="headerlink" title="中间元素，左右两边分组"></a>中间元素，左右两边分组</h3><p>快速排序是选一个数组中间元素值为准，左右分两组，这种操作类似易经大衍筮法占卜的手法。<br>不过快速排序不是一定要数组中间值，任意一个元素为准都可以，只是推荐使用中间元素。</p><h3 id="推荐使用中间元素-但也可使用其他元素"><a href="#推荐使用中间元素-但也可使用其他元素" class="headerlink" title="推荐使用中间元素,但也可使用其他元素"></a>推荐使用中间元素,但也可使用其他元素</h3><p>这里有一个以其他元素为准的快速排序写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    if (arr.length &lt;= 1) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    let leftArr = [];</span><br><span class="line">    let rightArr = [];</span><br><span class="line">    let q = arr[0];</span><br><span class="line">    for (let i = 1, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">        if (arr[i] &gt; q) &#123;</span><br><span class="line">            rightArr.push(arr[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            leftArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    return [].concat(quickSort(leftArr), [q], quickSort(rightArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="递归的经典运用"><a href="#递归的经典运用" class="headerlink" title="递归的经典运用"></a>递归的经典运用</h3><p>递归是快速排序的核心，如果无法理解，暂且就记住这种场景解法，用多了，自然就有了这种逻辑思维了。</p><h3 id="递归最后呈现的由最后的边界值决定"><a href="#递归最后呈现的由最后的边界值决定" class="headerlink" title="递归最后呈现的由最后的边界值决定"></a>递归最后呈现的由最后的边界值决定</h3><p>比如上面的代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">ary</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(ary.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> ary;<span class="comment">//这是边界值</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> pointIndex = <span class="built_in">Math</span>.floor(ary.length/<span class="number">2</span>);</span><br><span class="line">       <span class="comment">//从ary中删除pointIndex，并且通过[0]取出pointValue值</span></span><br><span class="line">       <span class="keyword">var</span> pointValue = ary.splice(pointIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">var</span> left = [];</span><br><span class="line">       <span class="keyword">var</span> right = [];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ary.length; i++)&#123;</span><br><span class="line">           <span class="keyword">var</span> cur = ary[i];</span><br><span class="line">           cur &lt; pointValue ? left.push(cur) : right.push(cur);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> quickSort(left).concat([pointValue],quickSort(right));<span class="comment">//return 表达式</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>无论quickSort(left)递归了多少次，quickSort(left)的值，肯定是 ary ，<br>同理，quickSort(right))的值，肯定是 ary。</p><h3 id="递归结果是边界值与return表达式作用的结果"><a href="#递归结果是边界值与return表达式作用的结果" class="headerlink" title="递归结果是边界值与return表达式作用的结果"></a>递归结果是边界值与return表达式作用的结果</h3><p>因此，无论怎么样，quickSort(ary)执行的结果，必将形式如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quickSort(left).concat([pointValue],quickSort(right))</span><br></pre></td></tr></table></figure></p><p>经过上面的分析，quickSort(left)等效 ary，<br>上面等效<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>].concat([<span class="number">1</span>],[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>这说明了，递归最后呈现的由最后的边界值决定，且返回的结果 就是边界值与return表达式作用的结果。</p><h2 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="通常方案"><a href="#通常方案" class="headerlink" title="通常方案"></a>通常方案</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>将原来数组打散重新将所有元素一个个放置，新建一个数组，用于接收放置的元素。<br>元素在新数组中，按照大小顺序插入放置。</p><figure class="image-box">                <img src="/image/calc/insort1.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">ary</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newAry=[];</span><br><span class="line">    newAry.push(ary[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;ary.length; i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> cur =ary[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = newAry.length - <span class="number">1</span>; j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">//其实这里就考虑两种情况，将最大值放入右侧，或者找不到最大值，就说明这个是最小值，放入左侧，</span></span><br><span class="line">            <span class="keyword">if</span>(cur&gt;newAry[j])&#123;</span><br><span class="line">                newAry.splice(j+<span class="number">1</span>,<span class="number">0</span>,cur);<span class="comment">//最大值放到右侧</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//j===0，数组表示遍历完了，说明此时数组的全部元素都大于cur</span></span><br><span class="line">                <span class="keyword">if</span>(j===<span class="number">0</span>)&#123;</span><br><span class="line">                  newAry.unshift(cur);<span class="comment">//最小值放入左侧</span></span><br><span class="line">                  <span class="keyword">break</span>;<span class="comment">//这个break可以不用，写出来，只是方便理解，告诉你，如果改变了newAry，那么将结束遍历</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newAry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提高"><a href="#提高" class="headerlink" title="提高"></a>提高</h3><h4 id="可不用了解"><a href="#可不用了解" class="headerlink" title="可不用了解"></a>可不用了解</h4><p>下面的提高做法，是网上比较流行的插入排序算法，有精力可以了解下</p><h4 id="不新建数组直接排序的实现"><a href="#不新建数组直接排序的实现" class="headerlink" title="不新建数组直接排序的实现"></a>不新建数组直接排序的实现</h4><p>这种方法与方案一不同的是，方案二没有单独创建新数组来存放排序元素，而是直接基于原数组进行改造，相对来说理解起来要难一点。<br>其实找到窍门后，理解起来就好了，理解插入排序，只需要理解<strong>内层遍历如何排序</strong>，就理解了整个插入排序的思想，后面有讲到。</p><figure class="image-box">                <img src="/image/calc/insort2.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> function insertSort(ary)&#123;</span><br><span class="line">    var key,j;</span><br><span class="line">    for(var i=1;i&lt;ary.length;i++)&#123;</span><br><span class="line">            key=ary[i];</span><br><span class="line">            for(var j=i-1;j&gt;-1;j--)&#123;</span><br><span class="line">                if(ary[j]&gt;key)&#123;</span><br><span class="line">                  如果ary[j]大于key，那么将ary[j]往右挪一步</span><br><span class="line">                    ary[j+1]=ary[j];</span><br><span class="line">                    if(j===0)&#123;</span><br><span class="line">                        //能走到j===0说明ary[j]都大于key，原来的j 数组已经整体往右挪一步，此时ary[0]值就是key；</span><br><span class="line">                        ary[0]=key;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    如果ary[j]小于key，那么将key置于其右侧</span><br><span class="line">                    ary[j+1]=key;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="外层遍历提供元素，内层遍历进行排序"><a href="#外层遍历提供元素，内层遍历进行排序" class="headerlink" title="外层遍历提供元素，内层遍历进行排序"></a>外层遍历提供元素，内层遍历进行排序</h4><h4 id="内层排序技巧"><a href="#内层排序技巧" class="headerlink" title="内层排序技巧"></a>内层排序技巧</h4><p>外层遍历每次给内层遍历输入一个元素；<br>内层遍历 接收这个元素后，如何排序；<br>接收一个元素势必增加长度；<br>所以通过j+1，通过比较，数组整体平移整个数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">key=ary[i];</span><br><span class="line">            for(var j=i-1;j&gt;-1;j--)&#123;</span><br><span class="line">                if(ary[j]&gt;key)&#123;</span><br><span class="line">                  如果ary[j]大于key，那么将ary[j]往右挪一步</span><br><span class="line">                    ary[j+1]=ary[j];</span><br><span class="line">                    if(j===0)&#123;</span><br><span class="line">                        //能走到j===0说明ary[j]都大于key，原来的j 数组已经整体往右挪一步，此时ary[0]值就是key；</span><br><span class="line">                        ary[0]=key;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    如果ary[j]小于key，那么将key置于其右侧</span><br><span class="line">                    ary[j+1]=key;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><h4 id="遍历的经典应用"><a href="#遍历的经典应用" class="headerlink" title="遍历的经典应用"></a>遍历的经典应用</h4><p>此方案是经典的</p><h4 id="用while来改写方案二"><a href="#用while来改写方案二" class="headerlink" title="用while来改写方案二"></a>用while来改写方案二</h4><p>此写法其思想跟方案二是一样的。<br>while的好处是代码十分简洁，但是此代码极具误导性，单凭此，就可以认定这种写法是不推荐的。<br>这里有一个理解误区，a[0] 可以进入 while体内，等出来的时候j就变成了 -1 ，ary[-1+1]就是a[0]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function insertSort1(ary)&#123;</span><br><span class="line">    var key,j;</span><br><span class="line">    for(var i=1;i&lt;ary.length;i++)&#123;</span><br><span class="line">            key=ary[i];</span><br><span class="line">            j=i-1;</span><br><span class="line">            while(j&gt;-1&amp;&amp;ary[j]&gt;key)&#123;</span><br><span class="line">                ary[j+1]=ary[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            ary[j+1]=key;</span><br><span class="line">        &#125;</span><br><span class="line">        return ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="复原ip地址-1"><a href="#复原ip地址-1" class="headerlink" title="复原ip地址"></a>复原ip地址</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。<br>示例:<br>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]<br><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">力扣原题 –  复原IP地址</a></p><p>用白话解释原题：给出一串字符，写出它能组成的所有的ip.</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>代码如下，个人觉得代码不容易理解，请先看下面当代码分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function calc(str) &#123;</span><br><span class="line">      // 保存所有符合条件的IP地址</span><br><span class="line">      let r = []</span><br><span class="line">      // 分四步递归处理ip分段</span><br><span class="line">      let search = (cur, sub) =&gt; &#123;</span><br><span class="line">        // 非法输入过滤 ip地址最多不超过12个字符长</span><br><span class="line">        if (sub.length &gt; 12) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        // 边界条件</span><br><span class="line">        if (cur.length === 4 &amp;&amp; cur.join(&apos;&apos;) === str) &#123;</span><br><span class="line">          r.push(cur.join(&apos;.&apos;))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 正常的处理过程 </span><br><span class="line">          // Math.min(3, sub.length) i必须小于等于3</span><br><span class="line">          for (let i = 0, tmp; i &lt; Math.min(3, sub.length); i++) &#123;</span><br><span class="line">            tmp = sub.substr(0, i + 1)</span><br><span class="line">            if (tmp - 256 &lt; 0) &#123;</span><br><span class="line">              const newCur = cur.concat([tmp]);</span><br><span class="line">              const newSub = sub.substr(i + 1);</span><br><span class="line">              //当 newCur的数组元素超过4时，就不是ip地址了；</span><br><span class="line">              //当newCur有三个元素，准备补充第四个元素时，如果第四个元素当字符长度大于3位，就没有必要再继续下去</span><br><span class="line">              if(newCur.length &gt; 4 || (newCur.length === 3 &amp;&amp; newSub.length&gt;3))&#123;</span><br><span class="line">                continue</span><br><span class="line">              &#125;</span><br><span class="line">              search(newCur, newSub)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      search([], str)</span><br><span class="line">      return r</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>如下图，25525511135 这样一个字符串，要组成一个ip时；<br>ip由四个不大于256的数字排列组成；<br>第一个数字可以是 2 25 255；<br>当第一个数字为2时 剩下的代码为 5525511135；<br>此时它的第二个数字可以是 5 55 552(大于256，不符合规则)；<br>当第二个数字为5时，剩下的代码为 525511135；<br>此时它第三个数字可以是 5 52 525；<br>当第三个数字为5时， 剩下代码为25511136 不符合规则；<br>依次类推–递归。<br>如果你还是对分析或则上面代码不太理解，请拿出你对纸和笔，将上面代码在纸上遍历几次，就明白了。<br><figure class="image-box">                <img src="/image/calc/cur.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="递归设计中-必不可少的-边界条件"><a href="#递归设计中-必不可少的-边界条件" class="headerlink" title="递归设计中 必不可少的 边界条件"></a>递归设计中 必不可少的 边界条件</h3><p>要写一个递归，必须要写终止递归条件，也就是边界条件。上面代码的边界条件就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (cur.length === 4 &amp;&amp; cur.join(&apos;&apos;) === str) &#123;</span><br><span class="line">         r.push(cur.join(&apos;.&apos;))</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h2 id="对称二叉树-1"><a href="#对称二叉树-1" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p> <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">力扣原题–对称二叉树</a></p><h3 id="创建对称二叉树"><a href="#创建对称二叉树" class="headerlink" title="创建对称二叉树"></a>创建对称二叉树</h3><h4 id="二叉树模型图"><a href="#二叉树模型图" class="headerlink" title="二叉树模型图"></a>二叉树模型图</h4> <figure class="image-box">                <img src="/image/calc/tree.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p> 以下是创建二叉树代码，后面会针对代码疑问进行解答</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"> // 二叉树的节点</span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(val) &#123;</span><br><span class="line">    this.val = val</span><br><span class="line">    this.left = this.right = undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tree &#123;</span><br><span class="line">  constructor(data) &#123;</span><br><span class="line">    // 临时存储所有节点，方便寻找父子节点</span><br><span class="line">    let nodeList = []</span><br><span class="line">    // 顶节点</span><br><span class="line">    let root</span><br><span class="line">    for (let i = 0, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">      let node = new Node(data[i])</span><br><span class="line">      nodeList.push(node)</span><br><span class="line">      if (i &gt; 0) &#123;</span><br><span class="line">        // 计算当前节点属于那一层</span><br><span class="line">        let n = Math.floor(Math.sqrt(i + 1))</span><br><span class="line">        // 记录当前层的起始nodelist的index</span><br><span class="line">        let q = Math.pow(2, n) - 1</span><br><span class="line">        // 记录上一层的起始nodelist的index</span><br><span class="line">        let p = Math.pow(2, n - 1) - 1</span><br><span class="line">        // 找到当前节点的父节nodelist的index</span><br><span class="line">        let parent = nodeList[p + Math.floor((i - q) / 2)]</span><br><span class="line">        // 将当前节点和上一层的父节点做关联</span><br><span class="line">        if (parent.left) &#123;</span><br><span class="line">          parent.right = node</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          parent.left = node</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //只有第一个元素是起始节点，</span><br><span class="line">    root = nodeList.shift()</span><br><span class="line">    //其他元素完成使命，可以去掉</span><br><span class="line">    nodeList.length = 0</span><br><span class="line">    return root</span><br><span class="line">  &#125;</span><br><span class="line">  //验证二叉树是否是对称</span><br><span class="line">  static isSymmetry(root) &#123;</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125;</span><br><span class="line">    let walk = (left, right) =&gt; &#123;</span><br><span class="line">      if (!left &amp;&amp; !right) &#123;</span><br><span class="line">        return true</span><br><span class="line">      &#125;</span><br><span class="line">      if ((left &amp;&amp; !right) || (!left &amp;&amp; right) || (left.val !== right.val)) &#123;</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">      return walk(left.left, right.right) &amp;&amp; walk(left.right, right.left)</span><br><span class="line">    &#125;</span><br><span class="line">    return walk(root.left, root.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Tree([1, 2, 2, 3, 4, 4, 3])</span><br><span class="line">//返回：</span><br><span class="line">const tree = &#123;</span><br><span class="line">  &quot;val&quot;: 1,</span><br><span class="line">  &quot;right&quot;: &#123;</span><br><span class="line">    &quot;val&quot;: 2,</span><br><span class="line">    &quot;right&quot;: &#123;</span><br><span class="line">      &quot;val&quot;: 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;left&quot;: &#123;</span><br><span class="line">      &quot;val&quot;: 4</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;left&quot;: &#123;</span><br><span class="line">    &quot;val&quot;: 2,</span><br><span class="line">    &quot;right&quot;: &#123;</span><br><span class="line">      &quot;val&quot;: 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;left&quot;: &#123;</span><br><span class="line">      &quot;val&quot;: 3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="当前节点属于那一层"><a href="#当前节点属于那一层" class="headerlink" title="当前节点属于那一层"></a>当前节点属于那一层</h4><p> 如果理解不了，请记住，这是业内得出的公式，无需太较真理解，记住这个定理公式就行。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 计算当前节点属于那一层</span><br><span class="line"> let n = Math.floor(Math.sqrt(i + 1))</span><br></pre></td></tr></table></figure></p><h4 id="记录当前层的起始nodelist的index"><a href="#记录当前层的起始nodelist的index" class="headerlink" title="记录当前层的起始nodelist的index"></a>记录当前层的起始nodelist的index</h4><p> 由上面的二叉树模型图看出，每一层的元素的起始点起始就是前面所有层元素个数之和，<br> 而这个和的值正好是2的n次幂，所以每一层对应到nodelist数组的index就是如下公式：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 记录当前层的起始 nodelist的index</span><br><span class="line">  let q = Math.pow(2, n) - 1</span><br><span class="line">  // 记录上一层的起始 nodelist的index</span><br><span class="line">  let p = Math.pow(2, n - 1) - 1</span><br></pre></td></tr></table></figure></p><h4 id="每一层有多少个元素"><a href="#每一层有多少个元素" class="headerlink" title="每一层有多少个元素"></a>每一层有多少个元素</h4><p> 参考上面《记录当前层的起始nodelist的index》</p><h4 id="找到当前节点的父节nodelist的index"><a href="#找到当前节点的父节nodelist的index" class="headerlink" title="找到当前节点的父节nodelist的index"></a>找到当前节点的父节nodelist的index</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 找到当前节点的父节点</span><br><span class="line">        let parent = nodeList[p + Math.floor((i - q) / 2)]</span><br></pre></td></tr></table></figure><p>有几个知识点要了解：<br>当前层的起始点 Math.pow(2, n) - 1 ，例如第二层，起始点是3；<br>那么这个3就是上面代码中的nodelist的index，<br>第一层，起始点是0；那么这个0就是nodelist的index；<br>所以上面代码中 进行for遍历时，i就是nodelist的下标，q或p也是nodelist的下标。<br>由于每两个子节点对应一个父节点，所以需要除以2</p><h4 id="数组每个元素都生成一个node节点"><a href="#数组每个元素都生成一个node节点" class="headerlink" title="数组每个元素都生成一个node节点"></a>数组每个元素都生成一个node节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> for (let i = 0, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">      let node = new Node(data[i])</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="利用node节点Object浅拷贝特性"><a href="#利用node节点Object浅拷贝特性" class="headerlink" title="利用node节点Object浅拷贝特性"></a>利用node节点Object浅拷贝特性</h4><p>利用这一浅拷贝特点，让第一个数组元素成为所有数组其他元素形成的节点的共同父节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let parent = nodeList[p + Math.floor((i - q) / 2)]</span><br><span class="line">       // 将当前节点和上一层的父节点做关联</span><br><span class="line">       if (parent.left) &#123;</span><br><span class="line">         parent.right = node</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         parent.left = node</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h3 id="验证二叉树是否是对称"><a href="#验证二叉树是否是对称" class="headerlink" title="验证二叉树是否是对称"></a>验证二叉树是否是对称</h3><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>代码见上面《创建二叉树》</p><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><p>主要运用了递归原理验证二叉树是否对称。</p><h2 id="验证二叉搜索树-1"><a href="#验证二叉搜索树-1" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">力扣原题–验证二叉搜索树</a></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3> <figure class="image-box">                <img src="/image/calc/tree1.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">  constructor (val) &#123;</span><br><span class="line">    this.val = val</span><br><span class="line">    this.left = this.right = undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tree &#123;</span><br><span class="line">  constructor (data) &#123;</span><br><span class="line">    let root = new Node(data.shift())</span><br><span class="line">    // 遍历所有的数据，逐渐插入到当前这棵搜索树中去</span><br><span class="line">    data.forEach(item =&gt; &#123;</span><br><span class="line">      this.insert(root, item)</span><br><span class="line">    &#125;)</span><br><span class="line">    return root</span><br><span class="line">  &#125;</span><br><span class="line">  insert (node, data) &#123;</span><br><span class="line">    if (node.val &gt; data) &#123;</span><br><span class="line">      if (node.left === undefined) &#123;</span><br><span class="line">        node.left = new Node(data)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.insert(node.left, data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (node.right === undefined) &#123;</span><br><span class="line">        node.right = new Node(data)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.insert(node.right, data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  static walk (root) &#123;</span><br><span class="line">    if (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">      return true</span><br><span class="line">    &#125; else if ((root.left &amp;&amp; root.val &lt; root.left.val) || (root.right &amp;&amp; root.val &gt; root.right.val)) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return Tree.walk(root.left) &amp;&amp; Tree.walk(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> new Tree([2, 1, 3,6,8,9])</span><br></pre></td></tr></table></figure><h3 id="小左大右"><a href="#小左大右" class="headerlink" title="小左大右"></a>小左大右</h3><p>本搜索二叉树按照左大右小排列。</p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>上面代码中，无论生成二叉树与验证二叉树都使用了二叉树，注意递归中 边界值处理技巧。</p><h2 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h2><h3 id="递归的结构"><a href="#递归的结构" class="headerlink" title="递归的结构"></a>递归的结构</h3><p>每个递归由一个递归体以及一个边界值组成。且必须有一个边界值。</p><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3> <figure class="image-box">                <img src="/image/calc/recursion.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foctorial(n)&#123;</span><br><span class="line">  if(n === 1 || n === 0)&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return n * foctorial(n-1)</span><br><span class="line">&#125;</span><br><span class="line">foctorial(5)//120</span><br></pre></td></tr></table></figure><h4 id="边界值-又称基线条件"><a href="#边界值-又称基线条件" class="headerlink" title="边界值(又称基线条件)"></a>边界值(又称基线条件)</h4><p>边界值与基线条件是一个道理，即一个停止点。<br>如下，递归中，很多最终都是通过边界值来计算，且终止递归。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//我们只需写出边界（1）的实现就行。</span><br><span class="line">foctorial(5) = 5*4*3*2*(1)；</span><br></pre></td></tr></table></figure></p><p>边界值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(n === 1 || n === 0)&#123;</span><br><span class="line">   return 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="斐波那契数-1"><a href="#斐波那契数-1" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>斐波那契数列 是一个由 0, 1, 1, 2, 3, 5, 8, 13, 21 等组成等序列。数2由1加1得到，数3由2加1得到…。<br>斐波那契数列有个定义：</p><ul><li>位置0的数是0；</li><li>1和2的数是1；</li><li>n(n&gt;2)的数是n-1、 n-2 之和。<h4 id="实现一（常规实现）"><a href="#实现一（常规实现）" class="headerlink" title="实现一（常规实现）"></a>实现一（常规实现）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function fn(n)&#123;</span><br><span class="line">     if(n&lt;1) return 0;</span><br><span class="line">     if(n&lt;=2) return 1;</span><br><span class="line">     let prepreStartval = 0;</span><br><span class="line">     let preStartval = 1;</span><br><span class="line">     //前一个的前一个位置的值</span><br><span class="line">     let prepre=prepreStartval;</span><br><span class="line">     //前一个位置的值</span><br><span class="line">     let pre=preStartval;</span><br><span class="line">     //本位置的值</span><br><span class="line">     let item= &apos;&apos;;</span><br><span class="line">     for(let i=2;i&lt;=n;i++)&#123;</span><br><span class="line">         //本位置的值 = 前一个位置值 + 前一个的前一个位置值</span><br><span class="line">         item=pre+prepre;</span><br><span class="line">         //新的前一个的前一个的值 变成上个位置的前一个位置的值</span><br><span class="line">         prepre=pre;</span><br><span class="line">         //新的前一个的值 变成上一个位置的值</span><br><span class="line">         pre=item;</span><br><span class="line">     &#125;</span><br><span class="line">     return item;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现二-（递归实现）"><a href="#实现二-（递归实现）" class="headerlink" title="实现二 （递归实现）"></a>实现二 （递归实现）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn(n)&#123;</span><br><span class="line">    if(n&lt;1) return 0;</span><br><span class="line">    if(n&lt;=2) return 1;</span><br><span class="line">    return fn(n-1) + fn(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> function calculate(n, fn)&#123;</span><br><span class="line">    var arr=[];</span><br><span class="line">    for(var j=0; j&lt;n; j++)&#123; </span><br><span class="line">        arr[j]=fn(j) </span><br><span class="line">    &#125; </span><br><span class="line">    return arr; </span><br><span class="line">&#125;</span><br><span class="line">calculate(8, fn)  // [0, 1, 1, 2, 3, 5, 8, 13]</span><br></pre></td></tr></table></figure></p><h4 id="实现三-（记忆化优化）"><a href="#实现三-（记忆化优化）" class="headerlink" title="实现三 （记忆化优化）"></a>实现三 （记忆化优化）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function calcFactory()&#123;</span><br><span class="line">    const memo = [0, 1];</span><br><span class="line">    const fn=(n)=&gt;&#123;</span><br><span class="line">        //memo[n]===0  0是非，但本例中是一个值；</span><br><span class="line">        if(memo[n] || memo[n]===0) return memo[n];</span><br><span class="line">        return memo[n] = fn(n-1) + fn(n-2);</span><br><span class="line">    &#125;</span><br><span class="line">    return fn;</span><br><span class="line">&#125;</span><br><span class="line">var calc = calcFactory()；</span><br><span class="line">calc(8) //13;</span><br></pre></td></tr></table></figure><h3 id="边界值-与-最小化分析"><a href="#边界值-与-最小化分析" class="headerlink" title="边界值 与 最小化分析"></a>边界值 与 最小化分析</h3><p>很多递归问题或其他算法问题，他们几乎都是由最小值或边界值重复或计算而来，在解决问题时，可以将问题使用边界值最小化分析</p><h3 id="递归记忆化技巧"><a href="#递归记忆化技巧" class="headerlink" title="递归记忆化技巧"></a>递归记忆化技巧</h3><p>参考《斐波那契数  –  实现三 （记忆优化）》</p><h3 id="递归与while"><a href="#递归与while" class="headerlink" title="递归与while"></a>递归与while</h3><p>有时候递归能实现的，通过while也能实现，while具有一些递归的质能。<br>参考《卡牌分组 — while 实现 递归效果》</p><h3 id="递归经典应用示例"><a href="#递归经典应用示例" class="headerlink" title="递归经典应用示例"></a>递归经典应用示例</h3><h4 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h4><p>参考《快速排序》</p><h4 id="电话号码-2"><a href="#电话号码-2" class="headerlink" title="电话号码"></a>电话号码</h4><p>参考《电话号码》</p><h4 id="卡牌分组-2"><a href="#卡牌分组-2" class="headerlink" title="卡牌分组"></a>卡牌分组</h4><p>参考《卡牌分组》</p><h4 id="复原ip地址-2"><a href="#复原ip地址-2" class="headerlink" title="复原ip地址"></a>复原ip地址</h4><p>参考《复原ip地址》</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="遍历类型"><a href="#遍历类型" class="headerlink" title="遍历类型"></a>遍历类型</h3><h4 id="多元遍历"><a href="#多元遍历" class="headerlink" title="多元遍历"></a>多元遍历</h4><p>上面的 种花问题，冒泡排序， 选择排序，都是多元遍历的运用；</p><h4 id="多层遍历"><a href="#多层遍历" class="headerlink" title="多层遍历"></a>多层遍历</h4><p>冒泡排序，选择排序 是多层遍历的运用；</p><h4 id="跳级-忽略-遍历"><a href="#跳级-忽略-遍历" class="headerlink" title="跳级(忽略)遍历"></a>跳级(忽略)遍历</h4><p>参考 《种花问题 — 遍历体用 i++ 跳级忽略遍历》</p><h4 id="多层遍历-内层遍历j-1"><a href="#多层遍历-内层遍历j-1" class="headerlink" title="多层遍历 内层遍历j+1"></a>多层遍历 内层遍历j+1</h4><p>内外两层遍历，内层遍历通过j+1,腾出多一个位置来接收一个元素，进行排序的技巧，参考<br>《插入排序 — 方案二 (推荐)》</p><h3 id="经典应用示例"><a href="#经典应用示例" class="headerlink" title="经典应用示例"></a>经典应用示例</h3><h4 id="插入排序-（非常经典）"><a href="#插入排序-（非常经典）" class="headerlink" title="插入排序 （非常经典）"></a>插入排序 （非常经典）</h4><p>是非常经典的排序方式，尤其是方案二。<br>插入排序与冒泡排序形成了两种思路的遍历思想；<br>插入由内部遍历排序，冒泡由外部遍历排序。</p><h4 id="种花问题-2"><a href="#种花问题-2" class="headerlink" title="种花问题"></a>种花问题</h4><p>这里是遍历的经典运用，参考《种花问题》</p><h4 id="冒泡排序-2"><a href="#冒泡排序-2" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>参考《冒泡排序》</p><h4 id="选择排序-2"><a href="#选择排序-2" class="headerlink" title="选择排序"></a>选择排序</h4><p>参考《选择排序》</p><h4 id="最大间距-1"><a href="#最大间距-1" class="headerlink" title="最大间距"></a>最大间距</h4><p>参考 《最大间距》</p><h4 id="数组中的第K个最大元素-1"><a href="#数组中的第K个最大元素-1" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h4><p>参考 《数组中的第K个最大元素》</p><h2 id="常用算法场景"><a href="#常用算法场景" class="headerlink" title="常用算法场景"></a>常用算法场景</h2><h3 id="数组前后两两比较-1"><a href="#数组前后两两比较-1" class="headerlink" title="数组前后两两比较"></a>数组前后两两比较</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p>参考：《电话号码》中的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const cur = (strarr)=&gt;&#123;</span><br><span class="line">    //第一次strarr[0]是一个字符串， 以后strarr[0]经过splice后，都是数组</span><br><span class="line">   const one = typeof strarr[0] === &apos;string&apos; ? strarr[0].split(&apos;&apos;) : strarr[0];</span><br><span class="line">   const two = strarr[1].split(&apos;&apos;);</span><br><span class="line">   const newItem0 = combile(one, two);</span><br><span class="line">   strarr.splice(0,2,newItem0);</span><br><span class="line">      if(strarr.length&lt;2)&#123;</span><br><span class="line">          return strarr[0];</span><br><span class="line">      &#125;</span><br><span class="line">    return cur(strarr)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>更多参考 《卡牌分组》</p><h4 id="每次只比较数组的第一和第二项"><a href="#每次只比较数组的第一和第二项" class="headerlink" title="每次只比较数组的第一和第二项"></a>每次只比较数组的第一和第二项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = typeof strarr[0] === &apos;string&apos; ? strarr[0].split(&apos;&apos;) : strarr[0];</span><br><span class="line">const two = strarr[1].split(&apos;&apos;);</span><br><span class="line">const newItem0 = combile(one, two);</span><br></pre></td></tr></table></figure><h4 id="删除第一和第二项，将比较结果重新置为第一项"><a href="#删除第一和第二项，将比较结果重新置为第一项" class="headerlink" title="删除第一和第二项，将比较结果重新置为第一项"></a>删除第一和第二项，将比较结果重新置为第一项</h4><p>如上代码，每次比较完第一和第二项后，删除他们，并将比较结果置为第一项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strarr.splice(0,2,newItem0);</span><br></pre></td></tr></table></figure></p><h4 id="递归是核心"><a href="#递归是核心" class="headerlink" title="递归是核心"></a>递归是核心</h4><p>见代码</p><h4 id="边界值：strarr-length-lt-2"><a href="#边界值：strarr-length-lt-2" class="headerlink" title="边界值：strarr.length&lt;2"></a>边界值：strarr.length&lt;2</h4><p>两两比较到最后，数组只剩下一个元素，此时递归停止，所以边界值：strarr.length&lt;2。</p><h3 id="找出元素出现次数"><a href="#找出元素出现次数" class="headerlink" title="找出元素出现次数"></a>找出元素出现次数</h3><h4 id="找出元素出现次数的方法-推荐-–match正则-1"><a href="#找出元素出现次数的方法-推荐-–match正则-1" class="headerlink" title="找出元素出现次数的方法(推荐)–match正则"></a>找出元素出现次数的方法(推荐)–match正则</h4><p>详细参考 《卡牌分组》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 分组(单张或者多张)  \1 在正则中表示连续一样的匹配</span><br><span class="line"> let group = str.match(/(\d)\1+|\d/g)</span><br></pre></td></tr></table></figure></p><h4 id="找出元素出现次数的方法–object-key方式-1"><a href="#找出元素出现次数的方法–object-key方式-1" class="headerlink" title="找出元素出现次数的方法–object key方式"></a>找出元素出现次数的方法–object key方式</h4><p>详细参考 《卡牌分组》<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const hash = deck.reduce((pre, num) =&gt; &#123;    //统计出每种数字的数目</span><br><span class="line">  if(!pre[num]) &#123;</span><br><span class="line">    pre[num] = 1</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    pre[num]++</span><br><span class="line">  &#125;</span><br><span class="line">  return pre</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="时间／空间复杂度"><a href="#时间／空间复杂度" class="headerlink" title="时间／空间复杂度"></a>时间／空间复杂度</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>简言之，<br>时间复杂度是对运行次数的描述，因为运行次数的多少决定了花多少时间。<br>空间复杂度是对运行内存的描述，在排序时定义了多少变量，就会消耗多少内存。<br>一般关注好时间复杂度即可。<br><figure class="image-box">                <img src="/image/calc/time.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//时间复杂度为 O(9)</span><br><span class="line">for (let j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">     console.log(j)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//时间复杂度为 O(9*9)</span><br><span class="line">  for (let i = 9; i &gt; 0; i--) &#123;</span><br><span class="line">        for (let j = 0; j &lt; 9; j++) &#123;</span><br><span class="line">             console.log(j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/chapter/315.html#Anchor" target="_blank" rel="noopener">JavaScript版 数据结构与算法</a><br><a href="https://v.youku.com/v_show/id_XMjQ4MjMxMDIwNA==.html?spm=a2h0j.11185381.listitem_page1.5!18~A" target="_blank" rel="noopener">珠峰教育 –js排序</a><br><a href="http://www.ituring.com.cn/book/2653" target="_blank" rel="noopener">学习JavaScript数据结构与算法（第3版）</a></p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack笔记</title>
      <link href="/2019/01/01/webpack/"/>
      <url>/2019/01/01/webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack常用知识-上"><a href="#webpack常用知识-上" class="headerlink" title="webpack常用知识 上"></a>webpack常用知识 上</h2><h3 id="sourcemap的处理"><a href="#sourcemap的处理" class="headerlink" title="sourcemap的处理"></a>sourcemap的处理</h3><h4 id="css模块-sourcemap的处理"><a href="#css模块-sourcemap的处理" class="headerlink" title="css模块 sourcemap的处理"></a>css模块 sourcemap的处理</h4><p>给一下loader加上sourceMap: true，就可以做到css的sourcemap调试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h3 id="js模块-sourcemap的处理"><a href="#js模块-sourcemap的处理" class="headerlink" title="js模块 sourcemap的处理"></a>js模块 sourcemap的处理</h3><p>很简单，加一个这个配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: &apos;inline-source-map&apos;, // 开发阶段开启 sourcemap</span><br></pre></td></tr></table></figure></p><h3 id="要不要配置index-html"><a href="#要不要配置index-html" class="headerlink" title="要不要配置index.html"></a>要不要配置index.html</h3><p>有时候容易误解，webpack会自动生成index.html，这是不对的。<br>入口文件index.html必须要自己手动配置例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>其实webpack只是一个js打包器，会把index.html用到的js全部打包成一个js，就是上面的index.js。<br>只是我们可以通过webpack的插件html-webpack-plugin，写一个index.html模板，不用手动输入index.js的引用，且不用每次手动将index.html拷贝到build目录。<br>将上面的index.html，改成模板，其实就是就是去掉这句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>改成的index.html如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//index.html模板</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>所以在项目中，你必须写一个index.html，或者一个index.html模板。<br>看这个章节加深 项目中index.html 的理解：《webpack常用知识 —解决css文件或者js文件名字哈希值变化的问题》</p><h3 id="output-publicPath-output-path-exports-context-devServer-publicPath"><a href="#output-publicPath-output-path-exports-context-devServer-publicPath" class="headerlink" title="output.publicPath output.path exports.context devServer.publicPath"></a>output.publicPath output.path exports.context devServer.publicPath</h3><ul><li>exports.context 与 output.path<br>exports.context 是提供一个全局的根目录，为配置提供方便,你也可不配置；如果配置此目录下面的output.path 基于此目录。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">output: &#123;</span><br><span class="line">  path: &apos;version1.0.0&apos;,</span><br><span class="line">  publicPath: &apos;/&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, &apos;version1.0.0/version1.0.0&apos;),</span><br><span class="line">  publicPath: &apos;/&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><ul><li>output.publicPath<br>output.publicPath是给index.html文件内所以link或js引用，在原编辑结果下，在最左侧统一加一个目录，通常也可不配置。<br>如：<br>不加output.publicPath<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">output: &#123;</span><br><span class="line">  path: &apos;version1.0.0&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>编译出来的index.html为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot;&gt;</span><br><span class="line">    &lt;title&gt;React App Pro&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/css/1.db782111.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/css/style.db782111.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/vendors.db782111.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;preload&quot; href=&quot;assets/client.db782111.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;assets/vendors.db782111.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;assets/client.db782111.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>加了output.publicPath<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">output: &#123;</span><br><span class="line">  path: &apos;version1.0.0&apos;,</span><br><span class="line">  publicPath: &apos;/&apos;,</span><br><span class="line">  filename: &apos;assets/[name].[hash:8].js&apos;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>编译出来的index.html每个引用路径前都加了一个’/‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/css/1.2e0f42df.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/css/style.2e0f42df.css&quot;  as=&quot;style&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/vendors.2e0f42df.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/assets/client.2e0f42df.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/vendors.2e0f42df.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/client.2e0f42df.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><ul><li>devServer.publicPath<br>这么没什么说的，默认配置为 ‘/‘，大多时候我们不会去改，使用默认配置。</li></ul><h3 id="给css加前缀-postcss-loader"><a href="#给css加前缀-postcss-loader" class="headerlink" title="给css加前缀  postcss-loader"></a>给css加前缀  postcss-loader</h3><p><a href="https://www.webpackjs.com/loaders/postcss-loader/#options" target="_blank" rel="noopener">postcss-loader</a>有很多用处，其中之一就是给各个浏览器添加css3兼容样式。</p><p>postcss-loader 要与 autoprefixer一起使用， autoprefixer 用来配置 postcss-loader。使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,//这里一定要定义一个唯一的名字，一般喜欢定义为postcss，你也可以定义任意其他唯一名字</span><br><span class="line">              //&gt; 0.15% in CN 大致是指兼容什么范围内的浏览器，这样写就行，一定要设置，否则可能不加前缀，</span><br><span class="line">              //且数值一定要设置合适，否则设置浏览器太新，也可能不会生成前缀</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>如上，给postcss-loader配置来options，<strong>如果不配置options，则一定要配置postcss.config.js，</strong>否则会报错。<br>如果配置了  postcss-loader，如果你还使用了happypack,就必须要 在根目录 (通常是webpack.comfig.js同级目录)配置 postcss.config.js。详细请看下面章节 《构建与性能优化–happypack》</p><h3 id="抽离css样式文件"><a href="#抽离css样式文件" class="headerlink" title="抽离css样式文件"></a>抽离css样式文件</h3><p>注意：1.webpack4开始使用mini-css-extract-plugin ，1-3版本可以用 extract-text-webpack-plugin。<br>     2.只有 mode: ‘production’ 插件才生效。<br>     3.开发阶段使用style-loader就行了<br>方法：<br>1.mode: ‘production’<br>2.抽离只需将原先style-loader的对象换成mini-css-extract-plugin；<br>3.配置plugins；</p><p>配置代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">...</span><br><span class="line">mode: &apos;production&apos;,</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line"> ....</span><br><span class="line"> plugins: [</span><br><span class="line">   new MiniCssExtractPlugin(&#123;</span><br><span class="line">     filename: &apos;[name][hash].css&apos;, // 设置最终输出的文件名，这个name最终根据output.filename一致。</span><br><span class="line">     chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">   &#125;)</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure><p>以下是css未从html上抽离的原先配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;style-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h3><p>所谓压缩代码，就是把css压缩成紧凑的一行。<br>注意：1.webpack5内置压缩 ，4版本可以设置插件optimize-css-assets-webpack-plugin即可。<br>     2.只有 mode: ‘production’ 。<br>配置代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);</span><br><span class="line">...</span><br><span class="line">mode: &apos;production&apos;</span><br><span class="line">...</span><br><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      new OptimizeCSSAssetsPlugin(&#123;&#125;), // 压缩CSS插件</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="解决css文件或者js文件名字哈希值变化的问题"><a href="#解决css文件或者js文件名字哈希值变化的问题" class="headerlink" title="解决css文件或者js文件名字哈希值变化的问题"></a>解决css文件或者js文件名字哈希值变化的问题</h3><p>html-webpack-plugin插件，可以把打包后的css或js文件引用直接注入到HTML模板中，这样就不用每次手动修改文件引用了。<br>因此，只要项目中使用了hash，就必须配套使用html-webpack-plugin。<br>另外如果要使用模板html，也必须配套使用html-webpack-plugin。<br>当然，你也可以不使用模板，就算有哈希值，你不怕麻烦，当然也可以不适用html-webpack-plugin,你自己手写html，然后将打包生成的js\css文件手动引用也是可以的。<br>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">  title: &apos;AICODER test&apos;, // 默认值：Webpack App</span><br><span class="line">  filename: &apos;index.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">  template: path.resolve(__dirname, &apos;src/main.html&apos;),</span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseWhitespace: true, // 折叠空白</span><br><span class="line">    removeComments: true, // 是否移除注释</span><br><span class="line">    removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="每次打包自动清除上一个dist目录"><a href="#每次打包自动清除上一个dist目录" class="headerlink" title="每次打包自动清除上一个dist目录"></a>每次打包自动清除上一个dist目录</h3><p>使用插件：clean-webpack-plugin，配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line">plugins: [</span><br><span class="line">    new CleanWebpackPlugin([&apos;dist&apos;])</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="配置如何解析react-与-jsx"><a href="#配置如何解析react-与-jsx" class="headerlink" title="配置如何解析react 与 jsx"></a>配置如何解析react 与 jsx</h3><p>解决方式如下，可以看到都是通过.babelrc完成，所以要重视.babelrc的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;react&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//package.json</span><br><span class="line"> &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,</span><br></pre></td></tr></table></figure></p><h3 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h3><p>使用loader：image-webpack-loader，一定在url-loader之前执行image-webpack-loader。<br>image-webpack-loader可以让原来90kb的图片，变成70kb，而不怎么影响质量。<br>配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;image-webpack-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              mozjpeg: &#123;</span><br><span class="line">                progressive: true,</span><br><span class="line">                quality: 65</span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123;</span><br><span class="line">                enabled: false</span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123;</span><br><span class="line">                quality: &apos;65-90&apos;,</span><br><span class="line">                speed: 4</span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123;</span><br><span class="line">                interlaced: false</span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123;</span><br><span class="line">                quality: 75</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h3 id="file-loader-与-url-loader-异同"><a href="#file-loader-与-url-loader-异同" class="headerlink" title="file-loader 与 url-loader 异同"></a>file-loader 与 url-loader 异同</h3><p>他们都是用来处理项目中图片的。<br>file-loader 有的功能，基本上url-loader都用；<br>而且url-loader还可以将图片进行base64压缩的功能（你可以不使用此功能）；<br>因此，项目中使用url-loader而不适用file-loader。<br>url-loader 配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000 //1kb以内的图片将被base64压缩</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>url-loader将图片进行base64压缩后就是一串DataURL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    background: url(data:image/png;base64,UklGRkYwAABXRUJQVlA4WAoAAAAQAAAA/QIA8AAAQUxQSMAcAAABb…KnjLJNbGNAMFRe2WQhUfMAAAA19AAAkbAAAAAAAAAAAAAAABrYAAAAAD0gAAAAAAAAAAAAAAAA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在基本上常用的浏览器和移动端都可很好兼容DataURL，所以可以放心使用。<br>base64压缩图片为一串DataURL的好处在于减少html页面的http请求。缺点在于会加大打包文件大小。<br>一般网页性能优化时：<br>对于小图片，会使用base64压缩，减少http请求；<br>对于大图片，还是使用http请求。</p><h3 id="字体文件处理"><a href="#字体文件处理" class="headerlink" title="字体文件处理"></a>字体文件处理</h3><p>字体文件处理同图片文件处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(woff|woff2|eot|ttf|otf)$/,</span><br><span class="line">    include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: &apos;file-loader&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><figure class="image-box">                <img src="/image/webpack/proxy1.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/webpack/proxy2.jpg" alt="" title="" class="">                <p></p>            </figure><figure class="image-box">                <img src="/image/webpack/proxy3.jpg" alt="" title="" class="">                <p></p>            </figure><h4 id="changeOrigin与其他注意"><a href="#changeOrigin与其他注意" class="headerlink" title="changeOrigin与其他注意"></a>changeOrigin与其他注意</h4><p>代理有三种情况：<br>localhost<br>http的其他主机名<br>https的其他主机名<br>涉及到其他主机名时，要配置changeOrigin: true，<br>涉及到https时，要配置secure: false,不过经测试，不设置secure: false，也可以运行正常<br>详细参考 <a href="https://www.webpackjs.com/configuration/dev-server/#devserver-proxy" target="_blank" rel="noopener">webpack官网 devServer.proxy</a><br><a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="noopener">http-proxy-middleware</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">     &quot;/j&quot;: &#123; </span><br><span class="line">       target: &quot;https://read.douban.com&quot;,</span><br><span class="line">       changeOrigin: true,</span><br><span class="line">       secure: false,</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;/ajax&quot;: &#123; </span><br><span class="line">       target: &quot;http://m.maoyan.com&quot;,</span><br><span class="line">       changeOrigin: true</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;/test&quot;: &#123; </span><br><span class="line">       target: &quot;http://127.0.0.1:8080&quot;,</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="外部扩展-externals"><a href="#外部扩展-externals" class="headerlink" title="外部扩展(externals)"></a>外部扩展(externals)</h3><p> 把一个模块做成外部依赖也就是用cdn的方式依赖，不会打包到 js文件中。<br> 例如lodash,jquery基本上每个页面都要用到，这个时候把它们放在index.html模板中，<br> 每个组件都可以通过externals定义的名称进行引用。<br> 从而可以减少打包后js的大小。<br> 配置如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//index.html模板中</span><br><span class="line">&lt;script</span><br><span class="line">  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br><span class="line">  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line"></span><br><span class="line">  //webpack.config.js</span><br><span class="line">   externals: &#123;  // 把一个模块做成外部依赖，不会打包到 js文件中。</span><br><span class="line">      jquery: &apos;jQuery&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    //index.js使用jquery</span><br><span class="line">    import $ from &apos;jquery&apos;; //注意是小写</span><br></pre></td></tr></table></figure></p><h3 id="webpack-bundle-analyzer统计分析"><a href="#webpack-bundle-analyzer统计分析" class="headerlink" title="webpack-bundle-analyzer统计分析"></a>webpack-bundle-analyzer统计分析</h3><p>注意，这个是在开发环境下使用,配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">   new BundleAnalyzerPlugin(), // 打包模块报表</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure></p><p>配置好后，执行npm start ，会自动在浏览器打开分析页面：<br><figure class="image-box">                <img src="/image/webpack/analyzer.png" alt="" title="" class="">                <p></p>            </figure><br>由图看出，loadsh.js的体积最大，经过分析，可以将loadsh.js做成外部依赖，从而减少打包后js的体积。</p><h3 id="分离-库与业务代码"><a href="#分离-库与业务代码" class="headerlink" title="分离 库与业务代码"></a>分离 库与业务代码</h3><h4 id="配置方法一"><a href="#配置方法一" class="headerlink" title="配置方法一"></a>配置方法一</h4><p>配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">   filename: &apos;[name].[hash].js&apos;, //定义库代码以外的代码打包成的js appIndex.54c949dd739536531ad5.js</span><br><span class="line">   chunkFilename: &apos;[name].chunk.js&apos;,//定义库代码打包成的js customChunkNameQQ.chunk.js</span><br><span class="line">   path: path.resolve(__dirname, &apos;dist&apos;) //打包后输出的路径</span><br><span class="line"> &#125;,</span><br><span class="line">optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">           cacheGroups: &#123;</span><br><span class="line">             commons: &#123;</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                test: path.resolve(__dirname,&apos;node_modules&apos;),//匹配到的文件都将被一起打包成库js</span><br><span class="line">                enforce: true,</span><br><span class="line">                name: &apos;customChunkNameQQ&apos;,//定义打包后[name]值</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>库与业务代码分离 使用的是splitChunks配置，其实它是一个插件，被整合到webpack4了。<br>这个插件的思路是，利用test匹配文件，只要匹配到的就打包成库js，剩下没有被匹配到的，就被打包成业务js；<br>所以如果test匹配不到任何文件，将不会有库js生成，所有的js资源都会被剩下，都被打包到业务js中。</p><p>以下就是一个例子，只有业务js生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">   appIndex:&apos;./src/index.js&apos;</span><br><span class="line"> &#125;,</span><br><span class="line"> optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">           cacheGroups: &#123;</span><br><span class="line">             commons: &#123;</span><br><span class="line">                chunks: &apos;initial&apos;,</span><br><span class="line">                test: path.resolve(__dirname,&apos;node_modules11&apos;),//因为项目没有node_modules11目录,将只会有一个业务js生成</span><br><span class="line">                enforce: true,</span><br><span class="line">                name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p> <strong>webpack打包的原则就是这样，如果没有插件,所有的js将被webpack系统打包成一个js，如果有插件做代码分离，插件匹配的部分将被插件打包成js，剩下的将被webpack系统打包成一个js，如果插件没有匹配到任何js，,所有的js将被webpack系统打包成一个js</strong></p><p>还有其他几种定义方法：</p><h4 id="显示配置方法-推荐"><a href="#显示配置方法-推荐" class="headerlink" title="显示配置方法(推荐)"></a>显示配置方法(推荐)</h4><p>注意下面这个示例配置有一点点问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: &apos;lodashAndAxios&apos;, //一定要匹配entry对象内，key值，lodashAndAxios就是entry中的key值</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>上面配置有些问题，打包后，会生成三个js：<br><figure class="image-box">                <img src="/image/webpack/verder2.png" alt="" title="" class="">                <p></p>            </figure><br>所以修改以上配置，将cacheGroups.commons.name与cacheGroups.commons.test统一定义成entry中的lodashAndAxios这样生成的文件就正常了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确配置方法 --&gt;</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: &apos;lodashAndAxios&apos;, //一定要匹配entry对象内，key值，lodashAndAxios就是entry中的key值</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;lodashAndAxios&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>打包结果为：<br><figure class="image-box">                <img src="/image/webpack/verder2.png" alt="" title="" class="">                <p></p>            </figure></p><h4 id="直接用test匹配方法"><a href="#直接用test匹配方法" class="headerlink" title="直接用test匹配方法"></a>直接用test匹配方法</h4><p>上面的方法也可以写成如下，效果一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: /lodash|axios/,  //直接使用test去匹配</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h3 id="entry多种配置形式"><a href="#entry多种配置形式" class="headerlink" title="entry多种配置形式"></a>entry多种配置形式</h3><p>入口可以使用 entry 字段来进行配置，webpack 支持配置多个入口来进行构建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上述配置等同于</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者配置多个入口</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: &apos;./src/page-foo.js&apos;,</span><br><span class="line">    bar: &apos;./src/page-bar.js&apos;,</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用数组来对多个文件进行打包</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [</span><br><span class="line">      &apos;./src/foo.js&apos;,</span><br><span class="line">      &apos;./src/bar.js&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后的例子，可以理解为多个文件作为一个入口，webpack 会解析两个文件的依赖后进行打包。</p><p>还有一种形式，就是使用库与业务代码分离optimization.splitChunks时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//将&apos;lodash&apos;,&apos;axios&apos;两个库的代码合并打包成一个名字为customChunkNameQQ 的 js，文件；</span><br><span class="line">//剩下所有js包含其他依赖库和业务js将被合并打包成另个一个js。</span><br><span class="line"> entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">    lodashAndAxios:[&apos;lodash&apos;,&apos;axios&apos;],//显示定义需要将这些依赖库打成一个js</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">  filename: &apos;[name].[hash].js&apos;,//库js剩下的，也就是所谓的业务js</span><br><span class="line">  chunkFilename: &apos;[name].chunk.js&apos;, //打包出来的库js</span><br><span class="line">  path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">&#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><strong>entry 值可以是字符串，可以是对象；当entry为对象时，对象元素的key，value；value可以是字符串，也可以是数组。</strong></p><h3 id="生产与开发环境差异配置"><a href="#生产与开发环境差异配置" class="headerlink" title="生产与开发环境差异配置"></a>生产与开发环境差异配置</h3><p>前面提及的使用环境变量的方式可以让我们在不同的构建环境中完成不同的构建需求，这里列举一下常见的 webpack 构建差异配置：</p><ul><li>生产环境可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件</li><li>生产环境需要压缩 HTML/CSS/JS 代码</li><li>生产环境需要压缩图片</li><li>开发环境需要生成 sourcemap 文件</li><li>开发环境需要打印 debug 信息</li><li>开发环境需要 live reload 或者 hot reload 的功能</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>Entry: 入口。</li><li>Module: 模块。在webpack里，一切皆模块，一个模块对应一个文件，webpack会从配置的entry开始递归找出所有依赖的模块。</li><li>Chunk: 代码块。一个Chunk由多个模块组合而成，用于代码合并和分割。</li><li>loader: 模块转换器。</li><li>Plugin: 扩展插件。</li><li>Output: 输出结果。<br>webpack 在启动后会从Entry里配置的Moule开始，递归解析Entry依赖的所有module，每找到一个module，就会根据配置的loader去找出对应的转换规则，对module进行转换后，再解析出当前module依赖的module。这些模块会以entry为单位进行分组，一个entry及其所有依赖的module被分到一个组也就是一个chunk，最后webpack会将所有chunk转换成文件输出。<br><strong>在webpack中chunk概念很重要，也很不好理解，也容易被忽视，其实webpack目的是一个打包工具，然而将整个包打成几个代码块，都是由chunk控制，所以理解chunk对理解webpack，至关重要。</strong></li></ul><h3 id="babelrc相关"><a href="#babelrc相关" class="headerlink" title=".babelrc相关"></a>.babelrc相关</h3><h4 id="babelrc插件安装"><a href="#babelrc插件安装" class="headerlink" title="babelrc插件安装"></a>babelrc插件安装</h4><p>如下，要安装 syntax-dynamic-import ，实际上安装的是 babel-plugin-syntax-dynamic-import，要在名字前加 babel-plugin-。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;syntax-dynamic-import&quot;,</span><br><span class="line">    &quot;transform-class-properties&quot;,</span><br><span class="line">    &quot;transform-object-rest-spread&quot;,</span><br><span class="line">    [&quot;module-resolver&quot;, &#123;</span><br><span class="line">      &quot;root&quot;: [&quot;./src&quot;]</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="webpack常用知识-下"><a href="#webpack常用知识-下" class="headerlink" title="webpack常用知识 下"></a>webpack常用知识 下</h2><h3 id="如何让某个插件-在其他代码之前执行"><a href="#如何让某个插件-在其他代码之前执行" class="headerlink" title="如何让某个插件 在其他代码之前执行"></a>如何让某个插件 在其他代码之前执行</h3><p>如下，从上到小，先后执行 babel-polyfill –&gt;  react-hot-loader/patch –&gt; src/index，这是将react-hot-loader/patch先于index执行的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry: [</span><br><span class="line">  &apos;babel-polyfill&apos;,</span><br><span class="line">  &apos;react-hot-loader/patch&apos;,</span><br><span class="line">  path.resolve(__dirname, &apos;src/index&apos;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><h2 id="webpack-黑知识"><a href="#webpack-黑知识" class="headerlink" title="webpack 黑知识"></a>webpack 黑知识</h2><h3 id="合并两个webpack的js配置"><a href="#合并两个webpack的js配置" class="headerlink" title="合并两个webpack的js配置"></a>合并两个webpack的js配置</h3><p>使用webpack-merge即可，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//webpack.common</span><br><span class="line">module.exports = &#123;&#125;  //module.exports是node的语法，是commonjs标准</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//webpack.dev.js</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const common = require(&apos;./webpack.common&apos;);</span><br><span class="line">let devConfig = &#123;&#125;</span><br><span class="line">module.exports = merge(common, devConfig);</span><br></pre></td></tr></table></figure><h3 id="–watch-与-热更新"><a href="#–watch-与-热更新" class="headerlink" title="–watch 与 热更新"></a>–watch 与 热更新</h3><p>在命令中加入 –watch，可以达到效果：当文件改动时，会自动编译，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;watch&quot;: &quot;npx webpack --watch --config webpack.dev.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>自动编译还是不够的，我们还想它能够编译后自动刷新页面，也就是热更新，最常见的是npm start：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;npm webpack-dev-server --config webpack.dev.js&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>其中devServer.hot置为true，就可以达到热更新。</p><p>所以启动 webpack-dev-server，可以达到自动编译(–watch功能)和热更新功能。</p><h3 id="自动编译与热更新三大条件"><a href="#自动编译与热更新三大条件" class="headerlink" title="自动编译与热更新三大条件"></a>自动编译与热更新三大条件</h3><p>需要同时如下配置，才能进行自动编译与热更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">devServer: &#123;</span><br><span class="line">   hot: true, // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  new webpack.NamedModulesPlugin(), // 更容易查看(patch)的依赖</span><br><span class="line">  new webpack.HotModuleReplacementPlugin() // 替换插件</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-dev-server黑知识"><a href="#webpack-dev-server黑知识" class="headerlink" title="webpack-dev-server黑知识"></a>webpack-dev-server黑知识</h3><p>如下，将看到以下几点黑知识：</p><h4 id="为什么是-0-0-0-0；"><a href="#为什么是-0-0-0-0；" class="headerlink" title="为什么是 0.0.0.0；"></a>为什么是 0.0.0.0；</h4><p>当然，服务器也可以设置为127.0.0.1，这个随你，注意的是设置为0.0.0.0时，可能0.0.0.0:58080有问题，在浏览器上改为127即可正常访问。</p><h4 id="npm-start后自动打开浏览器；"><a href="#npm-start后自动打开浏览器；" class="headerlink" title="npm start后自动打开浏览器；"></a>npm start后自动打开浏览器；</h4><h4 id="编译监听的防抖设置；"><a href="#编译监听的防抖设置；" class="headerlink" title="编译监听的防抖设置；"></a>编译监听的防抖设置；</h4><h4 id="忽略监控文件范围设置；"><a href="#忽略监控文件范围设置；" class="headerlink" title="忽略监控文件范围设置；"></a>忽略监控文件范围设置；</h4><h4 id="proxy的代理重写pathRewrite；"><a href="#proxy的代理重写pathRewrite；" class="headerlink" title="proxy的代理重写pathRewrite；"></a>proxy的代理重写pathRewrite；</h4><h4 id="publicPath的黑知识；"><a href="#publicPath的黑知识；" class="headerlink" title="publicPath的黑知识；"></a>publicPath的黑知识；</h4><figure class="image-box">                <img src="/image/webpack/publicPath.jpg" alt="" title="" class="">                <p></p>            </figure><p>publicPath 的优先级高于 contentBase。contentBase 用于配置提供额外静态文件内容的目录，之前提到的 publicPath 是配置构建好的结果以什么样的路径去访问，而 contentBase 是配置额外的静态文件内容的访问路径，即那些不经过 webpack 构建，但是需要在 webpack-dev-server 中提供访问的静态资源（如部分图片等）<br>你不懂contentBase publicPath为什么，没关系，先这样用着。<br>更多配置说明可参考掘金小册的第六章节。</p><p>webpack-dev-server的配置devServer 完整代码及解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    clientLogLevel: &apos;warning&apos;, // 可能的值有 none, error, warning 或者 info（默认值)</span><br><span class="line">    hot: true, // 启用 webpack 的模块热替换特性, 这个需要配合： webpack.HotModuleReplacementPlugin插件</span><br><span class="line">    contentBase: path.join(__dirname, &quot;dist&quot;), // 告诉服务器从哪里提供内容， 默认情况下，将使用当前工作目录作为提供内容的目录</span><br><span class="line">    compress: true, // 一切服务都启用gzip 压缩</span><br><span class="line">    host: &apos;0.0.0.0&apos;, // 指定使用一个 host。默认是 localhost。如果你希望服务器外部可访问 0.0.0.0</span><br><span class="line">    port: 58080, // 端口</span><br><span class="line">    open: true, // 是否打开浏览器</span><br><span class="line">    overlay: &#123; // 出现错误或者警告的时候，是否覆盖页面线上错误消息。</span><br><span class="line">      warnings: true,</span><br><span class="line">      errors: true</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    publicPath: &apos;/&apos;, // 此路径下的打包文件可在浏览器中访问。（注意若无特殊要求，一定设置为&apos;/&apos;,默认配置为 &apos;/                   //&apos;，大多时候我们不会去改，使用默认配置。）</span><br><span class="line"></span><br><span class="line">    proxy: &#123; // 设置代理</span><br><span class="line">      &quot;/api&quot;: &#123; // 访问api开头的请求，会跳转到  下面的target配置</span><br><span class="line">        target: &quot;http://192.168.0.102:8080&quot;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &quot;^/api&quot;: &quot;/mockjsdata/5/api&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        //以上配置的意思就是 /api/getuser     =&gt;  http://192.168.0.102:8080//mockjsdata/5/api/getuser</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    quiet: true, // necessary for FriendlyErrorsPlugin. 启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。</span><br><span class="line">    watchOptions: &#123; // 监视文件相关的控制选项</span><br><span class="line">      poll: true, // webpack 使用文件系统(file system)获取文件改动的通知。在某些情况下，不会正常工作。例如，当使用 Network File System (NFS) 时。Vagrant 也有很多问题。在这些情况下，请使用轮询. poll: true。当然 poll也可以设置成毫秒数，比如：  poll: 1000</span><br><span class="line">      ignored: /node_modules/, // 忽略监控的文件夹，正则</span><br><span class="line">      aggregateTimeout: 300 // 默认值，当第一个文件更改，会在重新构建前增加延迟，防抖的功能，如果你连续几次改的文件间隔小于300毫秒，会延迟编译</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="服务器默认读取index-html"><a href="#服务器默认读取index-html" class="headerlink" title="服务器默认读取index.html"></a>服务器默认读取index.html</h3><p>入口HTML若不是index.html则需补全：<br><figure class="image-box">                <img src="/image/webpack/index.jpg" alt="" title="" class="">                <p></p>            </figure></p><h3 id="resolve之默认扩展文件名"><a href="#resolve之默认扩展文件名" class="headerlink" title="resolve之默认扩展文件名"></a>resolve之默认扩展文件名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123; // 配置别名</span><br><span class="line">      &apos;@&apos;: path.resolve(__dirname, &apos;src/&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [&quot;.js&quot;, &quot;.vue&quot;, &quot;.json&quot;] // 默认值: [&quot;.js&quot;,&quot;.json&quot;]  模块名字可以省略的后缀名</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="name-id-hash-chunkhash"><a href="#name-id-hash-chunkhash" class="headerlink" title="[name][id][hash][chunkhash]"></a>[name][id][hash][chunkhash]</h3><h4 id="name"><a href="#name" class="headerlink" title="[name]"></a>[name]</h4><p>所有的name，默认为entry中定义的，如果entry的值为字符串，则默认为main。<br>如：<br>下面代码是entry为字符串时，[name] 为默认的main<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">entry: &apos;./src/index.js&apos;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//main.24673fe716edfcec07a9.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //commons~main.chunk.js 这里多了一个commons，是因为splitChunks的commons配置的，默认加commons</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line"> new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // main24673fe716edfcec07a9.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>下面代码是entry为对象时，[name] 为entry的key值，下面的例子，[name]就是appIndex：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.90feeea169ea4a86288d.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //commons~appIndex.chunk.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line"> new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndex90feeea169ea4a86288d.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>可在插件中自定义对应模块的[name]，例如定义splitChunks模块下name: ‘custom_chunkName’，他会覆盖entry中定义的name，由此splitChunks插件生成的文件将[name]值为custom_chunkName:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;custom_chunkName&apos;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.c81ab09b0bd828f71845.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //customChunkNameQQ.chunk.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndexc81ab09b0bd828f71845.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">//其他跟上面代码一样，只列与上不同的代码：</span><br></pre></td></tr></table></figure><p>当然你也可以直接通过filename定义splitChunks模块下输出文件的名字，这个优先级最高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  appIndex:&apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                 chunks: &apos;initial&apos;,</span><br><span class="line">                 test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">                 enforce: true,</span><br><span class="line">                 name: &apos;customChunkNameQQ&apos;,</span><br><span class="line">                 filename: &apos;chunckNiceName.js&apos;,</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"> output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,//appIndex.c81ab09b0bd828f71845.js</span><br><span class="line">    chunkFilename: &apos;[name].chunk.js&apos;, //chunckNiceName.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // appIndexc81ab09b0bd828f71845.css</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">//其他跟上面代码一样，只列与上不同的代码：</span><br></pre></td></tr></table></figure><p>关于[name]小结：<br>如果entry为字符串，name值默认为main；<br>如果entry以对象形式，name值为对象的key值；<br>各个插件(如css、js处理插件)可自定义本插件生成的js的文件名，或自定name值覆盖entry中定义的name值。</p><h4 id="id"><a href="#id" class="headerlink" title="[id]"></a>[id]</h4><p>这个最简单，[id]其实就是数字1,2,3,4…..；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">    chunkFilename: &apos;[id].chunk.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="hash"><a href="#hash" class="headerlink" title="[hash]"></a>[hash]</h4><p>这就是一个hash码，值得注意的是，每次build的hash值都是相同的，也就是打包完成后，js\css文件名的hash值都是相同的。<br>hash一个典型特征是，只有有一个文件改变，那么重新打包后hash值将变化，所以使用hash输出文件名的都将变化，<br>所以业务js，必须使用hash，而不能使用chunkhash。</p><h4 id="chunkhash-及-chunkhash-与-hash-的异同"><a href="#chunkhash-及-chunkhash-与-hash-的异同" class="headerlink" title="[chunkhash]及 [chunkhash]与[hash]的异同"></a>[chunkhash]及 [chunkhash]与[hash]的异同</h4><p>依赖库的源码，我们一般单独打包成一个库js，这个js必须使用chunkhash，<br>chunkhash的原则是只要chunkhash对应的模块文件不变，就算其他文件有变化了，重新打包了，改变的是hash值，chunkhash值保持不变。<br><strong>需特别注意的是，在一般情况下，修改文件和增加文件，webpack编译生成chunkhash的策略是不同的，上面所说的只适合修改文件的情况，如果增加文件或删除文件，就算库文件不变，还是会产生不同的chunkhash，原因在与webpack会根据总体文件，为每个文件设置一个index进行编译，增加或删除文件都会改变整体的index，从而导致chunkhash改变，为了防止这一情况，可配置webpack.HashedModuleIdsPlugin</strong><br>关于chunkhash的规则，更多请看章节3.12:《构建与性能优化 之 webpack.HashedModuleIdsPlugin》<br>对于 chunkhash与HashedModuleIdsPlugin 看参看 <a href="https://www.cnblogs.com/zhishaofei/p/8590627.html" target="_blank" rel="noopener">这里</a><br><strong>所以为了利用http缓存，对于依赖源码库js，必须使用chunkhash，业务js必须使用hash，否则将失去库与业务代码分离的意义</strong></p><h3 id="关于chunkFilename"><a href="#关于chunkFilename" class="headerlink" title="关于chunkFilename"></a>关于chunkFilename</h3><p>chunkFilename是用来配置无入口的chunk输出的名字的。<br>1.代码如下，进行打包；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    appIndex:&apos;./src/index.js&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;production&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].[hash].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: path.resolve(__dirname,&apos;node_modules&apos;),</span><br><span class="line">           enforce: true,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>打包后生成：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename1.png" alt="" title="" class="">                <p></p>            </figure><br>因为splitChunks.cacheGroups.commons没有定义name，所以输出文件，默认加 commons~….js;</p><p>2.与1其他配置不变，加上name，再打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      commons: &#123;</span><br><span class="line">        ...</span><br><span class="line">         name: &apos;lodashAndAxios&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打包后生成，我们发现，这个分离出来的代码块，用的是output.filename的配置：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename2.png" alt="" title="" class="">                <p></p>            </figure></p><p>3.与2其他配置不变，加上chunkfilename，再打包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    ...</span><br><span class="line">    chunkFilename: &apos;[name]._chunk_[chunkhash].js&apos;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>打包后生成，我们发现，这个分离出来的代码块，用的是output.chunkFilename的配置：<br><figure class="image-box">                <img src="/image/webpack/chunkfilename3.png" alt="" title="" class="">                <p></p>            </figure></p><p>这单独分离的代码，在entry中没有入口，只通过splitChunks.cacheGroups.test进行匹配，所以chunkFilename 是用来配置没有入口的名称的，<br>如果不配置chunkFilename，将会根据filename输出。不配置splitChunks.cacheGroups.name，会给输出文件名默认加commons~</p><h3 id="chunk的名称"><a href="#chunk的名称" class="headerlink" title="chunk的名称"></a>chunk的名称</h3><p>chunk的名称和entry的配置有关；</p><ul><li>如果entry是一个string或array，只会生成一个chunk，这是的chunk的名称就是main；</li><li>如果entry是一个Object，就可能会出现多个chunk,这时chunk的名称是Object键值对中健的名称。</li></ul><h3 id="从代码分离看chunk与minChunks"><a href="#从代码分离看chunk与minChunks" class="headerlink" title="从代码分离看chunk与minChunks"></a>从代码分离看chunk与minChunks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  a: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">  b: &apos;./path/to/my/entry/app.js&apos;,</span><br><span class="line">&#125;</span><br><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      commons: &#123;</span><br><span class="line">        &lt;!-- 如果不指定chunks，将会从现有的所有chunk中提取公共代码 --&gt;</span><br><span class="line">         chunks: [&apos;a&apos;,&apos;b&apos;],//a、b是entry中的两个chunk，从a，b中抽取公共的代码，最终会形成一个名字为appCommon的js，和a.js和b.js</span><br><span class="line">         name: &apos;appCommon&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个参数是minChunks，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minChunks = 2;</span><br><span class="line">chunks = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]</span><br></pre></td></tr></table></figure></p><p>只要在abcde模块中任意两个模块出现了公共代码的，都被提取。<br>minChunks主要应对，很可能abcde没有一个公共代码，在所有模块中都有的情况。</p><h3 id="dev模式禁chunkhash"><a href="#dev模式禁chunkhash" class="headerlink" title="dev模式禁chunkhash"></a>dev模式禁chunkhash</h3><p>在dev模式下，只能用hash，不能使用chunkhash，否则报错。</p><h3 id="模块解析规则与resolve"><a href="#模块解析规则与resolve" class="headerlink" title="模块解析规则与resolve"></a>模块解析规则与resolve</h3><h4 id="解析相对路径"><a href="#解析相对路径" class="headerlink" title="解析相对路径"></a>解析相对路径</h4><ul><li>查找相对当前模块的路径下是否有对应文件或文件夹</li><li>是文件则直接加载</li><li>是文件夹则继续查找文件夹下的 package.json 文件</li><li>有 package.json 文件则按照文件中 main 字段的文件名来查找文件</li><li>无 package.json 或者无 main 字段则查找 index.js 文件<h4 id="解析模块名"><a href="#解析模块名" class="headerlink" title="解析模块名"></a>解析模块名</h4>查找当前文件目录下，父级目录及以上目录下的 node_modules 文件夹，看是否有对应名称的模块<h4 id="解析绝对路径（不建议使用）"><a href="#解析绝对路径（不建议使用）" class="headerlink" title="解析绝对路径（不建议使用）"></a>解析绝对路径（不建议使用）</h4>直接查找对应路径的文件</li></ul><p>在 webpack 配置中，和模块路径解析相关的配置都在 resolve 字段下。</p><h4 id="resolve-常用配置："><a href="#resolve-常用配置：" class="headerlink" title="resolve 常用配置："></a>resolve 常用配置：</h4><p>module.exports = {<br>   resolve: {<br>      alias: { // 配置别名<br>         utils: path.resolve(<strong>dirname, ‘src/utils’), // 模糊匹配，意味着只要模块路径中携带utils 就可以被替换掉<br>         component$: path.resolve(</strong>dirname, ‘src/component’) // 只会匹配 import ‘component’， 这是精确匹配方法。<br>      },<br>      modules: [<br>        path.resolve(__dirname, ‘node_modules’), // 指定当前目录下的 node_modules 优先查找<br>        ‘node_modules’, // 如果有一些类库是放在一些奇怪的地方的，你可以添加自定义的路径或者目录<br>      ],<br>      mainFiles: [‘index’], //当目录下没有 package.json 文件时，我们说会默认使用目录下的 index.js 这个文件,就是这个字段配置的。// 你可以添加其他默认使用的文件名<br>      extensions: [“.js”, “.vue”, “.json”] // 默认值: [“.js”,”.json”]  模块名字可以省略的后缀名<br>  },<br>}</p><h3 id="loader的规则条件配置"><a href="#loader的规则条件配置" class="headerlink" title="loader的规则条件配置"></a>loader的规则条件配置</h3><p>大多数情况下，配置 loader 的匹配条件时，只要使用 test 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 loader，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式：</p><ul><li>{ test: … } 匹配特定条件</li><li>{ include: … } 匹配特定路径</li><li>{ exclude: … } 排除特定路径</li><li>{ and: […] }必须匹配数组中所有条件</li><li>{ or: […] } 匹配数组中任意一个条件</li><li><p>{ not: […] } 排除匹配数组中所有条件<br>上述的所谓条件的值可以是：</p></li><li><p>字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径</p></li><li>正则表达式：调用正则的 test 方法来判断匹配</li><li>函数：(path) =&gt; boolean，返回 true 表示匹配</li><li>数组：至少包含一个条件的数组</li><li>对象：匹配所有属性值的条件</li></ul><h3 id="关于output"><a href="#关于output" class="headerlink" title="关于output"></a>关于output</h3><p>单个入口是配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: &apos;./path/to/my/entry/file.js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: &apos;/home/proj/public/assets&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>多个入口时配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/app.js&apos;,</span><br><span class="line">    search: &apos;./src/search.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].js&apos;,//多个时，用占位符[name]的方式定义</span><br><span class="line">    path: __dirname + &apos;/dist&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="css-js是怎么嵌入html"><a href="#css-js是怎么嵌入html" class="headerlink" title="css\js是怎么嵌入html"></a>css\js是怎么嵌入html</h3><p>无论output出来一个或多个js，html-webpack-plugin都会将js、css嵌入到html内：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;AICODER 全栈线下实习&apos;, // 默认值：Webpack App</span><br><span class="line">      filename: &apos;indexMyApp.html&apos;, // 默认值： &apos;index.html&apos;</span><br><span class="line">      template: path.resolve(__dirname, &apos;src/tempHtml.html&apos;),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: true,</span><br><span class="line">        removeComments: true, // 是否移除注释</span><br><span class="line">        removeAttributeQuotes: true // 移除属性的引号</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure></p><h3 id="模板index-html的ejs写法与html-webpack-plugin配合"><a href="#模板index-html的ejs写法与html-webpack-plugin配合" class="headerlink" title="模板index.html的ejs写法与html-webpack-plugin配合"></a>模板index.html的ejs写法与html-webpack-plugin配合</h3><p>模板文件index.html可以写ejs，ejs语法允许写js，然后每行用&lt;%= %&gt;包起来即可:<br><figure class="image-box">                <img src="/image/webpack/tpl1.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl2.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl3.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl4.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/tpl5.png" alt="" title="" class="">                <p></p>            </figure></p><p>注意：1.当有需求把一个js放在html 的header上，一个在body上时，可以定义模板script引用，此时必须设置inject为fasle，表示不适用插件默认嵌入。<br>2.上面ejs模板上一定要写成htmlWebpackPlugin，否则undefined，目前不知道为什么写成HtmlWebpackPlugin就可以关联到插件html-webpack-plugin</p><h3 id="多页面html的配置打包"><a href="#多页面html的配置打包" class="headerlink" title="多页面html的配置打包"></a>多页面html的配置打包</h3><p>要生成多个html，就需要在webpack.config.js中多配置几次new  html-webpack-plugin<br><figure class="image-box">                <img src="/image/webpack/mutilPage1.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage2.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage3.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage4.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="image-box">                <img src="/image/webpack/mutilPage5.png" alt="" title="" class="">                <p></p>            </figure></p><h3 id="autoprefixer-配置-postcss-loader"><a href="#autoprefixer-配置-postcss-loader" class="headerlink" title="autoprefixer 配置 (postcss-loader)"></a>autoprefixer 配置 (postcss-loader)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">要生成多个html，就需要在webpack.config.js中多配置几次new  html-webpack-plugin</span><br><span class="line">&#123;</span><br><span class="line">  loader: &apos;postcss-loader&apos;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    ident: &apos;postcss&apos;,</span><br><span class="line">    sourceMap: true,</span><br><span class="line">    //根据中国使用浏览器情况统计，兼容使用率大于百分之0.15的所有浏览器</span><br><span class="line">    plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browsers: [&apos;&gt; 5% in US&apos;] //根据美国使用浏览器情况统计，兼容使用率大于百分之5的所有浏览器</span><br><span class="line">browsers: [&apos;last 5 versions&apos;] //兼容所有浏览器最新的五个版本</span><br></pre></td></tr></table></figure><p><a href="https://github.com/browserslist/browserslist#best-practices" target="_blank" rel="noopener">点击查看更多</a></p><h3 id="html内img图片引用路径"><a href="#html内img图片引用路径" class="headerlink" title="html内img图片引用路径"></a>html内img图片引用路径</h3><p>在html或ejs模板文件，此时如果写绝对路径引用图片是没问题的，如果要使用相对路径，就必须使用require，<br>这是index.html文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div class=img&gt;</span><br><span class="line">     &lt;img src=&quot;$&#123; require(&apos;./assets/img/WechatIMG92.jpeg&apos;) &#125;&quot;  alt=&quot;标志&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这是ejs模板文件：<br><figure class="image-box">                <img src="/image/webpack/htmltpl.png" alt="" title="" class="">                <p></p>            </figure><br>不过在项目中，所以类型的，对图片的引用，使用绝对路径都没问题，只有使用相对路径才会有以上问题。<br>不过在css中，引用图片，使用相对路径和绝对路径都没问题。</p><h3 id="给图片指定生成目录"><a href="#给图片指定生成目录" class="headerlink" title="给图片指定生成目录"></a>给图片指定生成目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(png|svg|jpg|gif|jpeg)$/,</span><br><span class="line">        include: [path.resolve(__dirname, &apos;src/&apos;)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000,</span><br><span class="line">              //name既可以定义文件名字，也可以定义css生成路径，占位符[ext]是扩展externals的简写指图片扩展名</span><br><span class="line">              name: &apos;image/[name]_image.[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="带ejs的入口index-html模板文件示例"><a href="#带ejs的入口index-html模板文件示例" class="headerlink" title="带ejs的入口index.html模板文件示例"></a>带ejs的入口index.html模板文件示例</h3><p>对ejs的一点解释</p><ol><li>&lt;%  %&gt; 不输出显示到浏览器上的写法，专门用来运算js；</li><li>&lt;%=  %&gt; 加了一个=后，输出显示到浏览器上的写法；<br>完整示例看 看<a href="https://github.com/YeWills/webpack-code/tree/ejsHtml" target="_blank" rel="noopener">github 仓库中的 ejsHtml 分支 demo </a>，对应的tag发布版本为ejsHtmlV1.0</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br><span class="line">  integrity=&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br><span class="line">  crossorigin=&quot;anonymous&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> &lt;% for (var key of htmlWebpackPlugin.files.css) &#123; %&gt;</span><br><span class="line">  &lt;link href=&quot;&lt;%= key %&gt;&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line"> &lt;% &#125; %&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;dmo&quot;&gt;我是模板文件自带的内容1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;% for (var key in htmlWebpackPlugin.files) &#123; %&gt;</span><br><span class="line">        &lt;%= key %&gt; : &lt;%= JSON.stringify(htmlWebpackPlugin.files.css) %&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=img&gt;</span><br><span class="line">      &lt;img src=&quot;$&#123; require(&apos;./assets/img/WechatIMG92.jpeg&apos;) &#125;&quot;  alt=&quot;标志&quot; /&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.appIndex.entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script</span><br><span class="line">  src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.lodashAndAxios.entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="两个横杠命令"><a href="#两个横杠命令" class="headerlink" title="两个横杠命令"></a>两个横杠命令</h3><p>webpack –devtool source-map;<br>发现凡是带两个–的命令，都是配置 webpack 的配置项。</p><h3 id="babel的presets与plugins"><a href="#babel的presets与plugins" class="headerlink" title="babel的presets与plugins"></a>babel的presets与plugins</h3><p>plugins是一个功能；<br>presets里面定义的是一系列功能；<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>:[</span><br><span class="line">    <span class="string">"@babel/preset-env"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>:[</span><br><span class="line">    <span class="string">"@babel/proposal-class-properties"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="构建与性能优化"><a href="#构建与性能优化" class="headerlink" title="构建与性能优化"></a>构建与性能优化</h2><p>构建与性能优化很多思路受益于kangshen，膜拜下大神。</p><h3 id="升级到最新的webpack稳定版本"><a href="#升级到最新的webpack稳定版本" class="headerlink" title="升级到最新的webpack稳定版本"></a>升级到最新的webpack稳定版本</h3><p>这无疑是性能显著提升的</p><h3 id="babel-loader-的优化"><a href="#babel-loader-的优化" class="headerlink" title="babel-loader 的优化"></a>babel-loader 的优化</h3><p>把 loader 应用的文件范围缩小,也就是说，配置loader的include来限定查询范围<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [ </span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.jsx?/,</span><br><span class="line">    include: [ </span><br><span class="line">      path.resolve(__dirname, &apos;src&apos;), </span><br><span class="line">      // 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理</span><br><span class="line">      // 通常我们需要 loader 处理的文件都是存放在 src 目录</span><br><span class="line">    ],</span><br><span class="line">    use: &apos;babel-loader&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p><h4 id="设置exclude"><a href="#设置exclude" class="headerlink" title="设置exclude"></a>设置exclude</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    path.resolve(__dirname, &apos;node_modules&apos;), // 使用绝对路径指定 node_modules，不做过多查询</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  // 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作</span><br><span class="line">  // 其他文件可以在编码时指定后缀，如 import(&apos;./index.scss&apos;)</span><br><span class="line">  extensions: [&quot;.js&quot;], </span><br><span class="line"></span><br><span class="line">  // 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度</span><br><span class="line">  mainFiles: [&apos;index&apos;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="启用缓存"><a href="#启用缓存" class="headerlink" title="启用缓存"></a>启用缓存</h4><p>总代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.js$/,</span><br><span class="line">    exclude: /(node_modules)/, // 加快编译速度，不包含node_modules文件夹内容</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: &apos;babel-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        cacheDirectory: true // 启用缓存，提高编译速度，生成和开发都要如此设置</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="生产下库与业务js分离"><a href="#生产下库与业务js分离" class="headerlink" title="生产下库与业务js分离"></a>生产下库与业务js分离</h3><p>对于单页面应用 生产下库与业务js分离，可以利用浏览器http请求缓存机制，提高下一次访问速度。<br>对于多页面应用 生产下库与业务js分离，可以利用浏览器http请求缓存机制，提高访问下一页的速度。</p><p>更多详细库与业务js分离配置方法 请看 1.13章节 《webpack常用知识–分离 库与业务代码》</p><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: &apos;initial&apos;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>optimization.splitChunks.cacheGroups.chunks也可以是函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        styles: &#123;</span><br><span class="line">           chunks: &apos;all&apos;,</span><br><span class="line">           test: /\.(sc|c|sa)ss$/,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;styles&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;,</span><br><span class="line">        commons: &#123;</span><br><span class="line">           chunks: (chunk) =&gt; &#123;</span><br><span class="line">             return chunk.name !== &apos;styles&apos;;//避开上面定义的styles chunk</span><br><span class="line">           &#125;,</span><br><span class="line">           test: &apos;lodashAndAxios&apos;,</span><br><span class="line">           enforce: true,</span><br><span class="line">           name: &apos;lodashAndAxios&apos;,//对应覆盖entry.chunkFilename中的name占位符[name]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="使用花括号-进行import"><a href="#使用花括号-进行import" class="headerlink" title="使用花括号{}进行import"></a>使用花括号{}进行import</h3><p>例如 使用lodash，推荐这种写法import { filter } from ‘lodash’;<br>用什么就花括号，取什么。</p><h3 id="依赖包和业务js分离"><a href="#依赖包和业务js分离" class="headerlink" title="依赖包和业务js分离"></a>依赖包和业务js分离</h3><p>一般依赖包如loadsh，jq这些很少改变，而一般只改变业务js，分开打包后，依赖包js文件名，每次发布版本都是一样的，<br>浏览器的http请求缓存机制，浏览器不会重复请求，直接拿浏览器缓存的依赖包js即可，可提高性能，减少流量。每次发布版本，<br>只需要请求业务js。</p><h3 id="设置外部依赖"><a href="#设置外部依赖" class="headerlink" title="设置外部依赖"></a>设置外部依赖</h3><p>将笨重的很多页面都用到的js通过externals设置成外部依赖。</p><h3 id="利用浏览器http缓解机制"><a href="#利用浏览器http缓解机制" class="headerlink" title="利用浏览器http缓解机制"></a>利用浏览器http缓解机制</h3><p>利用浏览器http缓解机制，库与js代码分离，可以提高速度，减少流量。(这个应该属于 项目性能优化范畴)</p><h3 id="autodll-webpack-plugin"><a href="#autodll-webpack-plugin" class="headerlink" title="autodll-webpack-plugin"></a>autodll-webpack-plugin</h3><p>该插件能够快速打包，能把第三方依赖的文件能提前进行预编译打包到一个文件里面去。提高了构建速度。因为很多第三方插件我们并不需要改动它，所以我们想这些第三方库在我们每次编译的时候不要再次构建它就好,可以非常明显提高rebuild速度<br>该插件有两个作用：<br>1、可以明显提高rebuild的速度；<br>2、可以调试库源码；</p><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const AutoDllPlugin = require(&apos;autodll-webpack-plugin&apos;);</span><br><span class="line"> new AutoDllPlugin(&#123;</span><br><span class="line">      filename: &apos;[name]_chunk.js&apos;,</span><br><span class="line">      // 如果需要调试库源码，将inherit设置为true，是调试源码的尖刀利器，不过会影响rebuild速度</span><br><span class="line">      inherit: false,//当为false时，速度更快；当为true时，可以打开webpack没有压缩过的源码sourcemap调试</span><br><span class="line">      inject: true,</span><br><span class="line">      debug: true,</span><br><span class="line">      entry: &#123;</span><br><span class="line">        appVendor: [</span><br><span class="line">          &apos;axios&apos;,</span><br><span class="line">          &apos;lodash&apos;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure><h3 id="happypack"><a href="#happypack" class="headerlink" title="happypack"></a>happypack</h3><p>webpack 只能一个loader处理完后处理下一个loader，这样，速度就慢，为了同时进行多线程loader，同时处理多个loader，可以使用happypack；<br>配置happypack可以明显提高构建速度。</p><ul><li>其他的都好配置，就postcss-loader 比较特殊，必须要另外新建 postcss.config.js 否则报错；</li><li>happypack 重写原来loader配置时，基本上就是复制，不改变，只有postcss可能稍微改动下</li></ul><p>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const HappyPack = require(&apos;happypack&apos;);</span><br><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        loader: &apos;happypack/loader?id=handerStyle&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"> new HappyPack(&#123;</span><br><span class="line">      id:&apos;handerStyle&apos;,</span><br><span class="line">      loaders:[</span><br><span class="line">        &apos;style-loader&apos;, </span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;css-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            sourceMap: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;postcss-loader&apos;, </span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;sass-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            sourceMap: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//postcss.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ident: &apos;postcss&apos;,</span><br><span class="line">  sourceMap: true,</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &apos;autoprefixer&apos;: &#123;</span><br><span class="line">      browsers: [&apos;&gt; 0.15% in CN&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webpack-parallel-uglify-plugin"><a href="#webpack-parallel-uglify-plugin" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h3><p>生产环境配置。<br>happypack是多线程操作loader进行多线程转译文件；与此相似，webpack-parallel-uglify-plugin是多线程进行压缩js，提高生产环境下的打包速度。<br>更多信息，看<a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">demo示例</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    // 使用 ParallelUglifyPlugin 并行压缩输出JS代码</span><br><span class="line">    new ParallelUglifyPlugin(&#123;</span><br><span class="line">      // 传递给 UglifyJS的参数如下：</span><br><span class="line">      uglifyJS: &#123;</span><br><span class="line">        output: &#123;</span><br><span class="line">          /*</span><br><span class="line">           是否输出可读性较强的代码，即会保留空格和制表符，默认为输出，为了达到更好的压缩效果，</span><br><span class="line">           可以设置为false</span><br><span class="line">          */</span><br><span class="line">          beautify: false,</span><br><span class="line">          /*</span><br><span class="line">           是否保留代码中的注释，默认为保留，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          comments: false</span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          /*</span><br><span class="line">           是否在UglifyJS删除没有用到的代码时输出警告信息，默认为输出，可以设置为false关闭这些作用</span><br><span class="line">           不大的警告</span><br><span class="line">          */</span><br><span class="line">          warnings: false,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否删除代码中所有的console语句，默认为不删除，开启后，会删除所有的console语句</span><br><span class="line">          */</span><br><span class="line">          drop_console: true,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否内嵌虽然已经定义了，但是只用到一次的变量，比如将 var x = 1; y = x, 转换成 y = 5, 默认为不</span><br><span class="line">           转换，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          collapse_vars: true,</span><br><span class="line"></span><br><span class="line">          /*</span><br><span class="line">           是否提取出现了多次但是没有定义成变量去引用的静态值，比如将 x = &apos;xxx&apos;; y = &apos;xxx&apos;  转换成</span><br><span class="line">           var a = &apos;xxxx&apos;; x = a; y = a; 默认为不转换，为了达到更好的压缩效果，可以设置为false</span><br><span class="line">          */</span><br><span class="line">          reduce_vars: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ContextReplacementPlugin"><a href="#ContextReplacementPlugin" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h3><p>配置ContextReplacementPlugin，是优化配置，下面章节《其他常用插件》有讲</p><h3 id="webpack-HashedModuleIdsPlugin"><a href="#webpack-HashedModuleIdsPlugin" class="headerlink" title="webpack.HashedModuleIdsPlugin"></a>webpack.HashedModuleIdsPlugin</h3><p>打包中chunkhash的规则：<br>当没有删除或增加文件，如果对于chunk的代码没有变化，chunkhash值不会变，可以起到浏览器缓存的作用；<br>但当有删除或增加文件是，如果对应chunk的代码没有变化，打包是，chunkhash还是会变，这不是我们想要的结果，我们只希望对应chunk代码如果没变化，<br>无论其他代码文件删除或增加，chunkhash都不变。<br>（为什么会变，webpack自带打包策略是给每个文件配置了一个数字index，无论增加或删除一个文件，都会打乱整个 index，导致chunkhash变化，<br>HashedModuleIdsPlugin，改变策略为，根据文件路径配置，所以达到了稳定chunkhash）<br>为了达到以上效果，请配置HashedModuleIdsPlugin插件：<br>new webpack.HashedModuleIdsPlugin({<br>  hashDigestLength：20<br>})</p><p>该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 建议用于生产环境。<br>用 HashedModuleIdsPlugin 可以轻松地实现 chunkhash 的稳定化，可以实现持久化缓存。<br>建议生产配置使用，如果使用到了chunkhash，则最好配置HashedModuleIdsPlugin。<br>更多请看章节2.7.4:《webpack 黑知识 之 [name][id][hash][chunkhash][name]》<br>或看官网<br>对于 chunkhash与HashedModuleIdsPlugin 看参看 <a href="https://www.cnblogs.com/zhishaofei/p/8590627.html" target="_blank" rel="noopener">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new webpack.HashedModuleIdsPlugin(&#123;</span><br><span class="line">    hashDigestLength: 20</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="webpack-NormalModuleReplacementPlugin"><a href="#webpack-NormalModuleReplacementPlugin" class="headerlink" title="webpack.NormalModuleReplacementPlugin"></a>webpack.NormalModuleReplacementPlugin</h3><p>webpack.NormalModuleReplacementPlugin(a,b)编译时，第一个参数通常是正则，第一个参数正则匹配到文件后，会将此文件替换为第二个参数，从而达到生产或开发时，编译不同文件的目的，比如生产和开发时编译不同的路由文件。<br>所以配置时，在webpack.config.plugins中，位于最前面，保证webpack执行编译时，首先启用此插件替换文件。<br>注意的是，此插件的第一个参数一般都设置为正则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.NormalModuleReplacementPlugin(</span><br><span class="line">    /some\/path\/config\.development\.js/,</span><br><span class="line">    &apos;./config.production.js&apos;</span><br><span class="line">  ),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-optimize-OccurrenceOrderPlugin"><a href="#webpack-optimize-OccurrenceOrderPlugin" class="headerlink" title="webpack.optimize.OccurrenceOrderPlugin"></a>webpack.optimize.OccurrenceOrderPlugin</h3><p>OccurrenceOrderPlugin插件：根据出现次数为每一个模块或者chunk设置id,经常使用的模块则会获取到较短的id(和前缀树类似)，这可以使id可预测并有效减少文件大小，建议使用在生产环境中～<br><a href="https://www.cnblogs.com/xuepei/p/7992423.html" target="_blank" rel="noopener">参考</a><br>有些说是可以优化排序输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="webpack-optimize-AggressiveMergingPlugin"><a href="#webpack-optimize-AggressiveMergingPlugin" class="headerlink" title="webpack.optimize.AggressiveMergingPlugin"></a>webpack.optimize.AggressiveMergingPlugin</h3><p>AggressiveMergingPlugin用于合并块。<br>AggressiveMergingPlugin用于解决如路由分配不合理，会打包出很多很小的文件，每个文件或许只有几k，却多了很多网络请求，得不偿失。<br>用法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new webpack.optimize.AggressiveMergingPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="react-loadable-懒加载优化生产模式构建速度以及页面访问速度"><a href="#react-loadable-懒加载优化生产模式构建速度以及页面访问速度" class="headerlink" title="react-loadable 懒加载优化生产模式构建速度以及页面访问速度"></a>react-loadable 懒加载优化生产模式构建速度以及页面访问速度</h3><p>这条优化经验受kangshen启发，表示对大神的膜拜，具体思路是：<br>利用react-loadable懒加载，将生产模式下的路由配合react-loadable懒加载，显示哪个路由页面，就编译加载某个路由页面，这样既提高webpack编译速度，又提高页面访问速度。<br>将路由进行懒加载有一个弊端是只能看到你打开页面的报错，没有打开的页面报错你无法看到。</p><p>react-loadable 是2017年5月左右才出现，到如今，GitHub上已经有一万多颗star，是可以比拟react-redux的插件，非常棒，项目中如果有用到懒加载，用这个框架非常好react-loadable</p><h3 id="减少不必要的plugin"><a href="#减少不必要的plugin" class="headerlink" title="减少不必要的plugin"></a>减少不必要的plugin</h3><h2 id="热重载与热替换"><a href="#热重载与热替换" class="headerlink" title="热重载与热替换"></a>热重载与热替换</h2><h3 id="热重载-与-–inline"><a href="#热重载-与-–inline" class="headerlink" title="热重载 与 –inline"></a>热重载 与 –inline</h3><p>在使用webpack的 devServer时，只需在<code>npm script</code>中加入<code>--inline</code>,即可自动编译，自动重新加载整个页面。<a href="https://www.webpackjs.com/configuration/dev-server/#devserver-inline" target="_blank" rel="noopener">参考 配置-开发中 Server(devServer)</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --inline</span><br></pre></td></tr></table></figure></p><h3 id="热替换介绍"><a href="#热替换介绍" class="headerlink" title="热替换介绍"></a>热替换介绍</h3><p>热替换有两种方法，一种是使用webpack-dev-server，一种是使用webpack-hot-loader；</p><h3 id="热替换方式一：-webpack-dev-server"><a href="#热替换方式一：-webpack-dev-server" class="headerlink" title="热替换方式一： webpack-dev-server"></a>热替换方式一： webpack-dev-server</h3><p>webpack-dev-server有两种方法，<br>一种是直接在webpack.config.js中的devSever上配置hot实现。<br>一种是自定义配置。</p><h4 id="devSever"><a href="#devSever" class="headerlink" title="devSever"></a>devSever</h4><p>只需在<code>npm script</code>中加入<code>--hot</code>,<a href="https://www.webpackjs.com/configuration/dev-server/#devserver-hot" target="_blank" rel="noopener">参考 配置-开发中 Server(devServer)-devServer.hot</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --hot</span><br></pre></td></tr></table></figure></p><p>在<code>npm script</code>中加入<code>--hot</code>这一句代码相当于 在webpack.config.js的设置devServer.hot为<code>true</code>,并且在plugins中加了 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new webpack.HotModuleReplacementPlugin()</span><br></pre></td></tr></table></figure></p><p>所以，一旦在<code>npm script</code>中加入<code>--hot</code>，就要去掉plugins的<code>new webpack.HotModuleReplacementPlugin()</code>，不然就相当于执行了两次HotModuleReplacementPlugin，并因此可能报错。</p><p><strong>值得注意的是， 在webpack.config.js的设置devServer.hot为<code>true</code>效果并不佳，推荐在<code>npm script</code>中加入<code>--hot</code></strong></p><p>因此一般<code>npm script</code>配置如下，意思是当代码变化，重新编译的时候，如果热替换起作用，就执行热替换，如果热替换不起作用，就执行热重装整个页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --inline --hot</span><br></pre></td></tr></table></figure></p><h4 id="express或koa-的自定义方式"><a href="#express或koa-的自定义方式" class="headerlink" title="express或koa 的自定义方式"></a>express或koa 的自定义方式</h4><p>有些项目不用webpack.config.js的设置devServer，而选择express或koa，直接引用webpack-dev-server插件自定义配置热替换效果，此时就需要配合 webpack-hot-middleware 与 webpack-dev-middleware 一起使用，才能达到效果。<br>详细见 <a href="https://github.com/YeWills/react-hot-loader-demo" target="_blank" rel="noopener">demo</a>。</p><h3 id="热替换方式二：-react-hot-loader"><a href="#热替换方式二：-react-hot-loader" class="headerlink" title="热替换方式二： react-hot-loader"></a>热替换方式二： react-hot-loader</h3><p>这是热替换最佳模式。具体配置方法，参见 <a href="https://github.com/YeWills/wills-react-pro/commit/971612a647e0a93c037c04830526cc684d90de76" target="_blank" rel="noopener">增加react-hot-loader热更新功能</a></p><h3 id="热替换最佳方案"><a href="#热替换最佳方案" class="headerlink" title="热替换最佳方案"></a>热替换最佳方案</h3><p>配置了几个项目的热加载后发现一般 webpack自带的webpack-dev-server方式的热替换一般效果不好或干脆失效，所以最佳方案是使用react-hot-loader。</p><h3 id="module-hot"><a href="#module-hot" class="headerlink" title="module.hot"></a>module.hot</h3><p>module.hot是一下代码是 webpack Hot Module Replacement API，在react-hot-loader v3的版本中要配置webpack Hot Module Replacement 的 module.hot。不过在v4的版本后，就不需要配置module.hot了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (module.hot) &#123;</span><br><span class="line">    module.hot.accept(&apos;./print.js&apos;, function()&#123;</span><br><span class="line">        console.log(&quot;Accepting the updated printMe module!&quot;);</span><br><span class="line">        printMe();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="react-hot-loader失效问题"><a href="#react-hot-loader失效问题" class="headerlink" title="react-hot-loader失效问题"></a>react-hot-loader失效问题</h3><h4 id="去掉不必要或重复配置"><a href="#去掉不必要或重复配置" class="headerlink" title="去掉不必要或重复配置"></a>去掉不必要或重复配置</h4><p>失效可能有很多问题，其中之一是 将不必要的配置删除，可以解决hot实效问题，例如在<code>npm script</code>中加入<code>--hot</code>，又在webpack.config.js的设置devServer.hot为<code>true</code>,并且在plugins中加HotModuleReplacementPlugin，就可能导致失效，删除重复配置即可。</p><h4 id="不要使用-createApp-而使用"><a href="#不要使用-createApp-而使用" class="headerlink" title="不要使用 createApp() 而使用"></a>不要使用 createApp() 而使用<app></app></h4><p>项目hot改造的坑在于application函数方式的缺点可能是，每次render页面都会执行函数，生成崭新的页面，这会有潜在的坑。—》解决之道函数方式改成 组件方式<code>&lt;app/&gt;</code><br>根据react-hot-loader的配置方法，需要改写为<code>&lt;app/&gt;</code>方式，并hot app；<br>详细见 <a href="https://github.com/YeWills/wills-react-pro/commit/971612a647e0a93c037c04830526cc684d90de76" target="_blank" rel="noopener">增加react-hot-loader热更新功能</a></p><h3 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h3><h4 id="–watch-与-热更新-1"><a href="#–watch-与-热更新-1" class="headerlink" title="–watch 与 热更新"></a>–watch 与 热更新</h4><p>参考《webpack 黑知识》</p><h4 id="自动编译与热更新三大条件-1"><a href="#自动编译与热更新三大条件-1" class="headerlink" title="自动编译与热更新三大条件"></a>自动编译与热更新三大条件</h4><p>参考《webpack 黑知识》</p><h4 id="webpack-dev-server黑知识-1"><a href="#webpack-dev-server黑知识-1" class="headerlink" title="webpack-dev-server黑知识"></a>webpack-dev-server黑知识</h4><p>参考《webpack 黑知识》</p><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="ContextReplacementPlugin-1"><a href="#ContextReplacementPlugin-1" class="headerlink" title="ContextReplacementPlugin"></a>ContextReplacementPlugin</h3><p>当项目用到moment时，务必使用此插件，可减少打包体积，以下代码为例，匹配moment/locale路径，只加载编译此路径下的/zh-cn|zh-hk|en/的文件。<br>new webpack.ContextReplacementPlugin(/moment[/\]locale$/, /zh-cn|zh-hk|en/)</p><h3 id="webpack-NormalModuleReplacementPlugin-1"><a href="#webpack-NormalModuleReplacementPlugin-1" class="headerlink" title="webpack.NormalModuleReplacementPlugin"></a>webpack.NormalModuleReplacementPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h3><p>此插件定义值时，都需加JSON.stringify。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env.ASSET_PATH&apos;: JSON.stringify(&quot;5fa3b9&quot;),</span><br><span class="line">      &apos;process.env.FLAG&apos;: JSON.stringify(true)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h3 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h3><p>配置全局变量，自动加载模块，不必到处import或require：<br>例如设置$为全局变量，指向jq。<br>new webpack.ProvidePlugin({<br>  $: ‘jquery’,<br>  jQuery: ‘jquery’<br>})</p><h3 id="webpack-optimize-OccurrenceOrderPlugin-1"><a href="#webpack-optimize-OccurrenceOrderPlugin-1" class="headerlink" title="webpack.optimize.OccurrenceOrderPlugin"></a>webpack.optimize.OccurrenceOrderPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="happypack-1"><a href="#happypack-1" class="headerlink" title="happypack"></a>happypack</h3><p>用法请看章节《构建与性能优化》</p><h3 id="AutoDllPlugin"><a href="#AutoDllPlugin" class="headerlink" title="AutoDllPlugin"></a>AutoDllPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-parallel-uglify-plugin-1"><a href="#webpack-parallel-uglify-plugin-1" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-HashedModuleIdsPlugin-1"><a href="#webpack-HashedModuleIdsPlugin-1" class="headerlink" title="webpack.HashedModuleIdsPlugin"></a>webpack.HashedModuleIdsPlugin</h3><p>用法请看章节《构建与性能优化》</p><h3 id="webpack-optimize-AggressiveMergingPlugin-1"><a href="#webpack-optimize-AggressiveMergingPlugin-1" class="headerlink" title="webpack.optimize.AggressiveMergingPlugin"></a>webpack.optimize.AggressiveMergingPlugin</h3><p>用法请看章节《构建与性能优化》</p><h2 id="webpack-版本变化"><a href="#webpack-版本变化" class="headerlink" title="webpack 版本变化"></a>webpack 版本变化</h2><h3 id="css分离插件"><a href="#css分离插件" class="headerlink" title="css分离插件"></a>css分离插件</h3><p>webpack4.x弃用了extract-text-webpack-plugin，使用mini-css-extract-plugin代替，来做css从html中分离单独成一个css文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line"> module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sc|c|sa)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">            loader: &apos;css-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;postcss-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &apos;postcss&apos;,</span><br><span class="line">              sourceMap: true,</span><br><span class="line">              plugins: (loader) =&gt; [require(&apos;autoprefixer&apos;)(&#123;browsers: [&apos;&gt; 0.15% in CN&apos;]&#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            loader: &apos;sass-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: true</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[name][hash].css&apos;, // 设置最终输出的文件名</span><br><span class="line">      chunkFilename: &apos;[id][hash].css&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure></p><h3 id="webpack注意事项"><a href="#webpack注意事项" class="headerlink" title="webpack注意事项"></a>webpack注意事项</h3><ul><li>不要在生产环境下使用inline模式的source map，因为这会使js文件变得很大，而且会泄露源码。</li><li>尽量写全名称，扩展名也写上 const common = require(‘./webpack.common.js’);不要写成require(‘./webpack.common’)，不利于编译查询。</li><li>线上发布，或CDN优化配置，大部分与合理配置publicpath有关。</li></ul><h2 id="参考和学习资料"><a href="#参考和学习资料" class="headerlink" title="参考和学习资料"></a>参考和学习资料</h2><h3 id="webpack-文档介绍"><a href="#webpack-文档介绍" class="headerlink" title="webpack 文档介绍"></a>webpack 文档介绍</h3><p>有两个webpack官网<br><a href="https://www.webpackjs.com/plugins/" target="_blank" rel="noopener">webpackjs 官网</a><br><a href="https://webpack.docschina.org/plugins/" target="_blank" rel="noopener">docschina 官网</a></p><p>其中webpackjs 官网的信息相比之下更全全，在webpackjs 官网中能搜索到插件NamedModulesPlugin，docschina 官网 中不能。<br>但是，webpack github上官方给出链接的官网是docschina 官网，为什么它信息还不全呢，可能的原因是不显示的API可能已经被废弃。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://ke.qq.com/course/321174" target="_blank" rel="noopener">老马全栈VIP2_02_webpack4配置入门到进阶</a><br><a href="https://www.imooc.com/learn/802" target="_blank" rel="noopener">webpack深入与实战</a><br><a href="https://www.imooc.com/learn/935" target="_blank" rel="noopener">Vue+Webpack打造todo应用</a><br>掘金小册-使用webpack定制前端开发环境<br>吴浩麟-深入浅出webpack<br><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack 官网</a><br>此官网下的四个子模块文档：<br>    <a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">webpack 文档官网_概念</a><br>    <a href="https://www.webpackjs.com/configuration/" target="_blank" rel="noopener">webpack 文档官网_配置</a><br>    <a href="https://www.webpackjs.com/api/" target="_blank" rel="noopener">webpack 文档官网_API</a><br>    <a href="https://www.webpackjs.com/guides/" target="_blank" rel="noopener">webpack 文档官网_指南</a><br>    <a href="https://www.webpackjs.com/loaders/" target="_blank" rel="noopener">webpack 文档官网_loader</a><br>    <a href="https://www.webpackjs.com/plugins/" target="_blank" rel="noopener">webpack 文档官网_插件</a><br><a href="https://segmentfault.com/a/1190000007479892" target="_blank" rel="noopener">webpack学习系列</a><br><a href="https://www.mmxiaowu.com/article/58482332d4352863efb55465" target="_blank" rel="noopener">WebPack 终极配置说明</a><br><a href="https://github.com/YeWills/webpack-code/tree/master" target="_blank" rel="noopener">原创webpack demo 主要应用分支</a><br><a href="https://github.com/YeWills/webpack-code/tree/ejsHtml" target="_blank" rel="noopener">原创webpack demo 模板ejs语法分支</a><br><a href="https://github.com/YeWills/webpack-code/tree/webpack_custom_merge_demo" target="_blank" rel="noopener">原创webpack demo 自定义merge config分支</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
